import { computeNextScalar, generateProgressionNote } from './personalization'

describe('Personalization Logic', () => {
  describe('computeNextScalar', () => {
    describe('Feedback adjustments', () => {
      test('should increase scalar by 0.1 for "easy" feedback', () => {
        const result = computeNextScalar(1.0, 'easy')
        expect(result).toBe(1.1)
      })

      test('should decrease scalar by 0.1 for "hard" feedback', () => {
        const result = computeNextScalar(1.0, 'hard')
        expect(result).toBe(0.9)
      })

      test('should increase scalar by 0.02 for "right" feedback (progressive overload)', () => {
        const result = computeNextScalar(1.0, 'right')
        expect(result).toBe(1.02)
      })
    })

    describe('Completion rate bias', () => {
      test('should apply -0.05 bias for low completion rate (<0.6)', () => {
        const result = computeNextScalar(1.0, 'right', 0.5)
        expect(result).toBe(0.97) // 1.0 + 0.02 - 0.05
      })

      test('should apply +0.05 bias for high completion rate (>0.9)', () => {
        const result = computeNextScalar(1.0, 'right', 0.95)
        expect(result).toBe(1.07) // 1.0 + 0.02 + 0.05
      })

      test('should not apply bias for moderate completion rate (0.6-0.9)', () => {
        const result1 = computeNextScalar(1.0, 'right', 0.7)
        const result2 = computeNextScalar(1.0, 'right', 0.8)
        expect(result1).toBe(1.02)
        expect(result2).toBe(1.02)
      })

      test('should handle undefined completion rate', () => {
        const result = computeNextScalar(1.0, 'easy', undefined)
        expect(result).toBe(1.1)
      })
    })

    describe('Scalar clamping', () => {
      test('should clamp to minimum 0.6', () => {
        const result = computeNextScalar(0.6, 'hard', 0.5)
        expect(result).toBe(0.6) // Would be 0.45 without clamping
      })

      test('should clamp to maximum 1.4', () => {
        const result = computeNextScalar(1.4, 'easy', 0.95)
        expect(result).toBe(1.4) // Would be 1.55 without clamping
      })

      test('should allow values within bounds', () => {
        const result = computeNextScalar(1.2, 'hard')
        expect(result).toBe(1.1)
      })
    })

    describe('Combined effects', () => {
      test('should handle easy feedback with high completion rate', () => {
        const result = computeNextScalar(1.0, 'easy', 0.95)
        expect(result).toBe(1.15) // 1.0 + 0.1 + 0.05
      })

      test('should handle hard feedback with low completion rate', () => {
        const result = computeNextScalar(1.0, 'hard', 0.5)
        expect(result).toBe(0.85) // 1.0 - 0.1 - 0.05
      })

      test('should handle conflicting signals (easy feedback, low completion)', () => {
        const result = computeNextScalar(1.0, 'easy', 0.4)
        expect(result).toBe(1.05) // 1.0 + 0.1 - 0.05
      })
    })

    describe('Edge cases', () => {
      test('should handle extreme starting values', () => {
        const result1 = computeNextScalar(0.6, 'easy')
        const result2 = computeNextScalar(1.4, 'hard')
        expect(result1).toBe(0.7)
        expect(result2).toBe(1.3)
      })

      test('should handle zero completion rate', () => {
        const result = computeNextScalar(1.0, 'right', 0.0)
        expect(result).toBe(0.97) // 1.0 + 0.02 - 0.05
      })

      test('should handle perfect completion rate', () => {
        const result = computeNextScalar(1.0, 'right', 1.0)
        expect(result).toBe(1.07) // 1.0 + 0.02 + 0.05
      })
    })

    describe('Idempotence and consistency', () => {
      test('should be consistent with same inputs', () => {
        const result1 = computeNextScalar(1.0, 'easy', 0.8)
        const result2 = computeNextScalar(1.0, 'easy', 0.8)
        expect(result1).toBe(result2)
      })

      test('should handle repeated "right" feedback with progressive overload', () => {
        let scalar = 1.0
        for (let i = 0; i < 10; i++) {
          scalar = computeNextScalar(scalar, 'right', 0.8)
        }
        expect(scalar).toBeCloseTo(1.2, 2) // Should gradually increase
        expect(scalar).toBeLessThanOrEqual(1.4) // But stay within bounds
      })
    })
  })

  describe('generateProgressionNote', () => {
    test('should generate note for easy feedback with increase', () => {
      const note = generateProgressionNote(1.0, 1.1, 'easy')
      expect(note).toBe('user rated last workout too easy; increase difficulty ~10% safely')
    })

    test('should generate note for hard feedback with decrease', () => {
      const note = generateProgressionNote(1.0, 0.9, 'hard')
      expect(note).toBe('user rated last workout too hard; decrease difficulty ~10% safely')
    })

    test('should generate note for right feedback with minimal change', () => {
      const note = generateProgressionNote(1.0, 1.005, 'right')
      expect(note).toBe('user rated last workout just right; maintain current difficulty level')
    })

    test('should handle no feedback with intensity above baseline', () => {
      const note = generateProgressionNote(1.0, 1.1, null)
      expect(note).toBe('Increase difficulty ~10% safely')
    })

    test('should handle no feedback with intensity below baseline', () => {
      const note = generateProgressionNote(1.0, 0.9, null)
      expect(note).toBe('Decrease difficulty ~10% safely')
    })

    test('should handle no feedback at baseline', () => {
      const note = generateProgressionNote(1.0, 1.0, null)
      expect(note).toBe('Maintain baseline difficulty')
    })

    test('should round intensity changes properly', () => {
      const note = generateProgressionNote(1.0, 1.067, 'easy')
      expect(note).toBe('user rated last workout too easy; increase difficulty ~7% safely')
    })
  })

  describe('Integration scenarios', () => {
    test('should handle typical user journey - easy to right to hard', () => {
      let scalar = 1.0
      
      // User finds workout too easy
      scalar = computeNextScalar(scalar, 'easy', 0.9)
      expect(scalar).toBe(1.15) // 1.0 + 0.1 + 0.05
      
      // Next workout feels just right
      scalar = computeNextScalar(scalar, 'right', 0.8)
      expect(scalar).toBe(1.17) // 1.15 + 0.02
      
      // Next workout is too hard
      scalar = computeNextScalar(scalar, 'hard', 0.6)
      expect(scalar).toBe(1.07) // 1.17 - 0.1
    })

    test('should handle beginner progression', () => {
      let scalar = 1.0
      
      // Multiple "right" ratings with good completion
      for (let i = 0; i < 5; i++) {
        scalar = computeNextScalar(scalar, 'right', 0.85)
      }
      
      expect(scalar).toBeCloseTo(1.1, 2)
      expect(scalar).toBeLessThanOrEqual(1.4)
    })

    test('should handle struggling user', () => {
      let scalar = 1.0
      
      // User consistently finds workouts too hard with low completion
      scalar = computeNextScalar(scalar, 'hard', 0.4) // 0.85
      scalar = computeNextScalar(scalar, 'hard', 0.5) // 0.7
      scalar = computeNextScalar(scalar, 'hard', 0.6) // 0.6 (clamped)
      
      expect(scalar).toBe(0.6)
      
      // Should stay at minimum even with more hard feedback
      scalar = computeNextScalar(scalar, 'hard', 0.3)
      expect(scalar).toBe(0.6)
    })
  })
})
