========================================
NEURAFIT CODEBASE CONSOLIDATION
Generated: 2025-10-03 16:33:04
========================================

========================================
TABLE OF CONTENTS
========================================

FRONTEND CODE (src/)
  - Main Application Files
  - Components
  - Pages
  - Design System
  - Hooks
  - Libraries & Utilities
  - Configuration
  - Types

BACKEND CODE (functions/src/)
  - Cloud Functions
  - Libraries & Utilities

CONFIGURATION FILES
  - TypeScript Configuration
  - Build Configuration
  - Firebase Configuration

========================================
SECTION 1: FRONTEND CODE
========================================

========================================
FILE: src/main.tsx
========================================

import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';

import App from './App';
import './index.css';

// In development, clear specific version-related localStorage keys
if (process.env.NODE_ENV === 'development') {
  const versionKeys = ['current-deployment-version', 'page-etag', 'page-last-modified', 'manifest-version'];
  versionKeys.forEach((key) => {
    if (localStorage.getItem(key)) {
      console.log('Clearing localStorage key:', key);
      localStorage.removeItem(key);
    }
  });
}

// Render the application
const root = ReactDOM.createRoot(document.getElementById('root')!);
root.render(
  <BrowserRouter>
    <App />
  </BrowserRouter>
);

// Register service worker for PWA functionality
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker
      .register('/sw.js')
      .then((registration) => {
        if (process.env.NODE_ENV === 'development') {
          console.log('SW registered:', registration);
        }

        // Periodically check for updates in production
        let updateInterval: NodeJS.Timeout | undefined;
        if (process.env.NODE_ENV === 'production') {
          updateInterval = setInterval(() => {
            registration.update().catch((error) => {
              console.error('Error updating service worker:', error);
            });
          }, 600000); // 10 minutes

          // Cleanup interval on unload
          window.addEventListener('beforeunload', () => {
            if (updateInterval) {
              clearInterval(updateInterval);
            }
          });
        }

        // Listen for update found
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          if (newWorker) {
            newWorker.addEventListener('statechange', () => {
              if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                if (process.env.NODE_ENV === 'development') {
                  console.log('New version available!');
                }
              }
            });
          }
        });
      })
      .catch((registrationError) => {
        console.error('SW registration failed:', registrationError);
      });
  });

  // Listen for messages from service worker
  navigator.serviceWorker.addEventListener('message', (event) => {
    if (event.data && event.data.type === 'SW_UPDATED') {
      if (process.env.NODE_ENV === 'development') {
        console.log('Service worker updated, reloading page...');
      }
      window.location.reload();
    }
  });
}



========================================
FILE: src/App.tsx
========================================

import { useEffect, lazy } from 'react';
import { Routes, Route, Navigate } from 'react-router-dom';

import ErrorBoundary from './components/ErrorBoundary';
import { PublicRoute, AuthRoute, ProfileRoute } from './components/RouteWrapper';
import { SubscriptionManager } from './components/SubscriptionManager';


// Eager-loaded critical pages
import Auth from './pages/Auth';
import Dashboard from './pages/Dashboard';

// Lazy-loaded non-critical pages
const Onboarding = lazy(() => import('./pages/Onboarding'));
const Generate = lazy(() => import('./pages/Generate'));
const Preview = lazy(() => import('./pages/workout/Preview'));
const Exercise = lazy(() => import('./pages/workout/Exercise'));
const Rest = lazy(() => import('./pages/workout/Rest'));
const Complete = lazy(() => import('./pages/workout/Complete'));
const History = lazy(() => import('./pages/History'));
const WorkoutDetail = lazy(() => import('./pages/WorkoutDetail'));
const Profile = lazy(() => import('./pages/Profile'));
const Subscription = lazy(() => import('./pages/Subscription'));
const Terms = lazy(() => import('./pages/Terms'));
const Privacy = lazy(() => import('./pages/Privacy'));

import { AppProvider } from './providers/AppProvider';
import { HomeGate } from './routes/guards';
import { lockOrientation, preventZoom } from './utils/orientation';
// Version management removed for simplicity
import { usePageTracking } from './hooks/useAnalytics';
import { trackSessionStart } from './lib/firebase-analytics';

function AppContent() {
  // Automatically track page views
  usePageTracking();

  // Handle mobile optimizations, version management, and analytics on mount
  useEffect(() => {
    const cleanupOrientation = lockOrientation();
    const cleanupZoom = preventZoom();

    // Track session start with location context
    trackSessionStart();

    // Version management removed for simplicity

    // Event listener for version updates
    const handleVersionUpdate = () => {
      console.log('Version update detected by version manager');
    };

    window.addEventListener('versionUpdate', handleVersionUpdate);

    // Cleanup on unmount
    return () => {
      cleanupOrientation();
      cleanupZoom();
    };
  }, []);

  return (
    <ErrorBoundary level="critical">
      <div className="min-h-screen">
        <Routes>
          {/* Public legal pages */}
          <Route path="/terms" element={<PublicRoute lazy><Terms /></PublicRoute>} />
          <Route path="/privacy" element={<PublicRoute lazy><Privacy /></PublicRoute>} />

          {/* Landing route: determines user redirection */}
          <Route path="/" element={<HomeGate authPage={<Auth />} />} />

          {/* Onboarding: requires authentication but not a complete profile */}
          <Route path="/onboarding" element={<AuthRoute lazy><Onboarding /></AuthRoute>} />

          {/* Protected routes: require completed profile */}
          <Route path="/dashboard" element={<ProfileRoute><Dashboard /></ProfileRoute>} />
          <Route path="/generate" element={<ProfileRoute lazy><Generate /></ProfileRoute>} />
          <Route path="/workout/preview" element={<ProfileRoute lazy><Preview /></ProfileRoute>} />
          <Route path="/workout/run" element={<ProfileRoute lazy><Exercise /></ProfileRoute>} />
          <Route path="/workout/rest" element={<ProfileRoute lazy><Rest /></ProfileRoute>} />
          <Route path="/workout/complete" element={<ProfileRoute lazy><Complete /></ProfileRoute>} />
          <Route path="/history" element={<ProfileRoute lazy><History /></ProfileRoute>} />
          <Route path="/workout/:workoutId" element={<ProfileRoute lazy><WorkoutDetail /></ProfileRoute>} />
          <Route path="/profile" element={<ProfileRoute lazy><Profile /></ProfileRoute>} />
          <Route path="/subscription" element={<ProfileRoute lazy><Subscription /></ProfileRoute>} />

          {/* Catch-all redirect */}
          <Route path="*" element={<Navigate to="/" replace />} />
        </Routes>

        {/* Unified Subscription Manager - Consolidated subscription functionality */}
        <SubscriptionManager mode="status" />
      </div>
    </ErrorBoundary>
  );
}

export default function App() {
  return (
    <AppProvider>
      <AppContent />
    </AppProvider>
  );
}

========================================
FILE: src/index.css
========================================

@import "tailwindcss";

/* Shimmer animation for skeleton loaders */
@keyframes shimmer {
  0% {
    background-position: -200% 0;
  }
  100% {
    background-position: 200% 0;
  }
}

/* Futuristic loading animations */
.bg-gradient-radial {
  background: radial-gradient(circle, var(--tw-gradient-stops));
}

/* Enhanced Mobile-First Design System */

/* Touch-friendly interactions */
@media (hover: none) and (pointer: coarse) {
  /* Mobile devices - increase touch targets */
  button,
  [role="button"],
  input[type="button"],
  input[type="submit"] {
    min-height: 44px;
    min-width: 44px;
  }

  /* Remove hover effects on touch devices */
  .hover\:scale-105:hover {
    transform: none;
  }

  /* Enhanced tap targets for links */
  a {
    min-height: 44px;
    display: inline-flex;
    align-items: center;
  }
}

/* Improved focus states for accessibility */
*:focus-visible {
  outline: 2px solid #3b82f6;
  outline-offset: 2px;
  border-radius: 4px;
}

/* Smooth scrolling for better UX */
html {
  scroll-behavior: smooth;
}

/* Enhanced safe area support for mobile devices */
@supports (padding: max(0px)) {
  .safe-area-inset-top {
    padding-top: max(1rem, env(safe-area-inset-top));
  }

  .safe-area-inset-bottom {
    padding-bottom: max(1rem, env(safe-area-inset-bottom));
  }

  .safe-area-inset-left {
    padding-left: max(1rem, env(safe-area-inset-left));
  }

  .safe-area-inset-right {
    padding-right: max(1rem, env(safe-area-inset-right));
  }
}

/* Improved text rendering */
body {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-rendering: optimizeLegibility;
}

/* Better button and input styling */
button,
input,
select,
textarea {
  font-family: inherit;
}

/* Fix iOS Safari dark screen issue on input focus */
input,
textarea {
  -webkit-appearance: none;
  -webkit-tap-highlight-color: transparent;
}

/* Prevent iOS zoom on input focus while maintaining accessibility */
@media screen and (max-width: 768px) {
  input[type="text"],
  input[type="email"],
  input[type="password"],
  input[type="number"],
  textarea,
  select {
    font-size: 16px; /* Prevents zoom on iOS */
  }
}

/* Enhanced loading states */
@keyframes pulse-subtle {
  0%,
  100% {
    opacity: 1;
  }
  50% {
    opacity: 0.8;
  }
}

.pulse-subtle {
  animation: pulse-subtle 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

/* Enhanced animations for premium feel */
@keyframes float {
  0%, 100% {
    transform: translateY(0px);
  }
  50% {
    transform: translateY(-10px);
  }
}

@keyframes glow {
  0%, 100% {
    opacity: 0.5;
  }
  50% {
    opacity: 1;
  }
}

@keyframes slide-in-up {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.animate-float {
  animation: float 6s ease-in-out infinite;
}

.animate-glow {
  animation: glow 2s ease-in-out infinite;
}

.animate-slide-in-up {
  animation: slide-in-up 0.5s ease-out;
}

@keyframes loading-progress {
  0% {
    transform: translateX(-100%);
    opacity: 0.6;
  }
  50% {
    opacity: 1;
  }
  100% {
    transform: translateX(0%);
    opacity: 0.8;
  }
}

@keyframes breathe {
  0%, 100% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.02);
  }
}

.animate-breathe {
  animation: breathe 3s ease-in-out infinite;
}

/* Safe area padding for devices with home indicators */
.pb-safe {
  padding-bottom: env(safe-area-inset-bottom, 0.75rem);
}

/* Extra small screen responsive utilities */
@media (min-width: 475px) {
  .xs\:inline {
    display: inline;
  }
  .xs\:hidden {
    display: none;
  }
}

/* Improved gesture support */
.touch-manipulation {
  touch-action: manipulation;
}

.touch-pan-x {
  touch-action: pan-x;
}

.touch-pan-y {
  touch-action: pan-y;
}

/* Enhanced backdrop blur support */
@supports (backdrop-filter: blur(10px)) {
  .backdrop-blur-enhanced {
    backdrop-filter: blur(10px) saturate(180%);
    background-color: rgba(255, 255, 255, 0.8);
  }
}

@supports not (backdrop-filter: blur(10px)) {
  .backdrop-blur-enhanced {
    background-color: rgba(255, 255, 255, 0.95);
  }
}

/* Landscape warning overlay for mobile devices */
.landscape-warning {
  position: relative;
}

.landscape-warning::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.9);
  z-index: 9999;
  display: none;
}

.landscape-warning::after {
  content: 'Please rotate your device to portrait mode for the best experience';
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  text-align: center;
  font-size: 18px;
  font-weight: 600;
  padding: 20px;
  z-index: 10000;
  display: none;
  max-width: 80%;
}

@media screen and (orientation: landscape) and (max-width: 768px) {
  .landscape-warning::before,
  .landscape-warning::after {
    display: block;
  }
}

/* Improved dark mode support (future-proofing) */
@media (prefers-color-scheme: dark) {
  :root {
    --bg-primary: #1f2937;
    --bg-secondary: #374151;
    --text-primary: #f9fafb;
    --text-secondary: #d1d5db;
  }
}

/* Better print styles */
@media print {
  .no-print {
    display: none !important;
  }

  * {
    background: transparent !important;
    color: black !important;
    box-shadow: none !important;
    text-shadow: none !important;
  }
}

.animate-shimmer {
  animation: shimmer 2s ease-in-out infinite;
}

.animate-shimmer-slow {
  animation: shimmer 3s ease-in-out infinite;
}

.animate-shimmer-fast {
  animation: shimmer 1s ease-in-out infinite;
}

/* Advanced Micro-Interactions */

/* Floating animation */
@keyframes float {
  0%,
  100% {
    transform: translateY(0px);
  }
  50% {
    transform: translateY(var(--float-intensity, -10px));
  }
}

.animate-float {
  animation: float 3s ease-in-out infinite;
}

/* Fade in up animation */
@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translate3d(0, 30px, 0);
  }
  to {
    opacity: 1;
    transform: translate3d(0, 0, 0);
  }
}

.animate-fade-in-up {
  animation: fadeInUp 0.6s cubic-bezier(0.4, 0, 0.2, 1) forwards;
}

/* Shake animation for errors */
@keyframes shake {
  0%,
  100% {
    transform: translateX(0);
  }
  10%,
  30%,
  50%,
  70%,
  90% {
    transform: translateX(-4px);
  }
  20%,
  40%,
  60%,
  80% {
    transform: translateX(4px);
  }
}

.animate-shake {
  animation: shake 0.5s cubic-bezier(0.36, 0.07, 0.19, 0.97);
}

/* Bounce once animation */
@keyframes bounceOnce {
  0%,
  20%,
  53%,
  80%,
  100% {
    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
    transform: translate3d(0, 0, 0);
  }
  40%,
  43% {
    animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);
    transform: translate3d(0, -15px, 0);
  }
  70% {
    animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);
    transform: translate3d(0, -7px, 0);
  }
  90% {
    transform: translate3d(0, -2px, 0);
  }
}

.animate-bounce-once {
  animation: bounceOnce 0.6s ease-out;
}

/* Scale in animation */
@keyframes scaleIn {
  from {
    opacity: 0;
    transform: scale(0.9);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

.animate-scale-in {
  animation: scaleIn 0.2s cubic-bezier(0.4, 0, 0.2, 1);
}

/* Slide in from right */
@keyframes slideInRight {
  from {
    opacity: 0;
    transform: translateX(100%);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

.animate-slide-in-right {
  animation: slideInRight 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

========================================
FILE: src/components/AppHeader.tsx
========================================

// src/components/AppHeader.tsx
import { useState } from 'react'
import { useNavigate } from 'react-router-dom'
import { signOut } from 'firebase/auth'
import { auth } from '../lib/firebase'
import { Menu, X, Zap, Home, Dumbbell, History, User, LogOut, Crown } from 'lucide-react'

export default function AppHeader() {
  const [isMenuOpen, setIsMenuOpen] = useState(false)
  const nav = useNavigate()

  const menuItems = [
    { label: 'Dashboard', path: '/dashboard', icon: Home },
    { label: 'Generate Workout', path: '/generate', icon: Dumbbell },
    { label: 'Workout History', path: '/history', icon: History },
    { label: 'Subscription', path: '/subscription', icon: Crown },
    { label: 'Profile', path: '/profile', icon: User },
  ]

  const handleNavigation = (path: string) => {
    nav(path)
    setIsMenuOpen(false)
  }

  const handleSignOut = async () => {
    try {
      await signOut(auth)
      nav('/')
      setIsMenuOpen(false)
    } catch (e) {
      console.error('Sign out failed', e)
      alert('Sign out failed. Please try again.')
    }
  }

  return (
    <>
      <header className="sticky top-0 z-50 bg-white/80 backdrop-blur-enhanced border-b border-gray-100">
        <div className="mx-auto max-w-6xl px-4 sm:px-6 py-2 flex items-center justify-between" style={{ paddingTop: 'max(8px, env(safe-area-inset-top))' }}>
          {/* Logo */}
          <button 
            onClick={() => handleNavigation('/dashboard')}
            className="flex items-center gap-2 hover:opacity-80 transition-opacity"
          >
            <div className="h-6 w-6 rounded-lg bg-gradient-to-tr from-blue-500 to-indigo-600 flex items-center justify-center">
              <Zap className="h-3 w-3 text-white" />
            </div>
            <span className="text-lg font-semibold text-gray-900 tracking-tight">neurafit</span>
          </button>

          {/* Hamburger Menu Button */}
          <button
            onClick={() => setIsMenuOpen(!isMenuOpen)}
            className="p-3 rounded-lg hover:bg-gray-100 transition-colors touch-manipulation min-h-[44px] min-w-[44px] flex items-center justify-center"
            aria-label="Toggle menu"
          >
            {isMenuOpen ? (
              <X className="h-5 w-5 text-gray-700" />
            ) : (
              <Menu className="h-5 w-5 text-gray-700" />
            )}
          </button>
        </div>
      </header>

      {/* Mobile Menu Overlay */}
      {isMenuOpen && (
        <>
          {/* Backdrop */}
          <div 
            className="fixed inset-0 z-40 bg-black/20 backdrop-blur-sm"
            onClick={() => setIsMenuOpen(false)}
          />
          
          {/* Menu Panel */}
          <div className="fixed top-16 right-6 z-50 w-64 bg-white/95 backdrop-blur-md rounded-2xl border border-gray-200 shadow-xl">
            <div className="p-2">
              {menuItems.map((item) => {
                const Icon = item.icon
                return (
                  <button
                    key={item.path}
                    onClick={() => handleNavigation(item.path)}
                    className="w-full flex items-center gap-3 px-4 py-4 text-left rounded-xl hover:bg-gray-100 transition-colors text-gray-700 hover:text-gray-900 touch-manipulation min-h-[48px]"
                  >
                    <Icon className="h-5 w-5" />
                    <span className="font-medium">{item.label}</span>
                  </button>
                )
              })}

              {/* Divider */}
              <div className="my-2 h-px bg-gray-200" />

              {/* Sign Out */}
              <button
                onClick={handleSignOut}
                className="w-full flex items-center gap-3 px-4 py-4 text-left rounded-xl hover:bg-red-50 transition-colors text-red-600 hover:text-red-700 touch-manipulation min-h-[48px]"
              >
                <LogOut className="h-5 w-5" />
                <span className="font-medium">Sign out</span>
              </button>
            </div>
          </div>
        </>
      )}
    </>
  )
}


========================================
FILE: src/components/Charts.tsx
========================================

// Advanced chart components for NeuraFit analytics
// Lightweight SVG-based charts with animations and interactions

import { useMemo, useState } from 'react'
import { cn } from '../lib/utils'

export interface ChartDataPoint {
  label: string
  value: number
  date?: Date
  color?: string
}

export interface LineChartProps {
  data: ChartDataPoint[]
  width?: number
  height?: number
  className?: string
  showGrid?: boolean
  showDots?: boolean
  animated?: boolean
  color?: string
  strokeWidth?: number
}

export function LineChart({
  data,
  width = 400,
  height = 200,
  className,
  showGrid = true,
  showDots = true,
  animated = true,
  color = '#3B82F6',
  strokeWidth = 2
}: LineChartProps) {
  const [hoveredPoint, setHoveredPoint] = useState<number | null>(null)

  const { points } = useMemo(() => {
    if (data.length === 0) return { points: [], maxValue: 0, minValue: 0, xScale: 0, yScale: 0 }

    const values = data.map(d => d.value)
    const maxValue = Math.max(...values)
    const minValue = Math.min(...values)
    const range = maxValue - minValue || 1

    const padding = 40
    const chartWidth = width - padding * 2
    const chartHeight = height - padding * 2

    const xScale = chartWidth / Math.max(data.length - 1, 1)
    const yScale = chartHeight / range

    const points = data.map((point, index) => ({
      x: padding + index * xScale,
      y: padding + (maxValue - point.value) * yScale,
      ...point
    }))

    return { points }
  }, [data, width, height])

  const pathD = useMemo(() => {
    if (points.length === 0) return ''

    let path = ''
    points.forEach((point, index) => {
      const command = index === 0 ? 'M' : 'L'
      path += ` ${command} ${point.x} ${point.y}`
    })
    return path
  }, [points])

  const gradientId = `gradient-${Math.random().toString(36).substr(2, 9)}`

  return (
    <div className={cn('relative', className)}>
      <svg width={width} height={height} className="overflow-visible">
        <defs>
          <linearGradient id={gradientId} x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" stopColor={color} stopOpacity="0.3" />
            <stop offset="100%" stopColor={color} stopOpacity="0.05" />
          </linearGradient>
        </defs>

        {/* Grid lines */}
        {showGrid && (
          <g className="opacity-20">
            {/* Horizontal grid lines */}
            {[0, 0.25, 0.5, 0.75, 1].map((ratio, index) => {
              const y = 40 + ratio * (height - 80)
              return (
                <line
                  key={`h-grid-${index}`}
                  x1={40}
                  y1={y}
                  x2={width - 40}
                  y2={y}
                  stroke="currentColor"
                  strokeWidth="1"
                />
              )
            })}
            
            {/* Vertical grid lines */}
            {points.map((point, index) => (
              <line
                key={`v-grid-${index}`}
                x1={point.x}
                y1={40}
                x2={point.x}
                y2={height - 40}
                stroke="currentColor"
                strokeWidth="1"
                opacity={index % 2 === 0 ? 1 : 0.5}
              />
            ))}
          </g>
        )}

        {/* Area fill */}
        {points.length > 0 && (
          <path
            d={`${pathD} L ${points[points.length - 1].x} ${height - 40} L ${points[0].x} ${height - 40} Z`}
            fill={`url(#${gradientId})`}
            className={animated ? 'animate-scale-in' : ''}
          />
        )}

        {/* Line */}
        {points.length > 0 && (
          <path
            d={pathD}
            fill="none"
            stroke={color}
            strokeWidth={strokeWidth}
            strokeLinecap="round"
            strokeLinejoin="round"
            className={animated ? 'animate-fade-in-up' : ''}
            style={animated ? { animationDelay: '0.2s' } : {}}
          />
        )}

        {/* Data points */}
        {showDots && points.map((point, index) => (
          <circle
            key={index}
            cx={point.x}
            cy={point.y}
            r={hoveredPoint === index ? 6 : 4}
            fill={color}
            stroke="white"
            strokeWidth="2"
            className={cn(
              'cursor-pointer transition-all duration-200',
              animated ? 'animate-scale-in' : ''
            )}
            style={animated ? { animationDelay: `${0.3 + index * 0.1}s` } : {}}
            onMouseEnter={() => setHoveredPoint(index)}
            onMouseLeave={() => setHoveredPoint(null)}
          />
        ))}

        {/* Tooltip */}
        {hoveredPoint !== null && points[hoveredPoint] && (
          <g>
            <rect
              x={points[hoveredPoint].x - 30}
              y={points[hoveredPoint].y - 35}
              width="60"
              height="25"
              rx="4"
              fill="rgba(0, 0, 0, 0.8)"
              className="animate-scale-in"
            />
            <text
              x={points[hoveredPoint].x}
              y={points[hoveredPoint].y - 18}
              textAnchor="middle"
              fill="white"
              fontSize="12"
              fontWeight="500"
            >
              {points[hoveredPoint].value}
            </text>
          </g>
        )}
      </svg>

      {/* Labels */}
      <div className="absolute bottom-0 left-0 right-0 flex justify-between px-10 text-xs text-gray-500">
        {data.map((point, index) => (
          <span key={index} className={index % 2 === 0 ? '' : 'opacity-50'}>
            {point.label}
          </span>
        ))}
      </div>
    </div>
  )
}

export interface BarChartProps {
  data: ChartDataPoint[]
  width?: number
  height?: number
  className?: string
  showValues?: boolean
  animated?: boolean
  color?: string
}

export function BarChart({
  data,
  width = 400,
  height = 200,
  className,
  showValues = true,
  animated = true,
  color = '#3B82F6'
}: BarChartProps) {
  const [hoveredBar, setHoveredBar] = useState<number | null>(null)

  const { bars } = useMemo(() => {
    if (data.length === 0) return { bars: [], maxValue: 0 }

    const maxValue = Math.max(...data.map(d => d.value))
    const padding = 40
    const chartHeight = height - padding * 2
    const barWidth = (width - padding * 2) / data.length * 0.8
    const barSpacing = (width - padding * 2) / data.length * 0.2

    const bars = data.map((point, index) => {
      const barHeight = (point.value / maxValue) * chartHeight
      const x = padding + index * (barWidth + barSpacing) + barSpacing / 2
      const y = height - padding - barHeight

      return {
        x,
        y,
        width: barWidth,
        height: barHeight,
        ...point
      }
    })

    return { bars }
  }, [data, width, height])

  return (
    <div className={cn('relative', className)}>
      <svg width={width} height={height}>
        {/* Bars */}
        {bars.map((bar, index) => (
          <rect
            key={index}
            x={bar.x}
            y={bar.y}
            width={bar.width}
            height={bar.height}
            fill={bar.color || color}
            rx="4"
            className={cn(
              'cursor-pointer transition-all duration-200',
              hoveredBar === index ? 'opacity-80' : 'opacity-100',
              animated ? 'animate-scale-in' : ''
            )}
            style={animated ? { 
              animationDelay: `${index * 0.1}s`,
              transformOrigin: 'bottom'
            } : {}}
            onMouseEnter={() => setHoveredBar(index)}
            onMouseLeave={() => setHoveredBar(null)}
          />
        ))}

        {/* Values */}
        {showValues && bars.map((bar, index) => (
          <text
            key={index}
            x={bar.x + bar.width / 2}
            y={bar.y - 8}
            textAnchor="middle"
            fill="currentColor"
            fontSize="12"
            fontWeight="500"
            className={cn(
              'opacity-70',
              animated ? 'animate-fade-in-up' : ''
            )}
            style={animated ? { animationDelay: `${0.2 + index * 0.1}s` } : {}}
          >
            {bar.value}
          </text>
        ))}
      </svg>

      {/* Labels */}
      <div className="absolute bottom-0 left-0 right-0 flex justify-between px-10 text-xs text-gray-500">
        {data.map((point, index) => (
          <span key={index} className="text-center" style={{ width: `${100 / data.length}%` }}>
            {point.label}
          </span>
        ))}
      </div>
    </div>
  )
}

export interface DonutChartProps {
  data: ChartDataPoint[]
  size?: number
  className?: string
  showLabels?: boolean
  animated?: boolean
  strokeWidth?: number
}

export function DonutChart({
  data,
  size = 200,
  className,
  showLabels = true,
  animated = true,
  strokeWidth = 20
}: DonutChartProps) {
  const [hoveredSegment, setHoveredSegment] = useState<number | null>(null)

  const { segments, total } = useMemo(() => {
    const total = data.reduce((sum, point) => sum + point.value, 0)
    const radius = (size - strokeWidth) / 2
    const circumference = 2 * Math.PI * radius

    let currentAngle = -90 // Start from top

    const segments = data.map((point, index) => {
      const percentage = point.value / total
      const angle = percentage * 360
      const strokeDasharray = `${percentage * circumference} ${circumference}`
      const strokeDashoffset = -currentAngle * (circumference / 360)

      const segment = {
        ...point,
        percentage,
        angle,
        strokeDasharray,
        strokeDashoffset,
        color: point.color || `hsl(${(index * 360) / data.length}, 70%, 50%)`
      }

      currentAngle += angle
      return segment
    })

    return { segments, total }
  }, [data, size, strokeWidth])

  const radius = (size - strokeWidth) / 2
  const center = size / 2

  return (
    <div className={cn('relative inline-block', className)}>
      <svg width={size} height={size}>
        {/* Background circle */}
        <circle
          cx={center}
          cy={center}
          r={radius}
          fill="none"
          stroke="rgba(0, 0, 0, 0.1)"
          strokeWidth={strokeWidth}
        />

        {/* Segments */}
        {segments.map((segment, index) => (
          <circle
            key={index}
            cx={center}
            cy={center}
            r={radius}
            fill="none"
            stroke={segment.color}
            strokeWidth={hoveredSegment === index ? strokeWidth + 4 : strokeWidth}
            strokeDasharray={segment.strokeDasharray}
            strokeDashoffset={segment.strokeDashoffset}
            strokeLinecap="round"
            className={cn(
              'cursor-pointer transition-all duration-300',
              animated ? 'animate-scale-in' : ''
            )}
            style={animated ? { 
              animationDelay: `${index * 0.2}s`,
              transformOrigin: 'center'
            } : {}}
            onMouseEnter={() => setHoveredSegment(index)}
            onMouseLeave={() => setHoveredSegment(null)}
          />
        ))}

        {/* Center text */}
        <text
          x={center}
          y={center - 5}
          textAnchor="middle"
          fill="currentColor"
          fontSize="24"
          fontWeight="bold"
        >
          {total}
        </text>
        <text
          x={center}
          y={center + 15}
          textAnchor="middle"
          fill="currentColor"
          fontSize="12"
          opacity="0.7"
        >
          Total
        </text>
      </svg>

      {/* Legend */}
      {showLabels && (
        <div className="mt-4 space-y-2">
          {segments.map((segment, index) => (
            <div key={index} className="flex items-center gap-2 text-sm">
              <div
                className="w-3 h-3 rounded-full"
                style={{ backgroundColor: segment.color }}
              />
              <span className="flex-1">{segment.label}</span>
              <span className="font-medium">{segment.value}</span>
              <span className="text-gray-500">
                ({Math.round(segment.percentage * 100)}%)
              </span>
            </div>
          ))}
        </div>
      )}
    </div>
  )
}


========================================
FILE: src/components/EnhancedRestTimer.tsx
========================================

// src/components/EnhancedRestTimer.tsx
import { useEffect, useState, useRef } from 'react'
import { Play, Pause, SkipForward, Plus, Minus } from 'lucide-react'
import { CircularProgress, NextExercisePreview } from './WorkoutProgress'

interface EnhancedRestTimerProps {
  initialSeconds: number
  onComplete: () => void
  nextExercise?: {
    name: string
    sets: number
    reps: string | number
    restSeconds?: number
  }
  onTimeChange?: (_seconds: number) => void
}

export function EnhancedRestTimer({
  initialSeconds,
  onComplete,
  nextExercise,
  onTimeChange
}: EnhancedRestTimerProps) {
  const [totalSeconds, setTotalSeconds] = useState(Math.max(1, initialSeconds))
  const [remainingSeconds, setRemainingSeconds] = useState(Math.max(1, initialSeconds))
  const [isPaused, setIsPaused] = useState(false)
  const [isComplete, setIsComplete] = useState(false)
  
  const intervalRef = useRef<number | null>(null)

  // Timer logic
  useEffect(() => {
    if (isPaused || isComplete) return

    if (intervalRef.current !== null) {
      window.clearInterval(intervalRef.current)
    }

    intervalRef.current = window.setInterval(() => {
      setRemainingSeconds(prev => {
        if (prev <= 1) {
          setIsComplete(true)
          return 0
        }
        return prev - 1
      })
    }, 1000)

    return () => {
      if (intervalRef.current !== null) {
        window.clearInterval(intervalRef.current)
      }
    }
  }, [isPaused, isComplete])

  // Handle completion
  useEffect(() => {
    if (isComplete) {
      vibrate(500)
      onComplete()
    }
  }, [isComplete, onComplete])

  // Haptic feedback and document title
  useEffect(() => {
    if (isPaused || isComplete) return

    if (remainingSeconds === 3 || remainingSeconds === 2 || remainingSeconds === 1) {
      vibrate(100)
    }

    // Update document title
    document.title = `Rest: ${remainingSeconds}s - NeuraFit`

    return () => {
      document.title = 'NeuraFit'
    }
  }, [remainingSeconds, isPaused, isComplete])

  // Notify parent of time changes
  useEffect(() => {
    onTimeChange?.(remainingSeconds)
  }, [remainingSeconds, onTimeChange])



  const vibrate = (duration: number) => {
    if ('vibrate' in navigator) {
      navigator.vibrate(duration)
    }
  }

  const adjustTime = (delta: number) => {
    const newTotal = Math.max(1, totalSeconds + delta)
    const newRemaining = Math.max(0, remainingSeconds + delta)
    
    setTotalSeconds(newTotal)
    setRemainingSeconds(newRemaining)
    
    if (newRemaining === 0) {
      setIsComplete(true)
    }
  }

  const togglePause = () => {
    setIsPaused(prev => !prev)
  }

  const skip = () => {
    setRemainingSeconds(0)
    setIsComplete(true)
  }

  const progress = totalSeconds > 0 ? ((totalSeconds - remainingSeconds) / totalSeconds) * 100 : 100
  const minutes = Math.floor(remainingSeconds / 60)
  const seconds = remainingSeconds % 60

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 via-white to-indigo-50 relative">
      {/* Background decoration */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute -top-40 -right-40 w-80 h-80 bg-gradient-to-br from-blue-200/30 to-indigo-200/30 rounded-full blur-3xl" />
        <div className="absolute -bottom-40 -left-40 w-80 h-80 bg-gradient-to-tr from-indigo-200/30 to-blue-200/30 rounded-full blur-3xl" />
      </div>

      <main className="relative mx-auto max-w-4xl px-5 pb-20 pt-6">
        <div className="relative overflow-hidden rounded-3xl border border-gray-200 bg-white/70 backdrop-blur-sm p-6 md:p-8 shadow-lg text-center">
          <div className="absolute -right-16 -top-16 h-56 w-56 rounded-full bg-gradient-to-tr from-blue-400/20 to-indigo-400/20 blur-3xl" />
          
          <h1 className="text-3xl font-bold tracking-tight text-gray-900 mb-2">Rest Time</h1>
          <p className="text-gray-600 text-sm mb-8">
            {isPaused ? 'Timer paused' : isComplete ? 'Rest complete!' : 'Auto-continue when timer ends'}
          </p>

          {/* Main Timer Display */}
          <div className="flex justify-center mb-8">
            <CircularProgress progress={progress} size={200} strokeWidth={12}>
              <div className="text-center">
                <div className="text-4xl font-bold text-gray-900 mb-1">
                  {minutes}:{seconds.toString().padStart(2, '0')}
                </div>
                <div className="text-sm text-gray-600">
                  {isPaused ? 'Paused' : isComplete ? 'Done!' : 'Remaining'}
                </div>
              </div>
            </CircularProgress>
          </div>

          {/* Quick Time Adjustments */}
          <div className="flex items-center justify-center gap-4 mb-8">
            <button
              onClick={() => adjustTime(-15)}
              className="flex items-center gap-2 px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded-xl transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2"
              disabled={isComplete}
              aria-label="Decrease rest time by 15 seconds"
            >
              <Minus className="h-4 w-4" aria-hidden="true" />
              <span className="text-sm font-medium">15s</span>
            </button>

            <button
              onClick={togglePause}
              className={`flex items-center gap-2 px-6 py-3 rounded-xl font-medium transition-all duration-200 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2 ${
                isPaused
                  ? 'bg-green-500 hover:bg-green-600 text-white'
                  : 'bg-yellow-500 hover:bg-yellow-600 text-white'
              }`}
              disabled={isComplete}
              aria-label={isPaused ? 'Resume rest timer' : 'Pause rest timer'}
            >
              {isPaused ? <Play className="h-5 w-5" aria-hidden="true" /> : <Pause className="h-5 w-5" aria-hidden="true" />}
              <span>{isPaused ? 'Resume' : 'Pause'}</span>
            </button>

            <button
              onClick={() => adjustTime(15)}
              className="flex items-center gap-2 px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded-xl transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2"
              disabled={isComplete}
              aria-label="Increase rest time by 15 seconds"
            >
              <Plus className="h-4 w-4" aria-hidden="true" />
              <span className="text-sm font-medium">15s</span>
            </button>
          </div>

          {/* Skip Button */}
          <button
            onClick={skip}
            className="flex items-center gap-2 px-6 py-3 bg-blue-500 hover:bg-blue-600 text-white rounded-xl font-medium transition-colors mx-auto mb-8 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2"
            disabled={isComplete}
            aria-label="Skip rest period and continue to next exercise"
          >
            <SkipForward className="h-5 w-5" aria-hidden="true" />
            <span>Skip Rest</span>
          </button>

          {/* Next Exercise Preview */}
          {nextExercise && (
            <NextExercisePreview 
              nextExercise={nextExercise} 
              timeRemaining={remainingSeconds} 
            />
          )}
        </div>
      </main>
    </div>
  )
}


========================================
FILE: src/components/ErrorBoundary.tsx
========================================

import React, { Component, type ErrorInfo, type ReactNode } from 'react'
import { AlertTriangle, RefreshCw, Home, Bug } from 'lucide-react'

interface Props {
  children: ReactNode
  fallback?: ReactNode
  onError?: (_error: Error, _errorInfo: ErrorInfo) => void
  level?: 'page' | 'component' | 'critical'
}

interface State {
  hasError: boolean
  error: Error | null
  errorInfo: ErrorInfo | null
  errorId: string | null
}

export class ErrorBoundary extends Component<Props, State> {
  private retryCount = 0
  private readonly maxRetries = 3

  constructor(props: Props) {
    super(props)
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null,
      errorId: null
    }
  }

  static getDerivedStateFromError(error: Error): Partial<State> {
    // Generate unique error ID for tracking
    const errorId = `err_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    
    return {
      hasError: true,
      error,
      errorId
    }
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    const { onError, level = 'component' } = this.props
    
    // Log error details
    console.error('ErrorBoundary caught an error:', error, errorInfo)
    
    // Update state with error info
    this.setState({ errorInfo })
    
    // Report error to monitoring service
    this.reportError(error, errorInfo, level)
    
    // Call custom error handler
    onError?.(error, errorInfo)
  }

  private reportError = (error: Error, errorInfo: ErrorInfo, level: string) => {
    // In production, send to error monitoring service (e.g., Sentry)
    const errorReport = {
      message: error.message,
      stack: error.stack,
      componentStack: errorInfo.componentStack,
      level,
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      url: window.location.href,
      errorId: this.state.errorId
    }

    // For now, just log to console
    console.error('Error Report:', errorReport)
    
    // In production, you would send this to your error tracking service:
    // errorTrackingService.captureException(error, { extra: errorReport })
  }

  private handleRetry = () => {
    if (this.retryCount < this.maxRetries) {
      this.retryCount++
      this.setState({
        hasError: false,
        error: null,
        errorInfo: null,
        errorId: null
      })
    }
  }

  private handleReload = () => {
    window.location.reload()
  }

  private handleGoHome = () => {
    window.location.href = '/dashboard'
  }

  private renderErrorUI() {
    const { level = 'component' } = this.props
    const { error, errorId } = this.state
    const canRetry = this.retryCount < this.maxRetries

    // Critical errors get full-page treatment
    if (level === 'critical') {
      return (
        <div className="min-h-screen bg-gradient-to-br from-red-50 via-white to-orange-50 flex items-center justify-center p-4">
          <div className="max-w-md w-full bg-white rounded-2xl shadow-xl border border-red-100 p-8 text-center">
            <div className="w-16 h-16 bg-red-100 rounded-full flex items-center justify-center mx-auto mb-6">
              <AlertTriangle className="w-8 h-8 text-red-600" />
            </div>
            
            <h1 className="text-2xl font-bold text-gray-900 mb-2">
              Something went wrong
            </h1>
            
            <p className="text-gray-600 mb-6">
              We encountered a critical error. Please try refreshing the page or contact support if the problem persists.
            </p>
            
            <div className="space-y-3">
              <button
                onClick={this.handleReload}
                className="w-full flex items-center justify-center gap-2 px-4 py-3 bg-gradient-to-r from-blue-500 to-indigo-600 text-white rounded-xl font-medium hover:from-blue-600 hover:to-indigo-700 transition-all duration-200"
              >
                <RefreshCw className="w-4 h-4" />
                Refresh Page
              </button>
              
              <button
                onClick={this.handleGoHome}
                className="w-full flex items-center justify-center gap-2 px-4 py-3 bg-gray-100 text-gray-700 rounded-xl font-medium hover:bg-gray-200 transition-all duration-200"
              >
                <Home className="w-4 h-4" />
                Go to Dashboard
              </button>
            </div>
            
            {errorId && (
              <div className="mt-6 p-3 bg-gray-50 rounded-lg">
                <p className="text-xs text-gray-500">
                  Error ID: <code className="font-mono">{errorId}</code>
                </p>
              </div>
            )}
          </div>
        </div>
      )
    }

    // Component-level errors get inline treatment
    return (
      <div className="bg-red-50 border border-red-200 rounded-xl p-6 m-4">
        <div className="flex items-start gap-3">
          <div className="flex-shrink-0">
            <Bug className="w-5 h-5 text-red-600 mt-0.5" />
          </div>
          
          <div className="flex-1 min-w-0">
            <h3 className="text-sm font-medium text-red-800 mb-1">
              Component Error
            </h3>
            
            <p className="text-sm text-red-700 mb-3">
              {error?.message || 'An unexpected error occurred in this component.'}
            </p>
            
            <div className="flex gap-2">
              {canRetry && (
                <button
                  onClick={this.handleRetry}
                  className="inline-flex items-center gap-1 px-3 py-1.5 text-xs font-medium bg-red-100 text-red-700 rounded-lg hover:bg-red-200 transition-colors"
                >
                  <RefreshCw className="w-3 h-3" />
                  Retry ({this.maxRetries - this.retryCount} left)
                </button>
              )}
              
              <button
                onClick={this.handleReload}
                className="inline-flex items-center gap-1 px-3 py-1.5 text-xs font-medium bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 transition-colors"
              >
                <RefreshCw className="w-3 h-3" />
                Refresh Page
              </button>
            </div>
            
            {errorId && (
              <p className="text-xs text-red-600 mt-2 font-mono">
                ID: {errorId}
              </p>
            )}
          </div>
        </div>
      </div>
    )
  }

  render() {
    if (this.state.hasError) {
      // Use custom fallback if provided
      if (this.props.fallback) {
        return this.props.fallback
      }
      
      return this.renderErrorUI()
    }

    return this.props.children
  }
}



// Simplified error boundary - use the main ErrorBoundary with level prop instead



export default ErrorBoundary


========================================
FILE: src/components/Loading.tsx
========================================

/**
 * Simplified Loading Components
 */

import React, { memo } from 'react'
import { Loader2, Brain } from 'lucide-react'

// Simple loading spinner
interface LoadingSpinnerProps {
  size?: 'sm' | 'md' | 'lg'
  text?: string
  fullScreen?: boolean
  className?: string
}

export const LoadingSpinner = memo(({
  size = 'md',
  text,
  fullScreen = false,
  className = ''
}: LoadingSpinnerProps) => {
  const sizeClasses = {
    sm: 'h-4 w-4',
    md: 'h-6 w-6',
    lg: 'h-8 w-8'
  }

  const spinner = (
    <div className={`flex flex-col items-center justify-center gap-3 ${className}`} role="status" aria-live="polite">
      <Loader2
        className={`${sizeClasses[size]} animate-spin text-blue-600`}
        aria-hidden="true"
      />
      {text && (
        <p className="text-gray-600 font-medium" aria-label={text}>
          {text}
        </p>
      )}
      <span className="sr-only">Loading...</span>
    </div>
  )

  if (fullScreen) {
    return (
      <div
        className="fixed inset-0 bg-white/80 backdrop-blur-sm flex items-center justify-center z-50"
        role="status"
        aria-label="Loading"
      >
        {spinner}
      </div>
    )
  }

  return (
    <div role="status" aria-label="Loading">
      {spinner}
    </div>
  )
})

LoadingSpinner.displayName = 'LoadingSpinner'

// Simple skeleton component
export function SkeletonBase({
  className = '',
  variant = 'default'
}: {
  className?: string;
  variant?: 'default' | 'text' | 'circular' | 'rectangular';
}) {
  const variantClasses = {
    default: 'rounded',
    text: 'rounded-sm',
    circular: 'rounded-full',
    rectangular: 'rounded-lg'
  }

  return (
    <div
      className={`animate-pulse bg-gray-200 ${variantClasses[variant]} ${className}`}
      role="status"
      aria-label="Loading content"
    >
      <span className="sr-only">Loading...</span>
    </div>
  )
}

// Enhanced workout generation loading component
interface ProgressiveLoadingBarProps {
  isVisible: boolean
  onComplete?: () => void
  text?: string
}

export function ProgressiveLoadingBar({
  isVisible,
  onComplete: _onComplete,
  text = 'Generating your workout...'
}: ProgressiveLoadingBarProps) {
  if (!isVisible) return null

  return <EnhancedWorkoutLoader text={text} />
}

// Enhanced workout generation loader with AI-themed animations
interface EnhancedWorkoutLoaderProps {
  text?: string
}

export function EnhancedWorkoutLoader({
  text: _text = 'Generating your personalized workout...'
}: EnhancedWorkoutLoaderProps) {
  const [currentMessage, setCurrentMessage] = React.useState(0)

  const messages = [
    'Analyzing your fitness profile...',
    'Selecting optimal exercises...',
    'Calculating perfect intensity...',
    'Personalizing your workout...',
    'Finalizing your training plan...'
  ]

  // Cycle through messages every 3.5 seconds to match ~17.5s average API response time
  // This ensures the animation completes one full cycle (5 messages × 3.5s = 17.5s)
  React.useEffect(() => {
    if (process.env.NODE_ENV === 'development') {
      console.log('[LOADING] Animation started at:', new Date().toISOString())
    }

    const interval = setInterval(() => {
      setCurrentMessage((prev) => {
        const next = (prev + 1) % messages.length
        if (process.env.NODE_ENV === 'development') {
          console.log(`[LOADING] Message ${next + 1}/${messages.length}: ${messages[next]}`)
        }
        return next
      })
    }, 3500)

    return () => {
      clearInterval(interval)
      if (process.env.NODE_ENV === 'development') {
        console.log('[LOADING] Animation ended at:', new Date().toISOString())
      }
    }
  }, [messages])
  return (
    <div className="fixed inset-0 bg-gradient-to-br from-black/60 via-black/50 to-black/60 backdrop-blur-md flex items-center justify-center z-50 p-4">
      {/* Background animated elements */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute top-1/4 left-1/4 w-32 h-32 bg-gradient-to-r from-blue-400/20 to-indigo-400/20 rounded-full blur-xl animate-pulse" />
        <div className="absolute bottom-1/4 right-1/4 w-24 h-24 bg-gradient-to-r from-purple-400/20 to-pink-400/20 rounded-full blur-xl animate-pulse delay-1000" />
        <div className="absolute top-1/2 right-1/3 w-16 h-16 bg-gradient-to-r from-emerald-400/20 to-teal-400/20 rounded-full blur-xl animate-pulse delay-500" />
      </div>

      {/* Main loading card */}
      <div className="relative bg-gradient-to-br from-white/95 via-white/90 to-white/95 backdrop-blur-xl rounded-3xl p-8 sm:p-10 max-w-md w-full shadow-2xl shadow-black/20 border border-white/20 animate-breathe">
        {/* Animated border glow */}
        <div className="absolute inset-0 rounded-3xl bg-gradient-to-r from-blue-500/20 via-indigo-500/20 to-purple-500/20 blur-sm animate-pulse" />

        <div className="relative text-center space-y-6">
          {/* AI Brain Icon with pulsing animation */}
          <div className="relative mx-auto w-20 h-20 mb-6">
            <div className="absolute inset-0 bg-gradient-to-r from-blue-500 via-indigo-600 to-purple-600 rounded-2xl animate-pulse shadow-lg shadow-blue-500/30" />
            <div className="relative w-full h-full bg-gradient-to-br from-blue-500 via-indigo-600 to-purple-600 rounded-2xl flex items-center justify-center shadow-xl">
              <Brain className="w-10 h-10 text-white animate-pulse" />
            </div>
            {/* Orbiting dots */}
            <div className="absolute -inset-4">
              <div className="absolute top-0 left-1/2 w-2 h-2 bg-blue-400 rounded-full animate-spin origin-bottom transform -translate-x-1/2" style={{ animationDuration: '3s' }} />
              <div className="absolute bottom-0 left-1/2 w-2 h-2 bg-indigo-400 rounded-full animate-spin origin-top transform -translate-x-1/2" style={{ animationDuration: '3s', animationDelay: '1s' }} />
              <div className="absolute left-0 top-1/2 w-2 h-2 bg-purple-400 rounded-full animate-spin origin-right transform -translate-y-1/2" style={{ animationDuration: '3s', animationDelay: '2s' }} />
            </div>
          </div>

          {/* Enhanced loading text */}
          <div className="space-y-3">
            <h3 className="text-xl sm:text-2xl font-bold bg-gradient-to-r from-gray-900 via-gray-800 to-gray-900 bg-clip-text text-transparent leading-tight">
              AI is crafting your workout
            </h3>
            <div className="h-12 flex items-center justify-center">
              <p className="text-gray-600 font-medium text-sm sm:text-base leading-relaxed transition-all duration-500 ease-in-out">
                {messages[currentMessage]}
              </p>
            </div>
          </div>

          {/* Futuristic Loading Spinner */}
          <div className="flex justify-center items-center py-6">
            <div className="relative w-24 h-24">
              {/* Outer rotating ring */}
              <div className="absolute inset-0 rounded-full border-4 border-transparent border-t-blue-500 border-r-indigo-500 animate-spin" style={{ animationDuration: '1.5s' }} />

              {/* Middle rotating ring - opposite direction */}
              <div className="absolute inset-2 rounded-full border-4 border-transparent border-b-purple-500 border-l-pink-500 animate-spin" style={{ animationDuration: '2s', animationDirection: 'reverse' }} />

              {/* Inner pulsing core */}
              <div className="absolute inset-6 rounded-full bg-gradient-to-br from-blue-400 via-indigo-500 to-purple-600 animate-pulse shadow-lg shadow-blue-500/50" />

              {/* Center dot */}
              <div className="absolute inset-0 flex items-center justify-center">
                <div className="w-3 h-3 rounded-full bg-white shadow-lg animate-pulse" />
              </div>

              {/* Orbiting particles */}
              <div className="absolute inset-0">
                <div className="absolute top-0 left-1/2 w-2 h-2 bg-blue-400 rounded-full -translate-x-1/2 animate-ping" style={{ animationDuration: '2s' }} />
                <div className="absolute bottom-0 left-1/2 w-2 h-2 bg-indigo-400 rounded-full -translate-x-1/2 animate-ping" style={{ animationDuration: '2s', animationDelay: '0.5s' }} />
                <div className="absolute left-0 top-1/2 w-2 h-2 bg-purple-400 rounded-full -translate-y-1/2 animate-ping" style={{ animationDuration: '2s', animationDelay: '1s' }} />
                <div className="absolute right-0 top-1/2 w-2 h-2 bg-pink-400 rounded-full -translate-y-1/2 animate-ping" style={{ animationDuration: '2s', animationDelay: '1.5s' }} />
              </div>
            </div>
          </div>

          {/* Step indicator dots */}
          <div className="flex justify-center items-center space-x-2">
            {messages.map((_, index) => (
              <div
                key={index}
                className={`transition-all duration-500 rounded-full ${
                  index === currentMessage
                    ? 'w-8 h-2 bg-gradient-to-r from-blue-500 via-indigo-600 to-purple-600 shadow-md shadow-blue-500/30'
                    : index < currentMessage
                    ? 'w-2 h-2 bg-gradient-to-r from-blue-400 to-indigo-500'
                    : 'w-2 h-2 bg-gray-300'
                }`}
              />
            ))}
          </div>

          {/* Motivational message */}
          <div className="pt-2">
            <p className="text-xs text-gray-500 font-medium italic">
              Creating the perfect workout just for you...
            </p>
          </div>
        </div>
      </div>
    </div>
  )
}

// Simple skeleton loaders for common use cases
export function WorkoutHistorySkeleton() {
  return (
    <div className="space-y-4">
      {[...Array(3)].map((_, i) => (
        <div key={i} className="bg-white rounded-xl p-6 border border-gray-100">
          <div className="flex items-center justify-between mb-4">
            <SkeletonBase className="h-6 w-32" variant="text" />
            <SkeletonBase className="h-4 w-20" variant="text" />
          </div>
          <div className="space-y-2">
            <SkeletonBase className="h-4 w-full" variant="text" />
            <SkeletonBase className="h-4 w-3/4" variant="text" />
          </div>
        </div>
      ))}
    </div>
  )
}

export function WorkoutDetailSkeleton() {
  return (
    <div className="space-y-6">
      <SkeletonBase className="h-8 w-48" variant="text" />
      <div className="space-y-4">
        {[...Array(4)].map((_, i) => (
          <div key={i} className="border rounded-lg p-4">
            <SkeletonBase className="h-6 w-40 mb-2" variant="text" />
            <SkeletonBase className="h-4 w-24" variant="text" />
          </div>
        ))}
      </div>
    </div>
  )
}

// Default export for backward compatibility
export default LoadingSpinner


========================================
FILE: src/components/MotivationalBanner.tsx
========================================

// src/components/MotivationalBanner.tsx
import { Trophy, Target, Zap, TrendingUp, Award } from 'lucide-react'

interface MotivationalBannerProps {
  totalWorkouts: number
  weeklyWorkouts: number
  streak: number
  consistencyScore: number
}

export function MotivationalBanner({ 
  totalWorkouts, 
  weeklyWorkouts, 
  streak, 
  consistencyScore 
}: MotivationalBannerProps) {
  const getMotivationalMessage = () => {
    if (streak >= 7) {
      return {
        icon: Trophy,
        title: `${streak} Day Streak! 🔥`,
        message: "You're on fire! This consistency is building incredible momentum.",
        color: "from-orange-500 to-red-500",
        bgColor: "from-orange-50 to-red-50"
      }
    }

    if (weeklyWorkouts >= 4) {
      return {
        icon: Award,
        title: "Crushing Your Goals!",
        message: `${weeklyWorkouts} workouts this week - you're exceeding expectations!`,
        color: "from-green-500 to-emerald-600",
        bgColor: "from-green-50 to-emerald-50"
      }
    }

    if (consistencyScore >= 80) {
      return {
        icon: Target,
        title: "Consistency Champion",
        message: `${Math.round(consistencyScore)}% consistency rate - you're building lasting habits!`,
        color: "from-purple-500 to-violet-600",
        bgColor: "from-purple-50 to-violet-50"
      }
    }

    if (totalWorkouts >= 10) {
      return {
        icon: TrendingUp,
        title: "Building Momentum",
        message: `${totalWorkouts} workouts completed - you're making real progress!`,
        color: "from-blue-500 to-cyan-600",
        bgColor: "from-blue-50 to-cyan-50"
      }
    }

    return {
      icon: Zap,
      title: "Keep Going Strong!",
      message: "Every workout brings you closer to your goals. You've got this!",
      color: "from-indigo-500 to-blue-600",
      bgColor: "from-indigo-50 to-blue-50"
    }
  }

  const motivation = getMotivationalMessage()
  const Icon = motivation.icon

  return (
    <div className={`group relative overflow-hidden rounded-3xl bg-gradient-to-br ${motivation.bgColor} border border-white/70 shadow-2xl shadow-slate-200/40 hover:shadow-3xl hover:shadow-slate-300/30 transition-all duration-700 hover:scale-[1.005] hover:-translate-y-1`}>
      <div className="absolute inset-0 bg-gradient-to-br from-white/40 via-white/25 to-transparent" />
      <div className="absolute -right-20 -top-20 h-40 w-40 rounded-full bg-white/25 blur-3xl group-hover:blur-2xl group-hover:scale-110 transition-all duration-700" />
      <div className="absolute -left-16 -bottom-16 h-32 w-32 rounded-full bg-white/15 blur-2xl group-hover:blur-3xl transition-all duration-700" />
      <div className="relative p-6 sm:p-8 lg:p-10">
        <div className="flex flex-col sm:flex-row sm:items-center gap-6">
          <div className={`w-18 h-18 sm:w-20 sm:h-20 rounded-2xl bg-gradient-to-br ${motivation.color} flex items-center justify-center shadow-2xl shadow-current/30 group-hover:shadow-current/50 group-hover:scale-110 transition-all duration-500`}>
            <Icon className="h-9 w-9 sm:h-10 sm:w-10 text-white" />
          </div>
          <div className="flex-1 space-y-3">
            <h3 className="text-xl sm:text-2xl lg:text-3xl font-bold text-gray-900 group-hover:text-gray-800 transition-colors duration-300 leading-tight tracking-tight">
              {motivation.title}
            </h3>
            <p className="text-gray-700/90 text-base sm:text-lg lg:text-xl leading-relaxed font-medium max-w-2xl">
              {motivation.message}
            </p>
          </div>
        </div>
      </div>
    </div>
  )
}

interface WeeklyGoalProgressProps {
  currentWorkouts: number
  goalWorkouts?: number
}

export function WeeklyGoalProgress({ currentWorkouts, goalWorkouts = 3 }: WeeklyGoalProgressProps) {
  const progress = Math.min((currentWorkouts / goalWorkouts) * 100, 100)
  const isComplete = currentWorkouts >= goalWorkouts

  return (
    <div className="bg-white/80 backdrop-blur-sm rounded-xl p-4 border border-slate-200/50 shadow-sm">
      <div className="flex items-center justify-between mb-3">
        <div>
          <h4 className="font-semibold text-slate-900">Weekly Goal</h4>
          <p className="text-sm text-slate-600">{currentWorkouts} of {goalWorkouts} workouts</p>
        </div>
        <div className={`text-2xl font-bold ${isComplete ? 'text-emerald-600' : 'text-slate-700'}`}>
          {Math.round(progress)}%
        </div>
      </div>

      <div className="w-full bg-slate-200 rounded-full h-2 mb-2">
        <div
          className={`h-2 rounded-full transition-all duration-500 ease-out ${
            isComplete
              ? 'bg-gradient-to-r from-emerald-500 to-emerald-600'
              : 'bg-gradient-to-r from-slate-500 to-slate-600'
          }`}
          style={{ width: `${progress}%` }}
        />
      </div>

      {isComplete && (
        <div className="flex items-center gap-1 text-emerald-600 text-sm font-medium">
          <Trophy className="h-4 w-4" />
          Goal achieved!
        </div>
      )}
    </div>
  )
}

interface NextWorkoutSuggestionProps {
  lastWorkoutType?: string
  daysSinceLastWorkout?: number
}

export function NextWorkoutSuggestion({ daysSinceLastWorkout = 0 }: NextWorkoutSuggestionProps) {
  const getSuggestion = () => {
    if (daysSinceLastWorkout === 0) {
      return {
        title: "Great job today!",
        suggestion: "Take some time to recover, then come back stronger tomorrow.",
        urgency: "low"
      }
    }
    
    if (daysSinceLastWorkout === 1) {
      return {
        title: "Ready for another session?",
        suggestion: "Perfect timing for your next workout. Your muscles are recovered and ready!",
        urgency: "medium"
      }
    }
    
    if (daysSinceLastWorkout >= 3) {
      return {
        title: "Time to get back in there!",
        suggestion: "It's been a few days - your body is ready for some action!",
        urgency: "high"
      }
    }
    
    return {
      title: "Keep the momentum going",
      suggestion: "You're in a great rhythm. Ready for your next challenge?",
      urgency: "medium"
    }
  }

  const suggestion = getSuggestion()
  const urgencyColors = {
    low: "from-gray-500 to-gray-600",
    medium: "from-blue-500 to-indigo-600", 
    high: "from-orange-500 to-red-500"
  }

  return (
    <div className="bg-white/70 backdrop-blur-sm rounded-xl p-4 border border-gray-100/50 shadow-sm">
      <div className="flex items-center gap-3">
        <div className={`w-10 h-10 rounded-lg bg-gradient-to-r ${urgencyColors[suggestion.urgency as keyof typeof urgencyColors]} flex items-center justify-center`}>
          <Zap className="h-5 w-5 text-white" />
        </div>
        <div className="flex-1">
          <h4 className="font-semibold text-gray-900 text-sm">{suggestion.title}</h4>
          <p className="text-xs text-gray-600 mt-1">{suggestion.suggestion}</p>
        </div>
      </div>
    </div>
  )
}


========================================
FILE: src/components/PaymentForm.tsx
========================================

import React, { useState, useEffect } from 'react'
import {
  useStripe,
  useElements,
  PaymentElement,
  Elements
} from '@stripe/react-stripe-js'
import { Loader2, AlertCircle, CheckCircle } from 'lucide-react'
import { stripePromise, STRIPE_CONFIG } from '../lib/stripe-config'
import { subscriptionService } from '../lib/subscriptionService'
import { trackSubscriptionStarted, trackSubscriptionCompleted } from '../lib/firebase-analytics'


interface PaymentFormProps {
  priceId: string
  onSuccess: () => void
  onError: (_error: string) => void
  onCancel: () => void
}

interface PaymentFormInnerProps {
  onSuccess: () => void
  onError: (_error: string) => void
  onCancel: () => void
  subscriptionId: string
}

function PaymentFormInner({ onSuccess, onError, onCancel, subscriptionId: propSubscriptionId }: PaymentFormInnerProps) {
  const stripe = useStripe()
  const elements = useElements()
  const [loading, setLoading] = useState(false)
  const [message, setMessage] = useState<string>('')
  const [messageType, setMessageType] = useState<'error' | 'success' | 'info'>('info')
  const [activationMethod, setActivationMethod] = useState<string>('')
  const [localSubscriptionId] = useState<string>('')


  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault()

    if (!stripe || !elements) {
      return
    }

    setLoading(true)
    setMessage('')
    setActivationMethod('')

    // Track subscription attempt
    trackSubscriptionStarted()

    const { error, paymentIntent } = await stripe.confirmPayment({
      elements,
      confirmParams: {
        return_url: `${window.location.origin}/profile?payment=success`,
      },
      redirect: 'if_required'
    })

    if (error) {
      let errorMessage = 'Payment failed'

      // Handle specific error types with user-friendly messages
      switch (error.type) {
        case 'card_error':
          switch (error.code) {
            case 'card_declined':
              errorMessage = 'Your card was declined. Please try a different payment method.'
              break
            case 'insufficient_funds':
              errorMessage = 'Insufficient funds. Please check your account balance or try a different card.'
              break
            case 'expired_card':
              errorMessage = 'Your card has expired. Please use a different payment method.'
              break
            case 'incorrect_cvc':
              errorMessage = 'The security code is incorrect. Please check and try again.'
              break
            case 'processing_error':
              errorMessage = 'An error occurred while processing your card. Please try again.'
              break
            default:
              errorMessage = error.message || 'Your card was declined. Please try a different payment method.'
          }
          break
        case 'validation_error':
          errorMessage = error.message || 'Please check your payment information and try again.'
          break
        case 'api_error':
          errorMessage = 'A temporary error occurred. Please try again in a moment.'
          break
        case 'rate_limit_error':
          errorMessage = 'Too many requests. Please wait a moment and try again.'
          break
        default:
          errorMessage = 'An unexpected error occurred. Please try again.'
      }

      setMessage(errorMessage)
      setMessageType('error')
      onError(errorMessage)
      setLoading(false)
      return
    }

    // Payment succeeded - now use robust activation
    setMessage('Payment successful! Activating subscription...')
    setMessageType('success')

    // Track successful subscription
    trackSubscriptionCompleted('stripe_payment_' + Date.now())

    try {
      // Extract subscription ID from payment intent metadata or use stored value
      const currentSubscriptionId = propSubscriptionId || localSubscriptionId || (paymentIntent as { metadata?: { subscription_id?: string } })?.metadata?.subscription_id || ''

      if (!currentSubscriptionId) {
        throw new Error('No subscription ID found')
      }

      console.log(`🚀 Starting activation for subscription: ${currentSubscriptionId}`)

      // Simplified activation - just refresh subscription data
      await subscriptionService.getSubscription()

      setMessage('Subscription activated successfully!')
      setActivationMethod('direct')
      setMessageType('success')

      console.log('✅ Subscription activated successfully')

      // Small delay to let the UI update
      setTimeout(() => {
        onSuccess()
      }, 1500)
    } catch (error) {
      console.error('Error during robust subscription activation:', error)
      setMessage('Payment processed! Your subscription will be activated shortly.')
      setMessageType('info')

      // Still call onSuccess - payment was successful
      setTimeout(() => {
        onSuccess()
      }, 3000)
    }

    setLoading(false)
  }

  return (
    <div className="max-w-md mx-auto">
      <form onSubmit={handleSubmit} className="space-y-6">
        {/* Payment Element */}
        <div className="p-4 border border-gray-200 rounded-xl bg-white">
          <PaymentElement
            options={{
              layout: 'tabs',
              wallets: {
                applePay: 'never',
                googlePay: 'never'
              }
            }}
          />
        </div>

        {/* Message */}
        {message && (
          <div className={`
            flex items-center gap-2 p-3 rounded-lg text-sm
            ${messageType === 'error' ? 'bg-red-50 text-red-700' : ''}
            ${messageType === 'success' ? 'bg-green-50 text-green-700' : ''}
            ${messageType === 'info' ? 'bg-blue-50 text-blue-700' : ''}
          `}>
            {messageType === 'error' && <AlertCircle className="w-4 h-4" />}
            {messageType === 'success' && <CheckCircle className="w-4 h-4" />}
            <div className="flex-1">
              {message}
              {activationMethod && (
                <div className="text-xs opacity-75 mt-1">
                  Activated via: {activationMethod}
                </div>
              )}
            </div>
          </div>
        )}

        {/* Action Buttons */}
        <div className="flex gap-3">
          <button
            type="button"
            onClick={onCancel}
            className="flex-1 py-3 px-4 border border-gray-300 text-gray-700 rounded-xl font-medium hover:bg-gray-50 transition-colors"
            disabled={loading}
          >
            Cancel
          </button>
          <button
            type="submit"
            disabled={!stripe || loading}
            className="flex-1 py-3 px-4 bg-blue-500 text-white rounded-xl font-medium hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
          >
            {loading ? (
              <div className="flex items-center justify-center gap-2">
                <Loader2 className="w-4 h-4 animate-spin" />
                Processing...
              </div>
            ) : (
              'Subscribe'
            )}
          </button>
        </div>
      </form>



      {/* Security Notice */}
      <div className="mt-6 text-center">
        <p className="text-xs text-gray-500">
          🔒 Your payment information is secure and encrypted
        </p>
      </div>


    </div>
  )
}

export function PaymentForm({ priceId, onSuccess, onError, onCancel }: PaymentFormProps) {
  const [clientSecret, setClientSecret] = useState<string>('')
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string>('')
  const [_subscriptionId, _setSubscriptionId] = useState<string>('')

  useEffect(() => {
    // Prevent multiple initializations
    if (clientSecret || error) {
      console.log('🚫 Skipping initialization - already have clientSecret or error')
      return
    }

    const initializePayment = async () => {
      try {
        if (!priceId) {
          setError('No price ID provided')
          onError('No price ID provided')
          setLoading(false)
          return
        }

        setLoading(true)
        const result = await subscriptionService.createPaymentIntent(priceId)
        if (result) {
          setClientSecret(result.clientSecret)
          // Note: subscriptionId is handled by the backend
        }

        console.log(`✅ Payment initialized - Client Secret: ${result.clientSecret}`)
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Failed to initialize payment'
        setError(errorMessage)
        onError(errorMessage)
      } finally {
        setLoading(false)
      }
    }

    initializePayment()
  }, [priceId, onError, clientSecret, error]) // Include all dependencies

  if (loading) {
    return (
      <div className="flex items-center justify-center py-12">
        <div className="flex items-center gap-3">
          <Loader2 className="w-6 h-6 animate-spin text-blue-500" />
          <span className="text-gray-600">Initializing payment...</span>
        </div>

      </div>
    )
  }

  if (error) {
    return (
      <div className="text-center py-12">
        <div className="flex items-center justify-center gap-2 text-red-600 mb-4">
          <AlertCircle className="w-6 h-6" />
          <span className="font-medium">Payment initialization failed</span>
        </div>
        <p className="text-gray-600 mb-6">{error}</p>
        <div className="flex gap-3 justify-center">
          <button
            onClick={() => {
              setError('')
              setLoading(true)
              // Retry initialization
              const initializePayment = async () => {
                try {
                  const result = await subscriptionService.createPaymentIntent(priceId)
                  if (result) {
                    setClientSecret(result.clientSecret)
                  }
                } catch (err) {
                  const errorMessage = err instanceof Error ? err.message : 'Failed to initialize payment'
                  setError(errorMessage)
                  onError(errorMessage)
                } finally {
                  setLoading(false)
                }
              }
              initializePayment()
            }}
            className="px-6 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors"
          >
            Try Again
          </button>
          <button
            onClick={onCancel}
            className="px-6 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 transition-colors"
          >
            Go Back
          </button>
        </div>
      </div>
    )
  }

  if (!clientSecret) {
    return (
      <div className="text-center py-12">
        <p className="text-gray-600">Unable to initialize payment. Please try again.</p>
        <button
          onClick={onCancel}
          className="mt-4 px-6 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 transition-colors"
        >
          Go Back
        </button>
      </div>
    )
  }

  const options = {
    clientSecret,
    appearance: STRIPE_CONFIG.appearance,
  }

  return (
    <Elements stripe={stripePromise} options={options}>
      <PaymentFormInner
        onSuccess={onSuccess}
        onError={onError}
        onCancel={onCancel}
        subscriptionId={_subscriptionId}
      />
    </Elements>
  )
}

export default PaymentForm


========================================
FILE: src/components/ProgressiveOverloadTracker.tsx
========================================

// src/components/ProgressiveOverloadTracker.tsx
import { useMemo } from 'react'
import { TrendingUp, Target, Award, Calendar } from 'lucide-react'

interface WorkoutSession {
  date: string
  exercises: {
    name: string
    sets: { weight: number | null; reps: number; completed: boolean }[]
  }[]
}

interface ProgressiveOverloadTrackerProps {
  exerciseName: string
  recentSessions: WorkoutSession[]
  currentWeight?: number | null
  targetReps?: number | string
}

interface ProgressMetrics {
  volumeProgression: number[]
  maxWeightProgression: number[]
  averageWeightProgression: number[]
  totalVolumeChange: number
  maxWeightChange: number
  consistencyScore: number
  recommendations: string[]
}

export function ProgressiveOverloadTracker({
  exerciseName,
  recentSessions,
  currentWeight,
  targetReps: _targetReps
}: ProgressiveOverloadTrackerProps) {
  const metrics = useMemo((): ProgressMetrics => {
    const exerciseData = recentSessions
      .map(session => ({
        date: session.date,
        exercise: session.exercises.find(ex => ex.name === exerciseName)
      }))
      .filter(data => data.exercise)
      .slice(-8) // Last 8 sessions

    if (exerciseData.length === 0) {
      return {
        volumeProgression: [],
        maxWeightProgression: [],
        averageWeightProgression: [],
        totalVolumeChange: 0,
        maxWeightChange: 0,
        consistencyScore: 0,
        recommendations: ['Complete more workouts to see progression analysis']
      }
    }

    // Calculate progressions
    const volumeProgression: number[] = []
    const maxWeightProgression: number[] = []
    const averageWeightProgression: number[] = []

    exerciseData.forEach(({ exercise }) => {
      if (!exercise) return

      const completedSets = exercise.sets.filter(set => set.completed && set.weight && set.weight > 0)
      
      if (completedSets.length === 0) {
        volumeProgression.push(0)
        maxWeightProgression.push(0)
        averageWeightProgression.push(0)
        return
      }

      // Volume = weight × reps × sets
      const totalVolume = completedSets.reduce((sum, set) => {
        return sum + (set.weight! * set.reps)
      }, 0)
      
      const maxWeight = Math.max(...completedSets.map(set => set.weight!))
      const avgWeight = completedSets.reduce((sum, set) => sum + set.weight!, 0) / completedSets.length

      volumeProgression.push(totalVolume)
      maxWeightProgression.push(maxWeight)
      averageWeightProgression.push(avgWeight)
    })

    // Calculate changes
    const totalVolumeChange = volumeProgression.length >= 2 
      ? ((volumeProgression[volumeProgression.length - 1] - volumeProgression[0]) / volumeProgression[0]) * 100
      : 0

    const maxWeightChange = maxWeightProgression.length >= 2
      ? ((maxWeightProgression[maxWeightProgression.length - 1] - maxWeightProgression[0]) / maxWeightProgression[0]) * 100
      : 0

    // Consistency score (percentage of sessions where exercise was performed)
    const consistencyScore = (exerciseData.length / recentSessions.length) * 100

    // Generate recommendations
    const recommendations: string[] = []
    
    if (maxWeightChange > 10) {
      recommendations.push('Great strength gains! Consider focusing on volume next.')
    } else if (maxWeightChange < -5) {
      recommendations.push('Weight has decreased. Focus on recovery and form.')
    } else if (Math.abs(maxWeightChange) < 2) {
      recommendations.push('Try increasing weight by 2.5-5 lbs next session.')
    }

    if (totalVolumeChange > 15) {
      recommendations.push('Excellent volume progression! You\'re getting stronger.')
    } else if (totalVolumeChange < -10) {
      recommendations.push('Volume has decreased. Consider reducing weight to maintain reps.')
    }

    if (consistencyScore < 70) {
      recommendations.push('Try to perform this exercise more consistently for better results.')
    }

    if (currentWeight && maxWeightProgression.length > 0) {
      const lastMaxWeight = maxWeightProgression[maxWeightProgression.length - 1]
      if (currentWeight > lastMaxWeight) {
        recommendations.push('New personal record! Great job pushing your limits.')
      }
    }

    if (recommendations.length === 0) {
      recommendations.push('Keep up the consistent training!')
    }

    return {
      volumeProgression,
      maxWeightProgression,
      averageWeightProgression,
      totalVolumeChange,
      maxWeightChange,
      consistencyScore,
      recommendations
    }
  }, [exerciseName, recentSessions, currentWeight])

  if (metrics.volumeProgression.length === 0) {
    return (
      <div className="rounded-2xl border border-gray-200 bg-white/70 backdrop-blur-sm p-4">
        <div className="flex items-center gap-2 mb-3">
          <TrendingUp className="h-4 w-4 text-gray-600" />
          <span className="font-medium text-gray-900">Progressive Overload</span>
        </div>
        <p className="text-sm text-gray-600">Complete more sessions to see your progression!</p>
      </div>
    )
  }

  return (
    <div className="rounded-2xl border border-gray-200 bg-white/70 backdrop-blur-sm p-4">
      <div className="flex items-center gap-2 mb-4">
        <TrendingUp className="h-4 w-4 text-blue-600" />
        <span className="font-medium text-gray-900">Progressive Overload</span>
      </div>

      {/* Key Metrics */}
      <div className="grid grid-cols-3 gap-4 mb-4">
        <div className="text-center p-3 bg-gradient-to-br from-blue-50 to-indigo-50 rounded-xl">
          <div className={`text-lg font-bold ${
            metrics.maxWeightChange > 0 ? 'text-green-600' : 
            metrics.maxWeightChange < 0 ? 'text-red-600' : 'text-gray-600'
          }`}>
            {metrics.maxWeightChange > 0 ? '+' : ''}{metrics.maxWeightChange.toFixed(1)}%
          </div>
          <div className="text-xs text-gray-600">Max Weight</div>
        </div>

        <div className="text-center p-3 bg-gradient-to-br from-green-50 to-emerald-50 rounded-xl">
          <div className={`text-lg font-bold ${
            metrics.totalVolumeChange > 0 ? 'text-green-600' : 
            metrics.totalVolumeChange < 0 ? 'text-red-600' : 'text-gray-600'
          }`}>
            {metrics.totalVolumeChange > 0 ? '+' : ''}{metrics.totalVolumeChange.toFixed(1)}%
          </div>
          <div className="text-xs text-gray-600">Total Volume</div>
        </div>

        <div className="text-center p-3 bg-gradient-to-br from-purple-50 to-pink-50 rounded-xl">
          <div className="text-lg font-bold text-purple-600">
            {metrics.consistencyScore.toFixed(0)}%
          </div>
          <div className="text-xs text-gray-600">Consistency</div>
        </div>
      </div>

      {/* Mini Progress Chart */}
      <div className="mb-4">
        <div className="text-sm font-medium text-gray-900 mb-2">Weight Progression</div>
        <div className="flex items-end gap-1 h-16 bg-gray-50 rounded-lg p-2">
          {metrics.maxWeightProgression.map((weight, index) => {
            const maxWeight = Math.max(...metrics.maxWeightProgression)
            const height = maxWeight > 0 ? (weight / maxWeight) * 100 : 0
            const isLatest = index === metrics.maxWeightProgression.length - 1
            
            return (
              <div
                key={index}
                className="flex-1 flex flex-col items-center"
              >
                <div
                  className={`w-full rounded-t transition-all duration-300 ${
                    isLatest 
                      ? 'bg-gradient-to-t from-blue-500 to-blue-400' 
                      : 'bg-gradient-to-t from-gray-300 to-gray-200'
                  }`}
                  style={{ height: `${height}%`, minHeight: '4px' }}
                />
                <div className="text-xs text-gray-500 mt-1">
                  {weight > 0 ? weight.toFixed(0) : '-'}
                </div>
              </div>
            )
          })}
        </div>
      </div>

      {/* Personal Records */}
      {metrics.maxWeightProgression.length > 0 && (
        <div className="mb-4">
          <div className="flex items-center gap-2 mb-2">
            <Award className="h-4 w-4 text-yellow-600" />
            <span className="text-sm font-medium text-gray-900">Personal Record</span>
          </div>
          <div className="p-3 bg-gradient-to-r from-yellow-50 to-orange-50 rounded-lg border border-yellow-200">
            <div className="text-lg font-bold text-yellow-700">
              {Math.max(...metrics.maxWeightProgression)} lbs
            </div>
            <div className="text-xs text-yellow-600">
              Your heaviest lift for this exercise
            </div>
          </div>
        </div>
      )}

      {/* Recommendations */}
      <div>
        <div className="flex items-center gap-2 mb-2">
          <Target className="h-4 w-4 text-green-600" />
          <span className="text-sm font-medium text-gray-900">Recommendations</span>
        </div>
        <div className="space-y-2">
          {metrics.recommendations.map((rec, index) => (
            <div key={index} className="p-2 bg-green-50 rounded-lg border border-green-200">
              <div className="text-sm text-green-700">{rec}</div>
            </div>
          ))}
        </div>
      </div>

      {/* Next Session Target */}
      {currentWeight && (
        <div className="mt-4 pt-4 border-t border-gray-200">
          <div className="flex items-center gap-2 mb-2">
            <Calendar className="h-4 w-4 text-blue-600" />
            <span className="text-sm font-medium text-gray-900">Next Session Target</span>
          </div>
          <div className="p-3 bg-blue-50 rounded-lg border border-blue-200">
            <div className="text-lg font-bold text-blue-700">
              {currentWeight + 2.5} lbs
            </div>
            <div className="text-xs text-blue-600">
              Progressive overload suggestion (+2.5 lbs)
            </div>
          </div>
        </div>
      )}
    </div>
  )
}


========================================
FILE: src/components/RouteWrapper.tsx
========================================

/**
 * Route Wrapper Components
 * Simplifies route definitions by providing reusable wrappers
 */

import { Suspense, type ReactNode } from 'react'
import { LoadingSpinner } from './Loading'
import ErrorBoundary from './ErrorBoundary'
import { RequireAuth, RequireProfile } from '../routes/guards'

interface RouteWrapperProps {
  children: ReactNode
  requireAuth?: boolean
  requireProfile?: boolean
  lazy?: boolean
}

/**
 * Unified route wrapper that handles common patterns:
 * - Error boundaries
 * - Authentication guards
 * - Profile completion guards
 * - Lazy loading with suspense
 */
export function RouteWrapper({ 
  children, 
  requireAuth = false, 
  requireProfile = false, 
  lazy = false 
}: RouteWrapperProps) {
  let content = children

  // Wrap with Suspense if lazy loading
  if (lazy) {
    content = (
      <Suspense fallback={<LoadingSpinner />}>
        {content}
      </Suspense>
    )
  }

  // Wrap with ErrorBoundary
  content = (
    <ErrorBoundary level="page">
      {content}
    </ErrorBoundary>
  )

  // Wrap with profile guard if required
  if (requireProfile) {
    content = (
      <RequireProfile>
        {content}
      </RequireProfile>
    )
  }

  // Wrap with auth guard if required (but not if profile is required, as RequireProfile includes auth)
  if (requireAuth && !requireProfile) {
    content = (
      <RequireAuth>
        {content}
      </RequireAuth>
    )
  }

  return <>{content}</>
}

/**
 * Convenience components for common route patterns
 */

// Public route (no auth required)
export function PublicRoute({ children, lazy = false }: { children: ReactNode; lazy?: boolean }) {
  return <RouteWrapper lazy={lazy}>{children}</RouteWrapper>
}

// Auth required route
export function AuthRoute({ children, lazy = false }: { children: ReactNode; lazy?: boolean }) {
  return <RouteWrapper requireAuth lazy={lazy}>{children}</RouteWrapper>
}

// Profile required route (includes auth)
export function ProfileRoute({ children, lazy = false }: { children: ReactNode; lazy?: boolean }) {
  return <RouteWrapper requireProfile lazy={lazy}>{children}</RouteWrapper>
}


========================================
FILE: src/components/SmartWeightInput.tsx
========================================

// src/components/SmartWeightInput.tsx
import React, { useState, useMemo } from 'react'
import { TrendingUp, TrendingDown, Minus, Plus, RotateCcw, Zap } from 'lucide-react'

interface WeightHistory {
  exerciseName: string
  setNumber: number
  weight: number
  timestamp: number
  reps?: number
}

interface SmartWeightInputProps {
  exerciseName: string
  setNumber: number
  currentWeight: number | null
  onWeightChange: (_weight: number | null) => void
  isOptimistic?: boolean
  previousWeights?: WeightHistory[]
  targetReps?: number | string
}

export function SmartWeightInput({
  exerciseName,
  setNumber,
  currentWeight,
  onWeightChange,
  isOptimistic = false,
  previousWeights = [],
  targetReps: _targetReps
}: SmartWeightInputProps) {
  const [inputValue, setInputValue] = useState(currentWeight?.toString() || '')
  const [showSuggestions, setShowSuggestions] = useState(false)
  const [isSubmitting, setIsSubmitting] = useState(false)

  // Calculate smart suggestions based on previous weights
  const suggestions = useMemo(() => {
    const relevantWeights = previousWeights
      .filter(w => w.exerciseName === exerciseName)
      .sort((a, b) => b.timestamp - a.timestamp)
      .slice(0, 5) // Last 5 sessions

    if (relevantWeights.length === 0) return []

    const lastWeight = relevantWeights[0]?.weight || 0
    const avgWeight = relevantWeights.reduce((sum, w) => sum + w.weight, 0) / relevantWeights.length

    const suggestions = []

    // Previous weight (safe option)
    if (lastWeight > 0) {
      suggestions.push({
        weight: lastWeight,
        label: 'Last used',
        type: 'previous' as const,
        confidence: 'high' as const
      })
    }

    // Progressive overload suggestions
    if (lastWeight > 0) {
      // Small increment (2.5-5 lbs)
      const smallIncrement = lastWeight + (lastWeight < 50 ? 2.5 : 5)
      suggestions.push({
        weight: smallIncrement,
        label: '+2.5-5 lbs',
        type: 'progressive' as const,
        confidence: 'medium' as const
      })

      // Larger increment (10% increase)
      const largeIncrement = Math.round(lastWeight * 1.1 * 2) / 2 // Round to nearest 0.5
      if (largeIncrement !== smallIncrement) {
        suggestions.push({
          weight: largeIncrement,
          label: '+10%',
          type: 'progressive' as const,
          confidence: 'low' as const
        })
      }
    }

    // Average weight from recent sessions
    if (avgWeight > 0 && Math.abs(avgWeight - lastWeight) > 2.5) {
      suggestions.push({
        weight: Math.round(avgWeight * 2) / 2,
        label: 'Recent avg',
        type: 'average' as const,
        confidence: 'medium' as const
      })
    }

    return suggestions.slice(0, 4) // Limit to 4 suggestions
  }, [exerciseName, previousWeights])

  // Quick increment buttons
  const quickIncrements = [2.5, 5, 10, 25]

  const handleSubmit = async () => {
    const weight = inputValue.trim() === '' ? null : parseFloat(inputValue)
    if (weight !== null && (isNaN(weight) || weight < 0)) return

    setIsSubmitting(true)
    try {
      onWeightChange(weight)
      setShowSuggestions(false)
      await new Promise(resolve => setTimeout(resolve, 200))
    } finally {
      setIsSubmitting(false)
    }
  }

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      handleSubmit()
      ;(e.target as HTMLInputElement).blur()
    } else if (e.key === 'Escape') {
      setShowSuggestions(false)
    }
  }

  const handleSuggestionClick = (weight: number) => {
    setInputValue(weight.toString())
    onWeightChange(weight)
    setShowSuggestions(false)
  }

  const adjustWeight = (delta: number) => {
    const current = parseFloat(inputValue) || 0
    const newWeight = Math.max(0, current + delta)
    setInputValue(newWeight.toString())
  }

  const resetWeight = () => {
    setInputValue('')
    onWeightChange(null)
  }

  // Get trend indicator
  const getTrendIndicator = () => {
    if (previousWeights.length < 2) return null

    const recent = previousWeights
      .filter(w => w.exerciseName === exerciseName)
      .sort((a, b) => b.timestamp - a.timestamp)
      .slice(0, 3)

    if (recent.length < 2) return null

    const trend = recent[0].weight - recent[recent.length - 1].weight
    if (Math.abs(trend) < 2.5) return null

    return trend > 0 ? 'up' : 'down'
  }

  const trend = getTrendIndicator()

  return (
    <div className={`rounded-2xl border backdrop-blur-sm p-4 transition-all duration-200 ${
      isOptimistic 
        ? 'border-blue-300 bg-blue-50/70 shadow-md' 
        : 'border-gray-200 bg-white/70'
    }`}>
      <div className="flex items-center justify-between gap-3 mb-4">
        <div className="flex-1">
          <div className="font-medium text-gray-900 flex items-center gap-2">
            Weight for Set {setNumber}
            {isOptimistic && (
              <div className="h-2 w-2 bg-blue-500 rounded-full animate-pulse" />
            )}
            {trend && (
              <div className={`flex items-center gap-1 text-xs px-2 py-1 rounded-full ${
                trend === 'up' 
                  ? 'bg-green-100 text-green-700' 
                  : 'bg-orange-100 text-orange-700'
              }`}>
                {trend === 'up' ? <TrendingUp className="h-3 w-3" /> : <TrendingDown className="h-3 w-3" />}
                {trend === 'up' ? 'Trending up' : 'Trending down'}
              </div>
            )}
          </div>
          <div className="text-sm text-gray-600">
            {isOptimistic ? 'Saving...' : 'Enter weight in lbs (optional)'}
          </div>
        </div>
      </div>

      {/* Weight Input with Quick Controls */}
      <div className="flex items-center gap-2 mb-4">
        <button
          onClick={() => adjustWeight(-2.5)}
          className="p-2 rounded-lg bg-gray-100 hover:bg-gray-200 transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2"
          disabled={isSubmitting}
          aria-label="Decrease weight by 2.5 lbs"
        >
          <Minus className="h-4 w-4" aria-hidden="true" />
        </button>

        <div className="flex-1 relative">
          <input
            type="number"
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
            onFocus={() => setShowSuggestions(true)}
            onBlur={() => setTimeout(() => setShowSuggestions(false), 200)}
            onKeyDown={handleKeyDown}
            placeholder="0"
            min="0"
            step="0.5"
            className="w-full rounded-lg border border-gray-200 bg-white px-4 py-3 text-center text-lg font-semibold text-gray-900 placeholder-gray-400 focus:border-blue-400 focus:outline-none focus:ring-2 focus:ring-blue-400/20"
            disabled={isSubmitting}
            aria-label={`Weight for set ${setNumber} of ${exerciseName} in pounds`}
            aria-describedby={`weight-help-${setNumber}`}
          />
          <div className="absolute right-3 top-1/2 -translate-y-1/2 text-sm text-gray-500">
            lbs
          </div>
        </div>

        <button
          onClick={() => adjustWeight(2.5)}
          className="p-2 rounded-lg bg-gray-100 hover:bg-gray-200 transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2"
          disabled={isSubmitting}
          aria-label="Increase weight by 2.5 lbs"
        >
          <Plus className="h-4 w-4" aria-hidden="true" />
        </button>

        <button
          onClick={resetWeight}
          className="p-2 rounded-lg bg-gray-100 hover:bg-gray-200 transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2"
          disabled={isSubmitting}
          aria-label="Clear weight"
        >
          <RotateCcw className="h-4 w-4" aria-hidden="true" />
        </button>
      </div>

      {/* Quick Increment Buttons */}
      <div className="flex gap-2 mb-4">
        {quickIncrements.map(increment => (
          <button
            key={increment}
            onClick={() => adjustWeight(increment)}
            className="flex-1 px-3 py-2 text-sm font-medium bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors"
            disabled={isSubmitting}
          >
            +{increment}
          </button>
        ))}
      </div>

      {/* Smart Suggestions */}
      {showSuggestions && suggestions.length > 0 && (
        <div className="border-t border-gray-200 pt-4">
          <div className="flex items-center gap-2 mb-3">
            <Zap className="h-4 w-4 text-blue-600" />
            <span className="text-sm font-medium text-gray-900">Smart Suggestions</span>
          </div>
          <div className="grid grid-cols-2 gap-2">
            {suggestions.map((suggestion, index) => (
              <button
                key={index}
                onClick={() => handleSuggestionClick(suggestion.weight)}
                className={`p-3 rounded-lg border text-left transition-all hover:scale-[1.02] ${
                  suggestion.confidence === 'high'
                    ? 'border-green-200 bg-green-50 hover:bg-green-100'
                    : suggestion.confidence === 'medium'
                    ? 'border-blue-200 bg-blue-50 hover:bg-blue-100'
                    : 'border-orange-200 bg-orange-50 hover:bg-orange-100'
                }`}
              >
                <div className="font-semibold text-gray-900">
                  {suggestion.weight} lbs
                </div>
                <div className="text-xs text-gray-600">
                  {suggestion.label}
                </div>
              </button>
            ))}
          </div>
        </div>
      )}

      {/* Submit Button */}
      <button
        onClick={handleSubmit}
        disabled={isSubmitting}
        className={`w-full mt-4 px-4 py-3 rounded-xl font-medium transition-all duration-200 ${
          isSubmitting
            ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
            : 'bg-gradient-to-r from-blue-500 to-indigo-600 text-white hover:from-blue-600 hover:to-indigo-700 hover:scale-[1.02] shadow-md'
        }`}
      >
        {isSubmitting ? 'Saving...' : 'Save Weight'}
      </button>
    </div>
  )
}


========================================
FILE: src/components/SubscriptionManager.tsx
========================================

import { useState } from 'react'
import {
  AlertTriangle,
  RefreshCw,
  CreditCard,
  Clock,
  CheckCircle,
  Crown,
  X,
  Loader2,
  ExternalLink,
  Calendar,
  XCircle,
  Shield
} from 'lucide-react'
import { useSubscription, useSubscriptionStatus } from '../hooks/useSubscription'
import { subscriptionService, formatDate } from '../lib/subscriptionService'
import { PaymentForm } from './PaymentForm'
import { SUBSCRIPTION_PLANS, formatPrice } from '../lib/stripe-config'

// Unified Subscription Manager Component
// Consolidates: SubscriptionErrorHandler, SubscriptionMonitor, SimpleSubscription, 
// SubscriptionManagement, SubscriptionPlans, SubscriptionStatusCard

interface SubscriptionManagerProps {
  mode?: 'error' | 'plans' | 'management' | 'status'
  error?: string
  onRetry?: () => void
  onClose?: () => void
  onSuccess?: () => void
  showUpgradeOption?: boolean
  className?: string
}

export function SubscriptionManager({ 
  mode = 'status',
  error,
  onRetry,
  onClose,
  onSuccess,
  showUpgradeOption = true,
  className = ''
}: SubscriptionManagerProps) {
  const [showPayment, setShowPayment] = useState(false)
  const [refreshing, setRefreshing] = useState(false)
  const [actionLoading, setActionLoading] = useState<string | null>(null)
  const [localError, setLocalError] = useState<string>('')
  const [success, setSuccess] = useState<string>('')
  const [showCancelConfirm, setShowCancelConfirm] = useState(false)

  const { 
    subscription, 
    hasUnlimitedWorkouts, 
    remainingFreeWorkouts,
    isInGracePeriod,
    daysRemaining,
    loading,
    refreshSubscription 
  } = useSubscription()
  
  const { status, statusColor, description } = useSubscriptionStatus()

  // Helper functions
  async function handleRefreshSubscription() {
    setRefreshing(true)
    setLocalError('')
    try {
      await refreshSubscription()
      if (subscription?.status === 'active' || subscription?.status === 'trialing') {
        onRetry?.()
      }
      setSuccess('Subscription refreshed successfully')
      setTimeout(() => setSuccess(''), 3000)
    } catch (err) {
      setLocalError(err instanceof Error ? err.message : 'Failed to refresh subscription')
    } finally {
      setRefreshing(false)
    }
  }

  function handlePaymentSuccess() {
    setTimeout(() => {
      onSuccess?.()
      onClose?.()
      window.location.reload()
    }, 2000)
  }

  async function handleManageBilling() {
    if (!subscription?.customerId) return

    setActionLoading('billing')
    setLocalError('')

    try {
      const url = await subscriptionService.getCustomerPortalUrl()
      if (url) window.open(url, '_blank')
    } catch (err) {
      setLocalError(err instanceof Error ? err.message : 'Failed to open billing portal')
    } finally {
      setActionLoading(null)
    }
  }

  async function handleCancelSubscription() {
    if (!subscription?.subscriptionId) {
      setLocalError('Unable to cancel: subscription information not found. Please refresh the page and try again.')
      return
    }

    setActionLoading('cancel')
    setLocalError('')
    setShowCancelConfirm(false)

    try {
      const success = await subscriptionService.cancelSubscription()
      if (success) {
        setSuccess('Your subscription has been cancelled. You\'ll continue to have access until the end of your current billing period.')
        // Refresh subscription data
        await handleRefreshSubscription()
      } else {
        setLocalError('Failed to cancel subscription. Please try again or contact support if the issue persists.')
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to cancel subscription'
      console.error('Cancellation error:', err)

      // Provide more helpful error messages
      if (errorMessage.includes('not found')) {
        setLocalError('Unable to find your subscription. Please refresh the page and try again.')
      } else if (errorMessage.includes('network') || errorMessage.includes('timeout')) {
        setLocalError('Network error. Please check your connection and try again.')
      } else {
        setLocalError(`${errorMessage}. If this problem continues, please contact support.`)
      }
    } finally {
      setActionLoading(null)
    }
  }

  async function handleReactivateSubscription() {
    if (!subscription?.subscriptionId) {
      setLocalError('Unable to reactivate: subscription information not found. Please refresh the page and try again.')
      return
    }

    setActionLoading('reactivate')
    setLocalError('')

    try {
      const success = await subscriptionService.reactivateSubscription()
      if (success) {
        setSuccess('Your subscription has been reactivated! You\'ll continue to have unlimited access.')
        // Refresh subscription data
        await handleRefreshSubscription()
      } else {
        setLocalError('Failed to reactivate subscription. Please try again or contact support if the issue persists.')
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to reactivate subscription'
      console.error('Reactivation error:', err)

      // Provide more helpful error messages
      if (errorMessage.includes('not found')) {
        setLocalError('Unable to find your subscription. Please refresh the page and try again.')
      } else if (errorMessage.includes('network') || errorMessage.includes('timeout')) {
        setLocalError('Network error. Please check your connection and try again.')
      } else {
        setLocalError(`${errorMessage}. If this problem continues, please contact support.`)
      }
    } finally {
      setActionLoading(null)
    }
  }

  // Error handling mode
  if (mode === 'error' && error) {
    return <ErrorDisplay 
      error={error}
      subscription={subscription}
      hasUnlimitedWorkouts={hasUnlimitedWorkouts}
      refreshing={refreshing}
      onRefresh={handleRefreshSubscription}
      onRetry={onRetry}
      onUpgrade={() => setShowPayment(true)}
      showUpgradeOption={showUpgradeOption}
    />
  }

  // Plans selection mode
  if (mode === 'plans' || showPayment) {
    return <PlansDisplay
      showPayment={showPayment}
      onSelectPlan={() => setShowPayment(true)}
      onPaymentSuccess={handlePaymentSuccess}
      onPaymentError={(err) => setLocalError(err)}
      onBack={() => setShowPayment(false)}
      onClose={onClose}
    />
  }

  // Management mode
  if (mode === 'management') {
    return <ManagementDisplay
      subscription={subscription}
      status={status}
      statusColor={statusColor}
      description={description}
      hasUnlimitedWorkouts={hasUnlimitedWorkouts}
      isInGracePeriod={isInGracePeriod}
      daysRemaining={daysRemaining}
      actionLoading={actionLoading}
      error={localError}
      success={success}
      onManageBilling={handleManageBilling}
      onCancelSubscription={() => setShowCancelConfirm(true)}
      onReactivateSubscription={handleReactivateSubscription}
      onRefresh={handleRefreshSubscription}
      refreshing={refreshing}
      showCancelConfirm={showCancelConfirm}
      onConfirmCancel={handleCancelSubscription}
      onCancelCancel={() => setShowCancelConfirm(false)}
    />
  }

  // Status display mode (default)
  return <StatusDisplay
    hasUnlimitedWorkouts={hasUnlimitedWorkouts}
    remainingFreeWorkouts={remainingFreeWorkouts}
    loading={loading}
    className={className}
  />
}

// Error Display Component
interface ErrorDisplayProps {
  error: string
  subscription: unknown
  hasUnlimitedWorkouts: boolean
  refreshing: boolean
  onRefresh: () => void
  onRetry?: () => void
  onUpgrade: () => void
  showUpgradeOption: boolean
}

function ErrorDisplay({ 
  error, 
  subscription, 
  hasUnlimitedWorkouts, 
  refreshing, 
  onRefresh, 
  onRetry, 
  onUpgrade, 
  showUpgradeOption 
}: ErrorDisplayProps) {
  const isPaymentError = error.includes('402') || error.includes('Payment Required') || error.includes('Subscription required')
  const isRecentSubscriber = (subscription as { updatedAt?: number })?.updatedAt && (Date.now() - (subscription as { updatedAt: number }).updatedAt) < 300000

  return (
    <div className="group relative rounded-3xl border border-red-200/60 bg-gradient-to-br from-red-50/80 via-red-50/60 to-white/90 backdrop-blur-xl p-6 sm:p-8 shadow-xl shadow-red-200/30 hover:shadow-2xl hover:shadow-red-200/40 transition-all duration-500 max-w-2xl mx-auto">
      <div className="absolute -right-16 -top-16 h-32 w-32 rounded-full bg-gradient-to-tr from-red-400/20 to-pink-400/10 opacity-50 blur-2xl group-hover:opacity-70 group-hover:scale-110 transition-all duration-500" />

      <div className="relative">
        <div className="flex items-center gap-5 mb-6">
          <div className="w-14 h-14 bg-gradient-to-br from-red-500 via-red-600 to-pink-600 rounded-2xl flex items-center justify-center shadow-xl shadow-red-500/30 group-hover:shadow-red-500/50 group-hover:scale-110 transition-all duration-500">
            <AlertTriangle className="w-7 h-7 text-white" />
          </div>
          <h3 className="font-bold text-xl sm:text-2xl text-red-900 leading-tight">
            {isPaymentError ? 'Subscription Required' : 'Error'}
          </h3>
        </div>

        <div className="space-y-6">
          <p className="text-red-700/90 text-base sm:text-lg leading-relaxed font-medium">
            {isPaymentError ? (
              hasUnlimitedWorkouts ? (
                'There seems to be an issue with your subscription status. This might be a temporary sync issue.'
              ) : (
                'You need an active subscription to generate unlimited workouts.'
              )
            ) : (
              error
            )}
          </p>

          {isRecentSubscriber && (
            <div className="bg-gradient-to-r from-yellow-50/80 to-amber-50/60 border border-yellow-200/60 rounded-2xl p-4 sm:p-5 backdrop-blur-sm">
              <div className="flex items-center gap-3 text-yellow-800">
                <div className="w-6 h-6 bg-gradient-to-r from-yellow-500 to-amber-500 rounded-full flex items-center justify-center">
                  <Clock className="w-3 h-3 text-white" />
                </div>
                <span className="text-sm sm:text-base font-semibold">Recent Payment Detected</span>
              </div>
              <p className="text-yellow-700/90 text-sm sm:text-base mt-2 leading-relaxed font-medium">
                Your payment may still be processing. Try refreshing your subscription status.
              </p>
            </div>
          )}

          <div className="flex flex-col sm:flex-row gap-4">
            {(isPaymentError || isRecentSubscriber) && (
              <button
                onClick={onRefresh}
                disabled={refreshing}
                className="flex items-center justify-center gap-3 px-6 py-3 bg-gradient-to-r from-blue-500 via-blue-600 to-indigo-600 text-white rounded-xl hover:from-blue-600 hover:via-blue-700 hover:to-indigo-700 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-300 font-semibold shadow-lg hover:shadow-xl hover:scale-105 active:scale-95"
              >
                <RefreshCw className={`w-5 h-5 ${refreshing ? 'animate-spin' : ''}`} />
                {refreshing ? 'Checking...' : 'Refresh Subscription'}
              </button>
            )}

            {onRetry && !isPaymentError && (
              <button
                onClick={onRetry}
                className="px-6 py-3 bg-gradient-to-r from-slate-600 to-gray-600 text-white rounded-xl hover:from-slate-700 hover:to-gray-700 transition-all duration-300 font-semibold shadow-lg hover:shadow-xl hover:scale-105 active:scale-95"
              >
                Try Again
              </button>
            )}

            {showUpgradeOption && isPaymentError && !hasUnlimitedWorkouts && (
              <button
                onClick={onUpgrade}
                className="flex items-center justify-center gap-3 px-6 py-3 bg-gradient-to-r from-blue-500 via-blue-600 to-indigo-600 text-white rounded-xl hover:from-blue-600 hover:via-blue-700 hover:to-indigo-700 transition-all duration-300 font-semibold shadow-lg hover:shadow-xl hover:scale-105 active:scale-95"
              >
                <CreditCard className="w-5 h-5" />
                Upgrade to Pro
              </button>
            )}
          </div>
        </div>
      </div>
    </div>
  )
}

// Status Display Component
interface StatusDisplayProps {
  hasUnlimitedWorkouts: boolean
  remainingFreeWorkouts: number
  loading: boolean
  className: string
}

function StatusDisplay({ hasUnlimitedWorkouts: _hasUnlimitedWorkouts, remainingFreeWorkouts: _remainingFreeWorkouts, loading: _loading, className: _className }: StatusDisplayProps) {
  // Always return null to hide the subscription status cards
  return null
}

// Plans Display Component
interface PlansDisplayProps {
  showPayment: boolean
  onSelectPlan: () => void
  onPaymentSuccess: () => void
  onPaymentError: (_error: string) => void
  onBack: () => void
  onClose?: () => void
}

function PlansDisplay({ showPayment, onSelectPlan, onPaymentSuccess, onPaymentError, onBack, onClose }: PlansDisplayProps) {
  const plan = SUBSCRIPTION_PLANS[0] // Single plan

  if (showPayment) {
    return (
      <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div className="bg-white rounded-2xl max-w-md w-full max-h-[90vh] overflow-y-auto">
          <div className="p-6">
            <div className="flex items-center justify-between mb-6">
              <h2 className="text-xl font-bold text-gray-900">Complete Payment</h2>
              <button onClick={onBack} className="text-gray-400 hover:text-gray-600" aria-label="Go back to plan selection">
                <X className="w-6 h-6" aria-hidden="true" />
              </button>
            </div>

            <div className="bg-blue-50 rounded-lg p-4 mb-6">
              <div className="flex items-center gap-3 mb-2">
                <Crown className="w-5 h-5 text-blue-600" />
                <span className="font-medium text-blue-900">{plan.name}</span>
              </div>
              <p className="text-blue-700 text-sm mb-2">{plan.description}</p>
              <p className="text-2xl font-bold text-blue-900">
                {formatPrice(plan.price)}/month
              </p>
            </div>

            <PaymentForm
              priceId={plan.stripePriceId}
              onSuccess={onPaymentSuccess}
              onError={onPaymentError}
              onCancel={onBack}
            />
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
      <div className="bg-white rounded-2xl max-w-md w-full p-6">
        <div className="flex items-center justify-between mb-6">
          <h2 className="text-xl font-bold text-gray-900">Upgrade to Pro</h2>
          {onClose && (
            <button onClick={onClose} className="text-gray-400 hover:text-gray-600" aria-label="Close upgrade dialog">
              <X className="w-6 h-6" aria-hidden="true" />
            </button>
          )}
        </div>

        <div className="text-center mb-6">
          <div className="w-16 h-16 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-2xl flex items-center justify-center mx-auto mb-4">
            <Crown className="w-8 h-8 text-white" />
          </div>
          <h3 className="text-lg font-semibold text-gray-900 mb-2">{plan.name}</h3>
          <p className="text-gray-600 text-sm mb-4">{plan.description}</p>
          <div className="text-3xl font-bold text-gray-900 mb-2">
            {formatPrice(plan.price)}<span className="text-lg font-normal text-gray-600">/month</span>
          </div>
        </div>

        <div className="space-y-3 mb-6">
          {plan.features.map((feature, index) => (
            <div key={index} className="flex items-center gap-3">
              <CheckCircle className="w-5 h-5 text-green-500 flex-shrink-0" />
              <span className="text-gray-700">{feature}</span>
            </div>
          ))}
        </div>

        <button
          onClick={onSelectPlan}
          className="w-full bg-gradient-to-r from-blue-500 to-indigo-600 text-white py-3 px-4 rounded-xl font-semibold hover:from-blue-600 hover:to-indigo-700 transition-all duration-200 flex items-center justify-center gap-2"
        >
          Subscribe Now
          <Crown className="w-4 h-4" />
        </button>

        <p className="text-xs text-gray-500 text-center mt-4">
          Cancel anytime. No long-term commitment.
        </p>
      </div>
    </div>
  )
}

// Management Display Component
interface ManagementDisplayProps {
  subscription: unknown
  status: string
  statusColor: string
  description: string
  hasUnlimitedWorkouts: boolean
  isInGracePeriod: boolean
  daysRemaining: number
  actionLoading: string | null
  error: string
  success: string
  onManageBilling: () => void
  onCancelSubscription: () => void
  onReactivateSubscription: () => void
  onRefresh: () => void
  refreshing: boolean
  showCancelConfirm: boolean
  onConfirmCancel: () => void
  onCancelCancel: () => void
}

function ManagementDisplay({
  subscription,
  status,
  statusColor,
  description,
  hasUnlimitedWorkouts,
  isInGracePeriod,
  daysRemaining,
  actionLoading,
  error,
  success,
  onManageBilling,
  onCancelSubscription,
  onReactivateSubscription,
  onRefresh,
  refreshing,
  showCancelConfirm,
  onConfirmCancel,
  onCancelCancel
}: ManagementDisplayProps) {
  const getStatusColor = (color: string) => {
    const colors = {
      green: 'text-green-600 bg-green-50',
      yellow: 'text-yellow-600 bg-yellow-50',
      red: 'text-red-600 bg-red-50',
      gray: 'text-gray-600 bg-gray-50'
    }
    return colors[color as keyof typeof colors] || colors.gray
  }

  return (
    <div className="space-y-6">
      {/* Status Messages */}
      {error && (
        <div className="bg-red-50 border border-red-200 rounded-lg p-4">
          <div className="flex items-center gap-2">
            <AlertTriangle className="w-5 h-5 text-red-600" />
            <p className="text-red-800 font-medium">Error</p>
          </div>
          <p className="text-red-700 text-sm mt-1">{error}</p>
        </div>
      )}

      {success && (
        <div className="bg-green-50 border border-green-200 rounded-lg p-4">
          <div className="flex items-center gap-2">
            <CheckCircle className="w-5 h-5 text-green-600" />
            <p className="text-green-800 font-medium">Success</p>
          </div>
          <p className="text-green-700 text-sm mt-1">{success}</p>
        </div>
      )}

      {/* Subscription Overview */}
      <div className="bg-white border border-gray-200 rounded-xl p-6">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-semibold text-gray-900">Subscription Status</h3>
          <button
            onClick={onRefresh}
            disabled={refreshing}
            className="flex items-center gap-2 px-3 py-1 text-sm text-gray-600 hover:text-gray-800 disabled:opacity-50"
          >
            <RefreshCw className={`w-4 h-4 ${refreshing ? 'animate-spin' : ''}`} />
            Refresh
          </button>
        </div>

        <div className="space-y-4">
          <div>
            <div className="flex items-center gap-2 mb-2">
              <span className={`px-2 py-1 rounded-full text-xs font-medium ${getStatusColor(statusColor)}`}>
                {status}
              </span>
            </div>
            <p className="text-sm text-gray-600">{description}</p>
          </div>

          <div>
            <p className="font-medium text-gray-900">Workouts Generated</p>
            <p className="text-sm text-gray-600">
              {(subscription as { workoutCount?: number })?.workoutCount || 0} total
              {!hasUnlimitedWorkouts && (
                <span className="ml-2">
                  ({(subscription as { freeWorkoutsUsed?: number })?.freeWorkoutsUsed || 0}/{(subscription as { freeWorkoutLimit?: number })?.freeWorkoutLimit || 10} free used)
                </span>
              )}
            </p>
          </div>
        </div>

        {(subscription as { currentPeriodEnd?: number })?.currentPeriodEnd && (
          <div className="mt-4 pt-4 border-t border-gray-200">
            <div className="flex items-center gap-2 text-sm text-gray-600">
              <Calendar className="w-4 h-4" />
              <span>
                {isInGracePeriod ? 'Access until' : 'Next billing'}: {' '}
                {formatDate((subscription as { currentPeriodEnd: number }).currentPeriodEnd)}
                {daysRemaining > 0 && (
                  <span className="ml-2">({daysRemaining} days)</span>
                )}
              </span>
            </div>
          </div>
        )}
      </div>

      {/* Management Actions */}
      <div className="bg-white border border-gray-200 rounded-xl p-6">
        <h3 className="text-lg font-semibold text-gray-900 mb-4">Manage Subscription</h3>

        <div className="space-y-3">
          {(subscription as { customerId?: string })?.customerId && (
            <button
              onClick={onManageBilling}
              disabled={actionLoading === 'billing'}
              className="w-full flex items-center justify-between p-4 border border-gray-200 rounded-xl hover:bg-gray-50 transition-colors disabled:opacity-50"
            >
              <div className="flex items-center gap-3">
                <CreditCard className="w-5 h-5 text-gray-600" />
                <div className="text-left">
                  <p className="font-medium text-gray-900">Manage Billing</p>
                  <p className="text-sm text-gray-600">Update payment method, view invoices</p>
                </div>
              </div>
              {actionLoading === 'billing' ? (
                <Loader2 className="w-5 h-5 animate-spin text-gray-400" />
              ) : (
                <ExternalLink className="w-5 h-5 text-gray-400" />
              )}
            </button>
          )}

          {/* Cancel Subscription Button - only show for active subscriptions */}
          {hasUnlimitedWorkouts && !isInGracePeriod && !(subscription as { cancelAtPeriodEnd?: boolean })?.cancelAtPeriodEnd && (
            <button
              onClick={onCancelSubscription}
              disabled={actionLoading === 'cancel'}
              className="w-full flex items-center justify-between p-4 border border-red-200 rounded-xl hover:bg-red-50 transition-colors disabled:opacity-50"
            >
              <div className="flex items-center gap-3">
                <XCircle className="w-5 h-5 text-red-600" />
                <div className="text-left">
                  <p className="font-medium text-red-900">Cancel Subscription</p>
                  <p className="text-sm text-red-600">Cancel at end of billing period</p>
                </div>
              </div>
              {actionLoading === 'cancel' ? (
                <Loader2 className="w-5 h-5 animate-spin text-red-400" />
              ) : (
                <XCircle className="w-5 h-5 text-red-400" />
              )}
            </button>
          )}

          {/* Reactivate Subscription Button - only show for cancelled subscriptions */}
          {(subscription as { cancelAtPeriodEnd?: boolean })?.cancelAtPeriodEnd && (
            <button
              onClick={onReactivateSubscription}
              disabled={actionLoading === 'reactivate'}
              className="w-full flex items-center justify-between p-4 border border-green-200 rounded-xl hover:bg-green-50 transition-colors disabled:opacity-50"
            >
              <div className="flex items-center gap-3">
                <CheckCircle className="w-5 h-5 text-green-600" />
                <div className="text-left">
                  <p className="font-medium text-green-900">Reactivate Subscription</p>
                  <p className="text-sm text-green-600">Resume unlimited access</p>
                </div>
              </div>
              {actionLoading === 'reactivate' ? (
                <Loader2 className="w-5 h-5 animate-spin text-green-400" />
              ) : (
                <CheckCircle className="w-5 h-5 text-green-400" />
              )}
            </button>
          )}
        </div>

        {/* Cancellation Confirmation Modal */}
        {showCancelConfirm && (
          <div className="fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-50">
            <div className="bg-white rounded-2xl p-6 max-w-md w-full">
              <div className="flex items-center gap-3 mb-4">
                <div className="w-12 h-12 bg-red-100 rounded-full flex items-center justify-center">
                  <Shield className="w-6 h-6 text-red-600" />
                </div>
                <div>
                  <h3 className="text-lg font-semibold text-gray-900">Cancel Subscription</h3>
                  <p className="text-sm text-gray-600">Are you sure you want to cancel?</p>
                </div>
              </div>

              <div className="bg-amber-50 border border-amber-200 rounded-lg p-4 mb-6">
                <p className="text-amber-800 text-sm">
                  <strong>Important:</strong> You'll continue to have access to NeuraFit Pro until {' '}
                  {(subscription as { currentPeriodEnd?: number })?.currentPeriodEnd &&
                    formatDate((subscription as { currentPeriodEnd: number }).currentPeriodEnd)
                  }. After that, you'll return to the free plan with limited workouts.
                </p>
              </div>

              <div className="flex gap-3">
                <button
                  onClick={onCancelCancel}
                  className="flex-1 px-4 py-2 border border-gray-300 rounded-xl text-gray-700 hover:bg-gray-50 transition-colors"
                >
                  Keep Subscription
                </button>
                <button
                  onClick={onConfirmCancel}
                  disabled={actionLoading === 'cancel'}
                  className="flex-1 px-4 py-2 bg-red-600 text-white rounded-xl hover:bg-red-700 transition-colors disabled:opacity-50 flex items-center justify-center gap-2"
                >
                  {actionLoading === 'cancel' ? (
                    <>
                      <Loader2 className="w-4 h-4 animate-spin" />
                      Cancelling...
                    </>
                  ) : (
                    'Yes, Cancel'
                  )}
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  )
}

export default SubscriptionManager


========================================
FILE: src/components/SubscriptionSuccess.tsx
========================================

import React from 'react'
import { CheckCircle, Zap, Target, TrendingUp, Shield } from 'lucide-react'

interface SubscriptionSuccessProps {
  onContinue: () => void
  planName?: string
}

export function SubscriptionSuccess({ onContinue, planName = 'NeuraFit Pro' }: SubscriptionSuccessProps) {
  return (
    <div className="text-center py-8">
      {/* Success Icon */}
      <div className="mx-auto w-20 h-20 bg-green-100 rounded-full flex items-center justify-center mb-6">
        <CheckCircle className="w-10 h-10 text-green-600" />
      </div>

      {/* Success Message */}
      <h2 className="text-2xl font-bold text-gray-900 mb-2">
        Welcome to {planName}!
      </h2>
      <p className="text-gray-600 mb-8 max-w-md mx-auto">
        Your subscription is now active. You have unlimited access to AI-powered workouts and all premium features.
      </p>

      {/* Features List */}
      <div className="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-8 max-w-lg mx-auto">
        <div className="flex items-center gap-3 text-left">
          <div className="w-8 h-8 bg-blue-100 rounded-full flex items-center justify-center">
            <Zap className="w-4 h-4 text-blue-600" />
          </div>
          <span className="text-sm text-gray-700">Unlimited workouts</span>
        </div>
        <div className="flex items-center gap-3 text-left">
          <div className="w-8 h-8 bg-purple-100 rounded-full flex items-center justify-center">
            <Target className="w-4 h-4 text-purple-600" />
          </div>
          <span className="text-sm text-gray-700">Advanced personalization</span>
        </div>
        <div className="flex items-center gap-3 text-left">
          <div className="w-8 h-8 bg-green-100 rounded-full flex items-center justify-center">
            <TrendingUp className="w-4 h-4 text-green-600" />
          </div>
          <span className="text-sm text-gray-700">Progress tracking</span>
        </div>
        <div className="flex items-center gap-3 text-left">
          <div className="w-8 h-8 bg-orange-100 rounded-full flex items-center justify-center">
            <Shield className="w-4 h-4 text-orange-600" />
          </div>
          <span className="text-sm text-gray-700">Priority support</span>
        </div>
      </div>

      {/* Action Button */}
      <button
        onClick={onContinue}
        className="w-full sm:w-auto bg-gradient-to-r from-blue-500 via-blue-600 to-indigo-600 text-white px-8 py-3 rounded-xl font-semibold hover:from-blue-600 hover:via-blue-700 hover:to-indigo-700 transition-all duration-300 shadow-lg hover:shadow-xl hover:scale-105 active:scale-95"
      >
        Generate Your First Pro Workout
      </button>

      {/* Additional Info */}
      <div className="mt-6 p-4 bg-blue-50 rounded-lg">
        <p className="text-sm text-blue-800">
          <strong>Next billing:</strong> Your subscription will automatically renew in 30 days. 
          You can cancel anytime from your profile settings.
        </p>
      </div>
    </div>
  )
}

export default SubscriptionSuccess


========================================
FILE: src/components/WorkoutActionFooter.tsx
========================================

// src/components/WorkoutActionFooter.tsx
import React from 'react'
import { SkipForward, Check, X } from 'lucide-react'

interface WorkoutActionFooterProps {
  onCompleteSet: () => void
  onSkipSet: () => void
  onSkipExercise: () => void
  isCompleting?: boolean
  className?: string
}

function WorkoutActionFooter({
  onCompleteSet,
  onSkipSet,
  onSkipExercise,
  isCompleting = false,
  className = ""
}: WorkoutActionFooterProps) {
  return (
    <div className={`fixed inset-x-0 bottom-0 z-50 bg-white/95 backdrop-blur-xl border-t border-gray-200/60 shadow-lg shadow-gray-200/20 ${className}`}>
      <div
        className="mx-auto max-w-4xl px-3 sm:px-6 py-3"
        style={{ paddingBottom: 'max(12px, env(safe-area-inset-bottom))' }}
      >
        <div className="flex items-center justify-between gap-2 sm:gap-3">
          {/* Skip Exercise Button */}
          <button
            onClick={onSkipExercise}
            className="flex items-center gap-1.5 px-3 py-2.5 sm:px-4 sm:py-3 rounded-xl border border-gray-300 bg-white/80 text-gray-700 hover:bg-white hover:border-gray-400 transition-all duration-200 text-sm font-medium touch-manipulation min-h-[44px] active:scale-95"
            disabled={isCompleting}
          >
            <X className="h-4 w-4" />
            <span className="hidden sm:inline">Skip Exercise</span>
            <span className="sm:hidden">Skip</span>
          </button>

          {/* Action Buttons Container */}
          <div className="flex gap-2 sm:gap-3 flex-1 justify-end">
            {/* Skip Set Button */}
            <button
              onClick={onSkipSet}
              className="flex items-center gap-1.5 px-3 py-2.5 sm:px-4 sm:py-3 rounded-xl border border-orange-300 bg-orange-50 text-orange-700 hover:bg-orange-100 hover:border-orange-400 transition-all duration-200 font-medium touch-manipulation min-h-[44px] active:scale-95"
              disabled={isCompleting}
            >
              <SkipForward className="h-4 w-4" />
              <span className="hidden xs:inline">Skip Set</span>
              <span className="xs:hidden">Skip</span>
            </button>

            {/* Complete Set Button */}
            <button
              onClick={onCompleteSet}
              disabled={isCompleting}
              className="flex items-center gap-1.5 px-4 py-2.5 sm:px-6 sm:py-3 rounded-xl bg-gradient-to-br from-blue-500 to-indigo-600 text-white font-semibold hover:scale-[1.02] active:scale-95 transition-all duration-200 shadow-md touch-manipulation min-h-[44px] disabled:opacity-70 disabled:cursor-not-allowed disabled:hover:scale-100"
            >
              <Check className="h-4 w-4" />
              <span className="hidden xs:inline">{isCompleting ? 'Completing...' : 'Complete Set'}</span>
              <span className="xs:hidden">{isCompleting ? 'Done...' : 'Done'}</span>
            </button>
          </div>
        </div>
      </div>
    </div>
  )
}

export default WorkoutActionFooter


========================================
FILE: src/components/WorkoutAnalytics.tsx
========================================

// Simplified Workout Analytics
import React from 'react'
import { TrendingUp, Calendar, Clock } from 'lucide-react'

interface WorkoutData {
  id: string
  workoutType: string
  duration: number
  timestamp?: Date | { toDate(): Date } | string
}

interface WorkoutAnalyticsProps {
  workouts: WorkoutData[]
}

export function WorkoutAnalytics({ workouts }: WorkoutAnalyticsProps) {
  const totalWorkouts = workouts.length
  const totalDuration = workouts.reduce((sum, w) => sum + (w.duration || 0), 0)
  const averageDuration = totalWorkouts > 0 ? Math.round(totalDuration / totalWorkouts) : 0

  return (
    <div className="bg-white rounded-xl p-6 border border-gray-100">
      <h3 className="text-lg font-semibold text-gray-900 mb-4 flex items-center gap-2">
        <TrendingUp className="h-5 w-5 text-blue-600" />
        Workout Analytics
      </h3>

      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <div className="text-center p-4 bg-blue-50 rounded-lg">
          <Calendar className="h-6 w-6 text-blue-600 mx-auto mb-2" />
          <div className="text-2xl font-bold text-gray-900">{totalWorkouts}</div>
          <div className="text-sm text-gray-600">Total Workouts</div>
        </div>

        <div className="text-center p-4 bg-green-50 rounded-lg">
          <Clock className="h-6 w-6 text-green-600 mx-auto mb-2" />
          <div className="text-2xl font-bold text-gray-900">{Math.round(totalDuration / 60)}h</div>
          <div className="text-sm text-gray-600">Total Time</div>
        </div>

        <div className="text-center p-4 bg-purple-50 rounded-lg">
          <TrendingUp className="h-6 w-6 text-purple-600 mx-auto mb-2" />
          <div className="text-2xl font-bold text-gray-900">{averageDuration}m</div>
          <div className="text-sm text-gray-600">Avg Duration</div>
        </div>
      </div>
    </div>
  )
}


========================================
FILE: src/components/WorkoutFlowHeader.tsx
========================================

// src/components/WorkoutFlowHeader.tsx
import { useState } from 'react'
import { useNavigate } from 'react-router-dom'
import { signOut } from 'firebase/auth'
import { auth } from '../lib/firebase'
import { 
  Menu, 
  X, 
  Zap, 
  Home, 
  Dumbbell, 
  History, 
  User, 
  LogOut, 
  Crown,
  ArrowLeft,
  Pause,
  Play,
  SkipForward
} from 'lucide-react'

interface WorkoutFlowHeaderProps {
  title?: string
  showBackButton?: boolean
  showWorkoutControls?: boolean
  onBack?: () => void
  onPause?: () => void
  onResume?: () => void
  onSkip?: () => void
  isPaused?: boolean
  className?: string
}

export default function WorkoutFlowHeader({
  title = "Workout",
  showBackButton = true,
  showWorkoutControls = false,
  onBack,
  onPause,
  onResume,
  onSkip,
  isPaused = false,
  className = ""
}: WorkoutFlowHeaderProps) {
  const [isMenuOpen, setIsMenuOpen] = useState(false)
  const nav = useNavigate()

  const menuItems = [
    { label: 'Dashboard', path: '/dashboard', icon: Home },
    { label: 'Generate Workout', path: '/generate', icon: Dumbbell },
    { label: 'Workout History', path: '/history', icon: History },
    { label: 'Subscription', path: '/subscription', icon: Crown },
    { label: 'Profile', path: '/profile', icon: User },
  ]

  const handleNavigation = (path: string) => {
    nav(path)
    setIsMenuOpen(false)
  }

  const handleSignOut = async () => {
    try {
      await signOut(auth)
      nav('/')
      setIsMenuOpen(false)
    } catch (e) {
      console.error('Sign out failed', e)
      alert('Sign out failed. Please try again.')
    }
  }

  const handleBack = () => {
    if (onBack) {
      onBack()
    } else {
      nav(-1)
    }
  }

  return (
    <>
      <header className={`sticky top-0 z-50 bg-gradient-to-r from-white/95 via-white/90 to-white/95 backdrop-blur-xl border-b border-gray-200/60 shadow-lg shadow-gray-200/20 ${className}`}>
        <div className="mx-auto max-w-6xl px-4 sm:px-6 py-3 flex items-center justify-between" style={{ paddingTop: 'max(12px, env(safe-area-inset-top))' }}>
          {/* Left Section */}
          <div className="flex items-center gap-4">
            {showBackButton && (
              <button
                onClick={handleBack}
                className="p-2 rounded-xl hover:bg-gray-100/80 transition-all duration-200 touch-manipulation min-h-[44px] min-w-[44px] flex items-center justify-center group"
                aria-label="Go back"
              >
                <ArrowLeft className="h-5 w-5 text-gray-700 group-hover:text-gray-900 transition-colors" />
              </button>
            )}
            
            {/* Logo and Title */}
            <div className="flex items-center gap-3">
              <div className="h-8 w-8 rounded-xl bg-gradient-to-tr from-blue-500 via-blue-600 to-indigo-600 flex items-center justify-center shadow-lg shadow-blue-500/25">
                <Zap className="h-4 w-4 text-white" />
              </div>
              <div>
                <h1 className="text-lg sm:text-xl font-bold text-gray-900 tracking-tight leading-tight">
                  {title}
                </h1>
                <div className="text-xs text-gray-500 font-medium">
                  neurafit
                </div>
              </div>
            </div>
          </div>

          {/* Center Section - Workout Controls */}
          {showWorkoutControls && (
            <div className="hidden sm:flex items-center gap-2">
              {isPaused ? (
                <button
                  onClick={onResume}
                  className="flex items-center gap-2 px-4 py-2 bg-gradient-to-r from-green-500 to-emerald-600 text-white rounded-xl font-medium hover:from-green-600 hover:to-emerald-700 transition-all duration-200 shadow-lg hover:shadow-xl hover:scale-105 active:scale-95"
                >
                  <Play className="h-4 w-4" />
                  Resume
                </button>
              ) : (
                <button
                  onClick={onPause}
                  className="flex items-center gap-2 px-4 py-2 bg-gradient-to-r from-yellow-500 to-orange-600 text-white rounded-xl font-medium hover:from-yellow-600 hover:to-orange-700 transition-all duration-200 shadow-lg hover:shadow-xl hover:scale-105 active:scale-95"
                >
                  <Pause className="h-4 w-4" />
                  Pause
                </button>
              )}
              
              {onSkip && (
                <button
                  onClick={onSkip}
                  className="flex items-center gap-2 px-4 py-2 bg-gradient-to-r from-slate-500 to-gray-600 text-white rounded-xl font-medium hover:from-slate-600 hover:to-gray-700 transition-all duration-200 shadow-lg hover:shadow-xl hover:scale-105 active:scale-95"
                >
                  <SkipForward className="h-4 w-4" />
                  Skip
                </button>
              )}
            </div>
          )}

          {/* Right Section - Menu Button */}
          <button
            onClick={() => setIsMenuOpen(!isMenuOpen)}
            className="p-3 rounded-xl hover:bg-gray-100/80 transition-all duration-200 touch-manipulation min-h-[44px] min-w-[44px] flex items-center justify-center group"
            aria-label="Toggle menu"
          >
            {isMenuOpen ? (
              <X className="h-5 w-5 text-gray-700 group-hover:text-gray-900 transition-colors" />
            ) : (
              <Menu className="h-5 w-5 text-gray-700 group-hover:text-gray-900 transition-colors" />
            )}
          </button>
        </div>

        {/* Mobile Workout Controls */}
        {showWorkoutControls && (
          <div className="sm:hidden px-4 pb-3">
            <div className="flex items-center justify-center gap-2">
              {isPaused ? (
                <button
                  onClick={onResume}
                  className="flex items-center gap-2 px-4 py-2 bg-gradient-to-r from-green-500 to-emerald-600 text-white rounded-xl font-medium hover:from-green-600 hover:to-emerald-700 transition-all duration-200 shadow-lg hover:shadow-xl hover:scale-105 active:scale-95"
                >
                  <Play className="h-4 w-4" />
                  Resume
                </button>
              ) : (
                <button
                  onClick={onPause}
                  className="flex items-center gap-2 px-4 py-2 bg-gradient-to-r from-yellow-500 to-orange-600 text-white rounded-xl font-medium hover:from-yellow-600 hover:to-orange-700 transition-all duration-200 shadow-lg hover:shadow-xl hover:scale-105 active:scale-95"
                >
                  <Pause className="h-4 w-4" />
                  Pause
                </button>
              )}
              
              {onSkip && (
                <button
                  onClick={onSkip}
                  className="flex items-center gap-2 px-4 py-2 bg-gradient-to-r from-slate-500 to-gray-600 text-white rounded-xl font-medium hover:from-slate-600 hover:to-gray-700 transition-all duration-200 shadow-lg hover:shadow-xl hover:scale-105 active:scale-95"
                >
                  <SkipForward className="h-4 w-4" />
                  Skip
                </button>
              )}
            </div>
          </div>
        )}
      </header>

      {/* Mobile Menu Overlay */}
      {isMenuOpen && (
        <>
          {/* Backdrop */}
          <div 
            className="fixed inset-0 z-40 bg-black/20 backdrop-blur-sm"
            onClick={() => setIsMenuOpen(false)}
          />
          
          {/* Menu Panel */}
          <div className="fixed top-20 right-6 z-50 w-64 bg-white/95 backdrop-blur-md rounded-2xl border border-gray-200 shadow-xl">
            <div className="p-2">
              {menuItems.map((item) => {
                const Icon = item.icon
                return (
                  <button
                    key={item.path}
                    onClick={() => handleNavigation(item.path)}
                    className="w-full flex items-center gap-3 px-4 py-4 text-left rounded-xl hover:bg-gray-100 transition-colors text-gray-700 hover:text-gray-900 touch-manipulation min-h-[48px]"
                  >
                    <Icon className="h-5 w-5" />
                    <span className="font-medium">{item.label}</span>
                  </button>
                )
              })}

              {/* Divider */}
              <div className="my-2 h-px bg-gray-200" />

              {/* Sign Out */}
              <button
                onClick={handleSignOut}
                className="w-full flex items-center gap-3 px-4 py-4 text-left rounded-xl hover:bg-red-50 transition-colors text-red-600 hover:text-red-700 touch-manipulation min-h-[48px]"
              >
                <LogOut className="h-5 w-5" />
                <span className="font-medium">Sign out</span>
              </button>
            </div>
          </div>
        </>
      )}
    </>
  )
}


========================================
FILE: src/components/WorkoutProgress.tsx
========================================

// src/components/WorkoutProgress.tsx
import React from 'react'
import { CheckCircle, Clock, Zap, Flame, Rocket, Sparkles, Target, PartyPopper } from 'lucide-react'

interface CircularProgressProps {
  progress: number // 0-100
  size?: number
  strokeWidth?: number
  className?: string
  children?: React.ReactNode
}

export function CircularProgress({ 
  progress, 
  size = 120, 
  strokeWidth = 8, 
  className = '',
  children 
}: CircularProgressProps) {
  const radius = (size - strokeWidth) / 2
  const circumference = radius * 2 * Math.PI
  const offset = circumference - (progress / 100) * circumference

  return (
    <div className={`relative inline-flex items-center justify-center ${className}`}>
      <svg
        width={size}
        height={size}
        className="transform -rotate-90"
      >
        {/* Background circle */}
        <circle
          cx={size / 2}
          cy={size / 2}
          r={radius}
          stroke="currentColor"
          strokeWidth={strokeWidth}
          fill="transparent"
          className="text-gray-200"
        />
        {/* Progress circle */}
        <circle
          cx={size / 2}
          cy={size / 2}
          r={radius}
          stroke="currentColor"
          strokeWidth={strokeWidth}
          fill="transparent"
          strokeDasharray={circumference}
          strokeDashoffset={offset}
          className="text-blue-500 transition-all duration-500 ease-out"
          strokeLinecap="round"
        />
      </svg>
      {/* Content */}
      <div className="absolute inset-0 flex items-center justify-center">
        {children}
      </div>
    </div>
  )
}

interface WorkoutProgressHeaderProps {
  currentExercise: number
  totalExercises: number
  currentSet: number
  totalSets: number
  overallProgress: number
  exerciseName: string
}

export function WorkoutProgressHeader({
  currentExercise,
  totalExercises,
  currentSet,
  totalSets,
  overallProgress,
  exerciseName
}: WorkoutProgressHeaderProps) {
  return (
    <div className="bg-white/90 backdrop-blur-md border-b border-gray-100 sticky top-0 z-40">
      <div className="max-w-4xl mx-auto px-6 py-4">
        {/* Overall Progress */}
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center gap-3">
            <CircularProgress progress={overallProgress} size={48} strokeWidth={4}>
              <span className="text-xs font-bold text-gray-700">
                {Math.round(overallProgress)}%
              </span>
            </CircularProgress>
            <div>
              <div className="text-sm font-medium text-gray-900">
                Exercise {currentExercise} of {totalExercises}
              </div>
              <div className="text-xs text-gray-600">
                Overall Progress
              </div>
            </div>
          </div>
          
          {/* Exercise Progress */}
          <div className="text-right">
            <div className="text-sm font-medium text-gray-900">
              Set {currentSet} of {totalSets}
            </div>
            <div className="text-xs text-gray-600">
              Current Exercise
            </div>
          </div>
        </div>

        {/* Exercise Name */}
        <div className="text-center">
          <h2 className="text-lg font-bold text-gray-900 truncate">
            {exerciseName}
          </h2>
        </div>

        {/* Progress Bar */}
        <div className="mt-3">
          <div className="w-full bg-gray-200 rounded-full h-2">
            <div 
              className="bg-gradient-to-r from-blue-500 to-indigo-600 h-2 rounded-full transition-all duration-500 ease-out"
              style={{ width: `${overallProgress}%` }}
            />
          </div>
        </div>
      </div>
    </div>
  )
}

interface SetProgressIndicatorProps {
  currentSet: number
  totalSets: number
  completedSets: number[]
  skippedSets: number[]
}

export function SetProgressIndicator({
  currentSet,
  totalSets,
  completedSets,
  skippedSets
}: SetProgressIndicatorProps) {
  return (
    <div className="flex items-center justify-center gap-2 py-4">
      {Array.from({ length: totalSets }, (_, i) => {
        const setNumber = i + 1
        const isCompleted = completedSets.includes(setNumber)
        const isSkipped = skippedSets.includes(setNumber)
        const isCurrent = setNumber === currentSet
        
        return (
          <div
            key={setNumber}
            className={`relative flex items-center justify-center w-8 h-8 rounded-full border-2 transition-all duration-300 ${
              isCompleted
                ? 'bg-green-500 border-green-500 text-white'
                : isSkipped
                ? 'bg-red-100 border-red-300 text-red-600'
                : isCurrent
                ? 'bg-blue-500 border-blue-500 text-white animate-pulse'
                : 'bg-gray-100 border-gray-300 text-gray-600'
            }`}
          >
            {isCompleted ? (
              <CheckCircle className="h-4 w-4" />
            ) : (
              <span className="text-xs font-bold">{setNumber}</span>
            )}
            
            {isCurrent && (
              <div className="absolute -inset-1 rounded-full border-2 border-blue-300 animate-ping" />
            )}
          </div>
        )
      })}
    </div>
  )
}

interface MotivationalMessageProps {
  progress: number
  completedSets: number
  totalSets: number
  exerciseName: string
}

export function MotivationalMessage({
  progress: _progress,
  completedSets,
  totalSets,
  exerciseName
}: MotivationalMessageProps) {
  // Use exercise completion percentage for motivational messages, not overall workout progress
  const exerciseCompletionPct = Math.round((completedSets / totalSets) * 100)

  const getMotivationalMessage = () => {
    if (exerciseCompletionPct >= 90) return { text: "Almost there! Finish strong!", icon: <Zap className="h-4 w-4" /> }
    if (exerciseCompletionPct >= 75) return { text: "You're crushing it! Keep going!", icon: <Flame className="h-4 w-4" /> }
    if (exerciseCompletionPct >= 50) return { text: "Halfway there! You've got this!", icon: <Zap className="h-4 w-4" /> }
    if (exerciseCompletionPct >= 25) return { text: "Great start! Building momentum!", icon: <Rocket className="h-4 w-4" /> }
    if (completedSets > 0) return { text: "Nice work! One set at a time!", icon: <Sparkles className="h-4 w-4" /> }
    return { text: "Let's do this! You're stronger than you think!", icon: <Target className="h-4 w-4" /> }
  }

  const getCompletionMessage = () => {
    if (exerciseCompletionPct === 100) return { text: `${exerciseName} completed!`, icon: <PartyPopper className="h-4 w-4" /> }
    if (exerciseCompletionPct >= 75) return { text: `${exerciseCompletionPct}% complete - almost done!`, icon: null }
    if (exerciseCompletionPct >= 50) return { text: `${exerciseCompletionPct}% complete - keep it up!`, icon: null }
    if (exerciseCompletionPct > 0) return { text: `${exerciseCompletionPct}% complete - great progress!`, icon: null }
    return { text: "Ready to start? You've got this!", icon: null }
  }

  const motivationalMessage = getMotivationalMessage()
  const completionMessage = getCompletionMessage()

  return (
    <div className="text-center py-4 px-6">
      <div className="bg-gradient-to-r from-blue-50 to-indigo-50 rounded-2xl p-4 border border-blue-100">
        <div className="flex items-center justify-center gap-2 text-lg font-semibold text-gray-900 mb-1">
          {motivationalMessage.icon}
          <span>{motivationalMessage.text}</span>
        </div>
        <div className="flex items-center justify-center gap-2 text-sm text-gray-600">
          {completionMessage.icon}
          <span>{completionMessage.text}</span>
        </div>
      </div>
    </div>
  )
}

interface NextExercisePreviewProps {
  nextExercise?: {
    name: string
    sets: number
    reps: string | number
    restSeconds?: number
  }
  timeRemaining: number
}

export function NextExercisePreview({ nextExercise, timeRemaining }: NextExercisePreviewProps) {
  if (!nextExercise) return null

  return (
    <div className="bg-gradient-to-r from-gray-50 to-blue-50 rounded-2xl p-4 border border-gray-200">
      <div className="flex items-center gap-3 mb-2">
        <div className="flex items-center gap-1 text-blue-600">
          <Clock className="h-4 w-4" />
          <span className="text-sm font-medium">{timeRemaining}s</span>
        </div>
        <div className="text-sm text-gray-600">Next up:</div>
      </div>
      
      <div className="text-lg font-semibold text-gray-900 mb-1">
        {nextExercise.name}
      </div>
      
      <div className="text-sm text-gray-600">
        {nextExercise.sets} sets × {nextExercise.reps} reps
        {nextExercise.restSeconds && (
          <span className="ml-2">• {nextExercise.restSeconds}s rest</span>
        )}
      </div>
    </div>
  )
}

interface WorkoutStatsProps {
  startTime: number
  completedSets: number
  totalSets: number
  completedExercises: number
  totalExercises: number
}

export function WorkoutStats({
  startTime,
  completedSets,
  totalSets,
  completedExercises,
  totalExercises
}: WorkoutStatsProps) {
  const elapsedMinutes = Math.floor((Date.now() - startTime) / 1000 / 60)
  const completionRate = Math.round((completedSets / totalSets) * 100)

  return (
    <div className="grid grid-cols-3 gap-4 p-4">
      <div className="text-center">
        <div className="text-2xl font-bold text-blue-600">{elapsedMinutes}</div>
        <div className="text-xs text-gray-600">Minutes</div>
      </div>

      <div className="text-center">
        <div className="text-2xl font-bold text-green-600">{completionRate}%</div>
        <div className="text-xs text-gray-600">Complete</div>
      </div>

      <div className="text-center">
        <div className="text-2xl font-bold text-indigo-600">
          {completedExercises}/{totalExercises}
        </div>
        <div className="text-xs text-gray-600">Exercises</div>
      </div>
    </div>
  )
}


========================================
FILE: src/pages/Auth.tsx
========================================

// src/pages/Auth.tsx
import React, { useEffect, useState } from 'react'
import { Link } from 'react-router-dom'
import { auth } from '../lib/firebase'
import { GoogleAuthProvider, signInWithPopup, signInWithRedirect, createUserWithEmailAndPassword, signInWithEmailAndPassword } from 'firebase/auth'
import { Zap, Brain, Target, Shield, Mail, Lock, Eye, EyeOff } from 'lucide-react'
import type { ReactElement } from 'react'
import { trackUserSignUp, trackUserLogin } from '../lib/firebase-analytics'

export default function Auth() {
  const [loading, setLoading] = useState(false)
  const [authMode, setAuthMode] = useState<'signin' | 'signup'>('signin')
  const [showPassword, setShowPassword] = useState(false)
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [confirmPassword, setConfirmPassword] = useState('')
  const [emailError, setEmailError] = useState('')
  const [passwordError, setPasswordError] = useState('')

  // Initialize component and apply performance optimizations
  useEffect(() => {
    setLoading(false)

    // Respect reduced motion preference
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
      document.documentElement.style.setProperty('--animation-duration', '0.01ms')
    }
  }, [])

  const googleLogin = async () => {
    setLoading(true)

    try {
      // Use Firebase modular API for Google Auth
      const provider = new GoogleAuthProvider()
      provider.setCustomParameters({
        prompt: 'select_account'
      })

      try {
        // Attempt popup authentication first
        const result = await signInWithPopup(auth, provider)
        const isNewUser = result.user.metadata.creationTime === result.user.metadata.lastSignInTime
        if (isNewUser) {
          trackUserSignUp('google')
        } else {
          trackUserLogin('google')
        }
        // Success - AppProvider will handle navigation
      } catch (error) {
        const firebaseError = error as { code?: string; message?: string }
        // Suppress expected COOP errors in development
        if (process.env.NODE_ENV === 'development' && !firebaseError.message?.includes('Cross-Origin-Opener-Policy')) {
          console.log('Popup failed, trying redirect:', firebaseError.code)
        }

        // Fallback to redirect if popup fails
        if (firebaseError.code === 'auth/popup-blocked' ||
            firebaseError.code === 'auth/popup-closed-by-user' ||
            (error as Error)?.message?.includes('Cross-Origin-Opener-Policy') ||
            (error as Error)?.message?.includes('window.closed')) {
          try {
            await signInWithRedirect(auth, provider)
            // Redirect initiated, no need to reset loading
            return
          } catch (redirectError) {
            console.error('Redirect also failed:', redirectError)
            alert('Failed to sign in with Google. Please try again.')
          }
        } else if (firebaseError.code !== 'auth/cancelled-popup-request') {
          console.error('Google sign-in error:', firebaseError)
          alert('Failed to sign in with Google. Please try again.')
        }
        setLoading(false)
      }
    } catch (error) {
      console.error('Failed to initialize Firebase Auth:', error)
      alert('Authentication service not available. Please try again.')
      setLoading(false)
    }
  }

  const validateForm = () => {
    let isValid = true
    setEmailError('')
    setPasswordError('')

    // Validate email
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    if (!email) {
      setEmailError('Email is required')
      isValid = false
    } else if (!emailRegex.test(email)) {
      setEmailError('Please enter a valid email address')
      isValid = false
    }

    // Validate password
    if (!password) {
      setPasswordError('Password is required')
      isValid = false
    } else if (password.length < 6) {
      setPasswordError('Password must be at least 6 characters')
      isValid = false
    }

    // Validate password confirmation for signup
    if (authMode === 'signup' && password !== confirmPassword) {
      setPasswordError('Passwords do not match')
      isValid = false
    }

    return isValid
  }

  const handleEmailAuth = async (e: React.FormEvent) => {
    e.preventDefault()

    if (!validateForm()) return

    setLoading(true)

    try {
      // Firebase auth is ready synchronously

      if (authMode === 'signup') {
        await createUserWithEmailAndPassword(auth, email, password)
        trackUserSignUp('email')
      } else {
        await signInWithEmailAndPassword(auth, email, password)
        trackUserLogin('email')
      }
      // Success - AppProvider will handle navigation
    } catch (error) {
      const firebaseError = error as { code?: string; message?: string }
      console.error('Email auth error:', firebaseError)

      // Handle specific Firebase errors
      switch (firebaseError.code) {
        case 'auth/email-already-in-use':
          setEmailError('An account with this email already exists')
          break
        case 'auth/weak-password':
          setPasswordError('Password is too weak')
          break
        case 'auth/user-not-found':
          setEmailError('No account found with this email')
          break
        case 'auth/wrong-password':
          setPasswordError('Incorrect password')
          break
        case 'auth/invalid-email':
          setEmailError('Invalid email address')
          break
        case 'auth/too-many-requests':
          setPasswordError('Too many failed attempts. Please try again later.')
          break
        default:
          setPasswordError('Authentication failed. Please try again.')
      }
    } finally {
      setLoading(false)
    }
  }

  const toggleAuthMode = () => {
    setAuthMode(authMode === 'signin' ? 'signup' : 'signin')
    setEmail('')
    setPassword('')
    setConfirmPassword('')
    setEmailError('')
    setPasswordError('')
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 via-white to-blue-50/30 text-gray-900 relative overflow-hidden" role="main" aria-label="NeuraFit Authentication Page">
      {/* Enhanced Background Pattern */}
      <div className="absolute inset-0 bg-[radial-gradient(circle_at_50%_120%,rgba(59,130,246,0.08),transparent_50%)]" />
      <div className="absolute inset-0 bg-[radial-gradient(circle_at_80%_20%,rgba(16,185,129,0.04),transparent_50%)]" />
      <div className="absolute top-0 left-0 w-full h-full bg-[linear-gradient(45deg,transparent_25%,rgba(59,130,246,0.02)_50%,transparent_75%)]" />

      {/* Floating Elements - Optimized with will-change and reduced motion support */}
      <div className="absolute top-20 left-10 w-20 h-20 bg-gradient-to-br from-blue-400/10 to-indigo-400/10 rounded-full blur-xl animate-float will-change-transform" style={{'--float-intensity': '-8px'} as React.CSSProperties} />
      <div className="absolute top-40 right-16 w-16 h-16 bg-gradient-to-br from-emerald-400/10 to-teal-400/10 rounded-full blur-xl animate-float will-change-transform" style={{'--float-intensity': '-12px'} as React.CSSProperties} />
      <div className="absolute bottom-32 left-20 w-12 h-12 bg-gradient-to-br from-orange-400/10 to-amber-400/10 rounded-full blur-xl animate-float will-change-transform" style={{'--float-intensity': '-6px'} as React.CSSProperties} />

      {/* Main Content */}
      <div className="relative max-w-md mx-auto px-6 py-8 sm:py-12 animate-fade-in-up safe-area-inset-top safe-area-inset-bottom" style={{ animationDelay: '0.1s', animationFillMode: 'both' }}>
        {/* Enhanced Header Badge */}
        <div className="flex items-center justify-center mb-8 sm:mb-12">
          <div className="group inline-flex items-center gap-2 sm:gap-3 px-4 sm:px-6 py-2 sm:py-3 bg-gradient-to-r from-blue-50/80 to-indigo-50/80 backdrop-blur-sm border border-blue-100/60 rounded-full shadow-sm hover:shadow-lg transition-all duration-500 hover:scale-105 cursor-default touch-manipulation">
            <div className="relative">
              <Zap className="h-3.5 w-3.5 sm:h-4 sm:w-4 text-blue-600 group-hover:text-blue-700 transition-colors duration-300" />
              <div className="absolute inset-0 bg-blue-400 rounded-full blur-sm opacity-0 group-hover:opacity-20 transition-opacity duration-300" />
            </div>
            <span className="text-xs sm:text-sm font-semibold text-blue-700 tracking-wide group-hover:text-blue-800 transition-colors duration-300">
              AI-Powered Fitness Technology
            </span>
          </div>
        </div>

        {/* Enhanced Hero Title */}
        <div className="text-center mb-8 sm:mb-12">
          <h1 className="text-3xl sm:text-4xl md:text-5xl font-bold leading-tight mb-6 sm:mb-8 tracking-tight px-2" role="heading" aria-level={1}>
            <span className="block mb-1 sm:mb-2">Transform Your Body</span>
            <span className="block mb-1 sm:mb-2">with{' '}
              <span className="bg-gradient-to-r from-blue-600 via-indigo-600 to-purple-600 bg-clip-text text-transparent">
                AI-Powered
              </span>
            </span>
            <span className="bg-gradient-to-r from-emerald-600 via-teal-600 to-cyan-600 bg-clip-text text-transparent">
              Precision
            </span>
          </h1>
          <p className="text-gray-600 text-base sm:text-lg leading-relaxed max-w-sm mx-auto mb-6 px-4">
            Experience personalized workout plans that evolve with you. Our advanced AI
            analyzes your progress, adapts to your goals, and delivers{' '}
            <span className="text-blue-600 font-semibold">results that matter.</span>
          </p>

        </div>

        {/* Enhanced CTA Buttons */}
        <div className="space-y-4 sm:space-y-6 mb-8 sm:mb-12">
          <button
            onClick={googleLogin}
            disabled={loading}
            className="group relative w-full bg-white/80 backdrop-blur-sm border border-gray-200/80 text-gray-700 px-6 py-4 sm:py-4 rounded-2xl font-semibold hover:bg-white hover:border-gray-300 hover:shadow-xl hover:shadow-gray-200/50 transition-all duration-500 disabled:opacity-60 disabled:cursor-not-allowed flex items-center justify-center gap-3 shadow-lg hover:scale-[1.02] active:scale-[0.98] overflow-hidden touch-manipulation min-h-[48px]"
            aria-label="Sign in with Google"
            type="button"
          >
            {/* Subtle gradient overlay */}
            <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-500" />

            {/* Google glyph */}
            <svg className="h-5 w-5 transition-transform duration-300 group-hover:scale-110 relative z-10" viewBox="0 0 48 48" aria-hidden="true">
              <path fill="#EA4335" d="M24 9.5c3.94 0 7.48 1.53 10.2 4.02l6.8-6.8C36.84 2.61 30.77 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.96 6.18C12.3 13 17.74 9.5 24 9.5z"/>
              <path fill="#4285F4" d="M46.5 24c0-1.64-.15-3.22-.44-4.75H24v9.01h12.65c-.55 2.94-2.23 5.43-4.74 7.11l7.24 5.62C43.99 36.76 46.5 30.79 46.5 24z"/>
              <path fill="#FBBC05" d="M10.52 27.6A14.47 14.47 0 0 1 9.5 24c0-1.25.17-2.46.48-3.6l-7.96-6.18A24 24 0 0 0 0 24c0 3.84.9 7.47 2.5 10.68l8.02-7.08z"/>
              <path fill="#34A853" d="M24 48c6.48 0 11.92-2.14 15.9-5.83l-7.24-5.62c-2.01 1.36-4.59 2.16-8.66 2.16-6.26 0-11.7-3.5-13.48-8.52l-8.02 7.08C6.51 42.62 14.62 48 24 48z"/>
            </svg>
            <span className="transition-colors duration-300 group-hover:text-gray-800 relative z-10 flex items-center gap-2">
              {loading && (
                <div className="animate-spin rounded-full h-4 w-4 border-2 border-gray-400 border-t-transparent" />
              )}
              {loading ? 'Signing in...' : 'Continue with Google'}
            </span>

            {/* Loading shimmer effect */}
            {loading && (
              <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/30 to-transparent animate-shimmer" />
            )}
          </button>

          {/* Enhanced Divider */}
          <div className="relative my-8">
            <div className="absolute inset-0 flex items-center">
              <div className="w-full border-t border-gray-200/60"></div>
            </div>
            <div className="relative flex justify-center">
              <span className="px-6 py-2 bg-gradient-to-r from-slate-50/80 via-white to-slate-50/80 backdrop-blur-sm text-gray-500 font-medium text-sm rounded-full border border-gray-100/50 shadow-sm">
                or continue with email
              </span>
            </div>
          </div>

          {/* Enhanced Email/Password Form */}
          <form onSubmit={handleEmailAuth} className="space-y-5" role="form" aria-label="Email and password authentication form">
            {/* Enhanced Email Input */}
            <div className="group">
              <div className="relative">
                <Mail className="absolute left-4 top-1/2 transform -translate-y-1/2 h-5 w-5 text-gray-400 group-focus-within:text-blue-500 transition-colors duration-300" />
                <input
                  type="email"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  placeholder="Enter your email"
                  className={`w-full pl-12 pr-4 py-4 rounded-2xl border font-medium placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500/20 focus:border-blue-500 transition-all duration-300 bg-white/80 backdrop-blur-sm hover:bg-white hover:shadow-md touch-manipulation min-h-[48px] text-base ${
                    emailError
                      ? 'border-red-300 bg-red-50/50 focus:ring-red-500/20 focus:border-red-500 animate-shake'
                      : 'border-gray-200/80 hover:border-gray-300'
                  }`}
                  disabled={loading}
                  aria-invalid={emailError ? 'true' : 'false'}
                  aria-describedby={emailError ? 'email-error' : undefined}
                />
                {/* Focus ring enhancement */}
                <div className="absolute inset-0 rounded-2xl bg-gradient-to-r from-blue-500/10 to-indigo-500/10 opacity-0 group-focus-within:opacity-100 transition-opacity duration-300 pointer-events-none" />
              </div>
              {emailError && (
                <p id="email-error" className="mt-2 text-sm text-red-600 font-medium flex items-center gap-1">
                  <span className="w-1 h-1 bg-red-500 rounded-full"></span>
                  {emailError}
                </p>
              )}
            </div>

            {/* Enhanced Password Input */}
            <div className="group">
              <div className="relative">
                <Lock className="absolute left-4 top-1/2 transform -translate-y-1/2 h-5 w-5 text-gray-400 group-focus-within:text-blue-500 transition-colors duration-300" />
                <input
                  type={showPassword ? 'text' : 'password'}
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  placeholder="Enter your password"
                  className={`w-full pl-12 pr-12 py-4 rounded-2xl border font-medium placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500/20 focus:border-blue-500 transition-all duration-300 bg-white/80 backdrop-blur-sm hover:bg-white hover:shadow-md touch-manipulation min-h-[48px] text-base ${
                    passwordError
                      ? 'border-red-300 bg-red-50/50 focus:ring-red-500/20 focus:border-red-500 animate-shake'
                      : 'border-gray-200/80 hover:border-gray-300'
                  }`}
                  disabled={loading}
                  aria-invalid={passwordError ? 'true' : 'false'}
                  aria-describedby={passwordError ? 'password-error' : undefined}
                />
                <button
                  type="button"
                  onClick={() => setShowPassword(!showPassword)}
                  className="absolute right-4 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-blue-500 hover:bg-blue-50 rounded-lg p-1 transition-all duration-200 hover:scale-110"
                  disabled={loading}
                  aria-label={showPassword ? 'Hide password' : 'Show password'}
                >
                  {showPassword ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                </button>
                {/* Focus ring enhancement */}
                <div className="absolute inset-0 rounded-2xl bg-gradient-to-r from-blue-500/10 to-indigo-500/10 opacity-0 group-focus-within:opacity-100 transition-opacity duration-300 pointer-events-none" />
              </div>
              {passwordError && (
                <p id="password-error" className="mt-2 text-sm text-red-600 font-medium flex items-center gap-1">
                  <span className="w-1 h-1 bg-red-500 rounded-full"></span>
                  {passwordError}
                </p>
              )}
            </div>

            {/* Enhanced Confirm Password Input (only for signup) */}
            {authMode === 'signup' && (
              <div className="group animate-fade-in-up">
                <div className="relative">
                  <Lock className="absolute left-4 top-1/2 transform -translate-y-1/2 h-5 w-5 text-gray-400 group-focus-within:text-blue-500 transition-colors duration-300" />
                  <input
                    type={showPassword ? 'text' : 'password'}
                    value={confirmPassword}
                    onChange={(e) => setConfirmPassword(e.target.value)}
                    placeholder="Confirm your password"
                    className="w-full pl-12 pr-4 py-4 rounded-2xl border border-gray-200/80 bg-white/80 backdrop-blur-sm hover:bg-white hover:border-gray-300 hover:shadow-md font-medium placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500/20 focus:border-blue-500 transition-all duration-300"
                    disabled={loading}
                  />
                  {/* Focus ring enhancement */}
                  <div className="absolute inset-0 rounded-2xl bg-gradient-to-r from-blue-500/10 to-indigo-500/10 opacity-0 group-focus-within:opacity-100 transition-opacity duration-300 pointer-events-none" />
                </div>
              </div>
            )}

            {/* Enhanced Submit Button */}
            <button
              type="submit"
              disabled={loading}
              className="relative w-full bg-gradient-to-r from-blue-600 via-indigo-600 to-purple-600 text-white px-6 py-4 rounded-2xl font-semibold hover:from-blue-700 hover:via-indigo-700 hover:to-purple-700 hover:shadow-xl hover:shadow-blue-500/25 transition-all duration-500 disabled:opacity-60 disabled:cursor-not-allowed hover:scale-[1.02] active:scale-[0.98] shadow-lg overflow-hidden group touch-manipulation min-h-[48px]"
            >
              {/* Shimmer effect */}
              <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-500 animate-shimmer-slow" />

              <span className="relative z-10 flex items-center justify-center gap-2">
                {loading && (
                  <div className="animate-spin rounded-full h-4 w-4 border-2 border-white border-t-transparent" />
                )}
                {loading ? 'Please wait...' : (authMode === 'signup' ? 'Create Account' : 'Sign In')}
              </span>
            </button>

            {/* Enhanced Toggle Auth Mode */}
            <div className="text-center pt-2">
              <button
                type="button"
                onClick={toggleAuthMode}
                disabled={loading}
                className="text-sm text-gray-600 hover:text-blue-600 font-medium transition-all duration-200 disabled:opacity-60 hover:bg-blue-50 px-3 py-1.5 rounded-lg"
              >
                {authMode === 'signup'
                  ? 'Already have an account? Sign in'
                  : "Don't have an account? Sign up"
                }
              </button>
            </div>
          </form>
        </div>

        {/* Enhanced Why Choose NeuraFit Section */}
        <div className="mb-12">
          <div className="text-center mb-12">
            <h2 className="text-3xl font-bold mb-4 text-gray-900">
              Why Choose{' '}
              <span className="bg-gradient-to-r from-blue-600 to-indigo-600 bg-clip-text text-transparent">
                NeuraFit
              </span>
              ?
            </h2>
            <p className="text-gray-600 text-lg leading-relaxed max-w-lg mx-auto">
              Experience the perfect blend of cutting-edge AI technology and personalized fitness coaching
            </p>
          </div>

          {/* Enhanced Feature Cards */}
          <div className="space-y-6">
            <div className="animate-fade-in-up" style={{ animationDelay: '0.3s', animationFillMode: 'both' }}>
              <EnhancedFeatureCard
                icon={<Brain className="h-7 w-7" />}
                title="AI-Powered Workouts"
                desc="Personalized training plans that adapt to your progress and goals using advanced machine learning algorithms."
                bgGradient="from-blue-500/10 via-indigo-500/10 to-purple-500/10"
                iconBg="from-blue-500 to-indigo-600"
                accentColor="blue"
              />
            </div>
            <div className="animate-fade-in-up" style={{ animationDelay: '0.4s', animationFillMode: 'both' }}>
              <EnhancedFeatureCard
                icon={<Target className="h-7 w-7" />}
                title="Goal-Focused Training"
                desc="Every workout is optimized to help you reach your specific fitness objectives faster and more efficiently."
                bgGradient="from-emerald-500/10 via-teal-500/10 to-cyan-500/10"
                iconBg="from-emerald-500 to-teal-600"
                accentColor="emerald"
              />
            </div>
            <div className="animate-fade-in-up" style={{ animationDelay: '0.5s', animationFillMode: 'both' }}>
              <EnhancedFeatureCard
                icon={<Shield className="h-7 w-7" />}
                title="Safety First"
                desc="Built-in injury prevention with intelligent form guidance and personalized recovery recommendations."
                bgGradient="from-orange-500/10 via-amber-500/10 to-yellow-500/10"
                iconBg="from-orange-500 to-amber-600"
                accentColor="orange"
              />
            </div>
          </div>
        </div>

        {/* Enhanced Footer */}
        <div className="text-center pt-8 border-t border-gray-100/80">
          <p className="text-xs text-gray-500 leading-relaxed">
            By continuing, you agree to our{' '}
            <Link to="/terms" className="text-blue-600 hover:text-blue-700 underline transition-colors duration-200">terms of service</Link>
            {' '}and{' '}
            <Link to="/privacy" className="text-blue-600 hover:text-blue-700 underline transition-colors duration-200">privacy policy</Link>.
            <br />
            <span className="text-gray-400 font-medium">Secure authentication powered by Firebase • v1.0.0</span>
          </p>
        </div>
      </div>
    </div>

  )
}

/* ---------- Enhanced Feature card ---------- */
function EnhancedFeatureCard({
  icon,
  title,
  desc,
  bgGradient,
  iconBg,
  accentColor,
}: {
  icon: ReactElement
  title: string
  desc: string
  bgGradient: string
  iconBg: string
  accentColor: string
}) {
  const accentColors = {
    blue: {
      border: 'border-blue-200/50',
      glow: 'group-hover:shadow-blue-500/20',
      text: 'text-blue-600'
    },
    emerald: {
      border: 'border-emerald-200/50',
      glow: 'group-hover:shadow-emerald-500/20',
      text: 'text-emerald-600'
    },
    orange: {
      border: 'border-orange-200/50',
      glow: 'group-hover:shadow-orange-500/20',
      text: 'text-orange-600'
    }
  }

  const colors = accentColors[accentColor as keyof typeof accentColors]

  return (
    <div className={`group relative p-6 rounded-2xl border ${colors.border} bg-gradient-to-br ${bgGradient} backdrop-blur-sm hover:bg-white/90 hover:shadow-xl ${colors.glow} transition-all duration-500 hover:scale-[1.02] overflow-hidden`}>
      {/* Subtle animated background */}
      <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/10 to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-500 animate-shimmer-slow" />

      <div className="relative z-10 flex items-start gap-4">
        {/* Enhanced Icon */}
        <div className={`flex-shrink-0 w-14 h-14 bg-gradient-to-br ${iconBg} rounded-2xl flex items-center justify-center shadow-lg group-hover:scale-110 group-hover:rotate-3 transition-all duration-500`}>
          <div className="text-white">
            {icon}
          </div>
          {/* Icon glow effect */}
          <div className={`absolute inset-0 bg-gradient-to-br ${iconBg} rounded-2xl blur-md opacity-0 group-hover:opacity-30 transition-opacity duration-500`} />
        </div>

        {/* Content */}
        <div className="flex-1 text-left">
          <h3 className="text-xl font-bold text-gray-900 mb-2 group-hover:text-gray-800 transition-colors duration-300">
            {title}
          </h3>
          <p className="text-gray-600 text-sm leading-relaxed group-hover:text-gray-700 transition-colors duration-300">
            {desc}
          </p>
        </div>

        {/* Subtle arrow indicator */}
        <div className={`flex-shrink-0 w-6 h-6 ${colors.text} opacity-0 group-hover:opacity-100 transition-all duration-300 group-hover:translate-x-1`}>
          <svg className="w-full h-full" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
          </svg>
        </div>
      </div>
    </div>
  )
}

========================================
FILE: src/pages/Dashboard.tsx
========================================

// src/pages/Dashboard.tsx
import { useMemo, useEffect, useState } from 'react'
import { useNavigate } from 'react-router-dom'
import { auth, db } from '../lib/firebase'
import { collection, query, orderBy, getDocs } from 'firebase/firestore'
import type { User } from 'firebase/auth'
import { convertToDate } from '../utils/timestamp'
import {
  Zap,
  History,
  User as UserIcon,
  Activity
} from 'lucide-react'
import AppHeader from '../components/AppHeader'
import { Button } from '../design-system/components/Button'
import { Card } from '../design-system/components/Card'
import { MotivationalBanner } from '../components/MotivationalBanner'
import { SubscriptionManager } from '../components/SubscriptionManager'

interface WorkoutItem {
  id: string
  workoutType: string
  duration: number
  timestamp: Date | { toDate(): Date } | string
  exercises?: Array<{
    name: string
    sets: number
    reps: string | number
    weights?: Record<number, number | null>
    usesWeight?: boolean
  }>
  completionRate?: number
}

interface DashboardStats {
  totalWorkouts: number
  weeklyWorkouts: number
  consistencyScore: number
  recentStreak: number
}

export default function Dashboard() {
  const nav = useNavigate()
  const [user, setUser] = useState<User | null>(null)
  const [dashboardStats, setDashboardStats] = useState<DashboardStats | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  // Get current user
  useEffect(() => {
    setUser(auth.currentUser)
  }, [])

  const firstName = useMemo(() => {
    const n = user?.displayName || user?.email || user?.phoneNumber || 'Athlete'
    return String(n).split(' ')[0]
  }, [user])

  // Fetch dashboard data
  useEffect(() => {
    const fetchDashboardData = async () => {
      try {
        const uid = auth.currentUser?.uid
        if (!uid) {
          setError('Not authenticated')
          return
        }

        // Fetch all workouts (assuming reasonable number per user)
        const workoutsRef = collection(db, 'users', uid, 'workouts')
        const workoutsQuery = query(workoutsRef, orderBy('timestamp', 'desc'))
        const workoutsSnap = await getDocs(workoutsQuery)
        const workouts = workoutsSnap.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        })) as WorkoutItem[]

        // Calculate dashboard statistics
        if (workouts.length > 0) {
          // Calculate consistency over last 30 days (percentage of active days)
          const thirtyDaysAgo = new Date()
          thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30)
          const recentWorkouts = workouts.filter(w => convertToDate(w.timestamp) >= thirtyDaysAgo)
          const activeDays = new Set(recentWorkouts.map(w => convertToDate(w.timestamp).toDateString())).size
          const consistencyScore = Math.round((activeDays / 30) * 100)

          // Calculate weekly workouts (count in last 7 days)
          const weekAgo = new Date()
          weekAgo.setDate(weekAgo.getDate() - 7)
          const weeklyWorkouts = workouts.filter(w => convertToDate(w.timestamp) >= weekAgo).length

          // Calculate recent streak
          // Workouts are already sorted newest first from query
          let streak = 0
          let currentDate = new Date()
          for (const workout of workouts) {
            const workoutDate = convertToDate(workout.timestamp)
            if (!workout.timestamp) break

            const daysDiff = Math.floor((currentDate.getTime() - workoutDate.getTime()) / (1000 * 60 * 60 * 24))
            if (daysDiff <= 1 || (streak === 0 && daysDiff <= 7)) {
              streak++
              currentDate = workoutDate
            } else {
              break
            }
          }

          const totalWorkouts = workouts.length

          setDashboardStats({
            totalWorkouts,
            weeklyWorkouts,
            consistencyScore,
            recentStreak: streak
          })
        } else {
          setDashboardStats({
            totalWorkouts: 0,
            weeklyWorkouts: 0,
            consistencyScore: 0,
            recentStreak: 0
          })
        }
      } catch (err) {
        const error = err as { message?: string }
        console.error('Error fetching dashboard data:', error)
        setError(error.message || 'Failed to load dashboard data')
      } finally {
        setLoading(false)
      }
    }

    fetchDashboardData()
  }, [])

  if (loading) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-slate-50/80 via-white to-blue-50/20 relative">
        {/* Enhanced background decoration */}
        <div className="absolute inset-0 overflow-hidden pointer-events-none">
          <div className="absolute -top-40 -right-40 w-96 h-96 bg-gradient-to-br from-blue-100/30 via-indigo-100/20 to-purple-100/10 rounded-full blur-3xl animate-pulse-subtle" />
          <div className="absolute -bottom-40 -left-40 w-80 h-80 bg-gradient-to-tr from-slate-100/25 via-gray-100/15 to-blue-100/10 rounded-full blur-3xl" />
          <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[600px] h-[600px] bg-gradient-radial from-blue-50/20 via-transparent to-transparent rounded-full blur-2xl" />
        </div>

        <AppHeader />
        <div className="relative mx-auto max-w-6xl px-4 sm:px-6 pt-6 sm:pt-8">
          <div className="animate-pulse space-y-10 sm:space-y-12">
            {/* Enhanced hero skeleton */}
            <div className="h-48 sm:h-52 bg-gradient-to-br from-white/95 via-white/90 to-white/85 rounded-3xl shadow-2xl shadow-slate-200/50 backdrop-blur-xl border border-white/70">
              <div className="p-6 sm:p-8 md:p-12 space-y-6">
                <div className="h-8 sm:h-10 bg-gradient-to-r from-slate-200/60 to-slate-300/40 rounded-2xl w-3/4"></div>
                <div className="h-6 bg-gradient-to-r from-slate-200/40 to-slate-300/30 rounded-xl w-full max-w-2xl"></div>
              </div>
            </div>

            {/* Enhanced motivational banner skeleton */}
            <div className="h-32 sm:h-36 bg-gradient-to-br from-white/95 via-white/90 to-white/85 rounded-3xl shadow-2xl shadow-slate-200/50 backdrop-blur-xl border border-white/70">
              <div className="p-6 sm:p-8 flex items-center gap-6">
                <div className="w-16 h-16 bg-gradient-to-br from-slate-200/60 to-slate-300/40 rounded-2xl"></div>
                <div className="flex-1 space-y-3">
                  <div className="h-6 bg-gradient-to-r from-slate-200/60 to-slate-300/40 rounded-xl w-48"></div>
                  <div className="h-4 bg-gradient-to-r from-slate-200/40 to-slate-300/30 rounded-lg w-64"></div>
                </div>
              </div>
            </div>

            {/* Enhanced quick actions skeleton */}
            <div className="space-y-8 sm:space-y-10">
              <div className="space-y-4 text-center sm:text-left">
                <div className="h-8 sm:h-10 bg-gradient-to-r from-slate-200/60 to-slate-300/40 rounded-2xl w-56 mx-auto sm:mx-0"></div>
                <div className="h-6 bg-gradient-to-r from-slate-200/40 to-slate-300/30 rounded-xl w-80 mx-auto sm:mx-0"></div>
              </div>
              <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 sm:gap-8 lg:gap-10">
                {[...Array(2)].map((_, i) => (
                  <div key={i} className="h-40 sm:h-44 bg-gradient-to-br from-white/95 via-white/90 to-white/85 rounded-3xl shadow-2xl shadow-slate-200/50 backdrop-blur-xl border border-white/70"></div>
                ))}
              </div>
            </div>

            {/* Enhanced profile settings skeleton */}
            <div className="h-24 sm:h-28 bg-gradient-to-br from-white/95 via-white/90 to-white/85 rounded-3xl shadow-2xl shadow-slate-200/50 backdrop-blur-xl border border-white/70"></div>
          </div>
        </div>
      </div>
    )
  }

  if (error) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-blue-50 via-white to-indigo-50">
        <AppHeader />
        <div className="relative mx-auto max-w-6xl px-6 pt-6">
          <div className="bg-white/70 backdrop-blur-sm rounded-3xl p-8 border border-red-100/50 shadow-lg text-center">
            <div className="w-16 h-16 bg-red-100 rounded-full flex items-center justify-center mx-auto mb-4">
              <Activity className="h-8 w-8 text-red-600" />
            </div>
            <h2 className="text-xl font-semibold text-gray-900 mb-2">Unable to Load Dashboard</h2>
            <p className="text-gray-600 mb-6">{error}</p>
            <Button onClick={() => window.location.reload()}>
              Try Again
            </Button>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50/80 via-white to-blue-50/20 relative">
      {/* Enhanced background decoration with more subtle gradients */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute -top-40 -right-40 w-96 h-96 bg-gradient-to-br from-blue-100/30 via-indigo-100/20 to-purple-100/10 rounded-full blur-3xl animate-pulse-subtle" />
        <div className="absolute -bottom-40 -left-40 w-80 h-80 bg-gradient-to-tr from-slate-100/25 via-gray-100/15 to-blue-100/10 rounded-full blur-3xl" />
        <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[600px] h-[600px] bg-gradient-radial from-blue-50/20 via-transparent to-transparent rounded-full blur-2xl" />
      </div>

      <AppHeader />

      {/* Hero Section with enhanced visual hierarchy */}
      <section className="relative mx-auto max-w-6xl px-4 sm:px-6 pt-6 sm:pt-8">
        <div className="group relative rounded-3xl border border-white/70 bg-gradient-to-br from-white/98 via-white/95 to-white/90 backdrop-blur-xl p-6 sm:p-8 md:p-12 overflow-hidden shadow-2xl shadow-slate-200/50 hover:shadow-3xl hover:shadow-slate-300/30 transition-all duration-700 hover:scale-[1.005]">
          {/* Enhanced background elements with better positioning */}
          <div className="absolute -right-24 -top-24 h-72 w-72 rounded-full bg-gradient-to-tr from-blue-400/15 via-indigo-400/10 to-purple-400/5 opacity-60 blur-3xl group-hover:opacity-80 group-hover:scale-110 transition-all duration-700" />
          <div className="absolute -left-20 -bottom-20 h-56 w-56 rounded-full bg-gradient-to-tr from-slate-400/10 via-gray-400/5 to-blue-400/5 opacity-40 blur-2xl group-hover:opacity-60 transition-all duration-700" />

          {/* Subtle inner glow */}
          <div className="absolute inset-0 rounded-3xl bg-gradient-to-br from-white/40 via-transparent to-white/20 pointer-events-none" />

          <div className="relative flex flex-col md:flex-row md:items-center md:justify-between">
            <div className="flex-1 space-y-6">
              <h1 className="text-3xl sm:text-4xl md:text-5xl lg:text-6xl font-bold tracking-tight bg-gradient-to-r from-slate-900 via-slate-800 to-slate-700 bg-clip-text text-transparent leading-[1.1] sm:leading-tight">
                Welcome back, {firstName}.
              </h1>
              <p className="text-slate-600/90 max-w-2xl text-base sm:text-lg lg:text-xl leading-relaxed font-medium">
                {dashboardStats?.totalWorkouts === 0
                  ? "Ready to start your fitness journey? Generate your first AI-powered workout below."
                  : "Keep up the momentum! Your personalized workouts are getting smarter with every session."
                }
              </p>
            </div>
          </div>
        </div>
      </section>

      {/* Motivational Banner with improved spacing */}
      {dashboardStats && dashboardStats.totalWorkouts > 0 && (
        <section className="relative mx-auto max-w-6xl px-4 sm:px-6 mt-8 sm:mt-10">
          <MotivationalBanner
            totalWorkouts={dashboardStats.totalWorkouts}
            weeklyWorkouts={dashboardStats.weeklyWorkouts}
            streak={dashboardStats.recentStreak}
            consistencyScore={dashboardStats.consistencyScore}
          />
        </section>
      )}

      {/* Quick Actions with enhanced typography and spacing */}
      <section className="relative mx-auto max-w-6xl px-4 sm:px-6 mt-12 sm:mt-16">
        <div className="mb-10 sm:mb-12 text-center sm:text-left">
          <h2 className="text-2xl sm:text-3xl lg:text-4xl font-bold bg-gradient-to-r from-slate-900 via-slate-800 to-slate-700 bg-clip-text text-transparent mb-4 tracking-tight leading-tight">
            Quick Actions
          </h2>
          <p className="text-slate-600/80 text-lg sm:text-xl font-medium leading-relaxed max-w-2xl">
            Everything you need to stay on track
          </p>
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 sm:gap-8 lg:gap-10">
          <div
            className="group relative cursor-pointer"
            onClick={() => nav('/generate')}
          >
            {/* Enhanced glow effect */}
            <div className="absolute inset-0 bg-gradient-to-r from-blue-500/15 via-indigo-500/10 to-purple-500/5 rounded-3xl blur-xl group-hover:blur-2xl transition-all duration-500 opacity-0 group-hover:opacity-100 scale-95 group-hover:scale-100" />
            <Card
              variant="elevated"
              rounded="3xl"
              className="relative p-6 sm:p-8 lg:p-10 border border-white/70 bg-gradient-to-br from-white/98 via-white/95 to-white/90 backdrop-blur-xl shadow-xl shadow-slate-200/40 hover:shadow-2xl hover:shadow-blue-200/30 transition-all duration-700 group-hover:scale-[1.02] group-hover:border-blue-200/60 group-hover:-translate-y-1"
            >
              <div className="flex flex-col sm:flex-row sm:items-start sm:justify-between gap-6">
                <div className="flex items-start space-x-5 flex-1">
                  <div className="flex-shrink-0 w-16 h-16 rounded-2xl bg-gradient-to-br from-blue-500 via-blue-600 to-indigo-600 flex items-center justify-center text-white shadow-xl shadow-blue-500/30 group-hover:shadow-blue-500/50 group-hover:scale-110 transition-all duration-500">
                    <Zap className="h-8 w-8" />
                  </div>
                  <div className="flex-1 space-y-3">
                    <h3 className="text-xl sm:text-2xl font-bold text-slate-900 group-hover:text-blue-900 transition-colors duration-300 leading-tight">
                      Generate Workout
                    </h3>
                    <p className="text-slate-600/90 leading-relaxed text-base sm:text-lg font-medium">
                      AI-tailored plans from goals, experience, equipment & injuries.
                    </p>
                  </div>
                </div>
                <Button
                  size="sm"
                  className="ml-0 sm:ml-4 shadow-lg hover:shadow-xl transition-all duration-300 group-hover:scale-105 self-start sm:self-center"
                  onClick={() => nav('/generate')}
                >
                  Start Now
                </Button>
              </div>
            </Card>
          </div>

          <div
            className="group relative cursor-pointer"
            onClick={() => nav('/history')}
          >
            {/* Enhanced glow effect for history card */}
            <div className="absolute inset-0 bg-gradient-to-r from-slate-500/15 via-gray-500/10 to-slate-400/5 rounded-3xl blur-xl group-hover:blur-2xl transition-all duration-500 opacity-0 group-hover:opacity-100 scale-95 group-hover:scale-100" />
            <Card
              variant="elevated"
              rounded="3xl"
              className="relative p-6 sm:p-8 lg:p-10 border border-white/70 bg-gradient-to-br from-white/98 via-white/95 to-white/90 backdrop-blur-xl shadow-xl shadow-slate-200/40 hover:shadow-2xl hover:shadow-slate-200/50 transition-all duration-700 group-hover:scale-[1.02] group-hover:border-slate-200/60 group-hover:-translate-y-1"
            >
              <div className="flex flex-col sm:flex-row sm:items-start sm:justify-between gap-6">
                <div className="flex items-start space-x-5 flex-1">
                  <div className="flex-shrink-0 w-16 h-16 rounded-2xl bg-gradient-to-br from-slate-500 via-slate-600 to-gray-600 flex items-center justify-center text-white shadow-xl shadow-slate-500/30 group-hover:shadow-slate-500/50 group-hover:scale-110 transition-all duration-500">
                    <History className="h-8 w-8" />
                  </div>
                  <div className="flex-1 space-y-3">
                    <h3 className="text-xl sm:text-2xl font-bold text-slate-900 group-hover:text-slate-700 transition-colors duration-300 leading-tight">
                      Workout History
                    </h3>
                    <p className="text-slate-600/90 leading-relaxed text-base sm:text-lg font-medium">
                      Auto-saved sessions to review, repeat, and track progress.
                    </p>
                  </div>
                </div>
                <Button
                  size="sm"
                  variant="secondary"
                  className="ml-0 sm:ml-4 shadow-lg hover:shadow-xl transition-all duration-300 group-hover:scale-105 self-start sm:self-center"
                  onClick={() => nav('/history')}
                >
                  View History
                </Button>
              </div>
            </Card>
          </div>
        </div>
      </section>

      {/* Profile Settings - Enhanced compact design */}
      <section className="relative mx-auto max-w-6xl px-4 sm:px-6 mt-12 sm:mt-16">
        <div className="group relative cursor-pointer" onClick={() => nav('/profile')}>
          <div className="absolute inset-0 bg-gradient-to-r from-slate-400/10 via-gray-400/5 to-slate-300/5 rounded-3xl blur-xl group-hover:blur-2xl transition-all duration-500 opacity-0 group-hover:opacity-100 scale-95 group-hover:scale-100" />
          <div className="relative bg-gradient-to-br from-white/95 via-white/90 to-white/85 backdrop-blur-xl rounded-3xl p-6 sm:p-8 border border-white/70 shadow-xl shadow-slate-200/30 hover:shadow-2xl hover:shadow-slate-200/40 transition-all duration-700 group-hover:scale-[1.01] group-hover:-translate-y-0.5">
            <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4 sm:gap-6">
              <div className="flex items-center gap-5">
                <div className="w-14 h-14 rounded-2xl bg-gradient-to-br from-slate-500 via-slate-600 to-gray-600 flex items-center justify-center shadow-xl shadow-slate-500/25 group-hover:shadow-slate-500/40 group-hover:scale-110 transition-all duration-500">
                  <UserIcon className="h-7 w-7 text-white" />
                </div>
                <div className="space-y-1">
                  <h3 className="text-lg sm:text-xl font-bold text-slate-900 group-hover:text-slate-700 transition-colors duration-300">Profile Settings</h3>
                  <p className="text-slate-600/90 text-sm sm:text-base font-medium">Update goals, equipment, or injuries</p>
                </div>
              </div>
              <Button
                size="sm"
                variant="outline"
                className="shadow-lg hover:shadow-xl transition-all duration-300 group-hover:scale-105 self-start sm:self-center"
                onClick={() => nav('/profile')}
              >
                Edit Profile
              </Button>
            </div>
          </div>
        </div>
      </section>

      {/* Subscription Status with improved spacing */}
      <section className="relative mx-auto max-w-6xl px-4 sm:px-6 mt-8 sm:mt-10 mb-16 sm:mb-20">
        <SubscriptionManager mode="status" />
      </section>

      {error && (
        <div className="fixed bottom-6 right-6 bg-gradient-to-r from-red-50 to-red-100/90 border border-red-200/60 text-red-800 px-6 py-4 rounded-2xl shadow-2xl shadow-red-200/40 backdrop-blur-xl max-w-sm animate-in slide-in-from-right-5 fade-in duration-500">
          <div className="flex items-start gap-3">
            <div className="w-5 h-5 rounded-full bg-red-500 flex-shrink-0 mt-0.5">
              <div className="w-full h-full rounded-full bg-red-400 animate-ping opacity-75"></div>
            </div>
            <p className="text-sm font-medium leading-relaxed">{error}</p>
          </div>
        </div>
      )}
    </div>
  )
}

========================================
FILE: src/pages/Generate.tsx
========================================

// src/pages/Generate.tsx
import { useEffect, useState } from 'react'
import { useNavigate } from 'react-router-dom'
import AppHeader from '../components/AppHeader'
import { auth } from '../lib/firebase'
import { EQUIPMENT } from '../config/onboarding'
import { isAdaptivePersonalizationEnabled, isIntensityCalibrationEnabled } from '../config/features'
import { trackCustomEvent } from '../lib/firebase-analytics'
import { Brain } from 'lucide-react'
import { ProgressiveLoadingBar } from '../components/Loading'
import { useSubscription } from '../hooks/useSubscription'
import { subscriptionService } from '../lib/subscriptionService'
import { SubscriptionManager } from '../components/SubscriptionManager'
import { trackWorkoutGenerated, trackFreeTrialLimitReached } from '../lib/firebase-analytics'
import { useWorkoutPreload } from '../hooks/useWorkoutPreload'

// Top 18 most common workout types organized by popularity
const TYPES = [
  'Full Body',        // Most popular - comprehensive workout
  'Upper Body',       // Very popular - convenient split
  'Lower Body',       // Very popular - leg day
  'Cardio',          // High demand - heart health
  'HIIT',            // Trending - time efficient
  'Core Focus',      // Popular - aesthetic goals
  'Strength',        // Classic - powerlifting focus
  'Circuit',         // Popular - variety and intensity
  'Push',            // Popular split - chest/shoulders/triceps
  'Pull',            // Popular split - back/biceps
  'Legs/Glutes',     // Specific lower body focus
  'Chest/Triceps',   // Classic push split
  'Back/Biceps',     // Classic pull split
  'Shoulders',       // Targeted muscle group
  'Arms',            // Popular aesthetic focus
  'Yoga',            // Mind-body connection - flexibility and mindfulness
  'Pilates',         // Mind-body connection - core strength and stability
  'Functional'       // Movement-based training
] as const

// Top 8 most common workout durations (optimized for user preferences)
const DUR = [15, 20, 30, 45, 60, 75, 90, 120] as const

// Profile type moved to types file for better organization
// type Profile = {
//   experience?: string
//   goals?: string[]
//   equipment?: string[]
//   personal?: { sex?: string; height?: string; weight?: string }
//   injuries?: { list?: string[]; notes?: string }
// }

export default function Generate() {
  const nav = useNavigate()
  const [type, setType] = useState<string>()
  const [duration, setDuration] = useState<number>()
  const [equipment, setEquipment] = useState<string[]>([])
  const [loading, setLoading] = useState(false)
  const [showProgressiveLoading, setShowProgressiveLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [showUpgradePrompt, setShowUpgradePrompt] = useState(false)

  // Use pre-loaded data hook
  const { preloadedData } = useWorkoutPreload()

  // Subscription hooks
  const { canGenerateWorkout, remainingFreeWorkouts, hasUnlimitedWorkouts, subscription } = useSubscription()

  // Handle preloaded data and navigation
  useEffect(() => {
    const uid = auth.currentUser?.uid
    if (!uid) {
      nav('/')
      return
    }

    // Handle preloaded data results
    if (!preloadedData.isLoading) {
      if (preloadedData.error) {
        if (preloadedData.error.includes('not found') || preloadedData.error.includes('incomplete')) {
          nav('/onboarding')
          return
        } else {
          console.error('Error with preloaded data:', preloadedData.error)
          nav('/')
          return
        }
      }

      if (preloadedData.profile) {
        // Initialize equipment from profile
        setEquipment((preloadedData.profile.equipment as string[]) || [])
      }
    }
  }, [nav, preloadedData])

  const disabled = !type || !duration || loading || showProgressiveLoading || preloadedData.isLoading || !preloadedData.profile

  async function generate() {
    if (disabled || !preloadedData.profile) return

    // Check subscription limits
    if (!canGenerateWorkout) {
      trackFreeTrialLimitReached()
      setShowUpgradePrompt(true)
      return
    }

    setError(null)
    setLoading(true)
    setShowProgressiveLoading(true)

    const uid = auth.currentUser?.uid

    const payload = {
      experience: preloadedData.profile.experience,
      goals: preloadedData.profile.goals,
      equipment: equipment,
      personalInfo: preloadedData.profile.personal,
      injuries: preloadedData.profile.injuries,
      workoutType: type,
      duration,
      uid,
      targetIntensity: preloadedData.targetIntensity,
      progressionNote: preloadedData.progressionNote
    }

    const url = import.meta.env.VITE_WORKOUT_FN_URL as string
    const controller = new AbortController()

    const fetchOnce = async () => {
      const t = setTimeout(() => controller.abort(), 60_000) // 60s timeout
      try {
        const res = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
          signal: controller.signal,
        })
        if (!res.ok) throw new Error(`HTTP ${res.status}`)
        const plan = await res.json()
        if (!plan?.exercises || !Array.isArray(plan.exercises)) {
          throw new Error('Invalid AI response')
        }

        // Log telemetry for workout generation with intensity
        if (uid && isAdaptivePersonalizationEnabled()) {
          trackCustomEvent('workout_generated_with_intensity', {
            target_intensity: preloadedData.targetIntensity,
            workout_type: type,
            duration,
            has_progression_note: Boolean(preloadedData.progressionNote)
          })
        }

        // Track workout generation in Firebase Analytics
        trackWorkoutGenerated(String(hasUnlimitedWorkouts), subscription?.workoutCount || 0)

        sessionStorage.setItem('nf_workout_plan', JSON.stringify({ plan, type, duration }))

        // Navigate immediately when workout is ready
        if (process.env.NODE_ENV === 'development') {
          console.log('[GENERATE] Workout generated successfully, navigating to preview')
        }
        setLoading(false)
        setShowProgressiveLoading(false)
        nav('/workout/preview')
      } finally {
        clearTimeout(t)
      }
    }

    // small retry (2 attempts total) for transient failures
    try {
      await fetchOnce()
      // Success - loading states cleared in fetchOnce
    } catch {
      try {
        await new Promise(r => setTimeout(r, 1000)) // Brief delay before retry
        await fetchOnce()
        // Success on retry - loading states cleared in fetchOnce
      } catch (e2) {
        // Clear loading states on error
        setLoading(false)
        setShowProgressiveLoading(false)

        const error = e2 as { message?: string; status?: number; name?: string }
        // Check if it's a subscription error (402 Payment Required)
        if (error?.message?.includes('Subscription required') || error?.status === 402) {
          // Before showing upgrade prompt, try refreshing subscription status
          // This handles cases where payment was completed but subscription status hasn't synced yet
          try {
            if (process.env.NODE_ENV === 'development') {
              console.log('🔄 Payment required error - checking for recent subscription updates...')
            }
            const freshSubscription = await subscriptionService.getSubscription()

            if (freshSubscription && (freshSubscription.status === 'active' || freshSubscription.status === 'trialing')) {
              if (process.env.NODE_ENV === 'development') {
                console.log('✅ Found active subscription after refresh, retrying workout generation...')
              }
              // Retry the workout generation with fresh subscription data
              setTimeout(() => {
                generate()
              }, 1000)
              return
            }
          } catch (refreshError) {
            console.error('Error refreshing subscription data:', refreshError)
          }

          setShowUpgradePrompt(true)
          return
        }

        setError(
          error?.name === 'AbortError'
            ? 'The server took too long to respond. Please try again.'
            : ((e2 as Error)?.message || 'Failed to generate. Please try again.')
        )
      }
    }
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50/80 via-white to-blue-50/20 relative safe-area-inset-bottom">
      {/* Enhanced background decoration */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute -top-40 -right-40 w-96 h-96 bg-gradient-to-br from-blue-100/30 via-indigo-100/20 to-purple-100/10 rounded-full blur-3xl animate-pulse-subtle" />
        <div className="absolute -bottom-40 -left-40 w-80 h-80 bg-gradient-to-tr from-slate-100/25 via-gray-100/15 to-blue-100/10 rounded-full blur-3xl" />
        <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[600px] h-[600px] bg-gradient-radial from-blue-50/20 via-transparent to-transparent rounded-full blur-2xl" />
      </div>

      <AppHeader />

      <main className="relative mx-auto max-w-6xl px-4 sm:px-6 pb-16 pt-6 sm:pt-8">
        {/* Enhanced Hero Section */}
        <section className="group relative rounded-3xl border border-white/70 bg-gradient-to-br from-white/98 via-white/95 to-white/90 backdrop-blur-xl p-6 sm:p-8 md:p-12 overflow-hidden shadow-2xl shadow-slate-200/50 hover:shadow-3xl hover:shadow-slate-300/30 transition-all duration-700 hover:scale-[1.005] hover:-translate-y-1">
          {/* Enhanced background elements */}
          <div className="absolute -right-24 -top-24 h-72 w-72 rounded-full bg-gradient-to-tr from-blue-400/15 via-indigo-400/10 to-purple-400/5 opacity-60 blur-3xl group-hover:opacity-80 group-hover:scale-110 transition-all duration-700" />
          <div className="absolute -left-20 -bottom-20 h-56 w-56 rounded-full bg-gradient-to-tr from-slate-400/10 via-gray-400/5 to-blue-400/5 opacity-40 blur-2xl group-hover:opacity-60 transition-all duration-700" />

          {/* Subtle inner glow */}
          <div className="absolute inset-0 rounded-3xl bg-gradient-to-br from-white/40 via-transparent to-white/20 pointer-events-none" />

          <div className="relative space-y-6 sm:space-y-8">
            <div className="space-y-4 sm:space-y-6">
              <h1 className="text-3xl sm:text-4xl md:text-5xl lg:text-6xl font-bold tracking-tight bg-gradient-to-r from-slate-900 via-slate-800 to-slate-700 bg-clip-text text-transparent leading-[1.1] sm:leading-tight">
                AI Workout Generator
              </h1>
              <h2 className="text-xl sm:text-2xl md:text-3xl font-semibold text-slate-700/90 leading-tight tracking-tight">
                Create Custom Fitness Plans
              </h2>
            </div>

            <p className="text-slate-600/90 text-base sm:text-lg lg:text-xl leading-relaxed font-medium max-w-4xl">
              Generate <strong className="text-slate-800 font-semibold">personalized workout plans</strong> instantly with advanced AI technology.
              Tailored to your fitness goals, experience level, available equipment, and any injuries—powered by OpenAI's GPT-4.1-nano for ultra-fast generation.
            </p>

            <div className="inline-flex items-center gap-3 px-6 py-3 bg-gradient-to-r from-blue-500/10 via-indigo-500/5 to-purple-500/5 rounded-2xl border border-blue-200/30 backdrop-blur-sm">
              <div className="w-3 h-3 bg-gradient-to-r from-blue-500 to-indigo-600 rounded-full animate-pulse"></div>
              <span className="text-blue-700 font-semibold text-sm sm:text-base">Get your custom training plan in 30 seconds!</span>
            </div>

            {/* Enhanced benefit highlights */}
            <div className="flex flex-wrap gap-4 sm:gap-6">
              <div className="flex items-center gap-3 text-sm sm:text-base text-slate-700/90 font-medium">
                <div className="w-3 h-3 bg-gradient-to-r from-blue-500 to-blue-600 rounded-full shadow-lg shadow-blue-500/30"></div>
                <span>Personalized for your goals</span>
              </div>
              <div className="flex items-center gap-3 text-sm sm:text-base text-slate-700/90 font-medium">
                <div className="w-3 h-3 bg-gradient-to-r from-emerald-500 to-emerald-600 rounded-full shadow-lg shadow-emerald-500/30"></div>
                <span>Equipment-based customization</span>
              </div>
              <div className="flex items-center gap-3 text-sm sm:text-base text-slate-700/90 font-medium">
                <div className="w-3 h-3 bg-gradient-to-r from-purple-500 to-purple-600 rounded-full shadow-lg shadow-purple-500/30"></div>
                <span>Injury-safe modifications</span>
              </div>
            </div>
          </div>
        </section>

        {/* Enhanced Subscription Status */}
        <SubscriptionManager mode="status" className="mt-8 sm:mt-10" />

        {/* Enhanced Legacy Subscription Status - keeping for users with more than 1 workout remaining */}
        {!hasUnlimitedWorkouts && remainingFreeWorkouts > 1 && (
          <section className="mt-8 sm:mt-10">
            <div className="group relative rounded-3xl border border-blue-200/60 bg-gradient-to-br from-blue-50/80 via-blue-50/60 to-white/90 backdrop-blur-xl p-6 sm:p-8 shadow-xl shadow-blue-200/30 hover:shadow-2xl hover:shadow-blue-200/40 transition-all duration-500 hover:scale-[1.01] hover:-translate-y-0.5">
              <div className="absolute -right-16 -top-16 h-32 w-32 rounded-full bg-gradient-to-tr from-blue-400/20 to-indigo-400/10 opacity-50 blur-2xl group-hover:opacity-70 group-hover:scale-110 transition-all duration-500" />

              <div className="relative flex flex-col sm:flex-row sm:items-center sm:justify-between gap-6">
                <div className="flex items-center gap-5">
                  <div className="w-14 h-14 bg-gradient-to-br from-blue-500 via-blue-600 to-indigo-600 rounded-2xl flex items-center justify-center shadow-xl shadow-blue-500/30 group-hover:shadow-blue-500/50 group-hover:scale-110 transition-all duration-500">
                    <span className="text-white font-bold text-lg">{remainingFreeWorkouts}</span>
                  </div>
                  <div className="space-y-2">
                    <div className="font-bold text-lg sm:text-xl text-gray-900 leading-tight">
                      {remainingFreeWorkouts} free workout{remainingFreeWorkouts === 1 ? '' : 's'} remaining
                    </div>
                    <div className="text-sm sm:text-base text-gray-600/90 font-medium">
                      Upgrade to Pro for unlimited AI-powered workouts
                    </div>
                    {/* Progress bar */}
                    <div className="w-full bg-gray-200 rounded-full h-2 mt-2">
                      <div
                        className="bg-gradient-to-r from-blue-500 to-indigo-600 h-2 rounded-full transition-all duration-300"
                        style={{ width: `${((10 - remainingFreeWorkouts) / 10) * 100}%` }}
                      />
                    </div>
                    <div className="text-xs text-gray-500 mt-1">
                      {10 - remainingFreeWorkouts} of 10 free workouts used
                    </div>
                  </div>
                </div>
                <button
                  onClick={() => setShowUpgradePrompt(true)}
                  className="px-6 py-3 bg-gradient-to-r from-blue-500 via-blue-600 to-indigo-600 text-white rounded-xl font-semibold hover:from-blue-600 hover:via-blue-700 hover:to-indigo-700 transition-all duration-300 shadow-lg hover:shadow-xl hover:scale-105 active:scale-95 text-sm sm:text-base self-start sm:self-center"
                >
                  $10/month
                </button>
              </div>
            </div>
          </section>
        )}

        {/* Subscription Upgrade Modal */}
        {showUpgradePrompt && (
          <SubscriptionManager
            mode="plans"
            onClose={() => setShowUpgradePrompt(false)}
            onSuccess={() => {
              // Subscription successful, user can now generate workouts
              setShowUpgradePrompt(false)
            }}
          />
        )}

        {/* Enhanced Intensity Calibration Indicator */}
        {preloadedData.targetIntensity !== 1.0 && isIntensityCalibrationEnabled() && (
          <section className="mt-8 sm:mt-10">
            <div className="group relative rounded-3xl border border-indigo-200/60 bg-gradient-to-br from-indigo-50/80 via-purple-50/60 to-white/90 backdrop-blur-xl p-6 sm:p-8 shadow-xl shadow-indigo-200/30 hover:shadow-2xl hover:shadow-indigo-200/40 transition-all duration-500 hover:scale-[1.01] hover:-translate-y-0.5">
              <div className="absolute -right-16 -top-16 h-32 w-32 rounded-full bg-gradient-to-tr from-indigo-400/20 to-purple-400/10 opacity-50 blur-2xl group-hover:opacity-70 group-hover:scale-110 transition-all duration-500" />

              <div className="relative flex items-center gap-5">
                <div className="w-14 h-14 bg-gradient-to-br from-indigo-500 via-indigo-600 to-purple-600 rounded-2xl flex items-center justify-center shadow-xl shadow-indigo-500/30 group-hover:shadow-indigo-500/50 group-hover:scale-110 transition-all duration-500">
                  <Brain className="h-7 w-7 text-white" />
                </div>
                <div className="flex-1 space-y-2">
                  <div className="font-bold text-lg sm:text-xl text-gray-900 leading-tight">
                    Intensity: {preloadedData.targetIntensity > 1.0 ? '+' : ''}{Math.round((preloadedData.targetIntensity - 1.0) * 100)}%
                  </div>
                  {preloadedData.progressionNote && (
                    <div className="text-sm sm:text-base text-gray-600/90 font-medium capitalize leading-relaxed">
                      {preloadedData.progressionNote}
                    </div>
                  )}
                  <div className="text-xs sm:text-sm text-indigo-600/80 font-medium">
                    AI-adjusted based on your recent workout feedback
                  </div>
                </div>
              </div>
            </div>
          </section>
        )}

        {/* Options */}
        <section className="mt-8 space-y-6">
          {/* Type */}
          <div className="rounded-2xl border border-gray-200 bg-white/70 backdrop-blur-sm p-5 shadow-sm">
            <div className="mb-3 flex items-center justify-between">
              <h3 className="font-semibold text-gray-900">Workout Type</h3>
              {type && <span className="text-xs text-gray-500">Selected: {type}</span>}
            </div>
            <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3">
              {TYPES.map((t) => (
                <button
                  key={t}
                  onClick={() => setType(t)}
                  className={[
                    'rounded-xl border px-3 py-2.5 text-left transition-all duration-200 text-sm font-medium',
                    type === t
                      ? 'bg-gradient-to-br from-blue-500 to-indigo-600 text-white border-blue-500 shadow-md scale-[1.02]'
                      : 'bg-white/70 border-gray-200 hover:border-blue-300 hover:bg-white text-gray-700 hover:scale-[1.01]'
                  ].join(' ')}
                >
                  {t}
                </button>
              ))}
            </div>
          </div>

          {/* Duration and Equipment */}
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            {/* Duration */}
            <div className="rounded-2xl border border-gray-200 bg-white/70 backdrop-blur-sm p-5 shadow-sm">
            <div className="mb-3 flex items-center justify-between">
              <h3 className="font-semibold text-gray-900">Duration</h3>
              {duration && <span className="text-xs text-gray-500">{duration} min</span>}
            </div>
            <div className="grid grid-cols-4 gap-2">
              {DUR.map((m) => (
                <button
                  key={m}
                  onClick={() => setDuration(m)}
                  className={[
                    'rounded-lg border px-3 py-2 text-sm font-medium transition-all duration-200',
                    duration === m
                      ? 'bg-gradient-to-br from-emerald-500 to-teal-600 text-white border-emerald-500 shadow-md scale-[1.02]'
                      : 'bg-white/70 border-gray-200 hover:border-emerald-300 hover:bg-white text-gray-700 hover:scale-[1.01]'
                  ].join(' ')}
                >
                  {m} min
                </button>
              ))}
            </div>

            </div>

            {/* Equipment */}
            <div className="rounded-2xl border border-gray-200 bg-white/70 backdrop-blur-sm p-5 shadow-sm">
              <div className="mb-3 flex items-center justify-between">
                <h3 className="font-semibold text-gray-900">Available Equipment</h3>
                {equipment.length > 0 && <span className="text-xs text-gray-500">{equipment.length} selected</span>}
              </div>
              <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
                {EQUIPMENT.map((eq) => (
                  <button
                    key={eq}
                    onClick={() => {
                      setEquipment(prev =>
                        prev.includes(eq)
                          ? prev.filter(e => e !== eq)
                          : [...prev, eq]
                      )
                    }}
                    className={[
                      'rounded-lg border px-3 py-2 text-sm font-medium transition-all duration-200 text-left',
                      equipment.includes(eq)
                        ? 'bg-gradient-to-br from-orange-500 to-amber-600 text-white border-orange-500 shadow-md scale-[1.02]'
                        : 'bg-white/70 border-gray-200 hover:border-orange-300 hover:bg-white text-gray-700 hover:scale-[1.01]'
                    ].join(' ')}
                  >
                    {eq}
                  </button>
                ))}
              </div>

            </div>
          </div>
        </section>

        {/* Error */}
        {error && (
          <div className="mt-6">
            <SubscriptionManager
              mode="error"
              error={error}
              onRetry={() => {
                setError(null)
                generate()
              }}
              onClose={() => setShowUpgradePrompt(true)}
              showUpgradeOption={!hasUnlimitedWorkouts}
            />
          </div>
        )}

        {/* Generate CTA */}
        <div className="mt-8 flex justify-center sm:justify-end">
          <button
            onClick={generate}
            disabled={disabled}
            className={[
              'rounded-xl px-8 py-4 font-semibold transition-all duration-300 shadow-sm touch-manipulation min-h-[56px] w-full sm:w-auto',
              disabled
                ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                : 'bg-gradient-to-r from-blue-500 to-indigo-600 text-white hover:from-blue-600 hover:to-indigo-700 hover:shadow-lg hover:scale-105 active:scale-95'
            ].join(' ')}
          >
            {loading || showProgressiveLoading ? (
              <div className="flex items-center gap-3">
                <div className="relative">
                  <div className="w-5 h-5 border-2 border-white/30 border-t-white rounded-full animate-spin"></div>
                  <div className="absolute inset-0 w-5 h-5 border border-white/20 rounded-full animate-pulse"></div>
                </div>
                <span className="font-semibold">Generating AI Workout…</span>
              </div>
            ) : preloadedData.isLoading ? (
              <div className="flex items-center gap-3">
                <div className="relative">
                  <div className="w-5 h-5 border-2 border-white/30 border-t-white rounded-full animate-spin"></div>
                </div>
                <span className="font-semibold">Loading Profile…</span>
              </div>
            ) : (
              <div className="flex items-center gap-2">
                <Brain className="w-5 h-5" />
                <span className="font-semibold">Generate Workout</span>
              </div>
            )}
          </button>
        </div>
      </main>

      {/* Progressive Loading Bar */}
      <ProgressiveLoadingBar
        isVisible={showProgressiveLoading}
        onComplete={() => {
          // Loading bar animation completed
          if (process.env.NODE_ENV === 'development') {
            console.log('Loading animation complete')
          }
        }}
        text="Generating your personalized workout..."
      />
    </div>
  )
}

========================================
FILE: src/pages/History.tsx
========================================

import { useEffect, useState, useMemo } from 'react'
import { useNavigate } from 'react-router-dom'
import { auth, db } from '../lib/firebase'
import { collection, getDocs, orderBy, query } from 'firebase/firestore'
import { convertToDate } from '../utils/timestamp'
import { ArrowLeft, Calendar, Clock, CheckCircle, XCircle, Zap, Activity, BarChart3, Trophy, TrendingUp, Target, Award } from 'lucide-react'
import AppHeader from '../components/AppHeader'
import { WorkoutHistorySkeleton } from '../components/Loading'
import { WorkoutAnalytics } from '../components/WorkoutAnalytics'
// Simple utility functions
const formatVolume = (volume: number): string => {
  if (volume >= 1000) {
    return `${(volume / 1000).toFixed(1)}k lbs`
  }
  return `${volume} lbs`
}

import { LineChart, DonutChart } from '../components/Charts'
import { StatsCard } from '../design-system/components/SpecializedCards'
import { Card } from '../design-system/components/Card'

type WorkoutItem = {
  id: string
  workoutType: string
  duration: number
  plannedDuration?: number
  exercises?: { name: string; sets: number; reps: string | number; weights?: Record<number, number | null>; usesWeight?: boolean }[]
  timestamp?: Date | { toDate(): Date } | string
}

export default function History() {
  const nav = useNavigate()
  const [items, setItems] = useState<WorkoutItem[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [activeTab, setActiveTab] = useState<'history' | 'analytics' | 'achievements'>('history')

  // Simplified analytics calculations
  const performanceMetrics = useMemo(() => {
    if (items.length === 0) return null

    const totalWorkouts = items.length
    const totalVolume = items.reduce((sum, item) => {
      return sum + (item.exercises || []).reduce((exerciseSum, exercise) => {
        return exerciseSum + Object.values(exercise.weights || {}).reduce((setSum, weight) => {
          return setSum + (weight || 0)
        }, 0)
      }, 0)
    }, 0)

    const totalSets = items.reduce((sum, item) => {
      return sum + (item.exercises || []).reduce((exerciseSum, exercise) => {
        return exerciseSum + Object.values(exercise.weights || {}).filter(weight => weight !== null).length
      }, 0)
    }, 0)

    return {
      totalWorkouts,
      totalVolume,
      totalSets,
      exerciseStats: [], // Simplified - removed complex exercise stats
      workoutFrequency: totalWorkouts > 0 ? (totalWorkouts / 4) : 0, // Simple approximation
      consistencyScore: totalWorkouts > 0 ? Math.min(100, totalWorkouts * 10) : 0,
      progressionRate: totalWorkouts > 1 ? 5.2 : 0, // Simple placeholder
      weeklyStats: [], // Simplified - empty array
      personalRecords: [] // Simplified - empty array
    }
  }, [items])

  useEffect(() => {
    (async () => {
      try {
        const uid = auth.currentUser?.uid
        if (!uid) {
          setError('Not authenticated')
          return
        }

        if (process.env.NODE_ENV === 'development') {
          console.log('📚 Loading workout history for user:', uid)
        }
        const q = query(collection(db, 'users', uid, 'workouts'), orderBy('timestamp', 'desc'))
        const snap = await getDocs(q)

        const workouts = snap.docs.map(d => {
          const data = d.data()
          if (process.env.NODE_ENV === 'development') {
            console.log('📋 Raw workout data:', { id: d.id, ...data })
          }
          return { id: d.id, ...data } as WorkoutItem
        })

        if (process.env.NODE_ENV === 'development') {
          console.log(`Loaded ${workouts.length} workouts`)
        }
        setItems(workouts)
      } catch (err) {
        const error = err as { message?: string }
        console.error('❌ Error fetching workout history:', error)
        setError(error.message || 'Failed to load workout history')
      } finally {
        setLoading(false)
      }
    })()
  }, [])

  const formatDate = (timestamp: Date | { toDate(): Date } | string) => {
    if (!timestamp) return 'Unknown date'
    const date = convertToDate(timestamp)
    return date.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric'
    })
  }

  const calculateWorkoutStats = (workout: WorkoutItem) => {
    if (!workout.exercises || workout.exercises.length === 0) {
      return { totalExercises: 0, completedExercises: 0, totalSets: 0, completedSets: 0, fullyCompletedExercises: 0 }
    }

    const totalExercises = workout.exercises.length
    let completedExercises = 0 // Exercises with ANY completed sets
    let fullyCompletedExercises = 0 // Exercises with ALL sets completed
    let totalSets = 0
    let completedSets = 0

    workout.exercises.forEach(exercise => {
      totalSets += exercise.sets

      // Calculate completed sets for this exercise using the exact same logic as WorkoutDetail
      let exerciseCompletedSets = 0

      if (exercise.weights && typeof exercise.weights === 'object') {
        // Count all entries with non-null values (including 0 which indicates completed sets)
        // null values indicate skipped sets
        exerciseCompletedSets = Object.values(exercise.weights).filter(w => w !== null).length
      } else {
        // No weights data means no sets were tracked (shouldn't happen with new system)
        exerciseCompletedSets = 0
      }

      completedSets += exerciseCompletedSets

      // Exercise is considered "completed" if it has ANY completed sets
      if (exerciseCompletedSets > 0) {
        completedExercises++
      }

      // Track fully completed exercises separately
      if (exerciseCompletedSets === exercise.sets) {
        fullyCompletedExercises++
      }
    })

    return { totalExercises, completedExercises, totalSets, completedSets, fullyCompletedExercises }
  }

  if (loading) {
    return <WorkoutHistorySkeleton />
  }

  if (error) {
    return (
      <div className="min-h-screen bg-white">
        <div className="max-w-md mx-auto px-6 py-8">
          <div className="text-center">
            <XCircle className="h-12 w-12 text-red-500 mx-auto mb-4" />
            <h1 className="text-xl font-semibold text-gray-900 mb-2">Unable to Load History</h1>
            <p className="text-gray-600 mb-6">{error}</p>
            <button
              onClick={() => nav('/dashboard')}
              className="inline-flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
            >
              <ArrowLeft className="h-4 w-4" />
              Back to Dashboard
            </button>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 via-white to-indigo-50 relative">
      {/* Background decoration */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute -top-40 -right-40 w-80 h-80 bg-gradient-to-br from-blue-200/30 to-indigo-200/30 rounded-full blur-3xl" />
        <div className="absolute -bottom-40 -left-40 w-80 h-80 bg-gradient-to-tr from-indigo-200/30 to-blue-200/30 rounded-full blur-3xl" />
      </div>

      <AppHeader />

      {/* Main Content */}
      <main className="relative max-w-4xl mx-auto px-6 py-8">
        {/* Page Header */}
        <div className="text-center mb-8">
          <div className="inline-flex items-center gap-2 px-4 py-2 bg-blue-50 rounded-full mb-4">
            <Activity className="h-4 w-4 text-blue-600" />
            <span className="text-sm font-medium text-blue-600">Fitness Dashboard</span>
          </div>
          <h1 className="text-3xl font-bold text-gray-900 mb-2">Your Fitness Journey</h1>
          <p className="text-gray-600 max-w-2xl mx-auto">
            Track your progress, analyze your performance, and celebrate your achievements.
          </p>
        </div>

        {/* Tab Navigation */}
        <div className="flex justify-center mb-8">
          <div className="inline-flex bg-white rounded-2xl p-1 border border-gray-200 shadow-sm" role="tablist" aria-label="Fitness dashboard tabs">
            <button
              onClick={() => setActiveTab('history')}
              className={`px-6 py-3 rounded-xl font-medium transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2 ${
                activeTab === 'history'
                  ? 'bg-blue-500 text-white shadow-md'
                  : 'text-gray-600 hover:text-gray-900'
              }`}
              role="tab"
              aria-selected={activeTab === 'history'}
              aria-controls="history-panel"
              id="history-tab"
            >
              <div className="flex items-center gap-2">
                <Activity className="h-4 w-4" aria-hidden="true" />
                History
              </div>
            </button>
            <button
              onClick={() => setActiveTab('analytics')}
              className={`px-6 py-3 rounded-xl font-medium transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2 ${
                activeTab === 'analytics'
                  ? 'bg-blue-500 text-white shadow-md'
                  : 'text-gray-600 hover:text-gray-900'
              }`}
              role="tab"
              aria-selected={activeTab === 'analytics'}
              aria-controls="analytics-panel"
              id="analytics-tab"
            >
              <div className="flex items-center gap-2">
                <BarChart3 className="h-4 w-4" aria-hidden="true" />
                Analytics
              </div>
            </button>
            <button
              onClick={() => setActiveTab('achievements')}
              className={`px-6 py-3 rounded-xl font-medium transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2 ${
                activeTab === 'achievements'
                  ? 'bg-blue-500 text-white shadow-md'
                  : 'text-gray-600 hover:text-gray-900'
              }`}
              role="tab"
              aria-selected={activeTab === 'achievements'}
              aria-controls="achievements-panel"
              id="achievements-tab"
            >
              <div className="flex items-center gap-2">
                <Trophy className="h-4 w-4" aria-hidden="true" />
                Achievements
              </div>
            </button>
          </div>
        </div>

        {/* Tab Content */}
        {activeTab === 'history' && (
          <div role="tabpanel" id="history-panel" aria-labelledby="history-tab">
          <>
            {/* Workout List */}
            {items.length === 0 ? (
          <div className="text-center py-12">
            <div className="bg-gray-50 rounded-full w-16 h-16 flex items-center justify-center mx-auto mb-4">
              <Activity className="h-8 w-8 text-gray-400" />
            </div>
            <h3 className="text-lg font-semibold text-gray-900 mb-2">No workouts yet</h3>
            <p className="text-gray-600 mb-6">Complete your first workout to start tracking your progress!</p>
            <button
              onClick={() => nav('/generate')}
              className="inline-flex items-center gap-2 px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
            >
              <Zap className="h-4 w-4" />
              Generate Your First Workout
            </button>
          </div>
        ) : (
          <div className="space-y-4">
            {items.map(workout => {
              const stats = calculateWorkoutStats(workout)

              // Calculate completion rate based on sets completed, not exercises
              const setCompletionRate = stats.totalSets > 0 ? Math.round((stats.completedSets / stats.totalSets) * 100) : 0
              const exerciseCompletionRate = stats.totalExercises > 0 ? Math.round((stats.completedExercises / stats.totalExercises) * 100) : 0

              // Use set completion rate as the primary metric
              const completionRate = setCompletionRate

              // Debug logging for workout stats
              if (process.env.NODE_ENV === 'development') {
                console.log(`Workout "${workout.workoutType}" stats:`, {
                  totalExercises: stats.totalExercises,
                  completedExercises: stats.completedExercises,
                  fullyCompletedExercises: stats.fullyCompletedExercises,
                  totalSets: stats.totalSets,
                  completedSets: stats.completedSets,
                  setCompletionRate: setCompletionRate,
                  exerciseCompletionRate: exerciseCompletionRate,
                  finalCompletionRate: completionRate
                })
              }

              return (
                <button
                  key={workout.id}
                  onClick={() => nav(`/workout/${workout.id}`)}
                  className="w-full text-left bg-white border border-gray-200 rounded-xl p-6 hover:border-blue-300 hover:shadow-md transition-all group"
                >
                  <div className="flex items-start justify-between mb-4">
                    <div className="flex-1">
                      <h3 className="text-lg font-semibold text-gray-900 group-hover:text-blue-600 transition-colors">
                        {workout.workoutType}
                      </h3>
                      <div className="flex items-center gap-4 text-sm text-gray-600 mt-1">
                        <div className="flex items-center gap-1">
                          <Calendar className="h-4 w-4" />
                          <span>{formatDate(workout.timestamp || new Date())}</span>
                        </div>
                        <div className="flex items-center gap-1">
                          <Clock className="h-4 w-4" />
                          <span>{workout.duration} min</span>
                        </div>
                      </div>
                    </div>
                    <div className="text-right">
                      <div className="flex items-center gap-2 mb-1">
                        {completionRate === 100 ? (
                          <CheckCircle className="h-5 w-5 text-green-500" />
                        ) : completionRate > 0 ? (
                          <div className="h-5 w-5 rounded-full bg-orange-100 flex items-center justify-center">
                            <div className="h-2 w-2 rounded-full bg-orange-500" />
                          </div>
                        ) : (
                          <XCircle className="h-5 w-5 text-red-500" />
                        )}
                        <span className="text-sm font-medium text-gray-700">{completionRate}%</span>
                      </div>
                      <div className="text-xs text-gray-500">
                        {stats.completedSets}/{stats.totalSets} sets completed
                      </div>
                      <div className="text-xs text-gray-400">
                        {stats.completedExercises}/{stats.totalExercises} exercises started
                      </div>
                    </div>
                  </div>

                  {/* Exercise Preview */}
                  {workout.exercises && workout.exercises.length > 0 && (
                    <div className="border-t border-gray-100 pt-4">
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                        {workout.exercises.slice(0, 4).map((exercise, index) => {
                          // Calculate average weight more safely
                          let avgWeight = null
                          let completedSets = 0

                          if (exercise.weights && typeof exercise.weights === 'object') {
                            const weights = Object.values(exercise.weights).filter(w => w !== null && w > 0) as number[]
                            completedSets = Object.values(exercise.weights).filter(w => w !== null).length

                            if (weights.length > 0) {
                              avgWeight = Math.round(weights.reduce((sum, w) => sum + w, 0) / weights.length)
                            }
                          }

                          return (
                            <div key={index} className="text-sm text-gray-700">
                              <span className="font-medium">{exercise.name}</span>
                              <span className="text-gray-500 ml-2">
                                {completedSets}/{exercise.sets} sets
                                {avgWeight && exercise.usesWeight && (
                                  <span className="text-blue-600 ml-1">@ {avgWeight}lbs</span>
                                )}
                              </span>
                            </div>
                          )
                        })}
                        {workout.exercises.length > 4 && (
                          <div className="text-sm text-gray-500 italic">
                            + {workout.exercises.length - 4} more exercises
                          </div>
                        )}
                      </div>
                    </div>
                  )}
                </button>
              )
            })}
          </div>
        )}
          </>
          </div>
        )}

        {/* Analytics Tab */}
        {activeTab === 'analytics' && (
          <div className="space-y-6" role="tabpanel" id="analytics-panel" aria-labelledby="analytics-tab">
            {performanceMetrics ? (
              <div>
                {/* Performance Overview */}
                <div className="grid grid-cols-1 md:grid-cols-4 gap-4 mb-8">
                  <StatsCard
                    label="Total Workouts"
                    value={performanceMetrics.totalWorkouts}
                    change={`${performanceMetrics.workoutFrequency.toFixed(1)}/week`}
                    trend="up"
                    icon={<Zap className="h-5 w-5" />}
                  />
                  <StatsCard
                    label="Total Volume"
                    value={formatVolume(performanceMetrics.totalVolume)}
                    change={`${performanceMetrics.totalSets} sets`}
                    trend="up"
                    icon={<TrendingUp className="h-5 w-5" />}
                  />
                  <StatsCard
                    label="Consistency"
                    value={`${performanceMetrics.consistencyScore}%`}
                    change={performanceMetrics.consistencyScore > 70 ? 'Excellent!' : 'Keep going!'}
                    trend={performanceMetrics.consistencyScore > 70 ? 'up' : 'neutral'}
                    icon={<Target className="h-5 w-5" />}
                  />
                  <StatsCard
                    label="Progress Rate"
                    value={`${performanceMetrics.progressionRate.toFixed(1)}%`}
                    change="Overall improvement"
                    trend={performanceMetrics.progressionRate > 0 ? 'up' : 'down'}
                    icon={<Award className="h-5 w-5" />}
                  />
                </div>

                {/* Charts Section */}
                <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                  {/* Weekly Volume Chart */}
                  <Card variant="elevated" rounded="xl" className="p-6">
                    <div className="flex items-center justify-between mb-4">
                      <div className="flex items-center space-x-3">
                        <div className="flex-shrink-0 w-10 h-10 rounded-lg bg-blue-100 flex items-center justify-center text-blue-600">
                          <BarChart3 className="h-5 w-5" />
                        </div>
                        <div>
                          <h3 className="font-semibold text-gray-900">Weekly Volume Trend</h3>
                          <p className="text-sm text-gray-600">Your training volume over the past 12 weeks</p>
                        </div>
                      </div>
                    </div>
                    <div className="mt-4">
                      <LineChart
                        data={performanceMetrics.weeklyStats.map(week => ({
                          label: new Date(week.weekStart).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
                          value: week.totalVolume,
                          date: week.weekStart
                        }))}
                        height={200}
                        color="#3B82F6"
                        animated
                      />
                    </div>
                  </Card>

                  {/* Exercise Distribution */}
                  <Card variant="elevated" rounded="xl" className="p-6">
                    <div className="flex items-center justify-between mb-4">
                      <div className="flex items-center space-x-3">
                        <div className="flex-shrink-0 w-10 h-10 rounded-lg bg-blue-100 flex items-center justify-center text-blue-600">
                          <Activity className="h-5 w-5" />
                        </div>
                        <div>
                          <h3 className="font-semibold text-gray-900">Exercise Distribution</h3>
                          <p className="text-sm text-gray-600">Your most trained exercises by volume</p>
                        </div>
                      </div>
                    </div>
                    <div className="mt-4">
                      <DonutChart
                        data={performanceMetrics.exerciseStats.slice(0, 5).map((exercise, index) => ({
                          label: exercise.name,
                          value: exercise.totalVolume,
                          color: `hsl(${(index * 72)}, 70%, 50%)`
                        }))}
                        size={200}
                        animated
                      />
                    </div>
                  </Card>
                </div>

                {/* Simplified Exercise Summary */}
                <Card variant="elevated" rounded="xl" className="p-6">
                  <div className="flex items-center justify-between mb-4">
                    <div className="flex items-center space-x-3">
                      <div className="flex-shrink-0 w-10 h-10 rounded-lg bg-blue-100 flex items-center justify-center text-blue-600">
                        <Trophy className="h-5 w-5" />
                      </div>
                      <div>
                        <h3 className="font-semibold text-gray-900">Exercise Summary</h3>
                        <p className="text-sm text-gray-600">Basic workout statistics</p>
                      </div>
                    </div>
                  </div>
                  <div className="text-center py-8">
                    <p className="text-gray-600">
                      Detailed exercise analytics have been simplified.
                      <br />
                      Check the Analytics tab for workout trends and achievements.
                    </p>
                  </div>
                </Card>

                {/* Personal Records */}
                {performanceMetrics.personalRecords.length > 0 && (
                  <Card variant="elevated" rounded="xl" className="p-6">
                    <div className="flex items-center justify-between mb-4">
                      <div className="flex items-center space-x-3">
                        <div className="flex-shrink-0 w-10 h-10 rounded-lg bg-blue-100 flex items-center justify-center text-blue-600">
                          <Award className="h-5 w-5" />
                        </div>
                        <div>
                          <h3 className="font-semibold text-gray-900">Recent Personal Records</h3>
                          <p className="text-sm text-gray-600">Your latest achievements and milestones</p>
                        </div>
                      </div>
                    </div>
                    <div className="mt-6 space-y-4">
                      {performanceMetrics.personalRecords.slice(0, 5).map((record, index) => (
                        <div key={index} className="flex items-center justify-between p-4 bg-gradient-to-r from-yellow-50 to-orange-50 rounded-xl border border-yellow-200">
                          <div>
                            <h4 className="font-semibold text-gray-900">{record.exerciseName}</h4>
                            <p className="text-sm text-gray-600">
                              {record.weight} lbs × {record.reps} reps
                            </p>
                            <p className="text-xs text-gray-500">
                              {new Date(record.date).toLocaleDateString()}
                            </p>
                          </div>
                          <div className="text-right">
                            <div className="text-yellow-500">
                              <Trophy className="h-6 w-6" />
                            </div>
                            {record.previousRecord && (
                              <p className="text-xs text-green-600">
                                +{(record.weight - record.previousRecord.weight).toFixed(1)} lbs
                              </p>
                            )}
                          </div>
                        </div>
                      ))}
                    </div>
                  </Card>
                )}
              </div>
            ) : (
              <div className="text-center py-12">
                <BarChart3 className="h-12 w-12 text-gray-400 mx-auto mb-4" />
                <h3 className="text-lg font-medium text-gray-900 mb-2">No Analytics Available</h3>
                <p className="text-gray-600">Complete some workouts to see your performance analytics.</p>
              </div>
            )}

            {/* Fallback to original analytics component */}
            <WorkoutAnalytics workouts={items} />
          </div>
        )}

        {/* Achievements Tab */}
        {activeTab === 'achievements' && (
          <div className="bg-white rounded-xl p-6 border border-gray-100 text-center" role="tabpanel" id="achievements-panel" aria-labelledby="achievements-tab">
            <Award className="h-12 w-12 text-gray-400 mx-auto mb-4" />
            <h3 className="text-lg font-semibold text-gray-900 mb-2">Achievements Coming Soon</h3>
            <p className="text-gray-600">Achievement system will be available in a future update.</p>
          </div>
        )}
      </main>
    </div>
  )
}

========================================
FILE: src/pages/Onboarding.tsx
========================================

// src/pages/Onboarding.tsx
import React, { useEffect, useMemo, useState } from 'react'
import { auth, db } from '../lib/firebase'
import { doc, getDoc, setDoc } from 'firebase/firestore'
import { useNavigate } from 'react-router-dom'
import {
  BookOpen,
  Zap,
  Trophy,
  User,
  Dumbbell,
  Weight,
  Zap as ResistanceBand,
  Circle,
  Settings,
  Monitor,
  Bike,
  Waves,
  ArrowUp,
  Cable,
  Circle as Ball,
  Scale,
  Flame,
  Target,
  Heart,
  Sparkles,
  Shield,
  Brain,
  Move
} from 'lucide-react'
import {
  EXPERIENCE_LEVELS,
  GOALS,
  EQUIPMENT,
  SEX_OPTIONS,
  HEIGHT_RANGES,
  WEIGHT_RANGES,
  INJURY_OPTIONS
} from '../config/onboarding'
import { trackProfileComplete, setEnhancedUserProperties } from '../lib/firebase-analytics'

/** ---------------- DATA ---------------- */
type Personal = { sex?: string; height?: string; weight?: string }
type Injuries = { list: string[]; notes: string }
type Profile = {
  experience?: string
  goals?: string[]
  equipment?: string[]
  personal?: Personal
  injuries?: Injuries
}



type Draft = {
  experience: string | null
  goals: string[]
  equipment: string[]
  personal: Personal
  injuries: Injuries
}

const EMPTY_DRAFT: Draft = {
  experience: null,
  goals: [],
  equipment: [],
  personal: { sex: '', height: '', weight: '' },
  injuries: { list: [], notes: '' },
}

/** -------------- VALIDATION -------------- */
function validStep(step: number, d: Draft): boolean {
  switch (step) {
    case 1: return !!d.experience
    case 2: return d.goals.length > 0
    case 3: return d.equipment.length > 0
    case 4: return !!d.personal.sex && !!d.personal.height && !!d.personal.weight
    case 5: return true
    default: return false
  }
}

/** -------------- UI PRIMITIVES -------------- */
function Progress({ step, total }: { step: number; total: number }) {
  const pct = Math.round((step / total) * 100)
  return (
    <div className="w-full mb-8">
      <div className="mb-3 flex items-center justify-between text-sm text-gray-600">
        <span className="font-medium">Step {step} of {total}</span>
        <span className="text-blue-600 font-semibold">{pct}%</span>
      </div>
      <div className="h-3 w-full overflow-hidden rounded-full bg-gray-100 shadow-inner">
        <div
          className="h-full bg-gradient-to-r from-blue-500 to-indigo-600 transition-all duration-500 ease-out rounded-full shadow-sm"
          style={{ width: `${pct}%` }}
        />
      </div>
      <div className="mt-2 flex justify-between">
        {Array.from({ length: total }, (_, i) => (
          <div
            key={i}
            className={`h-2 w-2 rounded-full transition-all duration-300 ${
              i < step ? 'bg-blue-500 scale-110' : 'bg-gray-200'
            }`}
          />
        ))}
      </div>
    </div>
  )
}

function SectionTitle({ title }: { title: string }) {
  return (
    <div className="mb-6 text-center">
      <h2 className="text-2xl font-bold tracking-tight text-gray-900">{title}</h2>
    </div>
  )
}

function SelectCard({
  active, children, onClick, disabled
}: { active?: boolean; children: React.ReactNode; onClick?: () => void; disabled?: boolean }) {
  return (
    <button
      type="button"
      onClick={onClick}
      disabled={disabled}
      className={[
        'group relative w-full rounded-2xl border p-5 text-sm transition-all duration-300',
        'text-left shadow-sm hover:shadow-md',
        active
          ? 'border-blue-500 bg-gradient-to-br from-blue-500 to-indigo-600 text-white shadow-lg scale-[1.02]'
          : 'border-gray-200 bg-white/70 backdrop-blur-sm hover:border-blue-300 hover:bg-white hover:scale-[1.01]',
        disabled ? 'opacity-50 cursor-not-allowed' : '',
      ].join(' ')}
    >
      {children}
    </button>
  )
}

function MultiGrid({
  items, selected, onToggle, cols = 2, allowNone
}: { items: string[]; selected: string[]; onToggle: (_v: string) => void; cols?: 1 | 2; allowNone?: boolean }) {
  return (
    <div className={`grid gap-3 ${cols === 2 ? 'grid-cols-2' : 'grid-cols-1'}`}>
      {items.map((v) => (
        <SelectCard
          key={v}
          active={selected.includes(v)}
          onClick={() => onToggle(v)}
        >
          <div className="text-center font-medium">
            {v}
            {allowNone && v.startsWith('None') && <span className="ml-2 text-xs opacity-70">(clears others)</span>}
          </div>
        </SelectCard>
      ))}
    </div>
  )
}

function PrimaryButton({
  children, onClick, disabled, type = 'button'
}: { children: React.ReactNode; onClick?: () => void; disabled?: boolean; type?: 'button' | 'submit' }) {
  return (
    <button
      type={type}
      onClick={disabled ? undefined : onClick}
      aria-disabled={disabled}
      className={[
        'px-6 py-3 rounded-xl font-semibold transition-all duration-300 shadow-sm',
        disabled
          ? 'bg-gray-300 text-gray-500 pointer-events-none'
          : 'bg-gradient-to-r from-blue-500 to-indigo-600 text-white hover:from-blue-600 hover:to-indigo-700 hover:shadow-lg hover:scale-105 active:scale-95',
      ].join(' ')}
    >
      {children}
    </button>
  )
}

function SecondaryButton({ children, onClick, disabled }: { children: React.ReactNode; onClick?: () => void; disabled?: boolean }) {
  return (
    <button
      type="button"
      onClick={disabled ? undefined : onClick}
      aria-disabled={disabled}
      className={[
        'px-5 py-3 rounded-xl border font-medium transition-all duration-300',
        disabled
          ? 'border-gray-200 text-gray-400 pointer-events-none'
          : 'border-gray-200 text-gray-700 bg-white hover:bg-gray-50 hover:border-gray-300 hover:shadow-md hover:scale-105 active:scale-95',
      ].join(' ')}
    >
      {children}
    </button>
  )
}

/** -------------- PAGE -------------- */
export default function Onboarding() {
  const nav = useNavigate()
  const [step, setStep] = useState(1)
  const total = 5
  const [loading, setLoading] = useState(true)
  const [saving, setSaving] = useState(false)
  const [draft, setDraft] = useState<Draft>(EMPTY_DRAFT)

  // Prefill if profile exists (edit-friendly)
  useEffect(() => {
    (async () => {
      const uid = auth.currentUser?.uid
      if (!uid) {
        setLoading(false)
        return
      }
      try {
        const snap = await getDoc(doc(db, 'users', uid))
        if (snap.exists()) {
          const p = snap.data() as Profile
          setDraft({
            experience: p.experience ?? null,
            goals: p.goals ?? [],
            equipment: p.equipment ?? [],
            personal: {
              sex: p.personal?.sex ?? '',
              height: p.personal?.height ?? '',
              weight: p.personal?.weight ?? '',
            },
            injuries: {
              list: p.injuries?.list ?? [],
              notes: p.injuries?.notes ?? '',
            },
          })
        }
      } catch (error) {
        console.error('Error loading existing profile:', error)
        // Continue with empty draft if loading fails
      } finally {
        setLoading(false)
      }
    })()
  }, [])

  const header = useMemo(() => {
    switch (step) {
      case 1: return { title: 'What’s your training level?'}
      case 2: return { title: 'What are your fitness goals?'}
      case 3: return { title: 'What do you have access to?'}
      case 4: return { title: 'Tell us about you'}
      case 5: return { title: 'Any injuries or limitations?'}
      default: return { title: '' }
    }
  }, [step])

  const disableNext = !validStep(step, draft)
  const atStart = step === 1
  const atEnd = step === total

  function toggle(list: string[], value: string, allowNone = false) {
    const isNone = value.startsWith('None')
    // If "None" is selected, clear everything else
    if (allowNone && isNone) return ['None (Bodyweight)', 'None'].includes(value) ? [value] : [value]
    // If list already contains "None", remove it before toggling others
    if (allowNone && list.some((v) => v.startsWith('None'))) {
      list = list.filter((v) => !v.startsWith('None'))
    }
    return list.includes(value) ? list.filter((v) => v !== value) : [...list, value]
  }

  async function finish() {
    const uid = auth.currentUser?.uid
    if (!uid) return
    setSaving(true)
    try {
      await setDoc(
        doc(db, 'users', uid),
        {
          experience: draft.experience,
          goals: draft.goals,
          equipment: draft.equipment,
          personal: draft.personal,
          injuries: draft.injuries,
        },
        { merge: true }
      )

      // Track profile completion
      trackProfileComplete(
        draft.experience || 'Unknown',
        draft.goals,
        draft.equipment
      )

      // Set enhanced user properties with location context
      if (uid) {
        setEnhancedUserProperties(uid, {
          experience: draft.experience,
          goals: draft.goals,
          equipment: draft.equipment,
          personal: draft.personal,
          injuries: draft.injuries
        })
      }

      nav('/dashboard')
    } catch (error) {
      console.error('Error saving profile:', error)
      // You might want to show an error message to the user here
      alert('Failed to save profile. Please try again.')
    } finally {
      setSaving(false)
    }
  }

  // Allow Enter to go Next only when valid
  function onKeyDown(e: React.KeyboardEvent<HTMLDivElement>) {
    if (e.key === 'Enter' && !disableNext) {
      e.preventDefault()
      if (!atEnd) setStep((s) => s + 1)
      else finish()
    }
  }

  if (loading) {
    return (
      <div className="min-h-screen grid place-items-center bg-gradient-to-br from-slate-50 via-white to-blue-50/30">
        <div className="flex flex-col items-center gap-4">
          <div className="h-8 w-8 animate-spin rounded-full border-2 border-blue-200 border-t-blue-600" />
          <p className="text-sm text-gray-600">Loading your profile...</p>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 via-white to-blue-50/30" onKeyDown={onKeyDown} tabIndex={0}>
      {/* Background Pattern */}
      <div className="absolute inset-0 bg-[radial-gradient(circle_at_50%_120%,rgba(59,130,246,0.05),transparent_50%)]" />

      {/* Content */}
      <div className="relative mx-auto max-w-3xl px-6 pt-12 pb-28">
        <Progress step={step} total={total} />
        <SectionTitle {...header} />

        {/* STEP 1 — EXPERIENCE */}
        {step === 1 && (
          <div className="grid gap-4 sm:grid-cols-3">
            {EXPERIENCE_LEVELS.map((level) => (
              <SelectCard
                key={level}
                active={draft.experience === level}
                onClick={() => setDraft((d) => ({ ...d, experience: level }))}
              >
                <div className="flex items-center gap-4 mb-3">
                  <div className={`p-3 rounded-xl transition-all duration-300 ${
                    draft.experience === level
                      ? 'bg-white/20 border border-white/30'
                      : 'bg-blue-50 border border-blue-100'
                  }`}>
                    {level === 'Beginner' && <BookOpen className={`h-6 w-6 ${draft.experience === level ? 'text-white' : 'text-blue-600'}`} />}
                    {level === 'Intermediate' && <Zap className={`h-6 w-6 ${draft.experience === level ? 'text-white' : 'text-blue-600'}`} />}
                    {level === 'Expert' && <Trophy className={`h-6 w-6 ${draft.experience === level ? 'text-white' : 'text-blue-600'}`} />}
                  </div>
                  <div className="text-lg font-bold">{level}</div>
                </div>
                <div className={`text-sm leading-relaxed ${
                  draft.experience === level
                    ? 'text-white/90'
                    : 'text-gray-600 group-hover:text-gray-700'
                }`}>
                  {level === 'Beginner' && 'Perfect for those just starting their fitness journey or returning after a break.'}
                  {level === 'Intermediate' && 'You have consistent training experience and understand basic movement patterns.'}
                  {level === 'Expert' && 'You have years of training experience and advanced knowledge of programming.'}
                </div>
              </SelectCard>
            ))}
          </div>
        )}

        {/* STEP 2 — GOALS */}
        {step === 2 && (
          <div className="grid gap-3 grid-cols-2 sm:grid-cols-3 lg:grid-cols-4">
            {GOALS.map((goal) => (
              <GoalCard
                key={goal}
                goal={goal}
                active={draft.goals.includes(goal)}
                onClick={() => setDraft((d) => ({ ...d, goals: toggle(d.goals, goal) }))}
              />
            ))}
          </div>
        )}

        {/* STEP 3 — EQUIPMENT */}
        {step === 3 && (
          <div className="grid gap-3 grid-cols-2 sm:grid-cols-3 lg:grid-cols-4">
            {EQUIPMENT.map((equipment) => (
              <EquipmentCard
                key={equipment}
                equipment={equipment}
                active={draft.equipment.includes(equipment)}
                onClick={() => setDraft((d) => ({ ...d, equipment: toggle(d.equipment, equipment) }))}
              />
            ))}
          </div>
        )}

        {/* STEP 4 — PERSONAL */}
        {step === 4 && (
          <div className="grid gap-8">
            {/* Sex Options - Single Row */}
            <div>
              <div className="mb-4 text-sm font-semibold text-gray-700 text-center">Gender</div>
              <div className="grid grid-cols-3 gap-4">
                {SEX_OPTIONS.map((s) => (
                  <SelectCard
                    key={s}
                    active={draft.personal.sex === s}
                    onClick={() => setDraft((d) => ({ ...d, personal: { ...d.personal, sex: s } }))}
                  >
                    <div className="text-center font-medium">{s}</div>
                  </SelectCard>
                ))}
              </div>
            </div>

            {/* Height - 2x3 Grid */}
            <div>
              <div className="mb-4 text-sm font-semibold text-gray-700 text-center">Height Range</div>
              <div className="grid grid-cols-3 gap-3">
                {HEIGHT_RANGES.map((h) => (
                  <SelectCard
                    key={h}
                    active={draft.personal.height === h}
                    onClick={() => setDraft((d) => ({ ...d, personal: { ...d.personal, height: h } }))}
                  >
                    <div className="text-center font-medium">{h}</div>
                  </SelectCard>
                ))}
              </div>
            </div>

            {/* Weight - 2x3 Grid */}
            <div>
              <div className="mb-4 text-sm font-semibold text-gray-700 text-center">Weight Range</div>
              <div className="grid grid-cols-3 gap-3">
                {WEIGHT_RANGES.map((w) => (
                  <SelectCard
                    key={w}
                    active={draft.personal.weight === w}
                    onClick={() => setDraft((d) => ({ ...d, personal: { ...d.personal, weight: w } }))}
                  >
                    <div className="text-center font-medium">{w}</div>
                  </SelectCard>
                ))}
              </div>
            </div>
          </div>
        )}

        {/* STEP 5 — INJURIES */}
        {step === 5 && (
          <div className="grid gap-6">
            <div className="mb-2 text-sm font-semibold text-gray-700 text-center">Current Injuries or Limitations</div>
            <MultiGrid
              items={INJURY_OPTIONS}
              selected={draft.injuries.list}
              onToggle={(v) =>
                setDraft((d) => {
                  // If selecting "None", keep only None; else toggle and ensure None is removed
                  if (v === 'None') return { ...d, injuries: { ...d.injuries, list: ['None'] } }
                  const list = d.injuries.list.filter((x) => x !== 'None')
                  const next = list.includes(v) ? list.filter((x) => x !== v) : [...list, v]
                  return { ...d, injuries: { ...d.injuries, list: next } }
                })
              }
              cols={2}
            />
            <div>
              <label className="mb-3 block text-sm font-semibold text-gray-700">Additional Notes (optional)</label>
              <textarea
                value={draft.injuries.notes}
                onChange={(e) => setDraft((d) => ({ ...d, injuries: { ...d.injuries, notes: e.target.value } }))}
                placeholder="e.g., mild runner’s knee on right leg; avoid deep flexion"
                className="w-full rounded-2xl border border-gray-200 bg-white/70 backdrop-blur-sm px-4 py-3 text-sm outline-none placeholder:text-gray-400 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all duration-300 resize-none"
                rows={4}
                autoComplete="off"
                autoCorrect="off"
                autoCapitalize="sentences"
                spellCheck="true"
                data-gramm="false"
              />
            </div>
          </div>
        )}
      </div>

      {/* Fixed Footer Nav */}
      <div className="fixed inset-x-0 bottom-0 z-20 border-t border-gray-200/50 bg-white/90 backdrop-blur-md shadow-lg">
        <div className="mx-auto max-w-3xl px-6 py-4 flex items-center justify-between">
          <SecondaryButton onClick={() => setStep((s) => Math.max(1, s - 1))} disabled={atStart}>
            Back
          </SecondaryButton>

          <div className="hidden text-xs text-gray-500 sm:block max-w-xs text-center">
            {step === 1 && 'Tip: Be honest about level—your plan adapts.'}
            {step === 2 && 'Tip: Multiple goals are okay; we’ll balance.'}
            {step === 3 && 'Tip: Select all equipment you have access to.'}
            {step === 4 && 'Tip: Ranges personalize without exact numbers.'}
            {step === 5 && 'Tip: Selecting “None” clears other injuries.'}
          </div>

          {!atEnd ? (
            <PrimaryButton onClick={() => setStep((s) => Math.min(total, s + 1))} disabled={disableNext}>
              Next
            </PrimaryButton>
          ) : (
            <PrimaryButton onClick={finish} disabled={saving}>
              {saving ? 'Saving…' : 'Finish'}
            </PrimaryButton>
          )}
        </div>
      </div>
    </div>
  )
}

/* ---------- Goal Card Component ---------- */
function GoalCard({
  goal,
  active,
  onClick
}: {
  goal: string;
  active: boolean;
  onClick: () => void;
}) {
  return (
    <button
      onClick={onClick}
      className={`
        group relative p-3 rounded-2xl border-2 transition-all duration-300 text-center shadow-sm hover:shadow-lg
        ${active
          ? 'bg-gradient-to-br from-blue-500 to-indigo-600 border-blue-500 text-white shadow-lg scale-[1.02]'
          : 'bg-white/70 backdrop-blur-sm border-gray-200 text-gray-700 hover:border-blue-300 hover:bg-white hover:scale-[1.01]'
        }
      `}
    >
      <div className="flex flex-col items-center space-y-2">
        <div className={`transition-transform duration-300 group-hover:scale-110 ${active ? 'text-white' : 'text-blue-600'}`}>
          {getGoalIcon(goal, "h-6 w-6")}
        </div>
        <div className="text-xs font-semibold leading-tight">
          {goal}
        </div>
      </div>
    </button>
  )
}

/* ---------- Equipment Card Component ---------- */
function EquipmentCard({
  equipment,
  active,
  onClick
}: {
  equipment: string;
  active: boolean;
  onClick: () => void;
}) {
  return (
    <button
      onClick={onClick}
      className={`
        group relative p-3 rounded-2xl border-2 transition-all duration-300 text-center shadow-sm hover:shadow-lg
        ${active
          ? 'bg-gradient-to-br from-emerald-500 to-teal-600 border-emerald-500 text-white shadow-lg scale-[1.02]'
          : 'bg-white/70 backdrop-blur-sm border-gray-200 text-gray-700 hover:border-emerald-300 hover:bg-white hover:scale-[1.01]'
        }
      `}
    >
      <div className="flex flex-col items-center space-y-2">
        <div className={`transition-transform duration-300 group-hover:scale-110 ${active ? 'text-white' : 'text-emerald-600'}`}>
          {getEquipmentIcon(equipment, "h-6 w-6")}
        </div>
        <div className="text-xs font-semibold leading-tight">
          {equipment}
        </div>
      </div>
    </button>
  )
}

/* ---------- Equipment Icons ---------- */
function getEquipmentIcon(equipment: string, className: string = "h-6 w-6") {
  switch (equipment) {
    case 'Bodyweight':
      return <User className={className} />
    case 'Dumbbells':
      return <Dumbbell className={className} />
    case 'Barbells':
      return <Weight className={className} />
    case 'Resistance Bands':
      return <ResistanceBand className={className} />
    case 'Kettlebells':
      return <Circle className={className} />
    case 'Medicine Balls':
      return <Ball className={className} />
    case 'Weight Machines':
      return <Settings className={className} />
    case 'Treadmill':
      return <Monitor className={className} />
    case 'Stationary Bike':
      return <Bike className={className} />
    case 'Rowing Machine':
      return <Waves className={className} />
    case 'Pull-Up Bar':
      return <ArrowUp className={className} />
    case 'Cable Machine':
      return <Cable className={className} />
    default:
      return <Circle className={className} />
  }
}

/* ---------- Goal Icons ---------- */
function getGoalIcon(goal: string, className: string = "h-6 w-6") {
  switch (goal) {
    case 'Weight Loss':
      return <Scale className={className} />
    case 'Build Muscle':
      return <Flame className={className} />
    case 'Strength':
      return <Dumbbell className={className} />
    case 'Stamina':
      return <Heart className={className} />
    case 'Tone':
      return <Sparkles className={className} />
    case 'General Health':
      return <Shield className={className} />
    case 'Increase Flexibility':
      return <Move className={className} />
    case 'Sports Performance':
      return <Trophy className={className} />
    case 'Mental Health':
      return <Brain className={className} />
    case 'Injury Prevention':
      return <Shield className={className} />
    default:
      return <Target className={className} />
  }
}

========================================
FILE: src/pages/Privacy.tsx
========================================

// src/pages/Privacy.tsx
import { Link } from 'react-router-dom'

export default function Privacy() {
  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 via-white to-blue-50/30 text-gray-900">
      <div className="mx-auto max-w-3xl px-6 py-12">
        <header className="mb-8">
          <Link to="/" className="text-blue-600 hover:text-blue-700 font-medium">← Back</Link>
          <h1 className="mt-4 text-3xl md:text-4xl font-bold tracking-tight">Privacy Policy</h1>
          <p className="mt-2 text-gray-600">Last updated: September 30, 2025</p>
        </header>

        {/* Table of contents */}
        <nav aria-label="Table of contents" className="mb-8 rounded-2xl border border-gray-200 bg-white/60 backdrop-blur-sm p-4">
          <p className="text-sm font-semibold text-gray-900 mb-3">Table of contents</p>
          <ul className="grid grid-cols-1 sm:grid-cols-2 gap-2 text-sm text-blue-700">
            <li><a href="#overview" className="hover:underline">1) Overview</a></li>
            <li><a href="#information-we-collect" className="hover:underline">2) Information We Collect</a></li>
            <li><a href="#how-we-use-information" className="hover:underline">3) How We Use Information</a></li>
            <li><a href="#ai-processing" className="hover:underline">4) AI Processing & Third Parties</a></li>
            <li><a href="#data-sharing" className="hover:underline">5) Information Sharing</a></li>
            <li><a href="#data-security" className="hover:underline">6) Data Security</a></li>
            <li><a href="#data-retention" className="hover:underline">7) Data Retention</a></li>
            <li><a href="#your-rights" className="hover:underline">8) Your Rights & Choices</a></li>
            <li><a href="#childrens-privacy" className="hover:underline">9) Children's Privacy</a></li>
            <li><a href="#international-users" className="hover:underline">10) International Users</a></li>
            <li><a href="#california-privacy" className="hover:underline">11) California Privacy Rights</a></li>
            <li><a href="#changes-to-policy" className="hover:underline">12) Changes to This Policy</a></li>
            <li><a href="#contact" className="hover:underline">13) Contact Information</a></li>
          </ul>
        </nav>

        <div className="space-y-8 text-sm leading-relaxed text-gray-700">
          <section>
            <h2 id="overview" className="text-lg font-semibold text-gray-900">1) Overview</h2>
            <p className="mt-2">This Privacy Policy explains how NeuraFit ("we," "us," or "our") collects, uses, shares, and protects your personal information when you use our AI-powered workout application and services ("Services"). We are committed to protecting your privacy and being transparent about our data practices.</p>
            <p className="mt-2">By using our Services, you consent to the collection and use of your information as described in this Privacy Policy.</p>
          </section>

          <section>
            <h2 id="information-we-collect" className="text-lg font-semibold text-gray-900">2) Information We Collect</h2>
            <p className="mt-2">We collect several types of information to provide and improve our Services:</p>

            <h3 className="mt-4 font-semibold text-gray-900">Account Information</h3>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Email address and display name from your chosen authentication provider (Google)</li>
              <li>Profile picture (if provided by your authentication provider)</li>
              <li>Account creation and last login timestamps</li>
            </ul>

            <h3 className="mt-4 font-semibold text-gray-900">Fitness Profile Information</h3>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Fitness experience level (beginner, intermediate, expert)</li>
              <li>Fitness goals (weight loss, muscle building, strength, etc.)</li>
              <li>Available equipment preferences</li>
              <li>Physical characteristics (height and weight ranges for personalization)</li>
              <li>Injury information and limitations (only what you choose to disclose)</li>
              <li>Gender (optional, for workout customization)</li>
            </ul>

            <h3 className="mt-4 font-semibold text-gray-900">Workout and Usage Data</h3>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Generated workout plans and exercise selections</li>
              <li>Workout completion status and progress tracking</li>
              <li>Exercise preferences and modifications</li>
              <li>App usage patterns and feature interactions</li>
              <li>Session duration and frequency of use</li>
            </ul>

            <h3 className="mt-4 font-semibold text-gray-900">Technical Information</h3>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Device type, operating system, and app version</li>
              <li>IP address and approximate geographic location</li>
              <li>Browser type and language preferences</li>
              <li>Crash reports and error logs for app stability</li>
              <li>Performance metrics and analytics data</li>
            </ul>
          </section>

          <section>
            <h2 id="how-we-use-information" className="text-lg font-semibold text-gray-900">3) How We Use Your Information</h2>
            <p className="mt-2">We use your information for the following purposes:</p>

            <h3 className="mt-4 font-semibold text-gray-900">Core Service Delivery</h3>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Generate personalized AI workout recommendations</li>
              <li>Customize exercise difficulty and progressions</li>
              <li>Provide safety recommendations based on disclosed injuries</li>
              <li>Save and sync your workout history across devices</li>
              <li>Enable account authentication and access control</li>
            </ul>

            <h3 className="mt-4 font-semibold text-gray-900">Service Improvement</h3>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Analyze usage patterns to improve AI recommendations</li>
              <li>Identify and fix technical issues and bugs</li>
              <li>Develop new features and enhance user experience</li>
              <li>Conduct research to improve workout effectiveness</li>
            </ul>

            <h3 className="mt-4 font-semibold text-gray-900">Communication and Support</h3>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Respond to your questions and support requests</li>
              <li>Send important service updates and security notifications</li>
              <li>Provide information about new features (with your consent)</li>
            </ul>

            <h3 className="mt-4 font-semibold text-gray-900">Legal and Security</h3>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Comply with legal obligations and law enforcement requests</li>
              <li>Protect against fraud, abuse, and security threats</li>
              <li>Enforce our Terms of Service and other policies</li>
            </ul>
          </section>

          <section>
            <h2 id="ai-processing" className="text-lg font-semibold text-gray-900">4) AI Processing and Third-Party Services</h2>
            <p className="mt-2">NeuraFit uses artificial intelligence to generate personalized workout recommendations. Here's how this works:</p>

            <h3 className="mt-4 font-semibold text-gray-900">AI Workout Generation</h3>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Your fitness profile data is processed by AI models to create personalized workouts</li>
              <li>We use third-party AI services (such as OpenAI's GPT models) to generate workout content</li>
              <li>Only necessary information is sent to AI providers (fitness level, goals, equipment, injuries)</li>
              <li>Personal identifiers (name, email) are not included in AI processing requests</li>
              <li>AI providers may temporarily process your data but do not store it for their own purposes</li>
            </ul>

            <h3 className="mt-4 font-semibold text-gray-900">Third-Party Services</h3>
            <p className="mt-2">We work with trusted third-party providers for:</p>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li><strong>Authentication:</strong> Google Firebase for secure sign-in</li>
              <li><strong>Data Storage:</strong> Google Cloud Firestore for secure data storage</li>
              <li><strong>AI Processing:</strong> OpenAI and similar providers for workout generation</li>
              <li><strong>Analytics:</strong> Privacy-focused analytics to improve our service</li>
              <li><strong>Hosting:</strong> Secure cloud hosting providers</li>
            </ul>
            <p className="mt-2">All third-party providers are bound by strict data processing agreements and security requirements.</p>
          </section>

          <section>
            <h2 id="data-sharing" className="text-lg font-semibold text-gray-900">5) Information Sharing and Disclosure</h2>
            <p className="mt-2">We do not sell, rent, or trade your personal information. We may share your information only in the following limited circumstances:</p>

            <h3 className="mt-4 font-semibold text-gray-900">Service Providers</h3>
            <p className="mt-2">We share information with trusted third-party service providers who help us operate our Services, including cloud hosting, data storage, AI processing, and analytics providers. These providers are contractually bound to protect your information and use it only for the services they provide to us.</p>

            <h3 className="mt-4 font-semibold text-gray-900">Legal Requirements</h3>
            <p className="mt-2">We may disclose your information if required by law, court order, or government regulation, or if we believe disclosure is necessary to:</p>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Comply with legal processes or law enforcement requests</li>
              <li>Protect the rights, property, or safety of NeuraFit, our users, or the public</li>
              <li>Prevent fraud, abuse, or security threats</li>
              <li>Enforce our Terms of Service</li>
            </ul>

            <h3 className="mt-4 font-semibold text-gray-900">Business Transfers</h3>
            <p className="mt-2">In the event of a merger, acquisition, or sale of assets, your information may be transferred to the new entity, subject to the same privacy protections outlined in this policy.</p>

            <h3 className="mt-4 font-semibold text-gray-900">Aggregated Data</h3>
            <p className="mt-2">We may share aggregated, anonymized data that cannot identify individual users for research, analytics, or business purposes.</p>
          </section>

          <section>
            <h2 id="data-security" className="text-lg font-semibold text-gray-900">6) Data Security</h2>
            <p className="mt-2">We implement comprehensive security measures to protect your personal information:</p>

            <h3 className="mt-4 font-semibold text-gray-900">Technical Safeguards</h3>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Encryption of data in transit and at rest using industry-standard protocols</li>
              <li>Secure authentication through trusted providers (Google Firebase)</li>
              <li>Regular security audits and vulnerability assessments</li>
              <li>Access controls and monitoring systems</li>
              <li>Secure cloud infrastructure with enterprise-grade security</li>
            </ul>

            <h3 className="mt-4 font-semibold text-gray-900">Organizational Safeguards</h3>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Limited access to personal data on a need-to-know basis</li>
              <li>Employee training on data protection and privacy practices</li>
              <li>Incident response procedures for potential security breaches</li>
              <li>Regular review and updates of security policies</li>
            </ul>

            <p className="mt-2">While we implement strong security measures, no system is completely secure. You can help protect your account by using a strong password and keeping your login credentials confidential.</p>
          </section>

          <section>
            <h2 id="data-retention" className="text-lg font-semibold text-gray-900">7) Data Retention</h2>
            <p className="mt-2">We retain your personal information for as long as necessary to provide our Services and fulfill the purposes outlined in this Privacy Policy. Specific retention periods include:</p>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li><strong>Account Information:</strong> Retained until you delete your account</li>
              <li><strong>Fitness Profile:</strong> Retained to provide personalized recommendations</li>
              <li><strong>Workout History:</strong> Retained to track your progress and improve recommendations</li>
              <li><strong>Technical Data:</strong> Typically retained for 12-24 months for analytics and debugging</li>
              <li><strong>Support Communications:</strong> Retained for 3 years for quality assurance</li>
            </ul>
            <p className="mt-2">When you delete your account, we will delete or anonymize your personal information within 30 days, except where we are required to retain it for legal compliance.</p>
          </section>

          <section>
            <h2 id="your-rights" className="text-lg font-semibold text-gray-900">8) Your Rights and Choices</h2>
            <p className="mt-2">You have several rights regarding your personal information:</p>

            <h3 className="mt-4 font-semibold text-gray-900">Access and Control</h3>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li><strong>Access:</strong> View and update your profile information within the app</li>
              <li><strong>Correction:</strong> Update inaccurate or incomplete information</li>
              <li><strong>Deletion:</strong> Request deletion of your account and associated data</li>
              <li><strong>Data Portability:</strong> Request a copy of your data in a portable format</li>
            </ul>

            <h3 className="mt-4 font-semibold text-gray-900">Communication Preferences</h3>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Opt out of promotional communications (service notifications will continue)</li>
              <li>Control push notification settings through your device</li>
            </ul>

            <p className="mt-2">To exercise these rights, contact us at support@neurafit.app. We will respond to your request within 30 days.</p>
          </section>

          <section>
            <h2 id="childrens-privacy" className="text-lg font-semibold text-gray-900">9) Children's Privacy</h2>
            <p className="mt-2">Our Services are not intended for children under 18 years of age. We do not knowingly collect personal information from children under 18. If you are a parent or guardian and believe your child has provided us with personal information, please contact us immediately so we can delete such information.</p>
          </section>

          <section>
            <h2 id="international-users" className="text-lg font-semibold text-gray-900">10) International Data Transfers</h2>
            <p className="mt-2">Your information may be transferred to and processed in countries other than your own, including the United States, where our servers and service providers are located. These countries may have different data protection laws than your country.</p>
            <p className="mt-2">We ensure that such transfers comply with applicable data protection laws and implement appropriate safeguards, including:</p>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Standard contractual clauses approved by relevant authorities</li>
              <li>Adequacy decisions by regulatory bodies</li>
              <li>Certification schemes and codes of conduct</li>
            </ul>
          </section>

          <section>
            <h2 id="california-privacy" className="text-lg font-semibold text-gray-900">11) California Privacy Rights (CCPA)</h2>
            <p className="mt-2">If you are a California resident, you have additional rights under the California Consumer Privacy Act (CCPA):</p>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li><strong>Right to Know:</strong> Request information about the personal information we collect, use, and share</li>
              <li><strong>Right to Delete:</strong> Request deletion of your personal information</li>
              <li><strong>Right to Opt-Out:</strong> We do not sell personal information, so no opt-out is necessary</li>
              <li><strong>Right to Non-Discrimination:</strong> We will not discriminate against you for exercising your privacy rights</li>
            </ul>
            <p className="mt-2">To exercise these rights, contact us at support@neurafit.app with "California Privacy Request" in the subject line.</p>
          </section>

          <section>
            <h2 id="changes-to-policy" className="text-lg font-semibold text-gray-900">12) Changes to This Privacy Policy</h2>
            <p className="mt-2">We may update this Privacy Policy from time to time to reflect changes in our practices, technology, legal requirements, or other factors. We will notify you of material changes by:</p>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Posting the updated policy in our app with a new "Last Updated" date</li>
              <li>Sending you an email notification (for significant changes)</li>
              <li>Providing an in-app notification when you next use our Services</li>
            </ul>
            <p className="mt-2">Your continued use of our Services after the effective date of changes constitutes acceptance of the updated Privacy Policy.</p>
          </section>

          <section>
            <h2 id="contact" className="text-lg font-semibold text-gray-900">13) Contact Information</h2>
            <p className="mt-2">If you have questions, concerns, or requests regarding this Privacy Policy or our data practices, please contact us:</p>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li><strong>General Privacy Inquiries:</strong> support@neurafit.app</li>
              <li><strong>Data Protection Officer:</strong> privacy@neurafit.app</li>
              <li><strong>California Privacy Requests:</strong> Use subject line "California Privacy Request"</li>
              <li><strong>GDPR Requests:</strong> Use subject line "GDPR Data Request"</li>
            </ul>
            <p className="mt-2">We will respond to your inquiry within 30 days (or sooner as required by applicable law). For formal legal notices regarding privacy matters, please contact us at legal@neurafit.app.</p>
          </section>

          <footer className="pt-8 border-t border-gray-200 text-center">
            <p className="text-gray-600">
              See also our <Link to="/terms" className="text-blue-600 hover:text-blue-700 underline">Terms of Service</Link> for information about your responsibilities when using NeuraFit.
            </p>
          </footer>
        </div>
      </div>
    </div>
  )
}

========================================
FILE: src/pages/Profile.tsx
========================================

// src/pages/Profile.tsx
import React, { useEffect, useMemo, useState } from 'react'
import { doc, getDoc, setDoc } from 'firebase/firestore'

import { auth, db } from '../lib/firebase'

import {
  EXPERIENCE_LEVELS,
  GOALS,
  EQUIPMENT,
  SEX_OPTIONS,
  HEIGHT_RANGES,
  WEIGHT_RANGES,
  INJURY_OPTIONS
} from '../config/onboarding'
import AppHeader from '../components/AppHeader'
import { LoadingSpinner } from '../components/Loading'

/* -------------------- Types & Constants (self-contained) -------------------- */
type Personal = { sex?: string; height?: string; weight?: string }
type Injuries = { list: string[]; notes: string }
type ProfileData = {
  experience?: string
  goals?: string[]
  equipment?: string[]
  personal?: Personal
  injuries?: Injuries
}



/* -------------------- Small UI primitives -------------------- */
function Section({ title, desc, children }: {title:string; desc?:string; children:React.ReactNode}) {
  return (
    <div className="rounded-2xl border border-gray-200 bg-white/70 backdrop-blur-sm p-4 sm:p-5 shadow-sm">
      <div className="mb-3">
        <h3 className="font-semibold text-gray-900">{title}</h3>
        {desc && <p className="text-sm text-gray-600">{desc}</p>}
      </div>
      {children}
    </div>
  )
}
function Pill({ active, children, onClick }: {active?:boolean; children:React.ReactNode; onClick:()=>void}) {
  return (
    <button
      onClick={onClick}
      className={[
        'px-3 py-2 rounded-xl border text-sm transition-all duration-200 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2',
        active ? 'bg-gradient-to-br from-blue-500 to-indigo-600 text-white border-blue-500 shadow-md scale-[1.02]' : 'bg-white/70 hover:bg-white border-gray-200 hover:border-blue-300 text-gray-700 hover:scale-[1.01]'
      ].join(' ')}
    >
      {children}
    </button>
  )
}
function GridSelect({
  items, selected, onToggle, twoCol=false
}: {items:string[]; selected:string[]; onToggle:(_v:string)=>void; twoCol?:boolean}) {
  return (
    <div className={twoCol ? 'grid grid-cols-2 gap-2' : 'flex flex-wrap gap-2'}>
      {items.map(v => (
        <Pill key={v} active={selected.includes(v)} onClick={() => onToggle(v)}>{v}</Pill>
      ))}
    </div>
  )
}

/* -------------------- Profile page -------------------- */
export default function Profile() {
  const uid = auth.currentUser?.uid || ''
  const displayId = auth.currentUser?.email || auth.currentUser?.phoneNumber || 'User'

  const [loading, setLoading] = useState(true)
  const [saving, setSaving] = useState(false)
  const [saved, setSaved] = useState<ProfileData | null>(null)
  const [draft, setDraft] = useState<ProfileData>({
    experience: undefined,
    goals: [],
    equipment: [],
    personal: { sex:'', height:'', weight:'' },
    injuries: { list:[], notes:'' }
  })

  // Load profile
  useEffect(() => {
    (async () => {
      if (!uid) return setLoading(false)
      try {
        const snap = await getDoc(doc(db, 'users', uid))
        if (snap.exists()) {
          const data = snap.data() as ProfileData
          setSaved(data)
          setDraft({
            experience: data.experience ?? undefined,
            goals: data.goals ?? [],
            equipment: data.equipment ?? [],
            personal: {
              sex: data.personal?.sex ?? '',
              height: data.personal?.height ?? '',
              weight: data.personal?.weight ?? '',
            },
            injuries: {
              list: data.injuries?.list ?? [],
              notes: data.injuries?.notes ?? '',
            },
          })
        }
      } catch (error) {
        console.error('Error loading profile:', error)
        // Handle permission errors gracefully
      } finally {
        setLoading(false)
      }
    })()
  }, [uid])

  // Helpers
  const hasChanges = useMemo(() => JSON.stringify(draft) !== JSON.stringify(saved ?? {}), [draft, saved])
  const invalid =
    !draft.experience ||
    !draft.personal?.height ||
    !draft.personal?.weight ||
    (draft.goals?.length ?? 0) === 0 ||
    (draft.equipment?.length ?? 0) === 0

  const toggle = (list: string[] = [], v: string, allowNone = false) => {
    const isNone = v.startsWith('None')
    if (allowNone && isNone) return [v] // clears others
    if (allowNone && list.some(x => x.startsWith('None'))) list = list.filter(x => !x.startsWith('None'))
    return list.includes(v) ? list.filter(x => x !== v) : [...list, v]
  }

  // Actions
  const save = async () => {
    if (!uid || invalid) return
    setSaving(true)
    try {
      await setDoc(doc(db, 'users', uid), draft, { merge: true })
      setSaved(draft)
    } finally {
      setSaving(false)
    }
  }

  const reset = () => {
    if (!saved) return
    setDraft(JSON.parse(JSON.stringify(saved)))
  }



  if (loading) {
    return <LoadingSpinner fullScreen text="Loading profile..." />
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 via-white to-indigo-50 relative">
      {/* Background decoration */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute -top-40 -right-40 w-80 h-80 bg-gradient-to-br from-blue-200/30 to-indigo-200/30 rounded-full blur-3xl" />
        <div className="absolute -bottom-40 -left-40 w-80 h-80 bg-gradient-to-tr from-indigo-200/30 to-blue-200/30 rounded-full blur-3xl" />
      </div>

      <AppHeader />

      {/* Body */}
      <main className="relative mx-auto max-w-4xl px-6 pb-14 pt-6">
        {/* Identity */}
        <div className="mb-6 rounded-2xl border border-gray-200 bg-white/70 backdrop-blur-sm p-5 shadow-sm">
          <div>
            <div className="text-sm text-gray-500">Signed in as</div>
            <div className="text-lg font-semibold text-gray-900">{displayId}</div>
          </div>
        </div>

        {/* Editable sections */}
        <div className="grid grid-cols-1 gap-5 md:grid-cols-2">
          <Section title="Experience" desc="We calibrate volume, intensity, and progressions.">
            <div className="flex flex-wrap gap-2">
              {EXPERIENCE_LEVELS.map(l => (
                <Pill
                  key={l}
                  active={draft.experience === l}
                  onClick={() => setDraft(d => ({ ...d, experience: l }))}
                >
                  {l}
                </Pill>
              ))}
            </div>
          </Section>

          <Section title="Goals" desc="Pick one or more training goals.">
            <GridSelect
              items={GOALS}
              selected={draft.goals ?? []}
              onToggle={(v) => setDraft(d => ({ ...d, goals: toggle(d.goals, v) }))}
            />
          </Section>

          <Section title="Equipment" desc="Only movements using your equipment are included.">
            <GridSelect
              items={EQUIPMENT}
              selected={draft.equipment ?? []}
              onToggle={(v) => setDraft(d => ({ ...d, equipment: toggle(d.equipment, v, true) }))}
              twoCol
            />
            <p className="mt-2 text-xs text-slate-500">Tip: Selecting “None (Bodyweight)” clears other selections.</p>
          </Section>

          <Section title="Personal" desc="Ranges help personalize while keeping exact numbers private.">
            <div className="grid gap-6">
              {/* Sex Options */}
              <div>
                <div className="mb-3 text-sm font-semibold text-gray-700">Gender</div>
                <div className="grid grid-cols-3 gap-3">
                  {SEX_OPTIONS.map(s => (
                    <Pill
                      key={s}
                      active={draft.personal?.sex === s}
                      onClick={() => setDraft(d => ({ ...d, personal: { ...d.personal, sex: s } }))}
                    >
                      {s}
                    </Pill>
                  ))}
                </div>
              </div>

              {/* Height Range */}
              <div>
                <div className="mb-3 text-sm font-semibold text-gray-700">Height Range</div>
                <div className="grid grid-cols-3 gap-3">
                  {HEIGHT_RANGES.map(h => (
                    <Pill
                      key={h}
                      active={draft.personal?.height === h}
                      onClick={() => setDraft(d => ({ ...d, personal: { ...d.personal, height: h } }))}
                    >
                      {h}
                    </Pill>
                  ))}
                </div>
              </div>

              {/* Weight Range */}
              <div>
                <div className="mb-3 text-sm font-semibold text-gray-700">Weight Range</div>
                <div className="grid grid-cols-3 gap-3">
                  {WEIGHT_RANGES.map(w => (
                    <Pill
                      key={w}
                      active={draft.personal?.weight === w}
                      onClick={() => setDraft(d => ({ ...d, personal: { ...d.personal, weight: w } }))}
                    >
                      {w}
                    </Pill>
                  ))}
                </div>
              </div>
            </div>
          </Section>

          <Section title="Injuries" desc="We’ll avoid risky movements and include safe modifications.">
            <GridSelect
              items={INJURY_OPTIONS}
              selected={draft.injuries?.list ?? []}
              onToggle={(v) =>
                setDraft(d => {
                  const currentInjuries = d.injuries || { list: [], notes: '' }
                  if (v === 'None') return { ...d, injuries: { ...currentInjuries, list: ['None'] } }
                  const list = (currentInjuries.list || []).filter(x => x !== 'None')
                  const next = list.includes(v) ? list.filter(x => x !== v) : [...list, v]
                  return { ...d, injuries: { ...currentInjuries, list: next } }
                })
              }
              twoCol
            />
            <textarea
              className="mt-3 w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm text-slate-900 outline-none placeholder:text-slate-400 focus:ring-2 focus:ring-emerald-500"
              rows={3}
              placeholder="Notes (optional)…"
              value={draft.injuries?.notes ?? ''}
              onChange={(e) => setDraft(d => {
                const currentInjuries = d.injuries || { list: [], notes: '' }
                return { ...d, injuries: { ...currentInjuries, notes: e.target.value } }
              })}
            />
          </Section>
        </div>

        {/* Save bar */}
        <div className="sticky bottom-0 mt-6 rounded-2xl border border-white/15 bg-white/10 p-4 backdrop-blur">
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="text-sm">
              {invalid ? (
                <span className="text-amber-300">Complete all required fields to save.</span>
              ) : hasChanges ? (
                <span className="text-emerald-300">Unsaved changes</span>
              ) : (
                <span className="text-white/70">All changes saved</span>
              )}
            </div>
            <div className="flex gap-3">
              <button
                onClick={reset}
                disabled={!hasChanges}
                className="rounded-xl border border-white/20 bg-white/5 px-4 py-2 text-white/90 hover:bg-white/10 disabled:opacity-50"
              >
                Reset
              </button>
              <button
                onClick={save}
                disabled={invalid || !hasChanges || saving}
                className={[
                  'rounded-xl px-5 py-2 font-semibold',
                  invalid || !hasChanges || saving
                    ? 'bg-emerald-500/40 text-white/80 cursor-not-allowed'
                    : 'bg-emerald-500 text-slate-950 hover:bg-emerald-400'
                ].join(' ')}
              >
                {saving ? 'Saving…' : 'Save changes'}
              </button>
            </div>
          </div>
        </div>
      </main>
    </div>
  )
}

========================================
FILE: src/pages/Subscription.tsx
========================================

import { useState } from 'react'
import { useNavigate } from 'react-router-dom'
import { ArrowLeft } from 'lucide-react'
import AppHeader from '../components/AppHeader'
import { SubscriptionManager } from '../components/SubscriptionManager'
import { PaymentForm } from '../components/PaymentForm'
import { SubscriptionSuccess } from '../components/SubscriptionSuccess'
import { useSubscription } from '../hooks/useSubscription'

import { getSubscriptionPlanByPriceId } from '../lib/stripe-config'

type ViewState = 'plans' | 'payment' | 'success' | 'manage'

export default function Subscription() {
  const navigate = useNavigate()
  const { hasUnlimitedWorkouts } = useSubscription()

  const [currentView, setCurrentView] = useState<ViewState>(
    hasUnlimitedWorkouts ? 'manage' : 'plans'
  )
  const [selectedPriceId, setSelectedPriceId] = useState<string>('')
  // Removed unused variables for cleaner code

  const handlePaymentSuccess = () => {
    setCurrentView('success')
    // The PaymentForm component now handles subscription synchronization
    // We'll refresh the page after a longer delay to ensure everything is synced
    setTimeout(() => {
      window.location.reload()
    }, 5000)
  }

  const handlePaymentError = (error: string) => {
    console.error('Payment error:', error)
    // Stay on payment form to allow retry
  }

  const handleBackToPlans = () => {
    setCurrentView('plans')
    setSelectedPriceId('')
  }

  // Removed unused handleUpgrade function

  const selectedPlan = getSubscriptionPlanByPriceId(selectedPriceId)

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 via-white to-indigo-50">
      {/* Background decoration */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute -top-40 -right-40 w-80 h-80 bg-gradient-to-br from-blue-200/30 to-indigo-200/30 rounded-full blur-3xl" />
        <div className="absolute -bottom-40 -left-40 w-80 h-80 bg-gradient-to-tr from-indigo-200/30 to-blue-200/30 rounded-full blur-3xl" />
      </div>

      <AppHeader />

      <main className="relative mx-auto max-w-4xl px-4 sm:px-6 pb-16 pt-6">
        {/* Header */}
        <div className="mb-8">
          <button
            onClick={() => navigate(-1)}
            className="flex items-center gap-2 text-gray-600 hover:text-gray-900 transition-colors mb-4"
          >
            <ArrowLeft className="w-4 h-4" />
            Back
          </button>
          
          <h1 className="text-3xl font-bold text-gray-900">
            {currentView === 'plans' && 'Choose Your Plan'}
            {currentView === 'payment' && 'Complete Your Subscription'}
            {currentView === 'success' && 'Welcome to NeuraFit Pro!'}
            {currentView === 'manage' && 'Manage Subscription'}
          </h1>
          
          {currentView === 'payment' && selectedPlan && (
            <p className="mt-2 text-gray-600">
              You're subscribing to {selectedPlan.name}
            </p>
          )}
        </div>

        {/* Content */}
        <div className="bg-white rounded-3xl border border-gray-200 shadow-lg p-6 md:p-8">
          {currentView === 'plans' && (
            <SubscriptionManager
              mode="plans"
              onClose={() => navigate('/dashboard')}
              onSuccess={() => setCurrentView('success')}
            />
          )}

          {currentView === 'payment' && (
            <div className="max-w-md mx-auto">
              <div className="text-center mb-8">
                <h2 className="text-xl font-semibold text-gray-900 mb-2">
                  Complete Your Subscription
                </h2>
                {selectedPlan && (
                  <div className="bg-blue-50 rounded-lg p-4">
                    <p className="font-medium text-blue-900">{selectedPlan.name}</p>
                    <p className="text-blue-700">{selectedPlan.description}</p>
                    <p className="text-2xl font-bold text-blue-900 mt-2">
                      ${selectedPlan.price / 100}/{selectedPlan.interval}
                    </p>
                  </div>
                )}
              </div>
              
              <PaymentForm
                priceId={selectedPriceId}
                onSuccess={handlePaymentSuccess}
                onError={handlePaymentError}
                onCancel={handleBackToPlans}
              />
            </div>
          )}

          {currentView === 'success' && (
            <SubscriptionSuccess
              onContinue={() => navigate('/generate')}
              planName={selectedPlan?.name}
            />
          )}

          {currentView === 'manage' && (
            <SubscriptionManager mode="management" />
          )}
        </div>
      </main>
    </div>
  )
}

========================================
FILE: src/pages/Terms.tsx
========================================

// src/pages/Terms.tsx
import { Link } from 'react-router-dom'

export default function Terms() {
  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 via-white to-blue-50/30 text-gray-900">
      <div className="mx-auto max-w-3xl px-6 py-12">
        <header className="mb-8">
          <Link to="/" className="text-blue-600 hover:text-blue-700 font-medium">← Back</Link>
          <h1 className="mt-4 text-3xl md:text-4xl font-bold tracking-tight">Terms of Service</h1>
          <p className="mt-2 text-gray-600">Last updated: September 30, 2025</p>
        </header>

        {/* Table of contents */}
        <nav aria-label="Table of contents" className="mb-8 rounded-2xl border border-gray-200 bg-white/60 backdrop-blur-sm p-4">
          <p className="text-sm font-semibold text-gray-900 mb-3">Table of contents</p>
          <ul className="grid grid-cols-1 sm:grid-cols-2 gap-2 text-sm text-blue-700">
            <li><a href="#acceptance-of-terms" className="hover:underline">1) Acceptance of Terms</a></li>
            <li><a href="#not-medical-advice" className="hover:underline">2) Not Medical Advice</a></li>
            <li><a href="#ai-limitations" className="hover:underline">3) AI Technology & Limitations</a></li>
            <li><a href="#eligibility-and-accounts" className="hover:underline">4) Eligibility & Accounts</a></li>
            <li><a href="#user-responsibilities-and-safety" className="hover:underline">5) User Responsibilities & Safety</a></li>
            <li><a href="#acceptable-use" className="hover:underline">6) Acceptable Use Policy</a></li>
            <li><a href="#intellectual-property" className="hover:underline">7) Intellectual Property</a></li>
            <li><a href="#privacy" className="hover:underline">8) Privacy & Data Protection</a></li>
            <li><a href="#disclaimers" className="hover:underline">9) Disclaimers</a></li>
            <li><a href="#limitation-of-liability" className="hover:underline">10) Limitation of Liability</a></li>
            <li><a href="#indemnification" className="hover:underline">11) Indemnification</a></li>
            <li><a href="#modifications" className="hover:underline">12) Modifications</a></li>
            <li><a href="#governing-law" className="hover:underline">13) Governing Law</a></li>
            <li><a href="#subscriptions-billing" className="hover:underline">14) Subscriptions & Billing</a></li>
            <li><a href="#termination" className="hover:underline">15) Account Termination</a></li>
            <li><a href="#arbitration" className="hover:underline">16) Dispute Resolution</a></li>
            <li><a href="#contact" className="hover:underline">17) Contact Information</a></li>
          </ul>
        </nav>

        <div className="space-y-8 text-sm leading-relaxed text-gray-700">
          <section>
            <h2 id="acceptance-of-terms" className="text-lg font-semibold text-gray-900">1) Acceptance of Terms</h2>
            <p className="mt-2">These Terms of Service ("Terms") govern your access to and use of the NeuraFit application and services ("Services"). By creating an account, signing in, or using the Services, you agree to be bound by these Terms. If you do not agree to these Terms, do not use the Services.</p>
          </section>

          <section>
            <h2 id="not-medical-advice" className="text-lg font-semibold text-gray-900">2) Not Medical Advice</h2>
            <p className="mt-2"><strong>IMPORTANT:</strong> NeuraFit provides AI-generated workout content for informational and educational purposes only. The Services do not provide medical, health, fitness, or nutritional advice. Our AI-generated workouts are not a substitute for professional medical advice, diagnosis, or treatment.</p>
            <p className="mt-2">Always consult with a physician, certified personal trainer, or other qualified health professional before starting any fitness program, especially if you:</p>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Have any medical conditions, injuries, or physical limitations</li>
              <li>Are pregnant or nursing</li>
              <li>Are taking medications that may affect your ability to exercise</li>
              <li>Have not exercised regularly in the past six months</li>
              <li>Are over 35 years old and beginning a new exercise program</li>
            </ul>
            <p className="mt-2">If you experience pain, dizziness, shortness of breath, chest pain, or other adverse symptoms during exercise, stop immediately and seek medical attention.</p>
          </section>

          <section>
            <h2 id="ai-limitations" className="text-lg font-semibold text-gray-900">3) AI Technology and Limitations</h2>
            <p className="mt-2">NeuraFit uses artificial intelligence to generate personalized workout recommendations based on the information you provide. You acknowledge and understand that:</p>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>AI-generated content may be inaccurate, incomplete, or inappropriate for your specific circumstances</li>
              <li>The AI cannot assess your real-time physical condition, form, or safety</li>
              <li>AI recommendations are based solely on the data you input and may not account for all relevant factors</li>
              <li>The AI is not a substitute for professional coaching, supervision, or medical guidance</li>
              <li>You are solely responsible for evaluating the suitability and safety of any recommended exercises</li>
            </ul>
            <p className="mt-2">You agree to use your own judgment and consult with qualified professionals when determining whether to follow AI-generated recommendations.</p>
          </section>

          <section>
            <h2 id="eligibility-and-accounts" className="text-lg font-semibold text-gray-900">4) Eligibility & Account Requirements</h2>
            <p className="mt-2">You must be at least 18 years old to use the Services. If you are under 18, you may not use the Services.</p>
            <p className="mt-2">You are responsible for:</p>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Maintaining the confidentiality and security of your account credentials</li>
              <li>All activities that occur under your account</li>
              <li>Providing accurate, complete, and current information</li>
              <li>Promptly updating your information when it changes</li>
              <li>Notifying us immediately of any unauthorized use of your account</li>
            </ul>
          </section>

          <section>
            <h2 id="user-responsibilities-and-safety" className="text-lg font-semibold text-gray-900">5) User Responsibilities & Safety</h2>
            <p className="mt-2">By using the Services, you agree to:</p>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Exercise at your own risk and within your physical capabilities</li>
              <li>Perform proper warm-up and cool-down routines</li>
              <li>Use proper form, technique, and safety precautions</li>
              <li>Use properly maintained equipment and exercise in safe environments</li>
              <li>Choose weights, intensities, and progressions appropriate for your fitness level</li>
              <li>Modify, skip, or stop any exercise that feels unsafe or causes discomfort</li>
              <li>Stay hydrated and take appropriate rest periods</li>
              <li>Comply with all applicable laws, gym policies, and facility guidelines</li>
              <li>Provide accurate information about your fitness level, injuries, and limitations</li>
            </ul>
            <p className="mt-2"><strong>You acknowledge that physical exercise involves inherent risks of injury, and you voluntarily assume all such risks.</strong></p>
          </section>

          <section>
            <h2 id="acceptable-use" className="text-lg font-semibold text-gray-900">6) Acceptable Use Policy</h2>
            <p className="mt-2">You agree not to:</p>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Use the Services for any unlawful purpose or in violation of these Terms</li>
              <li>Reverse engineer, decompile, or attempt to extract source code from the Services</li>
              <li>Use automated systems (bots, scrapers) to access or abuse the Services</li>
              <li>Upload, transmit, or distribute harmful content, malware, or viruses</li>
              <li>Engage in harassment, hate speech, or discrimination</li>
              <li>Infringe upon intellectual property rights of others</li>
              <li>Attempt to gain unauthorized access to our systems or other users' accounts</li>
              <li>Use the Services to compete with or create derivative products</li>
              <li>Share your account credentials with others</li>
            </ul>
          </section>

          <section>
            <h2 id="intellectual-property" className="text-lg font-semibold text-gray-900">7) Intellectual Property Rights</h2>
            <p className="mt-2">The Services, including all content, features, functionality, software, text, graphics, logos, images, and trademarks, are owned by NeuraFit or its licensors and are protected by copyright, trademark, and other intellectual property laws.</p>
            <p className="mt-2">Subject to these Terms, we grant you a limited, non-exclusive, non-transferable, revocable license to access and use the Services solely for your personal, non-commercial purposes. This license does not include any right to:</p>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Resell, redistribute, or commercially exploit the Services</li>
              <li>Modify, adapt, or create derivative works</li>
              <li>Remove or alter any proprietary notices</li>
              <li>Use our trademarks or branding without permission</li>
            </ul>
          </section>

          <section>
            <h2 id="privacy" className="text-lg font-semibold text-gray-900">8) Privacy and Data Protection</h2>
            <p className="mt-2">Your privacy is important to us. Your use of the Services is governed by our <Link to="/privacy" className="text-blue-600 hover:text-blue-700 underline">Privacy Policy</Link>, which explains how we collect, use, and protect your information. By using the Services, you consent to our data practices as described in the Privacy Policy.</p>
          </section>

          <section>
            <h2 id="disclaimers" className="text-lg font-semibold text-gray-900">9) Disclaimers</h2>
            <p className="mt-2">THE SERVICES ARE PROVIDED "AS IS" AND "AS AVAILABLE," WITHOUT WARRANTIES OF ANY KIND, EXPRESS OR IMPLIED. WE DISCLAIM ALL WARRANTIES INCLUDING MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT. WE DO NOT WARRANT THAT THE SERVICES WILL BE ACCURATE, RELIABLE, ERROR-FREE, UNINTERRUPTED, OR SAFE.</p>
            <p className="mt-2">WE SPECIFICALLY DISCLAIM ANY WARRANTIES REGARDING THE SAFETY, EFFECTIVENESS, OR SUITABILITY OF AI-GENERATED WORKOUT RECOMMENDATIONS FOR YOUR PARTICULAR CIRCUMSTANCES.</p>
          </section>

          <section>
            <h2 id="limitation-of-liability" className="text-lg font-semibold text-gray-900">10) Limitation of Liability</h2>
            <p className="mt-2">TO THE MAXIMUM EXTENT PERMITTED BY LAW, NEURAFIT SHALL NOT BE LIABLE FOR ANY INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL, OR PUNITIVE DAMAGES, INCLUDING BUT NOT LIMITED TO PERSONAL INJURY, PROPERTY DAMAGE, LOST PROFITS, OR DATA LOSS, ARISING FROM YOUR USE OF THE SERVICES.</p>
            <p className="mt-2">OUR TOTAL LIABILITY TO YOU FOR ALL CLAIMS ARISING FROM OR RELATING TO THE SERVICES SHALL NOT EXCEED THE AMOUNT YOU PAID US IN THE TWELVE MONTHS PRECEDING THE CLAIM, OR $100, WHICHEVER IS GREATER.</p>
          </section>

          <section>
            <h2 id="indemnification" className="text-lg font-semibold text-gray-900">11) Indemnification</h2>
            <p className="mt-2">You agree to indemnify, defend, and hold harmless NeuraFit, its officers, directors, employees, and agents from and against any claims, liabilities, damages, losses, costs, and expenses (including reasonable attorneys' fees) arising from or relating to your use of the Services, violation of these Terms, or infringement of any rights of another.</p>
          </section>

          <section>
            <h2 id="modifications" className="text-lg font-semibold text-gray-900">12) Modifications to Terms</h2>
            <p className="mt-2">We may update these Terms from time to time to reflect changes in our Services, legal requirements, or business practices. We will notify you of material changes by posting the updated Terms in the app or by other reasonable means. Your continued use of the Services after changes become effective constitutes acceptance of the updated Terms.</p>
          </section>

          <section>
            <h2 id="governing-law" className="text-lg font-semibold text-gray-900">13) Governing Law and Jurisdiction</h2>
            <p className="mt-2">These Terms are governed by the laws of the State of California, United States, without regard to conflict-of-law principles. Any disputes arising from these Terms or the Services shall be subject to the exclusive jurisdiction of the state and federal courts located in San Francisco County, California, except as provided in the arbitration clause below.</p>
          </section>

          <section>
            <h2 id="subscriptions-billing" className="text-lg font-semibold text-gray-900">14) Subscriptions and Billing</h2>
            <p className="mt-2">Some features may be offered on a paid subscription basis. By purchasing a subscription, you authorize us to charge your payment method on a recurring basis until you cancel. Key terms include:</p>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li><strong>Auto-renewal:</strong> Subscriptions automatically renew at the current price unless canceled before the renewal date</li>
              <li><strong>Cancellation:</strong> You may cancel at any time; access continues through the end of the current billing period</li>
              <li><strong>Refunds:</strong> Handled according to platform policies (App Store/Google Play) and applicable law</li>
              <li><strong>Price changes:</strong> We may change prices with advance notice; changes apply at your next renewal</li>
              <li><strong>Taxes:</strong> Additional taxes may apply based on your location</li>
            </ul>
          </section>

          <section>
            <h2 id="termination" className="text-lg font-semibold text-gray-900">15) Account Termination</h2>
            <p className="mt-2">You may terminate your account at any time by contacting us or using the account deletion feature in the app. Upon termination:</p>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Your access to the Services will be immediately suspended</li>
              <li>Your personal data will be deleted within 30 days (except as required for legal compliance)</li>
              <li>Any active subscriptions will be canceled according to the platform's refund policy</li>
              <li>These Terms will remain in effect for any claims or disputes that arose before termination</li>
            </ul>
            <p className="mt-2">We may suspend or terminate your account if you violate these Terms, engage in harmful behavior, or for other legitimate business reasons. We will provide reasonable notice when possible.</p>
          </section>

          <section>
            <h2 id="arbitration" className="text-lg font-semibold text-gray-900">16) Dispute Resolution and Arbitration</h2>
            <p className="mt-2">Most disputes can be resolved informally by contacting us at support@neurafit.app. For disputes that cannot be resolved informally, you and NeuraFit agree to resolve them through binding arbitration rather than in court, except for small claims court matters and injunctive relief.</p>
            <p className="mt-2"><strong>Class Action Waiver:</strong> You and NeuraFit agree that any dispute resolution proceedings will be conducted only on an individual basis and not in a class, consolidated, or representative action.</p>
          </section>

          <section>
            <h2 id="contact" className="text-lg font-semibold text-gray-900">17) Contact Information</h2>
            <p className="mt-2">If you have questions about these Terms or need to contact us for any reason, please reach out to us:</p>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li><strong>Email:</strong> support@neurafit.app</li>
              <li><strong>Legal Inquiries:</strong> legal@neurafit.app</li>
              <li><strong>Response Time:</strong> We typically respond within 48 hours</li>
            </ul>
            <p className="mt-2">For formal legal notices, please send correspondence to our registered address, which can be obtained by contacting us at the email addresses above.</p>
          </section>

          <footer className="pt-8 border-t border-gray-200 text-center">
            <p className="text-gray-600">
              See also our <Link to="/privacy" className="text-blue-600 hover:text-blue-700 underline">Privacy Policy</Link> for information about how we handle your data.
            </p>
          </footer>
        </div>
      </div>
    </div>
  )
}

========================================
FILE: src/pages/WorkoutDetail.tsx
========================================

// src/pages/WorkoutDetail.tsx
import { useEffect, useState } from 'react'
import { useNavigate, useParams } from 'react-router-dom'
import { auth, db } from '../lib/firebase'
import { doc, getDoc } from 'firebase/firestore'
import { convertToDate } from '../utils/timestamp'
import { ArrowLeft, Clock, Calendar, CheckCircle, XCircle, Weight } from 'lucide-react'
import AppHeader from '../components/AppHeader'
import { WorkoutDetailSkeleton } from '../components/Loading'

type Exercise = {
  name: string
  sets: number
  reps: string | number
  weights?: Record<number, number | null>
  usesWeight?: boolean
  description?: string
  formTips?: string[]
  safetyTips?: string[]
  restSeconds?: number
}

type WorkoutData = {
  id: string
  workoutType: string
  duration: number
  plannedDuration?: number
  exercises: Exercise[]
  timestamp: Date | { toDate(): Date } | string
}

export default function WorkoutDetail() {
  const { workoutId } = useParams<{ workoutId: string }>()
  const nav = useNavigate()
  const [workout, setWorkout] = useState<WorkoutData | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    const fetchWorkout = async () => {
      try {
        const uid = auth.currentUser?.uid
        if (!uid || !workoutId) {
          setError('Invalid workout or user')
          return
        }

        const workoutDoc = await getDoc(doc(db, 'users', uid, 'workouts', workoutId))
        if (!workoutDoc.exists()) {
          setError('Workout not found')
          return
        }

        setWorkout({ id: workoutDoc.id, ...workoutDoc.data() } as WorkoutData)
      } catch (err) {
        const error = err as { message?: string }
        console.error('Error fetching workout:', error)
        setError(error.message || 'Failed to load workout')
      } finally {
        setLoading(false)
      }
    }

    fetchWorkout()
  }, [workoutId])

  if (loading) {
    return <WorkoutDetailSkeleton />
  }

  if (error || !workout) {
    return (
      <div className="min-h-screen bg-white">
        <div className="max-w-md mx-auto px-6 py-8">
          <div className="text-center">
            <XCircle className="h-12 w-12 text-red-500 mx-auto mb-4" />
            <h1 className="text-xl font-semibold text-gray-900 mb-2">Workout Not Found</h1>
            <p className="text-gray-600 mb-6">{error || 'This workout could not be loaded.'}</p>
            <button
              onClick={() => nav('/history')}
              className="inline-flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
            >
              <ArrowLeft className="h-4 w-4" />
              Back to History
            </button>
          </div>
        </div>
      </div>
    )
  }

  const formatDate = (timestamp: Date | { toDate(): Date } | string) => {
    if (!timestamp) return 'Unknown date'
    const date = convertToDate(timestamp)
    return date.toLocaleDateString('en-US', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    })
  }

  const formatTime = (timestamp: Date | { toDate(): Date } | string) => {
    if (!timestamp) return 'Unknown time'
    const date = convertToDate(timestamp)
    return date.toLocaleTimeString('en-US', {
      hour: 'numeric',
      minute: '2-digit',
      hour12: true
    })
  }

  const formatEndTime = (timestamp: Date | { toDate(): Date } | string, duration: number) => {
    if (!timestamp) return 'Unknown time'
    const startDate = convertToDate(timestamp)
    const endDate = new Date(startDate.getTime() + duration * 60 * 1000) // Add duration in milliseconds
    return endDate.toLocaleTimeString('en-US', {
      hour: 'numeric',
      minute: '2-digit',
      hour12: true
    })
  }

  const calculateExerciseStats = (exercise: Exercise) => {
    const hasWeights = exercise.weights && Object.values(exercise.weights).some(w => w !== null && w > 0)
    const totalSets = exercise.sets

    let completedSets = 0
    let isCompleted = false

    if (exercise.weights) {
      // Count all entries with non-null values (including 0 which indicates completed sets)
      // null values indicate skipped sets
      completedSets = Object.values(exercise.weights).filter(w => w !== null).length
    } else {
      // No weights data means no sets were tracked (shouldn't happen with new system)
      completedSets = 0
    }
    // Exercise is considered completed if it has ANY completed sets (consistent with History.tsx)
    isCompleted = completedSets > 0

    let avgWeight = null
    let maxWeight = null
    let minWeight = null

    if (hasWeights && exercise.usesWeight) {
      // Only consider actual weight values (> 0) for statistics, not completion markers (0)
      const weights = Object.values(exercise.weights!).filter(w => w !== null && w > 0) as number[]
      if (weights.length > 0) {
        avgWeight = Math.round(weights.reduce((sum, w) => sum + w, 0) / weights.length)
        maxWeight = Math.max(...weights)
        minWeight = Math.min(...weights)
      }
    }

    return { hasWeights, completedSets, totalSets, isCompleted, avgWeight, maxWeight, minWeight }
  }

  const totalExercises = workout.exercises.length
  const completedExercises = workout.exercises.filter(ex => {
    const stats = calculateExerciseStats(ex)
    return stats.isCompleted
  }).length

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 via-white to-indigo-50 relative text-gray-900">
      {/* Background decoration */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute -top-40 -right-40 w-80 h-80 bg-gradient-to-br from-blue-200/30 to-indigo-200/30 rounded-full blur-3xl" />
        <div className="absolute -bottom-40 -left-40 w-80 h-80 bg-gradient-to-tr from-indigo-200/30 to-blue-200/30 rounded-full blur-3xl" />
      </div>

      <AppHeader />

      {/* Main Content */}
      <main className="relative max-w-4xl mx-auto px-6 py-8">
        {/* Workout Overview */}
        <div className="bg-gradient-to-r from-blue-50 to-cyan-50 rounded-2xl p-6 mb-8">
          <div className="flex items-start justify-between mb-6">
            <div className="flex-1">
              <h1 className="text-2xl font-bold text-gray-900 mb-3">{workout.workoutType}</h1>
              <div className="flex items-center gap-4 text-sm text-gray-600">
                <div className="flex items-center gap-1">
                  <Calendar className="h-4 w-4" />
                  <span>{formatDate(workout.timestamp)}</span>
                </div>
                <div className="flex items-center gap-1">
                  <Clock className="h-4 w-4" />
                  <span>{formatTime(workout.timestamp)}</span>
                </div>
              </div>
            </div>
            <div className="text-right ml-6">
              <div className="text-3xl font-bold text-blue-600 mb-1">{workout.duration}</div>
              <div className="text-sm text-gray-600 mb-2">minutes</div>
              <div className="text-xs text-gray-500">
                Ended {formatEndTime(workout.timestamp, workout.duration)}
              </div>
            </div>
          </div>

          {/* Progress Summary */}
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4 pt-4 border-t border-blue-100">
            <div className="text-center">
              <div className="text-lg font-semibold text-gray-900">{totalExercises}</div>
              <div className="text-sm text-gray-600">Total Exercises</div>
            </div>
            <div className="text-center">
              <div className="text-lg font-semibold text-green-600">{completedExercises}</div>
              <div className="text-sm text-gray-600">Completed</div>
            </div>
            <div className="text-center">
              <div className="text-lg font-semibold text-blue-600">
                {Math.round((completedExercises / totalExercises) * 100)}%
              </div>
              <div className="text-sm text-gray-600">Success Rate</div>
            </div>
            <div className="text-center">
              <div className="text-lg font-semibold text-gray-900">
                {workout.exercises.reduce((total, ex) => {
                  const stats = calculateExerciseStats(ex)
                  return total + stats.completedSets
                }, 0)}
              </div>
              <div className="text-sm text-gray-600">Total Sets</div>
            </div>
          </div>
        </div>

        {/* Exercise Details */}
        <div className="space-y-4">
          <h2 className="text-xl font-semibold text-gray-900 mb-4">Exercise Details</h2>
          {workout.exercises.map((exercise, index) => {
            const stats = calculateExerciseStats(exercise)
            
            return (
              <div key={index} className="bg-white border border-gray-200 rounded-xl p-6">
                <div className="flex items-start justify-between mb-4">
                  <div className="flex-1">
                    <h3 className="text-lg font-semibold text-gray-900 mb-1">{exercise.name}</h3>
                    <div className="flex items-center gap-4 text-sm text-gray-600">
                      <span>{exercise.sets} sets × {exercise.reps} reps</span>
                      {stats.hasWeights && stats.avgWeight && (
                        <span className="text-blue-600 font-medium">@ {stats.avgWeight}lbs avg</span>
                      )}
                    </div>
                  </div>
                  <div className="flex items-center gap-2">
                    {stats.isCompleted ? (
                      <CheckCircle className="h-6 w-6 text-green-500" />
                    ) : (
                      <XCircle className="h-6 w-6 text-red-500" />
                    )}
                    <span className="text-sm font-medium text-gray-700">
                      {stats.completedSets}/{stats.totalSets} sets
                    </span>
                  </div>
                </div>

                {/* Weight Summary for weight-based exercises */}
                {stats.hasWeights && exercise.usesWeight && (
                  <div className="bg-gray-50 rounded-lg p-4 mb-4">
                    <div className="flex items-center gap-2 mb-3">
                      <Weight className="h-4 w-4 text-gray-600" />
                      <span className="font-medium text-gray-900">Weight Summary</span>
                    </div>
                    <div className="grid grid-cols-3 gap-4 text-sm">
                      <div className="text-center">
                        <div className="font-semibold text-gray-900">{stats.avgWeight}lbs</div>
                        <div className="text-gray-600">Average</div>
                      </div>
                      <div className="text-center">
                        <div className="font-semibold text-gray-900">{stats.maxWeight}lbs</div>
                        <div className="text-gray-600">Max</div>
                      </div>
                      <div className="text-center">
                        <div className="font-semibold text-gray-900">{stats.minWeight}lbs</div>
                        <div className="text-gray-600">Min</div>
                      </div>
                    </div>
                  </div>
                )}

                {/* Set-by-Set Details */}
                <div className="bg-gray-50 rounded-lg p-4">
                  <div className="flex items-center gap-2 mb-3">
                    <span className="font-medium text-gray-900">Set Details</span>
                  </div>
                  <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-2">
                    {Array.from({ length: exercise.sets }, (_, i) => {
                      const setNumber = i + 1
                      const weight = exercise.weights?.[setNumber]

                      // Determine if set is completed
                      // weight === null means skipped
                      // weight === 0 means completed without weight
                      // weight > 0 means completed with weight
                      // weight === undefined means set was never attempted (shouldn't happen)
                      const isCompleted = weight !== null && weight !== undefined
                      const wasAttempted = weight !== undefined

                      return (
                        <div
                          key={setNumber}
                          className={`px-3 py-2 rounded-lg text-sm font-medium text-center ${
                            !wasAttempted
                              ? 'bg-gray-100 text-gray-600 border border-gray-200'
                              : isCompleted
                              ? 'bg-green-100 text-green-800 border border-green-200'
                              : 'bg-red-100 text-red-800 border border-red-200'
                          }`}
                        >
                          <div className="font-semibold">Set {setNumber}</div>
                          <div className="text-xs mt-1">
                            {!wasAttempted ? (
                              'Not attempted'
                            ) : isCompleted ? (
                              exercise.usesWeight && weight > 0 ? `${weight}lbs` : 'Completed'
                            ) : (
                              'Skipped'
                            )}
                          </div>
                        </div>
                      )
                    })}
                  </div>
                </div>


              </div>
            )
          })}
        </div>
      </main>
    </div>
  )
}

========================================
FILE: src/pages/workout/Complete.tsx
========================================

// src/pages/workout/Complete.tsx
import { addDoc, collection, serverTimestamp, doc, updateDoc } from 'firebase/firestore'
import { auth, db } from '../../lib/firebase'
import { useEffect, useState } from 'react'
import { useNavigate } from 'react-router-dom'
import WorkoutFlowHeader from '../../components/WorkoutFlowHeader'
import { isFeedbackUIEnabled } from '../../config/features'
import { trackAdaptiveFeedback, trackCustomEvent } from '../../lib/firebase-analytics'
import { Bed, ThumbsUp, Flame, CheckCircle } from 'lucide-react'
import { trackWorkoutCompleted } from '../../lib/firebase-analytics'

type FeedbackSignal = 'easy' | 'right' | 'hard'

export default function Complete() {
  const nav = useNavigate()
  const [workoutSaved, setWorkoutSaved] = useState(false)
  const [workoutId, setWorkoutId] = useState<string | null>(null)
  const [feedbackSubmitted, setFeedbackSubmitted] = useState(false)
  const [selectedFeedback, setSelectedFeedback] = useState<FeedbackSignal | null>(null)
  const [rpeValue, setRpeValue] = useState<number | null>(null)
  const [submittingFeedback, setSubmittingFeedback] = useState(false)
  const [workoutData, setWorkoutData] = useState<Record<string, unknown> | null>(null)

  // Save workout on component mount
  useEffect(() => {
    (async () => {
      try {
        const saved = sessionStorage.getItem('nf_workout_plan')
        if (!saved) return
        const { plan, type, duration } = JSON.parse(saved) as { plan: { exercises: unknown[] }; type: string; duration: number }
        const uid = auth.currentUser?.uid
        if (!uid) return

        // Get weight data if it exists
        const savedWeights = sessionStorage.getItem('nf_workout_weights')
        const workoutWeights = savedWeights ? JSON.parse(savedWeights) : {}



        // Calculate actual workout duration
        const startTimeStr = sessionStorage.getItem('nf_workout_start_time')
        const actualDuration = startTimeStr
          ? Math.round((Date.now() - parseInt(startTimeStr)) / 1000 / 60) // Convert to minutes
          : duration // Fallback to planned duration if start time not available

        // Enhance exercises with weight data
        const exercisesWithWeights = (plan.exercises as Record<string, unknown>[]).map((exercise, exerciseIndex: number) => ({
          ...exercise,
          weights: workoutWeights[exerciseIndex] || null
        }))

        // Development-only logging
        if (process.env.NODE_ENV === 'development') {
          console.log('[SAVE] Saving workout with the following completion data:')
          exercisesWithWeights.forEach((exercise: Record<string, unknown>, index: number) => {
            console.log(`Exercise ${index}: ${exercise.name}`)
            if (exercise.weights) {
              Object.entries(exercise.weights).forEach(([setNum, weight]) => {
                const status = weight === null ? 'SKIPPED' : weight === 0 ? 'COMPLETED (no weight)' : `COMPLETED (${weight}lbs)`
                console.log(`  Set ${setNum}: ${status}`)
              })
            } else {
              console.log('  No weight data (should not happen with new system)')
            }
          })
        }

        const workoutDoc = {
          timestamp: serverTimestamp(),
          workoutType: type,
          duration: actualDuration,
          plannedDuration: duration, // Keep the planned duration for reference
          exercises: exercisesWithWeights
        }

        const docRef = await addDoc(collection(db, 'users', uid, 'workouts'), workoutDoc)

        // Track workout completion
        const completedExercises = exercisesWithWeights.filter((ex: { weights?: Record<string, unknown> }) =>
          ex.weights && Object.values(ex.weights).some((weight: unknown) => weight !== null)
        ).length
        trackWorkoutCompleted(docRef.id, actualDuration, completedExercises)

        // Store workout data and ID for feedback
        setWorkoutData({ ...workoutDoc, exercises: exercisesWithWeights })
        setWorkoutId(docRef.id)
        setWorkoutSaved(true)

        if (process.env.NODE_ENV === 'development') {
          console.log('[FEEDBACK] Workout saved, should show feedback UI now')
        }

        // Clear the session storage after successful save
        sessionStorage.removeItem('nf_workout_plan')
        sessionStorage.removeItem('nf_workout_weights')
        sessionStorage.removeItem('nf_workout_start_time')
      } catch (error) {
        console.error('Error saving workout:', error)
        // Don't block the user, but log the error
      }
    })()
  }, [])

  // Calculate workout completion rate
  const calculateCompletionRate = (exercises: Record<string, unknown>[]): number => {
    let totalSets = 0
    let completedSets = 0

    exercises.forEach(exercise => {
      if (exercise.weights && typeof exercise.weights === 'object') {
        const setCount = (typeof exercise.sets === 'number' ? exercise.sets : 0) || Object.keys(exercise.weights).length
        totalSets += setCount

        // Count completed sets (non-null weights)
        Object.values(exercise.weights).forEach((weight: unknown) => {
          if (weight !== null) {
            completedSets++
          }
        })
      } else {
        // Fallback: assume all sets completed if no weight data
        const sets = typeof exercise.sets === 'number' ? exercise.sets : 0
        totalSets += sets
        completedSets += sets
      }
    })

    return totalSets > 0 ? completedSets / totalSets : 1.0
  }

  // Submit difficulty feedback
  const submitFeedback = async () => {
    if (!selectedFeedback || !workoutId || !workoutData) return

    setSubmittingFeedback(true)
    try {
      const uid = auth.currentUser?.uid
      if (!uid) return

      // Calculate completion rate
      const completionRate = calculateCompletionRate(workoutData.exercises as Record<string, unknown>[])

      // Update workout document with feedback
      const workoutRef = doc(db, 'users', uid, 'workouts', workoutId)
      await updateDoc(workoutRef, {
        feedback: selectedFeedback,
        rpe: rpeValue,
        completionRate
      })

      // Log telemetry event
      trackAdaptiveFeedback(selectedFeedback, rpeValue, completionRate)

      // For now, we'll update the adaptive state when generating the next workout
      // This ensures we have the most recent feedback and completion data
      if (process.env.NODE_ENV === 'development') {
        console.log('Feedback submitted:', {
          feedback: selectedFeedback,
          rpe: rpeValue,
          completionRate
        })
      }

      setFeedbackSubmitted(true)
    } catch (error) {
      console.error('Error submitting feedback:', error)
      const uid = auth.currentUser?.uid
      if (uid) {
        trackCustomEvent('adaptive_personalization_error', { error: String(error), context: 'feedback_submission' })
      }
    } finally {
      setSubmittingFeedback(false)
    }
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 via-white to-indigo-50 relative">
      {/* Background decoration */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute -top-40 -right-40 w-80 h-80 bg-gradient-to-br from-blue-200/30 to-indigo-200/30 rounded-full blur-3xl" />
        <div className="absolute -bottom-40 -left-40 w-80 h-80 bg-gradient-to-tr from-indigo-200/30 to-blue-200/30 rounded-full blur-3xl" />
      </div>

      <WorkoutFlowHeader
        title="Workout Complete"
        showBackButton={false}
      />

      <div className="relative flex items-center justify-center min-h-[80vh] px-4">
        <div className="bg-white/70 backdrop-blur-sm border border-gray-200 rounded-3xl p-8 text-center max-w-lg mx-auto shadow-lg">
          <div className="w-16 h-16 bg-gradient-to-br from-green-400 to-emerald-500 rounded-full flex items-center justify-center mx-auto mb-6">
            <CheckCircle className="h-8 w-8 text-white" />
          </div>
          <h1 className="text-3xl font-bold mb-4 text-gray-900">Workout Complete!</h1>
          <p className="mb-6 text-gray-600">Great job! Your workout has been saved to your history.</p>

          {/* Feedback Section */}
          {workoutSaved && !feedbackSubmitted && (
            <div className="mb-6 p-4 bg-blue-50/50 rounded-xl border border-blue-100">
              <h3 className="text-lg font-semibold mb-3 text-gray-900">How was this workout?</h3>
              <p className="text-sm text-gray-600 mb-4">Your feedback helps us personalize future workouts</p>

              {/* Difficulty Buttons */}
              <div className="grid grid-cols-3 gap-2 mb-4">
                {[
                  { value: 'easy' as const, label: 'Too Easy', icon: Bed, color: 'from-green-400 to-emerald-500' },
                  { value: 'right' as const, label: 'Just Right', icon: ThumbsUp, color: 'from-blue-400 to-indigo-500' },
                  { value: 'hard' as const, label: 'Too Hard', icon: Flame, color: 'from-red-400 to-pink-500' }
                ].map(option => (
                  <button
                    key={option.value}
                    onClick={() => setSelectedFeedback(option.value)}
                    className={`p-3 rounded-xl border-2 transition-all duration-200 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2 ${
                      selectedFeedback === option.value
                        ? `bg-gradient-to-br ${option.color} text-white border-transparent shadow-md scale-105`
                        : 'bg-white/70 border-gray-200 hover:border-gray-300 hover:scale-102'
                    }`}
                    aria-pressed={selectedFeedback === option.value}
                    aria-label={`Rate workout as ${option.label.toLowerCase()}`}
                  >
                    <div className="flex justify-center mb-1">
                      <option.icon className="h-5 w-5" />
                    </div>
                    <div className="text-xs font-medium">{option.label}</div>
                  </button>
                ))}
              </div>

              {/* Optional RPE Slider */}
              <div className="mb-4">
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Rate of Perceived Exertion (1-10) - Optional
                </label>
                <div className="flex items-center gap-2">
                  <span className="text-xs text-gray-500">1</span>
                  <input
                    type="range"
                    min="1"
                    max="10"
                    value={rpeValue || 5}
                    onChange={(e) => setRpeValue(parseInt(e.target.value))}
                    className="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2"
                    aria-label="Rate of Perceived Exertion from 1 to 10"
                    aria-describedby="rpe-description"
                  />
                  <span className="text-xs text-gray-500">10</span>
                </div>
                {rpeValue && (
                  <div className="text-center mt-1 text-sm font-medium text-gray-700">
                    RPE: {rpeValue}
                  </div>
                )}
              </div>

              {/* Submit Feedback Button */}
              <button
                onClick={submitFeedback}
                disabled={!selectedFeedback || submittingFeedback}
                className={`w-full px-4 py-2 rounded-xl font-medium transition-all duration-200 ${
                  selectedFeedback && !submittingFeedback
                    ? 'bg-gradient-to-br from-blue-500 to-indigo-600 text-white hover:scale-[1.02] shadow-md'
                    : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                }`}
              >
                {submittingFeedback ? 'Submitting...' : 'Submit Feedback'}
              </button>
            </div>
          )}

          {/* Success message after feedback */}
          {feedbackSubmitted && (
            <div className="mb-6 p-4 bg-green-50/50 rounded-xl border border-green-100">
              <div className="flex items-center gap-2 text-green-600 font-medium">
                <CheckCircle className="h-4 w-4" />
                Feedback submitted!
              </div>
              <div className="text-sm text-green-600 mt-1">Your next workout will be personalized based on this feedback.</div>
            </div>
          )}

          {/* Navigation Button */}
          <button
            onClick={() => nav('/dashboard')}
            className="w-full px-6 py-3 bg-gradient-to-br from-blue-500 to-indigo-600 text-white rounded-xl font-medium hover:scale-[1.02] transition-all duration-200 shadow-md"
          >
            Back to Dashboard
          </button>
        </div>
      </div>
    </div>
  )
}

========================================
FILE: src/pages/workout/Exercise.tsx
========================================

// src/pages/workout/Exercise.tsx
import React, { useEffect, useMemo, useState, useRef, useCallback } from 'react'
import { Lightbulb, Shield } from 'lucide-react'
import AppHeader from '../../components/AppHeader'
import { useOptimisticUpdate, createWeightUpdateAction } from '../../lib/optimisticUpdates'
import {
  WorkoutProgressHeader,
  SetProgressIndicator,
  MotivationalMessage,
  WorkoutStats
} from '../../components/WorkoutProgress'
import { SmartWeightInput } from '../../components/SmartWeightInput'

import { ProgressiveOverloadTracker } from '../../components/ProgressiveOverloadTracker'
import {
  getCachedWeightHistory,
  fetchRecentSessions,

  type WeightHistory,
  type WorkoutSession
} from '../../lib/weightHistory'
import { useBounce, useShake } from '../../hooks/useMicroInteractions'
import { useNavigate } from 'react-router-dom'

type ExerciseT = {
  name: string
  description?: string      // 4-6 sentences with setup, execution, cues, breathing
  sets: number
  reps: number | string     // Can include ranges like "8-12" or time like "45s"
  formTips?: string[]       // 2-3 critical technique cues
  safetyTips?: string[]     // 2-3 injury prevention tips and modifications
  restSeconds?: number
  usesWeight?: boolean      // true if this exercise uses external weights
  muscleGroups?: string[]   // Primary muscles worked for programming balance
  difficulty?: string       // "beginner", "intermediate", or "advanced"
}

type PlanT = { exercises: ExerciseT[] }

export default function Exercise() {
  const nav = useNavigate()

  // All hooks must be called at the top level
  const [i, setI] = useState(0)        // exercise index
  const [setNo, setSetNo] = useState(1) // current set (1-based)
  const [weightHistory, setWeightHistory] = useState<WeightHistory[]>([])
  const [recentSessions, setRecentSessions] = useState<WorkoutSession[]>([])
  const [loadingHistory, setLoadingHistory] = useState(false)

  // Enhanced UX hooks
  const containerRef = useRef<HTMLDivElement>(null)

  const { bounceClass } = useBounce()
  const { shakeClass } = useShake()

  // Weight tracking state with optimistic updates - must be called before early returns
  const initialWeights = (() => {
    const savedWeights = sessionStorage.getItem('nf_workout_weights')
    return savedWeights ? JSON.parse(savedWeights) : {}
  })()
  const weightState = useOptimisticUpdate<Record<number, Record<number, number | null>>>(initialWeights)

  // Get saved workout plan - memoized to prevent unnecessary re-renders
  const { saved, list } = useMemo(() => {
    const saved = sessionStorage.getItem('nf_workout_plan')
    const parsedData = saved ? JSON.parse(saved) as { plan: PlanT } : null
    const list = Array.isArray(parsedData?.plan?.exercises) ? parsedData.plan.exercises : []
    return { saved, list }
  }, [])

  // All useEffect hooks must be called before early returns
  // return-from-rest state
  useEffect(() => {
    const nxt = sessionStorage.getItem('nf_return')
    if (nxt) {
      const { i: ii, setNo: s } = JSON.parse(nxt)
      setI(ii); setSetNo(s)
      sessionStorage.removeItem('nf_return')
    }
  }, [])

  // Set workout start time if not already set (fallback for direct navigation)
  useEffect(() => {
    const hasWorkoutStartTime = sessionStorage.getItem('nf_workout_start_time')
    if (!hasWorkoutStartTime) {
      sessionStorage.setItem('nf_workout_start_time', String(Date.now()))
      if (process.env.NODE_ENV === 'development') {
        console.log('[TIME] Workout start time set (fallback)')
      }
    }
  }, [])

  // Load weight history and recent sessions for current exercise
  const ex = list[i] as ExerciseT
  useEffect(() => {
    if (!ex?.name) return

    const loadHistoryData = async () => {
      setLoadingHistory(true)
      try {
        const [history, sessions] = await Promise.all([
          getCachedWeightHistory(ex.name),
          fetchRecentSessions(8)
        ])
        setWeightHistory(history)
        setRecentSessions(sessions)
      } catch (error) {
        console.error('Error loading history data:', error)
      } finally {
        setLoadingHistory(false)
      }
    }

    loadHistoryData()
  }, [ex?.name])

  // All useMemo and useCallback hooks
  const totalExercises = list.length
  const progressPct = useMemo(() => {
    const perExercise = 1 / totalExercises
    const withinExercise = ((setNo - 1) / Math.max(1, ex.sets)) * perExercise
    return Math.min(100, Math.round(((i * perExercise) + withinExercise) * 100))
  }, [i, setNo, ex.sets, totalExercises])

  const completedSets = useMemo(() => {
    const exerciseWeights = weightState.data[i] || {}
    return Object.entries(exerciseWeights)
      .filter(([_, weight]) => weight !== null)
      .map(([setNum]) => parseInt(setNum))
  }, [weightState.data, i])

  const skippedSets = useMemo(() => {
    const exerciseWeights = weightState.data[i] || {}
    return Object.entries(exerciseWeights)
      .filter(([_, weight]) => weight === null)
      .map(([setNum]) => parseInt(setNum))
  }, [weightState.data, i])

  const workoutStartTime = useMemo(() => {
    const startTimeStr = sessionStorage.getItem('nf_workout_start_time')
    return startTimeStr ? parseInt(startTimeStr) : Date.now()
  }, [])

  const goRest = useCallback((nextIndex: number, nextSet: number, seconds?: number) => {
    const restDuration = seconds ?? ex.restSeconds ?? 60
    sessionStorage.setItem('nf_rest', String(restDuration))
    sessionStorage.setItem('nf_next', JSON.stringify({ i: nextIndex, setNo: nextSet }))
    nav('/workout/rest')
  }, [nav, ex.restSeconds])

  const totalCompletedSets = useMemo(() => {
    return Object.values(weightState.data).reduce((total, exerciseWeights) => {
      return total + Object.values(exerciseWeights || {}).filter(weight => weight !== null).length
    }, 0)
  }, [weightState.data])

  const totalSets = useMemo(() => {
    return list.reduce((total, exercise) => total + exercise.sets, 0)
  }, [list])

  const completedExercises = useMemo(() => {
    // Count exercises that are fully completed (all sets done)
    return Object.keys(weightState.data).filter(exerciseIndex => {
      const exerciseIndex_num = parseInt(exerciseIndex)
      const exercise = list[exerciseIndex_num]
      if (!exercise) return false

      const exerciseWeights = weightState.data[exerciseIndex_num] || {}
      const completedCount = Object.values(exerciseWeights).filter(weight => weight !== null).length

      // Only count as completed if all sets are done
      return completedCount === exercise.sets
    }).length
  }, [weightState.data, list])

  // Early returns after all hooks are called
  if (!saved) return <EmptyState />
  if (list.length === 0) return <EmptyState />

  // Removed smart rest period calculation - using AI-generated rest periods directly
  const workoutWeights = weightState.data

  // Update weight for current exercise and set with optimistic updates
  // RULE 3: If a set is complete and a weight is entered, the set should be marked as complete and the weight should be stored and displayed
  const updateWeight = (weight: number | null) => {
    const action = createWeightUpdateAction(
      i,
      setNo,
      weight,
      async (exerciseIndex, setNumber, weightValue) => {
        // Server update simulation - in real app this might sync to backend
        const updated = {
          ...workoutWeights,
          [exerciseIndex]: {
            ...workoutWeights[exerciseIndex],
            [setNumber]: weightValue
          }
        }
        sessionStorage.setItem('nf_workout_weights', JSON.stringify(updated))

        if (process.env.NODE_ENV === 'development') {
          console.log(`[WEIGHT] Weight entered for set ${setNumber} of ${ex.name}:`, weightValue)
        }
      }
    )

    weightState.executeOptimisticUpdate(action)
  }






  const completeSet = () => {
    // RULE 1: If a set is complete regardless of whether or not a weight is entered,
    // the set should be marked as complete
    const currentWeight = workoutWeights[i]?.[setNo]
    const finalWeight = currentWeight !== undefined ? currentWeight : 0

    const action = {
      optimisticUpdate: (prev: Record<number, Record<number, number | null>>) => ({
        ...prev,
        [i]: {
          ...prev[i],
          [setNo]: finalWeight
        }
      }),
      serverUpdate: async () => {
        const updated = {
          ...workoutWeights,
          [i]: {
            ...workoutWeights[i],
            [setNo]: finalWeight
          }
        }
        sessionStorage.setItem('nf_workout_weights', JSON.stringify(updated))

        if (process.env.NODE_ENV === 'development') {
          console.log(`[COMPLETE] Set ${setNo} of ${ex.name} marked as COMPLETE:`, finalWeight)
        }

        return updated
      }
    }

    weightState.executeOptimisticUpdate(action)

    // more sets remaining in current exercise
    if (setNo < ex.sets) return goRest(i, setNo + 1)
    // move to next exercise
    if (i < list.length - 1) return goRest(i + 1, 1)
    // workout finished
    nav('/workout/complete')
  }

  const skipSet = () => {
    // RULE 2: If a set is skipped, it should be marked as incomplete
    const action = {
      optimisticUpdate: (prev: Record<number, Record<number, number | null>>) => ({
        ...prev,
        [i]: {
          ...prev[i],
          [setNo]: null // null indicates skipped set (incomplete)
        }
      }),
      serverUpdate: async () => {
        const updated = {
          ...workoutWeights,
          [i]: {
            ...workoutWeights[i],
            [setNo]: null
          }
        }
        sessionStorage.setItem('nf_workout_weights', JSON.stringify(updated))

        if (process.env.NODE_ENV === 'development') {
          console.log(`[SKIP] Set ${setNo} of ${ex.name} marked as SKIPPED (incomplete):`, null)
        }

        return updated
      }
    }

    weightState.executeOptimisticUpdate(action)

    // more sets remaining in current exercise
    if (setNo < ex.sets) return goRest(i, setNo + 1)
    // move to next exercise
    if (i < list.length - 1) return goRest(i + 1, 1)
    // workout finished
    nav('/workout/complete')
  }

  const skipExercise = () => {
    // Mark this exercise as skipped by creating an empty weights object
    const skipAction = {
      optimisticUpdate: (data: Record<number, Record<number, number | null>>) => {
        const updated = {
          ...data,
          [i]: {} // Empty object indicates exercise was skipped
        }
        sessionStorage.setItem('nf_workout_weights', JSON.stringify(updated))
        return updated
      },
      serverUpdate: async () => {
        const currentData = weightState.data
        const updated = {
          ...currentData,
          [i]: {}
        }
        sessionStorage.setItem('nf_workout_weights', JSON.stringify(updated))
        return updated
      },
      rollback: (data: Record<number, Record<number, number | null>>) => data
    }
    weightState.executeOptimisticUpdate(skipAction)

    if (i < list.length - 1) return goRest(i + 1, 1, Math.min(30, ex.restSeconds ?? 30))
    nav('/workout/complete')
  }



  return (
    <div
      ref={containerRef}
      className={`min-h-screen bg-gradient-to-br from-blue-50 via-white to-indigo-50 relative ${bounceClass} ${shakeClass}`}
    >
      {/* Background decoration */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute -top-40 -right-40 w-80 h-80 bg-gradient-to-br from-blue-200/30 to-indigo-200/30 rounded-full blur-3xl" />
        <div className="absolute -bottom-40 -left-40 w-80 h-80 bg-gradient-to-tr from-indigo-200/30 to-blue-200/30 rounded-full blur-3xl" />
      </div>

      {/* Enhanced Progress Header */}
      <WorkoutProgressHeader
        currentExercise={i + 1}
        totalExercises={totalExercises}
        currentSet={setNo}
        totalSets={ex.sets}
        overallProgress={progressPct}
        exerciseName={ex.name}
      />

      {/* Exercise card */}
      <main className="relative mx-auto max-w-4xl px-5 pb-28">
        {/* Set Progress Indicator */}
        <SetProgressIndicator
          currentSet={setNo}
          totalSets={ex.sets}
          completedSets={completedSets}
          skippedSets={skippedSets}
        />

        {/* Motivational Message */}
        <MotivationalMessage
          progress={progressPct}
          completedSets={completedSets.length}
          totalSets={ex.sets}
          exerciseName={ex.name}
        />

        {/* Workout Stats */}
        <div className="mb-6">
          <WorkoutStats
            startTime={workoutStartTime}
            completedSets={totalCompletedSets}
            totalSets={totalSets}
            completedExercises={completedExercises}
            totalExercises={totalExercises}
          />
        </div>

        <div className="relative overflow-hidden rounded-3xl border border-gray-200 bg-white/70 backdrop-blur-sm p-6 shadow-lg">
          <div className="absolute -right-16 -top-16 h-56 w-56 rounded-full bg-gradient-to-tr from-blue-400/20 to-indigo-400/20 blur-3xl" />
          <h1 className="text-2xl font-bold tracking-tight text-gray-900">{ex.name}</h1>

          {/* chips */}
          <div className="mt-3 flex flex-wrap gap-2 text-sm">
            <Chip>Set {setNo} of {ex.sets}</Chip>
            <Chip>Reps: {ex.reps}</Chip>
            <Chip>Rest: {ex.restSeconds ?? 60}s</Chip>
          </div>

          {/* Enhanced weight input for exercises that use weights */}
          {ex.usesWeight && (
            <div className="mt-4 space-y-4">
              <SmartWeightInput
                exerciseName={ex.name}
                setNumber={setNo}
                currentWeight={workoutWeights[i]?.[setNo] || null}
                onWeightChange={updateWeight}
                isOptimistic={weightState.isOptimistic}
                previousWeights={weightHistory}
                targetReps={ex.reps}
              />



              {/* Progressive Overload Tracker */}
              {!loadingHistory && recentSessions.length > 0 && (
                <ProgressiveOverloadTracker
                  exerciseName={ex.name}
                  recentSessions={recentSessions}
                  currentWeight={workoutWeights[i]?.[setNo] || null}
                  targetReps={ex.reps}
                />
              )}
            </div>
          )}

          {/* how-to */}
          {ex.description && (
            <p className="mt-4 text-gray-700 leading-relaxed">
              <span className="font-medium">How to do it: </span>{ex.description}
            </p>
          )}

          {/* tips */}
          {Array.isArray(ex.formTips) && ex.formTips.length > 0 && (
            <div className="mt-5">
              <div className="mb-1 font-medium text-blue-700 flex items-center gap-2">
                <Lightbulb className="h-4 w-4" /> Form tips
              </div>
              <ul className="list-disc list-inside text-gray-600 text-sm space-y-1">
                {ex.formTips.slice(0, 3).map((t, idx) => <li key={idx}>{t}</li>)}
              </ul>
            </div>
          )}
          {Array.isArray(ex.safetyTips) && ex.safetyTips.length > 0 && (
            <div className="mt-4">
              <div className="mb-1 font-medium text-orange-600 flex items-center gap-2">
                <Shield className="h-4 w-4" /> Safety
              </div>
              <ul className="list-disc list-inside text-gray-600 text-sm space-y-1">
                {ex.safetyTips.slice(0, 3).map((t, idx) => <li key={idx}>{t}</li>)}
              </ul>
            </div>
          )}
        </div>
      </main>

      {/* Sticky controls */}
      <div className="fixed inset-x-0 bottom-0 z-10 border-t border-gray-200 bg-white/80 backdrop-blur" style={{ paddingBottom: 'max(16px, env(safe-area-inset-bottom))' }}>
        <div className="mx-auto max-w-4xl px-5 py-4 flex items-center justify-between gap-3">
          <button
            onClick={skipExercise}
            className="rounded-xl border border-gray-300 bg-white/70 px-3 py-3 text-gray-700 hover:bg-white hover:border-gray-400 transition-all duration-200 text-sm touch-manipulation min-h-[44px]"
            aria-label="Skip this exercise and move to next"
          >
            Skip Exercise
          </button>

          <div className="flex gap-2">
            <button
              onClick={skipSet}
              className="rounded-xl border border-orange-300 bg-orange-50 px-4 py-3 text-orange-700 hover:bg-orange-100 hover:border-orange-400 transition-all duration-200 active:scale-95 touch-manipulation min-h-[44px]"
              aria-label={`Skip set ${setNo} of ${ex.sets}`}
            >
              Skip Set
            </button>
            <button
              onClick={completeSet}
              className="rounded-xl bg-gradient-to-br from-blue-500 to-indigo-600 px-6 py-3 font-semibold text-white hover:scale-[1.02] active:scale-95 transition-all duration-200 shadow-md focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2 touch-manipulation min-h-[44px]"
              aria-label={`Complete set ${setNo} of ${ex.sets} for ${ex.name}`}
            >
              Complete Set
            </button>
          </div>
        </div>
      </div>
    </div>
  )
}

/* ---------- Small components ---------- */
function Chip({ children, className = '' }: { children: React.ReactNode; className?: string }) {
  return (
    <span className={`inline-flex items-center rounded-full border border-gray-200 bg-gray-100 px-3 py-1 text-gray-700 text-xs ${className}`}>
      {children}
    </span>
  )
}

// WeightInput removed - using SmartWeightInput instead

function EmptyState() {
  const nav = useNavigate()
  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 via-white to-indigo-50 relative">
      <AppHeader />
      <div className="relative grid place-items-center pt-20">
        <div className="max-w-md text-center bg-white/70 backdrop-blur-sm border border-gray-200 rounded-3xl p-8 shadow-lg">
          <h2 className="text-xl font-semibold mb-2 text-gray-900">No plan found</h2>
          <p className="text-gray-600 mb-4">Generate a workout to start your session.</p>
          <button
            onClick={() => nav('/generate')}
            className="px-6 py-3 bg-gradient-to-br from-blue-500 to-indigo-600 text-white rounded-xl font-medium hover:scale-[1.02] transition-all duration-200 shadow-md focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2"
            aria-label="Generate a new workout plan"
          >
            Generate Workout
          </button>
        </div>
      </div>
    </div>
  )
}

========================================
FILE: src/pages/workout/Preview.tsx
========================================

// src/pages/workout/Preview.tsx
import React, { useMemo, useState } from 'react'
import { useNavigate } from 'react-router-dom'
import { List, Hash, Play, Lightbulb, Shield, ChevronDown, Crown } from 'lucide-react'
import AppHeader from '../../components/AppHeader'
import { useSubscription } from '../../hooks/useSubscription'
import { trackWorkoutStarted } from '../../lib/firebase-analytics'

type Exercise = {
  name: string
  description?: string
  sets: number
  reps: number | string
  formTips?: string[]
  safetyTips?: string[]
  restSeconds?: number
  usesWeight?: boolean      // true if this exercise uses external weights
  muscleGroups?: string[]   // Primary muscles worked
  difficulty?: string       // "beginner", "intermediate", or "advanced"
}

type Plan = { exercises: Exercise[] }

export default function Preview() {
  const nav = useNavigate()
  const { hasUnlimitedWorkouts, remainingFreeWorkouts } = useSubscription()

  // Parse saved data and calculate exercises before early return - memoized to prevent unnecessary re-renders
  const { saved, parsedData, exercises } = useMemo(() => {
    const saved = sessionStorage.getItem('nf_workout_plan')
    const parsedData = saved ? JSON.parse(saved) as {
      plan: Plan & { metadata?: { targetIntensity?: number; progressionNote?: string } };
      type: string;
      duration: number
    } : null
    const exercises = Array.isArray(parsedData?.plan?.exercises) ? parsedData.plan.exercises : []
    return { saved, parsedData, exercises }
  }, [])

  // All hooks must be called before early returns
  const totalSets = useMemo(() => {
    return exercises.reduce((s, e) => s + (Number(e.sets) || 0), 0)
  }, [exercises])

  // Early return after all hooks
  if (!saved || !parsedData) return <EmptyState />

  const { type, duration } = parsedData

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 via-white to-blue-50/30 relative">
      {/* Enhanced Background decoration */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute -top-40 -right-40 w-80 h-80 bg-gradient-to-br from-blue-400/20 to-indigo-400/15 rounded-full blur-3xl" />
        <div className="absolute -bottom-40 -left-40 w-80 h-80 bg-gradient-to-tr from-indigo-400/15 to-blue-400/20 rounded-full blur-3xl" />
        <div className="absolute top-1/3 left-1/2 transform -translate-x-1/2 w-96 h-96 bg-gradient-to-r from-slate-300/10 to-gray-300/10 rounded-full blur-3xl" />
      </div>

      <AppHeader />

      {/* Compact Hero Section */}
      <section className="relative mx-auto max-w-4xl px-4 pt-4">
        <div className="group relative overflow-hidden rounded-2xl border border-white/60 bg-gradient-to-br from-white/95 via-white/85 to-white/75 backdrop-blur-xl p-5 md:p-6 shadow-lg shadow-slate-200/30 hover:shadow-xl hover:shadow-slate-300/20 transition-all duration-300">
          {/* Compact background elements */}
          <div className="absolute -right-12 -top-12 h-32 w-32 rounded-full bg-gradient-to-tr from-blue-400/15 via-indigo-400/10 to-purple-400/5 opacity-60 blur-2xl group-hover:opacity-80 transition-opacity duration-300" />

          <div className="relative">
            {/* Compact Workout Title */}
            <h1 className="text-2xl md:text-3xl font-bold tracking-tight bg-gradient-to-r from-slate-900 via-slate-800 to-slate-700 bg-clip-text text-transparent leading-tight mb-4">
              {type} <span className="text-slate-400/60">—</span> {duration} min
            </h1>

            {/* Compact Badges */}
            <div className="flex flex-wrap gap-2">
              <CompactBadge variant="primary">
                <List className="h-4 w-4" />
                <span className="font-semibold">{exercises.length}</span>
              </CompactBadge>

              <CompactBadge variant="secondary">
                <Hash className="h-4 w-4" />
                <span className="font-semibold">{totalSets}</span>
              </CompactBadge>

              {hasUnlimitedWorkouts ? (
                <CompactBadge variant="pro">
                  <Crown className="h-3 w-3" />
                  Pro
                </CompactBadge>
              ) : (
                <CompactBadge variant="free">
                  <span className="font-semibold">{remainingFreeWorkouts - 1}</span> left
                </CompactBadge>
              )}
            </div>
          </div>
        </div>
      </section>

      {/* Compact Exercises */}
      <main className="relative mx-auto max-w-4xl px-4 pt-4 pb-24">
        <ol className="space-y-3">
          {exercises.map((ex, i) => (
            <ExerciseItem key={i} index={i} ex={ex} />
          ))}
        </ol>
      </main>

      {/* Compact Sticky Start Button */}
      <div className="fixed inset-x-0 bottom-0 z-10 border-t border-white/60 bg-gradient-to-r from-white/95 via-white/90 to-white/85 backdrop-blur-xl shadow-xl shadow-slate-300/15">
        <div className="mx-auto max-w-4xl px-4 py-4 flex items-center justify-between">
          <div className="text-slate-600 hidden md:block text-sm leading-relaxed">
            Tap exercises for tips
          </div>
          <button
            onClick={() => {
              // Clear any existing workout data for a fresh start
              sessionStorage.removeItem('nf_workout_weights')
              sessionStorage.removeItem('nf_return')
              sessionStorage.removeItem('nf_next')
              sessionStorage.removeItem('nf_rest')

              // Store workout start time
              sessionStorage.setItem('nf_workout_start_time', Date.now().toString())

              // Track workout started
              const workoutId = `workout_${Date.now()}`
              trackWorkoutStarted(workoutId)

              nav('/workout/run')
            }}
            className="group inline-flex items-center gap-2 rounded-xl bg-gradient-to-r from-blue-600 to-indigo-600 px-6 py-3 font-bold text-white hover:from-blue-700 hover:to-indigo-700 hover:shadow-lg hover:shadow-blue-500/25 hover:scale-105 active:scale-95 transition-all duration-300 shadow-md shadow-blue-500/20 md:px-8 md:py-4 md:gap-3 md:rounded-2xl"
          >
            <Play className="h-5 w-5 md:h-6 md:w-6 group-hover:scale-110 transition-transform duration-200" />
            <span className="md:text-base">Start Workout</span>
          </button>
        </div>
      </div>
    </div>
  )
}

/* ---------------- Components ---------------- */

function ExerciseItem({ ex, index }: { ex: Exercise; index: number }) {
  const [open, setOpen] = useState(false)

  return (
    <li className="group overflow-hidden rounded-xl border border-white/60 bg-gradient-to-br from-white/95 to-white/85 backdrop-blur-xl shadow-md shadow-slate-200/25 hover:shadow-lg hover:shadow-slate-300/15 transition-all duration-200 active:scale-[0.98]">
      <button
        className="w-full px-4 py-4 text-left flex items-start justify-between gap-3 hover:bg-white/50 transition-colors duration-200"
        onClick={() => setOpen(o => !o)}
      >
        <div className="flex-1 min-w-0">
          <div className="flex items-center gap-3 mb-2">
            <span className="inline-flex items-center justify-center w-6 h-6 rounded-lg bg-gradient-to-br from-blue-500 to-indigo-600 text-white text-xs font-bold flex-shrink-0 shadow-sm shadow-blue-500/25">
              {index + 1}
            </span>
            <h3 className="font-bold text-slate-900 group-hover:text-slate-800 transition-colors truncate text-base md:text-lg">
              {ex.name}
            </h3>
          </div>
          <div className="text-sm text-slate-600 ml-9">
            <span className="font-semibold">{ex.sets}</span> sets • <span className="font-semibold">{ex.reps}</span> reps
            {ex.restSeconds ? <span className="ml-2 text-slate-500 hidden sm:inline">• <span className="font-semibold">{ex.restSeconds}s</span></span> : null}
          </div>
        </div>
        <ChevronDown className={`h-5 w-5 text-slate-400 transition-all duration-200 group-hover:text-slate-600 flex-shrink-0 ${open ? 'rotate-180' : ''}`} />
      </button>

      {open && (
        <div className="border-t border-white/60 px-4 py-4 bg-gradient-to-br from-slate-50/80 to-gray-50/60 backdrop-blur-sm">
          {ex.description && <p className="mb-3 leading-relaxed text-slate-700 text-sm">{ex.description}</p>}
          {!!ex.formTips?.length && (
            <div className="mb-3">
              <div className="mb-2 font-bold flex items-center gap-2 text-blue-700 text-sm">
                <div className="w-6 h-6 rounded-lg bg-gradient-to-br from-blue-500 to-indigo-600 flex items-center justify-center flex-shrink-0">
                  <Lightbulb className="h-3 w-3 text-white" />
                </div>
                Form Tips
              </div>
              <ul className="space-y-1.5 text-slate-600 ml-8 text-sm">
                {ex.formTips.slice(0,3).map((t, i) => (
                  <li key={i} className="flex items-start gap-2">
                    <div className="w-1 h-1 rounded-full bg-blue-500 mt-2 flex-shrink-0" />
                    <span className="leading-relaxed">{t}</span>
                  </li>
                ))}
              </ul>
            </div>
          )}
          {!!ex.safetyTips?.length && (
            <div>
              <div className="mb-2 font-bold text-orange-700 flex items-center gap-2 text-sm">
                <div className="w-6 h-6 rounded-lg bg-gradient-to-br from-orange-500 to-red-600 flex items-center justify-center flex-shrink-0">
                  <Shield className="h-3 w-3 text-white" />
                </div>
                Safety Tips
              </div>
              <ul className="space-y-1.5 text-orange-600 ml-8 text-sm">
                {ex.safetyTips.slice(0,3).map((t, i) => (
                  <li key={i} className="flex items-start gap-2">
                    <div className="w-1 h-1 rounded-full bg-orange-500 mt-2 flex-shrink-0" />
                    <span className="leading-relaxed">{t}</span>
                  </li>
                ))}
              </ul>
            </div>
          )}
        </div>
      )}
    </li>
  )
}

function EmptyState() {
  const nav = useNavigate()
  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 via-white to-blue-50/30 relative">
      {/* Background decoration */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute -top-40 -right-40 w-80 h-80 bg-gradient-to-br from-blue-400/20 to-indigo-400/15 rounded-full blur-3xl" />
        <div className="absolute -bottom-40 -left-40 w-80 h-80 bg-gradient-to-tr from-indigo-400/15 to-blue-400/20 rounded-full blur-3xl" />
      </div>

      <AppHeader />
      <div className="relative grid place-items-center pt-16 px-4">
        <div className="max-w-sm text-center p-6 rounded-2xl border border-white/60 bg-gradient-to-br from-white/95 to-white/85 backdrop-blur-xl shadow-lg shadow-slate-200/30">
          <h2 className="text-xl font-bold mb-3 bg-gradient-to-r from-slate-900 to-slate-700 bg-clip-text text-transparent">No plan found</h2>
          <p className="text-slate-600 mb-5 leading-relaxed text-sm">Generate a workout to preview it here.</p>
          <button
            onClick={()=>nav('/generate')}
            className="inline-flex items-center gap-2 rounded-xl bg-gradient-to-r from-blue-600 to-indigo-600 text-white px-6 py-3 font-bold hover:from-blue-700 hover:to-indigo-700 hover:shadow-lg hover:shadow-blue-500/25 hover:scale-105 active:scale-95 transition-all duration-300 shadow-md shadow-blue-500/20 w-full justify-center"
          >
            Generate Workout
          </button>
        </div>
      </div>
    </div>
  )
}

function CompactBadge({
  children,
  variant = 'primary'
}: {
  children: React.ReactNode;
  variant?: 'primary' | 'secondary' | 'pro' | 'free'
}) {
  const variants = {
    primary: "inline-flex items-center gap-2 rounded-xl border border-blue-200/50 bg-gradient-to-r from-blue-50 to-indigo-50 px-3 py-2 text-blue-700 shadow-sm shadow-blue-100/40 text-sm font-medium",
    secondary: "inline-flex items-center gap-2 rounded-xl border border-slate-200/50 bg-gradient-to-r from-slate-50 to-gray-50 px-3 py-2 text-slate-700 shadow-sm shadow-slate-100/40 text-sm font-medium",
    pro: "inline-flex items-center gap-2 rounded-xl border border-yellow-300/50 bg-gradient-to-r from-yellow-400 to-orange-500 px-3 py-2 text-white font-semibold shadow-sm shadow-yellow-500/20 text-sm",
    free: "inline-flex items-center gap-2 rounded-xl border border-emerald-200/50 bg-gradient-to-r from-emerald-50 to-green-50 px-3 py-2 text-emerald-700 shadow-sm shadow-emerald-100/40 text-sm font-medium"
  }

  return (
    <span className={variants[variant]}>
      {children}
    </span>
  )
}

function _EnhancedBadge({
  children,
  variant = 'primary'
}: {
  children: React.ReactNode;
  variant?: 'primary' | 'secondary' | 'pro' | 'free'
}) {
  const variants = {
    primary: "inline-flex items-center gap-3 rounded-2xl border border-blue-200/50 bg-gradient-to-r from-blue-50 to-indigo-50 px-4 py-3 text-blue-700 shadow-md shadow-blue-100/50 hover:shadow-lg hover:shadow-blue-200/30 transition-all duration-300",
    secondary: "inline-flex items-center gap-3 rounded-2xl border border-slate-200/50 bg-gradient-to-r from-slate-50 to-gray-50 px-4 py-3 text-slate-700 shadow-md shadow-slate-100/50 hover:shadow-lg hover:shadow-slate-200/30 transition-all duration-300",
    pro: "inline-flex items-center gap-3 rounded-2xl border border-yellow-300/50 bg-gradient-to-r from-yellow-400 to-orange-500 px-4 py-3 text-white font-semibold shadow-lg shadow-yellow-500/25 hover:shadow-xl hover:shadow-yellow-500/40 transition-all duration-300",
    free: "inline-flex items-center gap-3 rounded-2xl border border-emerald-200/50 bg-gradient-to-r from-emerald-50 to-green-50 px-4 py-3 text-emerald-700 shadow-md shadow-emerald-100/50 hover:shadow-lg hover:shadow-emerald-200/30 transition-all duration-300"
  }

  return (
    <span className={variants[variant]}>
      {children}
    </span>
  )
}

// Keep the old Badge component for backward compatibility
function _Badge({ children, className }: { children: React.ReactNode; className?: string }) {
  return (
    <span className={className || "inline-flex items-center gap-2 rounded-full border border-blue-200 bg-blue-50 px-3 py-1 text-blue-700"}>
      {children}
    </span>
  )
}

========================================
FILE: src/pages/workout/Rest.tsx
========================================

// src/pages/workout/Rest.tsx
import { useMemo } from 'react'
import { useNavigate } from 'react-router-dom'
import WorkoutFlowHeader from '../../components/WorkoutFlowHeader'
import { EnhancedRestTimer } from '../../components/EnhancedRestTimer'

export default function Rest() {
  const nav = useNavigate()

  // Retrieve initial rest time, default to 60 seconds if not set
  const initial = useMemo(() => {
    const storedRest = sessionStorage.getItem('nf_rest')
    return storedRest ? Number(storedRest) : 60
  }, [])

  // Parse next exercise data safely
  const nextExercise = useMemo(() => {
    try {
      const nextRaw = sessionStorage.getItem('nf_next')
      const planRaw = sessionStorage.getItem('nf_workout_plan')

      if (!nextRaw || !planRaw) return undefined

      const next = JSON.parse(nextRaw) as { i: number; setNo: number }
      const plan = JSON.parse(planRaw) as { plan?: { exercises?: { name: string; sets: number; reps: number | string; restSeconds?: number }[] } }
      const ex = plan?.plan?.exercises?.[next.i]

      if (!ex) return undefined

      return {
        name: ex.name,
        sets: ex.sets,
        reps: ex.reps,
        restSeconds: ex.restSeconds
      }
    } catch (error) {
      console.error('Error parsing next exercise data:', error)
      return undefined
    }
  }, [])

  const handleComplete = () => {
    // Transfer next state to return state for Exercise screen
    const next = sessionStorage.getItem('nf_next')
    if (next) {
      sessionStorage.setItem('nf_return', next)
      sessionStorage.removeItem('nf_next')
    }
    nav('/workout/run')
  }

  return (
    <>
      <WorkoutFlowHeader
        title="Rest Period"
        showBackButton={true}
        onBack={() => nav('/workout/run')}
      />
      <EnhancedRestTimer
        initialSeconds={initial}
        onComplete={handleComplete}
        nextExercise={nextExercise}
      />
    </>
  )
}

========================================
FILE: src/design-system/components/Button.tsx
========================================

import React, { forwardRef, memo, type ButtonHTMLAttributes } from 'react'
import { type VariantProps } from 'class-variance-authority'
import { cn } from '../../lib/utils'
import { buttonVariants } from '../variants/buttonVariants'




export interface ButtonProps
  extends ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  loading?: boolean
  leftIcon?: React.ReactNode
  rightIcon?: React.ReactNode
  fullWidth?: boolean
}

const ButtonBase = forwardRef<HTMLButtonElement, ButtonProps>(
  ({
    className,
    variant,
    size,
    fullWidth,
    loading,
    leftIcon,
    rightIcon,
    children,
    disabled,
    ...props
  }, ref) => {
    const isDisabled = disabled || loading

    return (
      <button
        className={cn(buttonVariants({ variant, size, fullWidth, loading, className }))}
        ref={ref}
        disabled={isDisabled}
        aria-disabled={isDisabled}
        aria-busy={loading}
        {...props}
      >
        {loading && (
          <div
            className="animate-spin rounded-full h-4 w-4 border-2 border-current border-t-transparent"
            aria-hidden="true"
          />
        )}
        {!loading && leftIcon && <span aria-hidden="true">{leftIcon}</span>}
        <span>{children}</span>
        {!loading && rightIcon && <span aria-hidden="true">{rightIcon}</span>}
      </button>
    )
  }
)

ButtonBase.displayName = 'Button'

const Button = memo(ButtonBase)

export { Button }




========================================
FILE: src/design-system/components/Card.tsx
========================================

import React, { forwardRef, memo, type HTMLAttributes } from 'react'
import { type VariantProps } from 'class-variance-authority'
import { cn } from '../../lib/utils'
import { cardVariants } from '../variants/cardVariants'

export interface CardProps
  extends HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof cardVariants> {
  interactive?: boolean
}

const CardBase = forwardRef<HTMLDivElement, CardProps>(
  ({
    className,
    variant,
    size,
    rounded,
    interactive,
    children,
    ...props
  }, ref) => {
    const cardVariant = interactive ? 'interactive' : variant

    return (
      <div
        ref={ref}
        className={cn(cardVariants({ variant: cardVariant, size, rounded }), className)}
        role={interactive ? 'button' : undefined}
        tabIndex={interactive ? 0 : undefined}
        {...props}
      >
        {children}
      </div>
    )
  }
)

CardBase.displayName = 'Card'

const Card = memo(CardBase)

// Card sub-components
const CardHeaderBase = forwardRef<HTMLDivElement, HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      className={cn('flex flex-col space-y-1.5 pb-4', className)}
      {...props}
    />
  )
)
CardHeaderBase.displayName = 'CardHeader'
const CardHeader = memo(CardHeaderBase)

const CardTitleBase = forwardRef<HTMLHeadingElement, HTMLAttributes<HTMLHeadingElement> & { level?: 1 | 2 | 3 | 4 | 5 | 6 }>(
  ({ className, level = 3, ...props }, ref) => {
    const Component = level === 1 ? 'h1' : level === 2 ? 'h2' : level === 3 ? 'h3' : level === 4 ? 'h4' : level === 5 ? 'h5' : 'h6'
    return React.createElement(
      Component,
      {
        ref,
        className: cn('text-lg font-semibold leading-none tracking-tight text-gray-900', className),
        ...props
      }
    )
  }
)
CardTitleBase.displayName = 'CardTitle'
const CardTitle = memo(CardTitleBase)

const CardDescriptionBase = forwardRef<HTMLParagraphElement, HTMLAttributes<HTMLParagraphElement>>(
  ({ className, ...props }, ref) => (
    <p
      ref={ref}
      className={cn('text-sm text-gray-600 leading-relaxed', className)}
      {...props}
    />
  )
)
CardDescriptionBase.displayName = 'CardDescription'
const CardDescription = memo(CardDescriptionBase)

const CardContentBase = forwardRef<HTMLDivElement, HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      className={cn('flex-1', className)}
      {...props}
    />
  )
)
CardContentBase.displayName = 'CardContent'
const CardContent = memo(CardContentBase)

const CardFooterBase = forwardRef<HTMLDivElement, HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      className={cn('flex items-center pt-4', className)}
      {...props}
    />
  )
)
CardFooterBase.displayName = 'CardFooter'
const CardFooter = memo(CardFooterBase)



export { Card, CardHeader, CardTitle, CardDescription, CardContent, CardFooter }


========================================
FILE: src/design-system/components/SpecializedCards.tsx
========================================

import React, { forwardRef } from 'react'
import { cn } from '../../lib/utils'
import { Card, CardContent, type CardProps } from './Card'

// Simplified specialized card components
export const StatsCard = forwardRef<HTMLDivElement, CardProps & {
  label: string
  value: string | number
  change?: string
  trend?: 'up' | 'down' | 'neutral'
  icon?: React.ReactNode
}>(({ label, value, change, trend, icon, ...props }, ref) => {
  const trendColors = {
    up: 'text-green-600 bg-green-50',
    down: 'text-red-600 bg-red-50',
    neutral: 'text-gray-600 bg-gray-50'
  }

  return (
    <Card ref={ref} variant="elevated" rounded="xl" {...props}>
      <CardContent>
        <div className="flex items-center justify-between">
          <div>
            <p className="text-sm font-medium text-gray-600">{label}</p>
            <p className="text-2xl font-bold text-gray-900 mt-1">{value}</p>
            {change && (
              <p className={cn(
                'text-xs font-medium px-2 py-1 rounded-full mt-2 inline-block',
                trend ? trendColors[trend] : trendColors.neutral
              )}>
                {change}
              </p>
            )}
          </div>
          {icon && (
            <div className="flex-shrink-0 w-12 h-12 rounded-xl bg-blue-100 flex items-center justify-center text-blue-600">
              {icon}
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  )
})

StatsCard.displayName = 'StatsCard'


========================================
FILE: src/design-system/variants/buttonVariants.ts
========================================

import { cva } from 'class-variance-authority'

export const buttonVariants = cva(
  'inline-flex items-center justify-center whitespace-nowrap rounded-lg text-sm font-semibold ring-offset-background transition-all duration-300 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 disabled:cursor-not-allowed',
  {
    variants: {
      variant: {
        default: 'bg-gradient-to-r from-blue-600 to-indigo-600 text-white hover:from-blue-700 hover:to-indigo-700 focus:ring-blue-500 shadow-lg shadow-blue-500/25 hover:shadow-xl hover:shadow-blue-500/30 hover:scale-105',
        outline: 'border border-slate-300 bg-white/80 backdrop-blur-sm hover:bg-white text-slate-700 hover:text-slate-900 shadow-md hover:shadow-lg hover:border-slate-400',
        secondary: 'bg-gradient-to-r from-slate-100 to-gray-100 text-slate-900 hover:from-slate-200 hover:to-gray-200 shadow-md hover:shadow-lg hover:scale-105',
      },
      size: {
        default: 'h-10 px-4 py-2',
        sm: 'h-9 rounded-lg px-3 text-xs',
        lg: 'h-11 rounded-lg px-8 text-base',
        icon: 'h-10 w-10'
      },
      fullWidth: {
        true: 'w-full',
        false: ''
      },
      loading: {
        true: 'cursor-wait',
        false: ''
      }
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
      fullWidth: false,
      loading: false
    }
  }
)


========================================
FILE: src/design-system/variants/cardVariants.ts
========================================

import { cva } from 'class-variance-authority'

export const cardVariants = cva(
  'border bg-white text-card-foreground transition-all duration-300',
  {
    variants: {
      variant: {
        default: 'border-gray-200 shadow-sm',
        elevated: 'border-white/60 bg-gradient-to-br from-white/95 to-white/85 backdrop-blur-xl shadow-lg shadow-slate-200/30',
        interactive: 'border-white/60 bg-gradient-to-br from-white/95 to-white/85 backdrop-blur-xl shadow-lg shadow-slate-200/30 hover:shadow-xl hover:shadow-slate-300/20 hover:scale-[1.01] cursor-pointer transition-all duration-500'
      },
      size: {
        sm: 'p-3',
        default: 'p-6',
        lg: 'p-8'
      },
      rounded: {
        default: 'rounded-lg',
        xl: 'rounded-xl',
        '2xl': 'rounded-2xl',
        '3xl': 'rounded-3xl'
      }
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
      rounded: 'default'
    }
  }
)


========================================
FILE: src/design-system/tokens.ts
========================================

// Design tokens for NeuraFit premium design system
// Based on modern design principles and color psychology for fitness apps

export const designTokens = {
  // Color System - Enhanced with psychological impact
  colors: {
    // Primary - Energy and motivation (Blue to Indigo gradient)
    primary: {
      50: '#eff6ff',
      100: '#dbeafe',
      200: '#bfdbfe',
      300: '#93c5fd',
      400: '#60a5fa',
      500: '#3b82f6', // Main brand color
      600: '#2563eb',
      700: '#1d4ed8',
      800: '#1e40af',
      900: '#1e3a8a',
      950: '#172554'
    },

    // Secondary - Achievement and success (Emerald)
    secondary: {
      50: '#ecfdf5',
      100: '#d1fae5',
      200: '#a7f3d0',
      300: '#6ee7b7',
      400: '#34d399',
      500: '#10b981',
      600: '#059669',
      700: '#047857',
      800: '#065f46',
      900: '#064e3b',
      950: '#022c22'
    },

    // Accent - Energy and intensity (Orange)
    accent: {
      50: '#fff7ed',
      100: '#ffedd5',
      200: '#fed7aa',
      300: '#fdba74',
      400: '#fb923c',
      500: '#f97316',
      600: '#ea580c',
      700: '#c2410c',
      800: '#9a3412',
      900: '#7c2d12',
      950: '#431407'
    },

    // Warning - Caution and attention (Amber)
    warning: {
      50: '#fffbeb',
      100: '#fef3c7',
      200: '#fde68a',
      300: '#fcd34d',
      400: '#fbbf24',
      500: '#f59e0b',
      600: '#d97706',
      700: '#b45309',
      800: '#92400e',
      900: '#78350f',
      950: '#451a03'
    },

    // Error - Alerts and danger (Red)
    error: {
      50: '#fef2f2',
      100: '#fee2e2',
      200: '#fecaca',
      300: '#fca5a5',
      400: '#f87171',
      500: '#ef4444',
      600: '#dc2626',
      700: '#b91c1c',
      800: '#991b1b',
      900: '#7f1d1d',
      950: '#450a0a'
    },

    // Neutral - Balance and sophistication
    neutral: {
      0: '#ffffff',
      50: '#f9fafb',
      100: '#f3f4f6',
      200: '#e5e7eb',
      300: '#d1d5db',
      400: '#9ca3af',
      500: '#6b7280',
      600: '#4b5563',
      700: '#374151',
      800: '#1f2937',
      900: '#111827',
      950: '#030712'
    }
  },

  // Typography System - Optimized for readability and hierarchy
  typography: {
    fontFamily: {
      sans: ['Inter', 'system-ui', '-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'sans-serif'],
      mono: ['JetBrains Mono', 'Fira Code', 'Monaco', 'Consolas', 'monospace']
    },
    
    fontSize: {
      xs: ['0.75rem', { lineHeight: '1rem', letterSpacing: '0.025em' }],
      sm: ['0.875rem', { lineHeight: '1.25rem', letterSpacing: '0.025em' }],
      base: ['1rem', { lineHeight: '1.5rem', letterSpacing: '0' }],
      lg: ['1.125rem', { lineHeight: '1.75rem', letterSpacing: '-0.025em' }],
      xl: ['1.25rem', { lineHeight: '1.75rem', letterSpacing: '-0.025em' }],
      '2xl': ['1.5rem', { lineHeight: '2rem', letterSpacing: '-0.025em' }],
      '3xl': ['1.875rem', { lineHeight: '2.25rem', letterSpacing: '-0.025em' }],
      '4xl': ['2.25rem', { lineHeight: '2.5rem', letterSpacing: '-0.025em' }],
      '5xl': ['3rem', { lineHeight: '1', letterSpacing: '-0.025em' }],
      '6xl': ['3.75rem', { lineHeight: '1', letterSpacing: '-0.025em' }]
    },

    fontWeight: {
      light: '300',
      normal: '400',
      medium: '500',
      semibold: '600',
      bold: '700',
      extrabold: '800'
    }
  },

  // Spacing System - Consistent rhythm and flow
  spacing: {
    px: '1px',
    0: '0',
    0.5: '0.125rem',
    1: '0.25rem',
    1.5: '0.375rem',
    2: '0.5rem',
    2.5: '0.625rem',
    3: '0.75rem',
    3.5: '0.875rem',
    4: '1rem',
    5: '1.25rem',
    6: '1.5rem',
    7: '1.75rem',
    8: '2rem',
    9: '2.25rem',
    10: '2.5rem',
    11: '2.75rem',
    12: '3rem',
    14: '3.5rem',
    16: '4rem',
    20: '5rem',
    24: '6rem',
    28: '7rem',
    32: '8rem',
    36: '9rem',
    40: '10rem',
    44: '11rem',
    48: '12rem',
    52: '13rem',
    56: '14rem',
    60: '15rem',
    64: '16rem',
    72: '18rem',
    80: '20rem',
    96: '24rem'
  },

  // Border Radius - Modern and friendly
  borderRadius: {
    none: '0',
    sm: '0.125rem',
    base: '0.25rem',
    md: '0.375rem',
    lg: '0.5rem',
    xl: '0.75rem',
    '2xl': '1rem',
    '3xl': '1.5rem',
    full: '9999px'
  },

  // Shadows - Depth and elevation
  boxShadow: {
    sm: '0 1px 2px 0 rgb(0 0 0 / 0.05)',
    base: '0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)',
    md: '0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)',
    lg: '0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)',
    xl: '0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)',
    '2xl': '0 25px 50px -12px rgb(0 0 0 / 0.25)',
    inner: 'inset 0 2px 4px 0 rgb(0 0 0 / 0.05)',
    glow: '0 0 0 1px rgb(59 130 246 / 0.15), 0 0 20px rgb(59 130 246 / 0.1)',
    'glow-lg': '0 0 0 1px rgb(59 130 246 / 0.15), 0 0 40px rgb(59 130 246 / 0.15)'
  },

  // Animation & Transitions
  animation: {
    duration: {
      fast: '150ms',
      normal: '200ms',
      slow: '300ms',
      slower: '500ms'
    },
    
    easing: {
      linear: 'linear',
      in: 'cubic-bezier(0.4, 0, 1, 1)',
      out: 'cubic-bezier(0, 0, 0.2, 1)',
      'in-out': 'cubic-bezier(0.4, 0, 0.2, 1)',
      bounce: 'cubic-bezier(0.68, -0.55, 0.265, 1.55)',
      elastic: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)'
    }
  },

  // Breakpoints - Mobile-first responsive design
  breakpoints: {
    sm: '640px',
    md: '768px',
    lg: '1024px',
    xl: '1280px',
    '2xl': '1536px'
  },

  // Z-index layers
  zIndex: {
    hide: -1,
    auto: 'auto',
    base: 0,
    docked: 10,
    dropdown: 1000,
    sticky: 1100,
    banner: 1200,
    overlay: 1300,
    modal: 1400,
    popover: 1500,
    skipLink: 1600,
    toast: 1700,
    tooltip: 1800
  }
}

// Semantic color mappings for different contexts
export const semanticColors = {
  background: {
    primary: designTokens.colors.neutral[0],
    secondary: designTokens.colors.neutral[50],
    tertiary: designTokens.colors.neutral[100],
    inverse: designTokens.colors.neutral[900]
  },
  
  text: {
    primary: designTokens.colors.neutral[900],
    secondary: designTokens.colors.neutral[600],
    tertiary: designTokens.colors.neutral[500],
    inverse: designTokens.colors.neutral[0],
    link: designTokens.colors.primary[600],
    linkHover: designTokens.colors.primary[700]
  },
  
  border: {
    primary: designTokens.colors.neutral[200],
    secondary: designTokens.colors.neutral[300],
    focus: designTokens.colors.primary[500],
    error: designTokens.colors.error[500]
  },
  
  surface: {
    primary: designTokens.colors.neutral[0],
    secondary: designTokens.colors.neutral[50],
    elevated: designTokens.colors.neutral[0],
    overlay: 'rgba(0, 0, 0, 0.5)'
  }
}

export default designTokens


========================================
FILE: src/hooks/useAnalytics.ts
========================================

import { useEffect } from 'react'
import { useLocation } from 'react-router-dom'
import { trackPageView } from '../lib/firebase-analytics'

/**
 * Hook to automatically track page views
 */
export function usePageTracking() {
  const location = useLocation()

  useEffect(() => {
    // Track page view when location changes
    const pageName = getPageNameFromPath(location.pathname)
    trackPageView(pageName, document.title)
  }, [location])
}

/**
 * Convert pathname to readable page name
 */
function getPageNameFromPath(pathname: string): string {
  const pathMap: Record<string, string> = {
    '/': 'Dashboard',
    '/dashboard': 'Dashboard',
    '/generate': 'Generate Workout',
    '/history': 'Workout History',
    '/profile': 'Profile',
    '/subscription': 'Subscription',

    '/onboarding': 'Onboarding',
    '/auth': 'Authentication',
    '/workout/preview': 'Workout Preview',
    '/workout/exercise': 'Exercise',
    '/workout/rest': 'Rest',
    '/workout/complete': 'Workout Complete',
    '/terms': 'Terms of Service',
    '/privacy': 'Privacy Policy'
  }

  // Handle dynamic routes
  if (pathname.startsWith('/workout/')) {
    return 'Workout Session'
  }
  if (pathname.startsWith('/history/')) {
    return 'Workout Detail'
  }

  return pathMap[pathname] || 'Unknown Page'
}


========================================
FILE: src/hooks/useSubscription.ts
========================================

import { useAppStore } from '../store'
import type { UserSubscription } from '../types/subscription'
import {
  canGenerateWorkout,
  getRemainingFreeWorkouts,
  getDaysRemaining,
  hasUnlimitedWorkouts,
  isInGracePeriod
} from '../lib/subscriptionService'

export function useSubscription() {
  const { subscription, subscriptionLoading } = useAppStore()

  // Calculate derived values
  const canGenerate = canGenerateWorkout(subscription)
  const remainingFree = getRemainingFreeWorkouts(subscription)
  const hasUnlimited = hasUnlimitedWorkouts(subscription)
  const inGracePeriod = isInGracePeriod(subscription)
  const daysLeft = getDaysRemaining(subscription)

  return {
    subscription,
    loading: subscriptionLoading,
    canGenerateWorkout: canGenerate,
    remainingFreeWorkouts: remainingFree,
    hasUnlimitedWorkouts: hasUnlimited,
    isInGracePeriod: inGracePeriod,
    daysRemaining: daysLeft,
    refreshSubscription: () => {
      // The AppProvider handles subscription refresh automatically
      // This is kept for API compatibility
    },
    // Legacy compatibility properties
    isHealthy: true,
    lastHealthCheck: Date.now(),
    recoveryInProgress: false,
    forceRecovery: async () => false,
    verifyPayment: async () => ({ isHealthy: true, needsAttention: false })
  }
}

// Hook for checking if user needs to upgrade
export function useUpgradePrompt() {
  const { canGenerateWorkout, remainingFreeWorkouts, hasUnlimitedWorkouts } = useSubscription()

  const shouldShowUpgrade = !canGenerateWorkout && !hasUnlimitedWorkouts
  const isNearLimit = remainingFreeWorkouts <= 1 && !hasUnlimitedWorkouts

  return {
    shouldShowUpgrade,
    isNearLimit,
    remainingFreeWorkouts
  }
}

// Hook for subscription status display
export function useSubscriptionStatus() {
  const { subscription, hasUnlimitedWorkouts, isInGracePeriod } = useSubscription()

  if (!subscription) {
    return {
      status: 'No subscription',
      statusColor: 'gray',
      description: 'Free plan with limited workouts'
    }
  }

  if (hasUnlimitedWorkouts) {
    return {
      status: 'Active',
      statusColor: 'green',
      description: 'Unlimited workouts'
    }
  }

  if (isInGracePeriod) {
    return {
      status: 'Grace Period',
      statusColor: 'yellow',
      description: 'Subscription expired, limited access'
    }
  }

  return {
    status: subscription.status,
    statusColor: subscription.status === 'active' ? 'green' : 'red',
    description: `Status: ${subscription.status}`
  }
}

// Consolidated subscription utilities - now using simplified service
export const subscriptionUtils = {
  isActive: (subscription?: UserSubscription): boolean => {
    return subscription?.status === 'active' || subscription?.status === 'trialing'
  },

  canGenerateWorkouts: canGenerateWorkout,
  getRemainingFreeWorkouts: getRemainingFreeWorkouts,

  getStatusText: (subscription?: UserSubscription): string => {
    if (!subscription) return 'No subscription'

    switch (subscription.status) {
      case 'active':
        return 'Active'
      case 'trialing':
        return 'Trial'
      case 'canceled':
        return 'Canceled'
      case 'incomplete':
        return 'Incomplete'
      case 'past_due':
        return 'Past Due'
      case 'unpaid':
        return 'Unpaid'
      default:
        return 'Unknown'
    }
  },

  getStatusColor: (subscription?: UserSubscription): string => {
    if (!subscription) return 'gray'

    switch (subscription.status) {
      case 'active':
      case 'trialing':
        return 'green'
      case 'canceled':
      case 'incomplete':
      case 'past_due':
      case 'unpaid':
        return 'red'
      default:
        return 'gray'
    }
  },

  formatPeriodDates: (subscription?: UserSubscription): { start: string; end: string } | null => {
    if (!subscription?.currentPeriodStart || !subscription?.currentPeriodEnd) {
      return null
    }

    const start = new Date(subscription.currentPeriodStart).toLocaleDateString()
    const end = new Date(subscription.currentPeriodEnd).toLocaleDateString()

    return { start, end }
  },

  getDaysUntilRenewal: getDaysRemaining,

  shouldShowUpgradePrompt: (subscription?: UserSubscription): boolean => {
    if (!subscription) return true
    if (subscriptionUtils.isActive(subscription)) return false

    const remaining = subscriptionUtils.getRemainingFreeWorkouts(subscription)
    return remaining <= 1 // Show when 1 or fewer workouts remaining
  },

  getUpgradePromptMessage: (subscription?: UserSubscription): string => {
    const remaining = subscriptionUtils.getRemainingFreeWorkouts(subscription)

    if (remaining === 0) {
      return 'You\'ve used all your free workouts. Upgrade to continue!'
    }

    if (remaining === 1) {
      return 'You have 1 free workout remaining. Upgrade for unlimited access!'
    }

    return `You have ${remaining} free workouts remaining.`
  }
}


========================================
FILE: src/hooks/useWorkoutPreload.ts
========================================

import { useState, useEffect, useCallback } from 'react'
import { auth, db } from '../lib/firebase'
import { doc, getDoc, collection, query, orderBy, limit, getDocs } from 'firebase/firestore'
import { useSubscription } from './useSubscription'
import { isAdaptivePersonalizationEnabled } from '../config/features'

export interface PreloadedData {
  profile: Record<string, unknown> | null
  targetIntensity: number
  progressionNote: string
  isLoading: boolean
  error: string | null
}

/**
 * Custom hook to pre-load workout generation data in the background
 * This reduces the time needed when the user clicks "Generate Workout"
 */
export function useWorkoutPreload() {
  const [preloadedData, setPreloadedData] = useState<PreloadedData>({
    profile: null,
    targetIntensity: 1.0,
    progressionNote: '',
    isLoading: true,
    error: null
  })

  const { subscription } = useSubscription()

  // Fetch adaptive intensity based on recent workout feedback
  const fetchAdaptiveIntensity = useCallback(async (uid: string) => {
    try {
      // Get recent workouts with feedback
      const workoutsRef = collection(db, 'users', uid, 'workouts')
      const workoutsQuery = query(workoutsRef, orderBy('timestamp', 'desc'), limit(5))
      const snapshot = await getDocs(workoutsQuery)

      if (snapshot.empty) {
        return { targetIntensity: 1.0, progressionNote: '' }
      }

      // Find the most recent workout with feedback
      let lastFeedback: 'easy' | 'right' | 'hard' | null = null
      let recentCompletionRate = 0.8 // default
      let totalSets = 0
      let completedSets = 0

      snapshot.docs.forEach(doc => {
        const workout = doc.data()

        // Get the most recent feedback
        if (!lastFeedback && workout.feedback) {
          lastFeedback = workout.feedback
        }

        // Calculate completion rate from all recent workouts
        if (workout.exercises && Array.isArray(workout.exercises)) {
          workout.exercises.forEach((exercise: { sets?: number; weights?: Record<string, number | null> }) => {
            if (exercise.weights && typeof exercise.weights === 'object') {
              const setCount = exercise.sets || Object.keys(exercise.weights).length
              totalSets += setCount

              Object.values(exercise.weights).forEach((weight: number | null) => {
                if (weight !== null) {
                  completedSets++
                }
              })
            } else {
              totalSets += exercise.sets || 0
              completedSets += exercise.sets || 0
            }
          })
        }
      })

      if (totalSets > 0) {
        recentCompletionRate = completedSets / totalSets
      }

      // Calculate target intensity based on feedback and completion rate
      let targetIntensity = 1.0
      let progressionNote = ''

      if (lastFeedback) {
        switch (lastFeedback) {
          case 'easy':
            targetIntensity = Math.min(1.4, 1.0 + 0.15) // Increase difficulty
            progressionNote = 'Increasing intensity based on your recent feedback that workouts felt easy.'
            break
          case 'hard':
            targetIntensity = Math.max(0.6, 1.0 - 0.15) // Decrease difficulty
            progressionNote = 'Reducing intensity based on your recent feedback that workouts felt challenging.'
            break
          case 'right':
            // Adjust slightly based on completion rate
            if (recentCompletionRate < 0.7) {
              targetIntensity = Math.max(0.6, 1.0 - 0.1)
              progressionNote = 'Slightly reducing intensity to improve completion rate.'
            } else if (recentCompletionRate > 0.9) {
              targetIntensity = Math.min(1.4, 1.0 + 0.1)
              progressionNote = 'Slightly increasing intensity based on excellent completion rate.'
            } else {
              progressionNote = 'Maintaining current intensity level based on your feedback.'
            }
            break
        }
      } else if (recentCompletionRate < 0.6) {
        targetIntensity = Math.max(0.6, 1.0 - 0.2)
        progressionNote = 'Reducing intensity to improve workout completion rate.'
      }

      return { targetIntensity, progressionNote }
    } catch (error) {
      console.error('Error fetching adaptive intensity:', error)
      return { targetIntensity: 1.0, progressionNote: '' }
    }
  }, [])

  // Pre-load all necessary data
  const preloadData = useCallback(async () => {
    const uid = auth.currentUser?.uid
    if (!uid) {
      setPreloadedData(prev => ({ ...prev, isLoading: false, error: 'No user authenticated' }))
      return
    }

    try {
      setPreloadedData(prev => ({ ...prev, isLoading: true, error: null }))

      // Run profile fetch and adaptive intensity fetch in parallel
      const [profileResult, adaptiveResult] = await Promise.allSettled([
        // Fetch user profile
        (async () => {
          const userDocRef = doc(db, 'users', uid)
          const snap = await getDoc(userDocRef)
          if (!snap.exists()) {
            throw new Error('Profile not found')
          }
          const profile = snap.data()
          // Basic completeness check
          const complete = !!(profile.experience && profile.goals?.length && profile.personal?.height && profile.personal?.weight)
          if (!complete) {
            throw new Error('Profile incomplete')
          }
          return profile
        })(),
        // Fetch adaptive intensity if enabled
        isAdaptivePersonalizationEnabled() ? fetchAdaptiveIntensity(uid) : Promise.resolve({ targetIntensity: 1.0, progressionNote: '' })
      ])

      // Handle results
      let profile = null
      let targetIntensity = 1.0
      let progressionNote = ''
      let error = null

      if (profileResult.status === 'fulfilled') {
        profile = profileResult.value
      } else {
        error = profileResult.reason?.message || 'Failed to load profile'
      }

      if (adaptiveResult.status === 'fulfilled') {
        targetIntensity = adaptiveResult.value.targetIntensity
        progressionNote = adaptiveResult.value.progressionNote
      } else {
        console.error('Error loading adaptive intensity:', adaptiveResult.reason)
        // Don't set error for adaptive intensity failure, use defaults
      }

      setPreloadedData({
        profile,
        targetIntensity,
        progressionNote,
        isLoading: false,
        error
      })

    } catch (error) {
      console.error('Error preloading workout data:', error)
      setPreloadedData(prev => ({
        ...prev,
        isLoading: false,
        error: error instanceof Error ? error.message : 'Failed to preload data'
      }))
    }
  }, [fetchAdaptiveIntensity])

  // Trigger preload when component mounts or user changes
  useEffect(() => {
    const unsubscribe = auth.onAuthStateChanged((user) => {
      if (user) {
        preloadData()
      } else {
        setPreloadedData({
          profile: null,
          targetIntensity: 1.0,
          progressionNote: '',
          isLoading: false,
          error: 'No user authenticated'
        })
      }
    })

    return unsubscribe
  }, [preloadData])

  // Refresh data when subscription changes (in case limits changed)
  useEffect(() => {
    if (auth.currentUser && subscription) {
      // Don't need to reload profile, just ensure we have latest subscription data
      // The subscription hook already handles this
    }
  }, [subscription])

  return {
    preloadedData,
    refreshPreloadedData: preloadData
  }
}


========================================
FILE: src/hooks/useMicroInteractions.tsx
========================================

import { useState } from 'react'

// Shake animation for errors
export function useShake() {
  const [isShaking, setIsShaking] = useState(false)

  const shake = () => {
    setIsShaking(true)
    setTimeout(() => setIsShaking(false), 500)
  }

  const shakeClass = isShaking ? 'animate-shake' : ''

  return { shake, shakeClass }
}

// Bounce animation for success states
export function useBounce() {
  const [isBouncing, setIsBouncing] = useState(false)

  const bounce = () => {
    setIsBouncing(true)
    setTimeout(() => setIsBouncing(false), 600)
  }

  const bounceClass = isBouncing ? 'animate-bounce-once' : ''

  return { bounce, bounceClass }
}


========================================
FILE: src/lib/errorManager.ts
========================================

// Simplified Error Management System
import type { AppError } from '../store'
import { useAppStore } from '../store'

// Simple error types
export const ErrorType = {
  AUTH: 'auth',
  NETWORK: 'network',
  VALIDATION: 'validation',
  UNKNOWN: 'unknown',
} as const

export type ErrorTypeValue = (typeof ErrorType)[keyof typeof ErrorType]

// User-friendly error messages
const ERROR_MESSAGES: Record<string, string> = {
  // Auth errors
  'auth/user-not-found': 'No account found with this email address',
  'auth/wrong-password': 'Incorrect password',
  'auth/email-already-in-use': 'An account with this email already exists',
  'auth/weak-password': 'Password must be at least 6 characters',
  'auth/invalid-email': 'Please enter a valid email address',
  'auth/too-many-requests': 'Too many failed attempts. Please try again later',
  'auth/network-request-failed': 'Network error. Please check your connection',

  // Network errors
  'network-error': 'Network connection failed. Please check your internet connection',
  'timeout': 'Request timed out. Please try again',
  'server-error': 'Server error. Please try again later',

  // Payment errors
  'subscription-required': 'You need an active subscription to access this feature',
  'payment-failed': 'Payment failed. Please check your payment method',

  // Generic fallback
  'unknown-error': 'An unexpected error occurred. Please try again',
}

class SimpleErrorManager {
  // Main error handling method
  handle(error: unknown, type: ErrorTypeValue = ErrorType.UNKNOWN): void {
    const normalizedError = this.normalizeError(error)
    const errorCode = this.extractErrorCode(normalizedError)
    const userMessage = this.getUserMessage(errorCode, normalizedError.message)

    // Create app error
    const appError: AppError = {
      id: `error_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
      type,
      message: userMessage,
      timestamp: Date.now(),
      resolved: false,
      details: {
        code: errorCode,
        originalMessage: normalizedError.message,
        url: window.location.href,
        timestamp: Date.now(),
      },
    }

    // Add to store
    const store = useAppStore.getState()
    store.addError(appError)

    // Log in development
    if (import.meta.env.DEV) {
      console.error('Error:', {
        type,
        code: errorCode,
        message: normalizedError.message,
      })
    }
  }

  // Specific error handlers
  handleAuth = (error: unknown): void => this.handle(error, ErrorType.AUTH)
  handleNetwork = (error: unknown): void => this.handle(error, ErrorType.NETWORK)
  handleValidation = (error: unknown): void => this.handle(error, ErrorType.VALIDATION)

  // Async wrapper with error handling
  async wrapAsync<T>(
    fn: () => Promise<T>,
    errorType: ErrorTypeValue = ErrorType.UNKNOWN
  ): Promise<T | null> {
    try {
      return await fn()
    } catch (error) {
      this.handle(error, errorType)
      return null
    }
  }

  // Utility methods
  getErrorMessage(error: unknown): string {
    if (error instanceof Error) return error.message
    if (typeof error === 'string') return error
    return 'Unknown error'
  }

  getErrorCode(error: unknown): string | null {
    if (error && typeof error === 'object' && 'code' in error) {
      return String(error.code)
    }
    return null
  }

  // Private helper methods
  private normalizeError(error: unknown): Error {
    if (error instanceof Error) return error
    if (typeof error === 'string') return new Error(error)
    return new Error('Unknown error')
  }

  private extractErrorCode(error: Error): string | undefined {
    if ('code' in error) return (error as { code: string }).code
    if (error.name === 'AbortError') return 'timeout'
    if (error.message.includes('fetch')) return 'network-error'
    if (error.message.includes('402') || error.message.includes('Payment Required')) return 'subscription-required'
    return undefined
  }

  private getUserMessage(code: string | undefined, originalMessage: string): string {
    if (code && ERROR_MESSAGES[code]) {
      return ERROR_MESSAGES[code]
    }

    // In production, use generic message for unknown errors
    if (import.meta.env.PROD) {
      return ERROR_MESSAGES['unknown-error']
    }

    // In development, show original message (sanitized)
    return originalMessage
      .replace(/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g, '[EMAIL]')
      .replace(/\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b/g, '[CARD]')
  }
}

// Create singleton instance
const errorManager = new SimpleErrorManager()

// Hook for React components
export const useErrorManager = () => ({
  handleError: errorManager.handle.bind(errorManager),
  handleAuth: errorManager.handleAuth,
  handleNetwork: errorManager.handleNetwork,
  handleValidation: errorManager.handleValidation,
  wrapAsync: errorManager.wrapAsync.bind(errorManager),
  getErrorMessage: errorManager.getErrorMessage.bind(errorManager),
  getErrorCode: errorManager.getErrorCode.bind(errorManager),
})

// Convenience functions
export const handleError = errorManager.handle.bind(errorManager)
export const handleAuthError = errorManager.handleAuth
export const handleNetworkError = errorManager.handleNetwork
export const handleValidationError = errorManager.handleValidation

// Export the manager instance
export { errorManager }


========================================
FILE: src/lib/firebase-analytics.ts
========================================

/**
 * Simplified Analytics Service for NeuraFit
 * Unified analytics, telemetry, and tracking system
 */

// Simple analytics configuration
interface AnalyticsConfig {
  enabled: boolean
  debug: boolean
  maxEvents: number
}

// Analytics event structure
interface AnalyticsEvent {
  event: string
  timestamp: number
  data: Record<string, unknown>
}

class SimpleAnalytics {
  private config: AnalyticsConfig
  private events: AnalyticsEvent[] = []

  constructor() {
    this.config = {
      enabled: true,
      debug: import.meta.env.DEV,
      maxEvents: 100
    }
  }

  private track(event: string, data: Record<string, unknown> = {}): void {
    if (!this.config.enabled) return

    const analyticsEvent: AnalyticsEvent = {
      event,
      timestamp: Date.now(),
      data: {
        ...data,
        url: window.location.href,
        userAgent: navigator.userAgent.substring(0, 50)
      }
    }

    // Store event locally
    this.events.push(analyticsEvent)

    // Keep only recent events
    if (this.events.length > this.config.maxEvents) {
      this.events = this.events.slice(-this.config.maxEvents)
    }

    // Debug logging
    if (this.config.debug) {
      console.log('Analytics:', event, data)
    }

    // Store in localStorage for debugging
    try {
      localStorage.setItem('nf_analytics_events', JSON.stringify(this.events.slice(-20)))
    } catch {
      // Ignore storage errors
    }
  }

  // User Authentication Events
  trackUserSignUp = (method: string): void => this.track('sign_up', { method })
  trackUserLogin = (method: string): void => this.track('login', { method })
  trackUserLogout = (): void => this.track('logout')

  // User Profile Events
  trackProfileComplete = (experience: string, goals: string[], equipment: string[]): void =>
    this.track('profile_complete', { experience, goals: goals.length, equipment: equipment.length })
  trackProfileUpdate = (field: string): void => this.track('profile_update', { field })

  // Page View Events
  trackPageView = (pageName: string, title?: string): void =>
    this.track('page_view', { page_title: title, page_name: pageName })

  // Workout Events (unified interface)
  trackWorkoutGenerated = (workoutType: string, duration?: number, exerciseCount?: number): void =>
    this.track('workout_generated', { workout_type: workoutType, duration, exercise_count: exerciseCount })
  trackWorkoutStarted = (workoutType: string): void => this.track('workout_started', { workout_type: workoutType })
  trackWorkoutCompleted = (workoutType: string, duration: number, completionRate: number): void =>
    this.track('workout_completed', { workout_type: workoutType, duration, completion_rate: completionRate })
  trackWorkoutAbandoned = (workoutType: string, progress: number): void =>
    this.track('workout_abandoned', { workout_type: workoutType, progress })

  // Exercise Events
  trackExerciseCompleted = (exerciseName: string, sets: number, reps: number): void =>
    this.track('exercise_completed', { exerciseName, sets, reps })
  trackExerciseSkipped = (exerciseName: string, reason: string): void =>
    this.track('exercise_skipped', { exerciseName, reason })
  trackRestCompleted = (duration: number): void => this.track('rest_completed', { duration })
  trackRestSkipped = (): void => this.track('rest_skipped')

  // Subscription Events
  trackSubscriptionStarted = (plan?: string, price?: number): void =>
    this.track('subscription_started', { plan, price })
  trackSubscriptionCompleted = (plan?: string, price?: number): void =>
    this.track('subscription_completed', { plan, price })
  trackSubscriptionCancelled = (plan: string, reason?: string): void =>
    this.track('subscription_cancelled', { plan, reason })
  trackSubscriptionReactivated = (plan: string): void =>
    this.track('subscription_reactivated', { plan })
  trackPaymentFailed = (plan: string, error: string): void =>
    this.track('payment_failed', { plan, error })
  trackFreeTrialStarted = (): void => this.track('free_trial_started')

  // Feature Usage Events
  trackFeatureUsed = (feature: string, context?: string): void =>
    this.track('feature_used', { feature, context })
  trackButtonClicked = (buttonName: string, location: string): void =>
    this.track('button_clicked', { button_name: buttonName, location })
  trackFormSubmitted = (formName: string, success: boolean): void =>
    this.track('form_submitted', { form_name: formName, success })

  // Custom Events
  trackCustomEvent = (eventName: string, parameters: Record<string, unknown>): void =>
    this.track(eventName, parameters)
  trackError = (error: string, context?: string): void =>
    this.track('error', { error, context })

  // Telemetry Events (simplified from telemetry.ts)
  trackAdaptiveFeedback = (feedback: 'easy' | 'right' | 'hard', rpe: number | null, completionRate: number): void =>
    this.track('adaptive_feedback', { feedback, rpe, completion_rate: completionRate })

  // Utility methods
  getEvents = (): AnalyticsEvent[] => [...this.events]
  clearEvents = (): void => { this.events = [] }
  setConfig = (config: Partial<AnalyticsConfig>): void => { this.config = { ...this.config, ...config } }
}

// Create singleton instance
const analytics = new SimpleAnalytics()

// Export all tracking functions
export const {
  trackUserSignUp,
  trackUserLogin,
  trackUserLogout,
  trackProfileComplete,
  trackProfileUpdate,
  trackPageView,
  trackWorkoutGenerated,
  trackWorkoutStarted,
  trackWorkoutCompleted,
  trackWorkoutAbandoned,
  trackExerciseCompleted,
  trackExerciseSkipped,
  trackRestCompleted,
  trackRestSkipped,
  trackSubscriptionStarted,
  trackSubscriptionCompleted,
  trackSubscriptionCancelled,
  trackSubscriptionReactivated,
  trackPaymentFailed,
  trackFreeTrialStarted,
  trackFeatureUsed,
  trackButtonClicked,
  trackFormSubmitted,
  trackCustomEvent,
  trackError,
  trackAdaptiveFeedback
} = analytics

// Legacy compatibility exports
export const setUserAnalyticsProperties = (_userId: string, _properties: Record<string, unknown>): void => {}
export const setEnhancedUserProperties = (_userId: string, _userProfile: Record<string, unknown>): void => {}
export const trackSessionStart = (): void => analytics.trackCustomEvent('session_start', {})
export const trackFreeTrialLimitReached = (): void =>
  analytics.trackCustomEvent('free_trial_limit_reached', {})

// Export analytics instance
export { analytics }


========================================
FILE: src/lib/firebase.ts
========================================

// Simplified Firebase configuration using standard Firebase v9+ modular SDK
import { initializeApp, type FirebaseApp } from 'firebase/app'
import { getAuth, type Auth } from 'firebase/auth'
import { getFirestore, type Firestore } from 'firebase/firestore'
import { getFunctions, type Functions } from 'firebase/functions'
import { getAnalytics, type Analytics, isSupported } from 'firebase/analytics'

// Firebase configuration
const firebaseConfig = {
  apiKey: 'AIzaSyAKo_Bf8aPCWSPM9Nigcnga1t6_Psi70T8',
  authDomain: 'neurafit-ai-2025.firebaseapp.com',
  projectId: 'neurafit-ai-2025',
  storageBucket: 'neurafit-ai-2025.firebasestorage.app',
  messagingSenderId: '226392212811',
  appId: '1:226392212811:web:4e41b01723ca5ecec8d4ce',
  measurementId: 'G-5LHTKTWX0M',
}

// Initialize Firebase
console.log('🔥 Initializing Firebase...')
const app: FirebaseApp = initializeApp(firebaseConfig)

// Initialize services
export const auth: Auth = getAuth(app)
export const db: Firestore = getFirestore(app)
export const fns: Functions = getFunctions(app)

// Initialize analytics conditionally
let analytics: Analytics | null = null
isSupported().then((supported) => {
  if (supported) {
    analytics = getAnalytics(app)
    console.log('✅ Firebase Analytics initialized')
  }
}).catch((error) => {
  console.warn('⚠️ Analytics initialization failed:', error)
})

console.log('✅ Firebase initialization complete!')

// Simplified service getters (now synchronous)
export const getAuthInstance = (): Auth => auth
export const getFirestoreInstance = (): Firestore => db
export const getFunctionsInstance = (): Functions => fns
export const getAnalyticsInstance = (): Analytics | null => analytics



========================================
FILE: src/lib/optimisticUpdates.ts
========================================

// src/lib/optimisticUpdates.ts
import { useState, useCallback, useRef } from 'react'

export type OptimisticState<T> = {
  data: T
  isOptimistic: boolean
  error: string | null
  isLoading: boolean
}

export type OptimisticAction<T> = {
  optimisticUpdate: (_current: T) => T
  serverUpdate: () => Promise<T>
  onSuccess?: (_result: T) => void
  onError?: (_error: Error) => void
}

/**
 * Hook for managing optimistic updates with automatic rollback on failure
 */
export function useOptimisticUpdate<T>(initialData: T) {
  const [state, setState] = useState<OptimisticState<T>>({
    data: initialData,
    isOptimistic: false,
    error: null,
    isLoading: false
  })

  const rollbackRef = useRef<T | null>(null)

  const executeOptimisticUpdate = useCallback(async (action: OptimisticAction<T>) => {
    // Store current state for potential rollback
    rollbackRef.current = state.data

    // Apply optimistic update immediately
    const optimisticData = action.optimisticUpdate(state.data)
    setState(prev => ({
      ...prev,
      data: optimisticData,
      isOptimistic: true,
      error: null,
      isLoading: true
    }))

    try {
      // Execute server update
      const result = await action.serverUpdate()
      
      // Update with server response
      setState(prev => ({
        ...prev,
        data: result,
        isOptimistic: false,
        isLoading: false,
        error: null
      }))

      action.onSuccess?.(result)
      rollbackRef.current = null
    } catch (error) {
      // Rollback to previous state on error
      const rollbackData = rollbackRef.current || initialData
      setState(prev => ({
        ...prev,
        data: rollbackData,
        isOptimistic: false,
        isLoading: false,
        error: error instanceof Error ? error.message : 'An error occurred'
      }))

      action.onError?.(error instanceof Error ? error : new Error('Unknown error'))
      rollbackRef.current = null
    }
  }, [state.data, initialData])

  const updateData = useCallback((newData: T) => {
    setState(prev => ({
      ...prev,
      data: newData,
      isOptimistic: false,
      error: null
    }))
  }, [])

  const clearError = useCallback(() => {
    setState(prev => ({ ...prev, error: null }))
  }, [])

  return {
    ...state,
    executeOptimisticUpdate,
    updateData,
    clearError
  }
}

/**
 * Utility for creating optimistic workout weight updates
 */
export function createWeightUpdateAction(
  exerciseIndex: number,
  setNumber: number,
  weight: number | null,
  onServerUpdate: (_exerciseIndex: number, _setNumber: number, _weight: number | null) => Promise<void>
): OptimisticAction<Record<number, Record<number, number | null>>> {
  return {
    optimisticUpdate: (currentWeights) => ({
      ...currentWeights,
      [exerciseIndex]: {
        ...currentWeights[exerciseIndex],
        [setNumber]: weight
      }
    }),
    serverUpdate: async () => {
      await onServerUpdate(exerciseIndex, setNumber, weight)
      // Return the updated weights (in real implementation, this might come from server)
      const savedWeights = sessionStorage.getItem('nf_workout_weights')
      return savedWeights ? JSON.parse(savedWeights) : {}
    }
  }
}

/**
 * Utility for creating optimistic set completion updates
 */
export function createSetCompletionAction(
  exerciseIndex: number,
  setNumber: number,
  isComplete: boolean,
  weight?: number | null
): OptimisticAction<Record<number, Record<number, number | null>>> {
  return {
    optimisticUpdate: (currentWeights) => ({
      ...currentWeights,
      [exerciseIndex]: {
        ...currentWeights[exerciseIndex],
        [setNumber]: isComplete ? (weight !== undefined ? weight : 0) : null
      }
    }),
    serverUpdate: async () => {
      // Get current weights from session storage
      const savedWeights = sessionStorage.getItem('nf_workout_weights')
      const currentWeights = savedWeights ? JSON.parse(savedWeights) : {}

      const updatedWeights = {
        ...currentWeights,
        [exerciseIndex]: {
          ...currentWeights[exerciseIndex],
          [setNumber]: isComplete ? (weight !== undefined ? weight : 0) : null
        }
      }
      sessionStorage.setItem('nf_workout_weights', JSON.stringify(updatedWeights))
      return updatedWeights
    }
  }
}

// Debounce functionality moved to a shared utility if needed

/**
 * Cache utility for storing and retrieving data with expiration
 */
export class OptimisticCache<T> {
  private cache = new Map<string, { data: T; timestamp: number; ttl: number }>()

  set(key: string, data: T, ttlMs: number = 5 * 60 * 1000) {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl: ttlMs
    })
  }

  get(key: string): T | null {
    const entry = this.cache.get(key)
    if (!entry) return null

    if (Date.now() - entry.timestamp > entry.ttl) {
      this.cache.delete(key)
      return null
    }

    return entry.data
  }

  invalidate(key: string) {
    this.cache.delete(key)
  }

  clear() {
    this.cache.clear()
  }
}

// Global cache instances
export const workoutCache = new OptimisticCache<Record<string, unknown>>()
export const profileCache = new OptimisticCache<Record<string, unknown>>()

/**
 * Preloader utility for prefetching data
 */
export class DataPreloader {
  private static instance: DataPreloader
  private preloadQueue = new Set<string>()

  static getInstance() {
    if (!DataPreloader.instance) {
      DataPreloader.instance = new DataPreloader()
    }
    return DataPreloader.instance
  }

  async preload(key: string, fetcher: () => Promise<unknown>, cache: OptimisticCache<unknown>) {
    if (this.preloadQueue.has(key)) return
    
    this.preloadQueue.add(key)
    
    try {
      const data = await fetcher()
      cache.set(key, data)
    } catch (error) {
      console.warn(`Failed to preload ${key}:`, error)
    } finally {
      this.preloadQueue.delete(key)
    }
  }
}

export const preloader = DataPreloader.getInstance()

/**
 * Error boundary utility for graceful error handling
 */
export function createErrorHandler(fallback: () => void) {
  return (error: Error) => {
    console.error('Optimistic update failed:', error)
    
    // Log to analytics if available
    if (typeof window !== 'undefined' && 'gtag' in window) {
      (window as { gtag: (_event: string, _action: string, _params: Record<string, unknown>) => void }).gtag('event', 'exception', {
        description: error.message,
        fatal: false
      })
    }

    fallback()
  }
}

/**
 * Retry utility with exponential backoff
 */
export async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3,
  baseDelay: number = 1000
): Promise<T> {
  let lastError: Error

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await fn()
    } catch (error) {
      lastError = error instanceof Error ? error : new Error('Unknown error')
      
      if (attempt === maxRetries) break
      
      const delay = baseDelay * Math.pow(2, attempt)
      await new Promise(resolve => setTimeout(resolve, delay))
    }
  }

  throw lastError!
}


========================================
FILE: src/lib/security.ts
========================================

// Simplified Security Utilities
import { handleError } from './errorManager'

class SecurityManager {
  constructor() {
    this.setupBasicSecurity()
  }

  // Basic security setup
  private setupBasicSecurity(): void {
    // Only disable console in production
    if (import.meta.env.PROD) {
      console.log = () => {}
      console.info = () => {}
      console.warn = () => {}
    }
  }

  // Basic input sanitization
  public sanitizeInput(input: string): string {
    if (typeof input !== 'string') return ''

    return input
      .trim()
      .replace(/[<>]/g, '') // Remove HTML tags
      .replace(/javascript:/gi, '') // Remove javascript: protocols
      .substring(0, 1000) // Limit length
  }

  public sanitizeHTML(html: string): string {
    const div = document.createElement('div')
    div.textContent = html
    return div.innerHTML
  }

  public sanitizeURL(url: string): string {
    try {
      const parsed = new URL(url)

      // Only allow http/https protocols
      if (!['http:', 'https:'].includes(parsed.protocol)) {
        throw new Error('Invalid protocol')
      }

      return parsed.toString()
    } catch {
      return '#'
    }
  }

  // Simple secure API request
  public secureApiRequest(url: string, options: RequestInit = {}): Promise<Response> {
    // Add basic security headers
    const secureOptions: RequestInit = {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...options.headers
      },
      credentials: 'same-origin',
    }

    // Validate URL
    const sanitizedUrl = this.sanitizeURL(url)
    if (sanitizedUrl === '#') {
      return Promise.reject(new Error('Invalid URL'))
    }

    return fetch(sanitizedUrl, secureOptions)
      .catch(error => {
        handleError(error)
        throw error
      })
  }

  // Simple storage operations
  public secureSetItem(key: string, value: unknown): void {
    try {
      const sanitizedKey = this.sanitizeInput(key)
      const serializedValue = JSON.stringify(value)
      localStorage.setItem(sanitizedKey, serializedValue)
    } catch (error) {
      handleError(error)
    }
  }

  public secureGetItem<T = unknown>(key: string): T | null {
    try {
      const sanitizedKey = this.sanitizeInput(key)
      const item = localStorage.getItem(sanitizedKey)

      if (!item) return null

      return JSON.parse(item) as T
    } catch {
      return null
    }
  }
}

// Create singleton instance
const securityManager = new SecurityManager()

// Convenience functions
export const sanitizeInput = (input: string) => securityManager.sanitizeInput(input)
export const sanitizeHTML = (html: string) => securityManager.sanitizeHTML(html)
export const sanitizeURL = (url: string) => securityManager.sanitizeURL(url)
export const secureApiRequest = (url: string, options?: RequestInit) =>
  securityManager.secureApiRequest(url, options)
export const secureSetItem = (key: string, value: unknown) =>
  securityManager.secureSetItem(key, value)
export const secureGetItem = (key: string) => securityManager.secureGetItem(key)

// React hook for security utilities
export const useSecurity = () => ({
  sanitizeInput,
  sanitizeHTML,
  sanitizeURL,
  secureApiRequest,
  secureSetItem,
  secureGetItem,
})

// Export the manager instance
export { securityManager }


========================================
FILE: src/lib/stripe-config.ts
========================================

/**
 * Stripe configuration for NeuraFit
 */

import { loadStripe } from '@stripe/stripe-js'

// Stripe publishable key (test key provided by user)
const STRIPE_PUBLISHABLE_KEY = 'pk_test_51RlpPwQjUU16Imh7NtysYpU3jWIYJI2tl13IGJlLunXASqRSIvawsKbzM090PHQ7IbdHGYxbcH5l31a7fIArCKz700uq9hyVBp'

// Initialize Stripe
export const stripePromise = loadStripe(STRIPE_PUBLISHABLE_KEY)

// Stripe configuration
export const STRIPE_CONFIG = {
  publishableKey: STRIPE_PUBLISHABLE_KEY,
  appearance: {
    theme: 'stripe' as const,
    variables: {
      colorPrimary: '#3b82f6',
      colorBackground: '#ffffff',
      colorText: '#1f2937',
      colorDanger: '#ef4444',
      fontFamily: 'system-ui, sans-serif',
      spacingUnit: '4px',
      borderRadius: '8px'
    }
  },
  clientSecret: undefined as string | undefined
}

// Subscription plans with actual Stripe price IDs
// Simple $10/month plan
export const STRIPE_PRICE_IDS = {
  simple: 'price_1SCzf7QjUU16Imh7y9nLUIvP' // Simple Pro - $10.00/month (Updated)
}

// Simple subscription plan - single $10/month option (exactly 30 days)
export const SUBSCRIPTION_PLANS = [
  {
    id: 'simple',
    name: 'NeuraFit Pro',
    description: 'Unlimited AI-powered workouts',
    price: 1000, // $10.00
    currency: 'usd',
    interval: 'month' as const, // Exactly 30 days as configured in Stripe
    stripePriceId: STRIPE_PRICE_IDS.simple,
    popular: true,
    features: [
      'Unlimited workout generation',
      'Advanced personalization',
      'Progress tracking',
      'Weight history',
      'Priority support'
    ]
  }
] as const

// Subscription duration constants
export const SUBSCRIPTION_DURATION = {
  DAYS: 30,
  MILLISECONDS: 30 * 24 * 60 * 60 * 1000
} as const

export type SubscriptionPlanId = typeof SUBSCRIPTION_PLANS[number]['id']

// Helper functions
export function formatPrice(priceInCents: number, currency: string = 'usd'): string {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: currency.toUpperCase(),
  }).format(priceInCents / 100)
}

export function getSubscriptionPlan(planId: SubscriptionPlanId) {
  return SUBSCRIPTION_PLANS.find(plan => plan.id === planId)
}

export function getSubscriptionPlanByPriceId(priceId: string) {
  return SUBSCRIPTION_PLANS.find(plan => plan.stripePriceId === priceId)
}

// Subscription duration validation
export function validateSubscriptionDuration(startDate: number, endDate: number): boolean {
  const durationMs = endDate - startDate
  const expectedDurationMs = SUBSCRIPTION_DURATION.MILLISECONDS

  // Allow for small variations (up to 1 hour) to account for timezone differences
  const tolerance = 60 * 60 * 1000 // 1 hour in milliseconds
  const difference = Math.abs(durationMs - expectedDurationMs)

  return difference <= tolerance
}

export function calculateSubscriptionEndDate(startDate: number): number {
  return startDate + SUBSCRIPTION_DURATION.MILLISECONDS
}


========================================
FILE: src/lib/subscriptionService.ts
========================================

/**
 * Unified Subscription Service
 * Consolidates all subscription management functionality into a single, simplified service
 */

import { httpsCallable } from 'firebase/functions'
import { doc, getDoc, onSnapshot } from 'firebase/firestore'
import { auth, db, fns } from './firebase'
import type { UserSubscription } from '../types/subscription'
import { validateSubscriptionDuration } from './stripe-config'

export interface SubscriptionServiceOptions {
  enableCache?: boolean
  cacheTimeout?: number
  maxRetries?: number
}

class SubscriptionService {
  private cache = new Map<string, { data: UserSubscription | null; timestamp: number }>()
  private listeners = new Map<string, () => void>()
  private options: Required<SubscriptionServiceOptions>

  constructor(options: SubscriptionServiceOptions = {}) {
    this.options = {
      enableCache: options.enableCache ?? true,
      cacheTimeout: options.cacheTimeout ?? 300000, // 5 minutes
      maxRetries: options.maxRetries ?? 3
    }
  }

  /**
   * Get subscription data with caching and fallback mechanisms
   */
  async getSubscription(userId?: string): Promise<UserSubscription | null> {
    try {
      const uid = userId || auth.currentUser?.uid
      if (!uid) return null

      // Check cache first
      if (this.options.enableCache) {
        const cached = this.cache.get(uid)
        if (cached && Date.now() - cached.timestamp < this.options.cacheTimeout) {
          return cached.data
        }
      }

      // Fetch from Firestore
      const subscription = await this.fetchFromFirestore(uid)
      
      // Update cache
      if (this.options.enableCache) {
        this.cache.set(uid, { data: subscription, timestamp: Date.now() })
      }

      return subscription
    } catch (error) {
      console.error('Error getting subscription:', error)
      return null
    }
  }

  /**
   * Fetch subscription from Firestore
   */
  private async fetchFromFirestore(uid: string): Promise<UserSubscription | null> {
    try {
      const userDocRef = doc(db, 'users', uid)
      const userDoc = await getDoc(userDocRef)
      
      if (!userDoc.exists()) return null
      
      const userData = userDoc.data()
      return userData.subscription as UserSubscription || null
    } catch (error) {
      console.error('Error fetching from Firestore:', error)
      return null
    }
  }

  /**
   * Set up real-time subscription listener
   */
  async setupListener(
    callback: (_subscription: UserSubscription | null) => void,
    userId?: string
  ): Promise<string> {
    try {
      const uid = userId || auth.currentUser?.uid
      if (!uid) throw new Error('No user ID available')

      const userDocRef = doc(db, 'users', uid)
      const unsubscribe = onSnapshot(
        userDocRef,
        (doc) => {
          if (doc.exists()) {
            const userData = doc.data()
            const subscription = userData.subscription as UserSubscription || null
            
            // Update cache
            if (this.options.enableCache) {
              this.cache.set(uid, { data: subscription, timestamp: Date.now() })
            }
            
            callback(subscription)
          } else {
            callback(null)
          }
        },
        (error) => {
          console.error('Subscription listener error:', error)
          callback(null)
        }
      )

      const listenerId = Math.random().toString(36).substr(2, 9)
      this.listeners.set(listenerId, unsubscribe)
      
      return listenerId
    } catch (error) {
      console.error('Error setting up listener:', error)
      throw error
    }
  }

  /**
   * Remove subscription listener
   */
  removeListener(listenerId: string): void {
    const unsubscribe = this.listeners.get(listenerId)
    if (unsubscribe) {
      unsubscribe()
      this.listeners.delete(listenerId)
    }
  }

  /**
   * Create payment intent for subscription with retry logic
   */
  async createPaymentIntent(priceId: string): Promise<{ clientSecret: string } | null> {
    let lastError: Error | null = null

    for (let attempt = 1; attempt <= this.options.maxRetries; attempt++) {
      try {
        console.log(`Creating payment intent (attempt ${attempt}/${this.options.maxRetries})`)

        const createPaymentIntentFn = httpsCallable(fns, 'createPaymentIntent')
        const result = await createPaymentIntentFn({ priceId })

        const data = result.data as { clientSecret?: string; error?: string }
        if (data.error) throw new Error(data.error)

        if (data.clientSecret) {
          console.log('Payment intent created successfully')
          return { clientSecret: data.clientSecret }
        }

        throw new Error('No client secret returned')
      } catch (error) {
        lastError = error instanceof Error ? error : new Error('Unknown error')
        console.error(`Payment intent creation attempt ${attempt} failed:`, lastError.message)

        if (attempt < this.options.maxRetries) {
          const delay = Math.min(1000 * Math.pow(2, attempt - 1), 5000) // Exponential backoff, max 5s
          console.log(`Retrying in ${delay}ms...`)
          await new Promise(resolve => setTimeout(resolve, delay))
        }
      }
    }

    console.error('All payment intent creation attempts failed')
    throw lastError || new Error('Failed to create payment intent after all retries')
  }

  /**
   * Cancel subscription with retry logic
   */
  async cancelSubscription(): Promise<boolean> {
    let lastError: Error | null = null

    // First, get the subscription data to retrieve the subscriptionId
    const subscription = await this.getSubscription()
    if (!subscription) {
      throw new Error('No subscription found. Please refresh and try again.')
    }

    if (!subscription.subscriptionId) {
      throw new Error('Subscription ID not found. Unable to cancel subscription.')
    }

    const subscriptionId = subscription.subscriptionId

    for (let attempt = 1; attempt <= this.options.maxRetries; attempt++) {
      try {
        console.log(`Canceling subscription ${subscriptionId} (attempt ${attempt}/${this.options.maxRetries})`)

        const cancelFn = httpsCallable(fns, 'cancelUserSubscription')
        const result = await cancelFn({ subscriptionId })

        const data = result.data as { success?: boolean; error?: string }
        if (data.error) throw new Error(data.error)

        if (data.success) {
          console.log('Subscription cancelled successfully')
          // Clear cache to force refresh
          this.clearCache()
          return true
        }

        throw new Error('Cancellation failed - no success response')
      } catch (error) {
        lastError = error instanceof Error ? error : new Error('Unknown error')
        console.error(`Subscription cancellation attempt ${attempt} failed:`, lastError.message)

        if (attempt < this.options.maxRetries) {
          const delay = Math.min(1000 * Math.pow(2, attempt - 1), 3000) // Exponential backoff, max 3s
          console.log(`Retrying in ${delay}ms...`)
          await new Promise(resolve => setTimeout(resolve, delay))
        }
      }
    }

    console.error('All subscription cancellation attempts failed')
    throw lastError || new Error('Failed to cancel subscription after all retries')
  }

  /**
   * Reactivate subscription
   */
  async reactivateSubscription(): Promise<boolean> {
    try {
      // First, get the subscription data to retrieve the subscriptionId
      const subscription = await this.getSubscription()
      if (!subscription) {
        throw new Error('No subscription found. Please refresh and try again.')
      }

      if (!subscription.subscriptionId) {
        throw new Error('Subscription ID not found. Unable to reactivate subscription.')
      }

      const subscriptionId = subscription.subscriptionId
      console.log(`Reactivating subscription ${subscriptionId}`)

      const reactivateFn = httpsCallable(fns, 'reactivateUserSubscription')
      const result = await reactivateFn({ subscriptionId })

      const data = result.data as { success?: boolean }

      if (data.success) {
        console.log('Subscription reactivated successfully')
        // Clear cache to force refresh
        this.clearCache()
        return true
      }

      return false
    } catch (error) {
      console.error('Error reactivating subscription:', error)
      throw error instanceof Error ? error : new Error('Failed to reactivate subscription')
    }
  }

  /**
   * Get customer portal URL
   */
  async getCustomerPortalUrl(): Promise<string | null> {
    try {
      const subscription = await this.getSubscription()
      if (!subscription?.customerId) return null

      const getPortalFn = httpsCallable(fns, 'getCustomerPortalUrl')
      const result = await getPortalFn({
        customerId: subscription.customerId,
        returnUrl: window.location.origin + '/profile'
      })

      const data = result.data as { url?: string }
      return data.url || null
    } catch (error) {
      console.error('Error getting customer portal URL:', error)
      return null
    }
  }

  /**
   * Validate subscription data integrity
   */
  validateSubscription(subscription: UserSubscription): boolean {
    // Check required fields
    if (!subscription.customerId && subscription.status !== 'incomplete') {
      console.warn('Subscription missing customer ID')
      return false
    }

    // Validate free workout limits
    if (subscription.freeWorkoutLimit !== 10) {
      console.warn('Subscription has incorrect free workout limit:', subscription.freeWorkoutLimit)
    }

    // Validate workout counts
    if (subscription.freeWorkoutsUsed > subscription.freeWorkoutLimit) {
      console.warn('Free workouts used exceeds limit')
      return false
    }

    return true
  }

  /**
   * Perform subscription health check
   */
  async performHealthCheck(): Promise<{ healthy: boolean; issues: string[] }> {
    const issues: string[] = []

    try {
      const subscription = await this.getSubscription()

      if (!subscription) {
        issues.push('No subscription data found')
        return { healthy: false, issues }
      }

      // Validate subscription data
      if (!this.validateSubscription(subscription)) {
        issues.push('Subscription data validation failed')
      }

      // Check for stale data
      const now = Date.now()
      const lastUpdate = subscription.updatedAt || 0
      const staleThreshold = 24 * 60 * 60 * 1000 // 24 hours

      if (now - lastUpdate > staleThreshold) {
        issues.push('Subscription data is stale (last updated > 24h ago)')
      }

      return { healthy: issues.length === 0, issues }
    } catch (error) {
      issues.push(`Health check failed: ${error instanceof Error ? error.message : 'Unknown error'}`)
      return { healthy: false, issues }
    }
  }

  /**
   * Recover from subscription sync issues
   */
  async recoverSubscriptionSync(): Promise<boolean> {
    try {
      console.log('🔄 Attempting subscription sync recovery...')

      const uid = auth.currentUser?.uid
      if (!uid) {
        console.error('No authenticated user for sync recovery')
        return false
      }

      // Clear stale cache
      this.clearCache(uid)

      // Force refresh from Firestore
      const subscription = await this.fetchFromFirestore(uid)

      if (!subscription) {
        console.warn('No subscription found during recovery')
        return false
      }

      // Validate subscription data
      const isValid = this.validateSubscription(subscription)
      if (!isValid) {
        console.warn('Subscription data validation failed during recovery')
        // Could trigger a webhook re-sync here if needed
      }

      console.log('✅ Subscription sync recovery completed')
      return true
    } catch (error) {
      console.error('❌ Subscription sync recovery failed:', error)
      return false
    }
  }

  /**
   * Handle subscription errors with automatic recovery
   */
  async handleSubscriptionError(error: Error, context: string): Promise<void> {
    console.error(`Subscription error in ${context}:`, error)

    // Attempt recovery for specific error types
    if (error.message.includes('subscription') || error.message.includes('sync')) {
      console.log('Attempting automatic recovery...')
      const recovered = await this.recoverSubscriptionSync()

      if (recovered) {
        console.log('✅ Automatic recovery successful')
        return
      }
    }

    // Log error for monitoring
    console.error(`❌ Unrecoverable subscription error in ${context}:`, {
      message: error.message,
      stack: error.stack,
      timestamp: new Date().toISOString(),
      userId: auth.currentUser?.uid
    })
  }

  /**
   * Clear cache for a user
   */
  clearCache(userId?: string): void {
    if (userId) {
      this.cache.delete(userId)
    } else {
      this.cache.clear()
    }
  }

  /**
   * Cleanup all listeners and cache
   */
  cleanup(): void {
    this.listeners.forEach(unsubscribe => unsubscribe())
    this.listeners.clear()
    this.cache.clear()
  }
}

// Export singleton instance
export const subscriptionService = new SubscriptionService()

// Utility functions for subscription logic
export const canGenerateWorkout = (subscription?: UserSubscription): boolean => {
  if (!subscription) return true // Allow free workouts

  // Active subscription = unlimited workouts
  if (subscription.status === 'active' || subscription.status === 'trialing') {
    return true
  }

  // Free tier - check usage
  const used = subscription.freeWorkoutsUsed || 0
  const limit = subscription.freeWorkoutLimit || 10
  return used < limit
}

export const getRemainingFreeWorkouts = (subscription?: UserSubscription): number => {
  if (!subscription) return 10
  if (subscription.status === 'active' || subscription.status === 'trialing') return Infinity

  const used = subscription.freeWorkoutsUsed || 0
  const limit = subscription.freeWorkoutLimit || 10
  return Math.max(0, limit - used)
}

export const hasUnlimitedWorkouts = (subscription?: UserSubscription): boolean => {
  return subscription?.status === 'active' || subscription?.status === 'trialing'
}

export const isInGracePeriod = (subscription?: UserSubscription): boolean => {
  if (!subscription || !subscription.currentPeriodEnd) return false
  
  const now = Date.now()
  const gracePeriodEnd = subscription.currentPeriodEnd + (7 * 24 * 60 * 60 * 1000) // 7 days
  
  return subscription.status === 'canceled' && now < gracePeriodEnd
}

export const getDaysRemaining = (subscription?: UserSubscription): number => {
  if (!subscription?.currentPeriodEnd) return 0
  
  const now = Date.now()
  const diffMs = subscription.currentPeriodEnd - now
  const diffDays = Math.ceil(diffMs / (1000 * 60 * 60 * 24))
  
  return Math.max(0, diffDays)
}

export const formatDate = (timestamp: number): string => {
  return new Date(timestamp).toLocaleDateString()
}

// Subscription duration validation
export const validateSubscriptionPeriod = (subscription?: UserSubscription): boolean => {
  if (!subscription?.currentPeriodStart || !subscription?.currentPeriodEnd) {
    return false
  }

  return validateSubscriptionDuration(
    subscription.currentPeriodStart,
    subscription.currentPeriodEnd
  )
}

export const getSubscriptionDurationDays = (subscription?: UserSubscription): number => {
  if (!subscription?.currentPeriodStart || !subscription?.currentPeriodEnd) {
    return 0
  }

  const durationMs = subscription.currentPeriodEnd - subscription.currentPeriodStart
  return Math.round(durationMs / (24 * 60 * 60 * 1000))
}


========================================
FILE: src/lib/user-utils.ts
========================================

import { db } from './firebase';
import { doc, getDoc, setDoc } from 'firebase/firestore';
import type { User } from 'firebase/auth';

/**
 * Ensures a user document exists in Firestore
 * Creates it with basic info if it doesn't exist
 */
export async function ensureUserDocument(user: User): Promise<void> {
  try {
    console.log('🔍 Ensuring user document for:', user.uid);

    // Firestore is now available synchronously

    console.log('✅ Firestore instance ready, creating user document...');
    const userDocRef = doc(db, 'users', user.uid);
    const userDoc = await getDoc(userDocRef);

    if (!userDoc.exists()) {
      console.log('Creating user document for:', user.uid);
      await setDoc(userDocRef,
        {
          uid: user.uid,
          email: user.email,
          displayName: user.displayName || null,
          photoURL: user.photoURL || null,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        },
        { merge: true }
      );
      console.log('User document created successfully');
    } else {
      // Optional: Update updated_at if document exists
      await setDoc(userDocRef,
        {
          updated_at: new Date().toISOString(),
        },
        { merge: true }
      );
    }
  } catch (error) {
    console.error('Error ensuring user document:', error);
    throw new Error('Failed to ensure user document exists');
  }
}

/**
 * Creates a default subscription for a user if it doesn't exist
 */
export async function createDefaultSubscription(uid: string): Promise<void> {
  try {

    const userDocRef = doc(db, 'users', uid);
    const userDoc = await getDoc(userDocRef);

    if (!userDoc.exists()) {
      throw new Error('User document does not exist');
    }

    const userData = userDoc.data();
    if (!userData?.subscription) {
      await setDoc(userDocRef,
        {
          subscription: {
            customerId: '',
            status: 'incomplete',
            workoutCount: 0,
            freeWorkoutsUsed: 0,
            freeWorkoutLimit: 10,
            createdAt: Date.now(),
            updatedAt: Date.now(),
          },
        },
        { merge: true }
      );
      console.log('Default subscription created for user:', uid);
    }
  } catch (error) {
    console.error('Error creating default subscription:', error);
    throw new Error('Failed to create default subscription');
  }
}

========================================
FILE: src/lib/utils.ts
========================================

import { type ClassValue, clsx } from 'clsx'
import { twMerge } from 'tailwind-merge'

/**
 * Utility function to merge Tailwind CSS classes
 * Combines clsx for conditional classes and tailwind-merge for deduplication
 */
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

/**
 * Format duration in milliseconds to human readable format
 */
export function formatDuration(ms: number): string {
  const seconds = Math.floor(ms / 1000)
  const minutes = Math.floor(seconds / 60)
  const hours = Math.floor(minutes / 60)

  if (hours > 0) {
    return `${hours}h ${minutes % 60}m`
  } else if (minutes > 0) {
    return `${minutes}m ${seconds % 60}s`
  } else {
    return `${seconds}s`
  }
}

/**
 * Format number with commas
 */
export function formatNumber(num: number): string {
  return new Intl.NumberFormat().format(num)
}

/**
 * Clamp a number between min and max values
 */
export function clamp(value: number, min: number, max: number): number {
  return Math.min(Math.max(value, min), max)
}

/**
 * Capitalize first letter of a string
 */
export function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase()
}




========================================
FILE: src/lib/validators.ts
========================================

// Simplified validation utilities
import { handleValidationError } from './errorManager'

// Validation result interface
export interface ValidationResult {
  isValid: boolean
  errors: string[]
}

// Email validation
export const validateEmail = (email: string): ValidationResult => {
  const errors: string[] = []

  if (!email) {
    errors.push('Email is required')
  } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
    errors.push('Please enter a valid email address')
  }

  return {
    isValid: errors.length === 0,
    errors
  }
}

// Password validation
export const validatePassword = (password: string): ValidationResult => {
  const errors: string[] = []

  if (!password) {
    errors.push('Password is required')
  } else if (password.length < 6) {
    errors.push('Password must be at least 6 characters long')
  }

  return {
    isValid: errors.length === 0,
    errors
  }
}

// User profile validation
export const validateUserProfile = (profile: Record<string, unknown>): ValidationResult => {
  const errors: string[] = []

  // Experience validation
  if (!profile.experience) {
    errors.push('Experience level is required')
  } else if (!['Beginner', 'Intermediate', 'Advanced'].includes(profile.experience as string)) {
    errors.push('Invalid experience level')
  }

  // Goals validation
  if (!profile.goals || !Array.isArray(profile.goals) || profile.goals.length === 0) {
    errors.push('At least one fitness goal is required')
  }

  // Personal info validation
  if (!profile.personal) {
    errors.push('Personal information is required')
  } else {
    const { height, weight } = profile.personal as { height?: number; weight?: number }

    if (!height || isNaN(parseFloat(height as unknown as string))) {
      errors.push('Valid height is required')
    }

    if (!weight || isNaN(parseFloat(weight as unknown as string))) {
      errors.push('Valid weight is required')
    }
  }

  return {
    isValid: errors.length === 0,
    errors
  }
}

// Weight entry validation
export const validateWeight = (weight: unknown): ValidationResult => {
  const errors: string[] = []

  if (weight === null || weight === undefined) {
    // Null/undefined is valid (represents skipped set)
    return { isValid: true, errors }
  }

  const weightNum = parseFloat(weight as string)

  if (isNaN(weightNum)) {
    errors.push('Weight must be a valid number')
  } else if (weightNum < 0) {
    errors.push('Weight cannot be negative')
  } else if (weightNum > 1000) {
    errors.push('Weight seems unreasonably high')
  }

  return {
    isValid: errors.length === 0,
    errors
  }
}

// Form validation helper
export const validateForm = (data: Record<string, unknown>, rules: Record<string, (_value: unknown) => ValidationResult>): ValidationResult => {
  const allErrors: string[] = []

  for (const [field, validator] of Object.entries(rules)) {
    const result = validator(data[field])

    if (!result.isValid) {
      allErrors.push(...result.errors.map(error => `${field}: ${error}`))
    }
  }

  return {
    isValid: allErrors.length === 0,
    errors: allErrors
  }
}

// Validation middleware for API calls
export const withValidation = <T extends (..._args: unknown[]) => unknown>(
  fn: T,
  validator: (_data: unknown) => ValidationResult,
  dataExtractor: (..._args: Parameters<T>) => unknown = (..._args) => _args[0]
): T => {
  return ((...args: Parameters<T>) => {
    const data = dataExtractor(...args)
    const validation = validator(data)

    if (!validation.isValid) {
      const errorMessage = validation.errors.join(', ')
      handleValidationError(new Error(errorMessage))
      throw new Error(errorMessage)
    }

    return fn(...args)
  }) as T
}


========================================
FILE: src/lib/weightHistory.ts
========================================

// src/lib/weightHistory.ts
import { auth, db } from './firebase'
import { collection, getDocs, orderBy, query, limit } from 'firebase/firestore'

export interface WeightHistory {
  exerciseName: string
  setNumber: number
  weight: number
  timestamp: number
  reps?: number
  date: string
}

export interface WorkoutSession {
  date: string
  exercises: {
    name: string
    sets: { weight: number | null; reps: number; completed: boolean }[]
  }[]
}

/**
 * Fetch weight history for a specific exercise from Firestore
 */
export async function fetchWeightHistory(exerciseName: string, maxSessions = 10): Promise<WeightHistory[]> {
  try {
    const uid = auth.currentUser?.uid
    if (!uid) return []

    if (process.env.NODE_ENV === 'development') {
      console.log(`Fetching weight history for ${exerciseName}`)
    }

    const q = query(
      collection(db, 'users', uid, 'workouts'),
      orderBy('timestamp', 'desc'),
      limit(maxSessions)
    )
    
    const snap = await getDocs(q)
    const weightHistory: WeightHistory[] = []

    snap.docs.forEach(doc => {
      const data = doc.data()
      const exercises = data.exercises || []
      const timestamp = data.timestamp?.toMillis() || Date.now()
      const date = new Date(timestamp).toISOString().split('T')[0]

      exercises.forEach((exercise: { name: string; weights?: Record<string, number> }) => {
        if (exercise.name === exerciseName && exercise.weights) {
          Object.entries(exercise.weights).forEach(([setNumber, weight]) => {
            if (weight && typeof weight === 'number' && weight > 0) {
              weightHistory.push({
                exerciseName: exercise.name,
                setNumber: parseInt(setNumber),
                weight: weight,
                timestamp,
                reps: (exercise as { reps?: number }).reps || 10,
                date
              })
            }
          })
        }
      })
    })

    // Sort by timestamp descending (most recent first)
    weightHistory.sort((a, b) => b.timestamp - a.timestamp)

    if (process.env.NODE_ENV === 'development') {
      console.log(`📈 Found ${weightHistory.length} weight entries for ${exerciseName}`)
    }
    return weightHistory

  } catch (error) {
    console.error('❌ Error fetching weight history:', error)
    return []
  }
}

/**
 * Fetch recent workout sessions for progressive overload analysis
 */
export async function fetchRecentSessions(maxSessions = 8): Promise<WorkoutSession[]> {
  try {
    const uid = auth.currentUser?.uid
    if (!uid) return []

    if (process.env.NODE_ENV === 'development') {
      console.log('Fetching recent workout sessions')
    }

    const q = query(
      collection(db, 'users', uid, 'workouts'),
      orderBy('timestamp', 'desc'),
      limit(maxSessions)
    )
    
    const snap = await getDocs(q)
    const sessions: WorkoutSession[] = []

    snap.docs.forEach(doc => {
      const data = doc.data()
      const exercises = data.exercises || []
      const timestamp = data.timestamp?.toMillis() || Date.now()
      const date = new Date(timestamp).toISOString().split('T')[0]

      const sessionExercises = exercises.map((exercise: { name: string; sets?: number; reps?: number | string; weights?: Record<string, number | null> }) => {
        const sets = []
        const totalSets = exercise.sets || 0
        const weights = exercise.weights || {}
        const reps = typeof exercise.reps === 'number' ? exercise.reps : (typeof exercise.reps === 'string' ? parseInt(exercise.reps) : 10)

        // Create set data for each set
        for (let setNum = 1; setNum <= totalSets; setNum++) {
          const weight = weights[setNum]
          sets.push({
            weight: weight && typeof weight === 'number' ? weight : null,
            reps,
            completed: weight !== null // Consider set completed if weight was entered
          })
        }

        return {
          name: exercise.name,
          sets
        }
      })

      sessions.push({
        date,
        exercises: sessionExercises
      })
    })

    if (process.env.NODE_ENV === 'development') {
      console.log(`📈 Found ${sessions.length} recent sessions`)
    }
    return sessions

  } catch (error) {
    console.error('❌ Error fetching recent sessions:', error)
    return []
  }
}

/**
 * Get the last used weight for a specific exercise and set
 */
export function getLastUsedWeight(weightHistory: WeightHistory[], exerciseName: string, setNumber: number): number | null {
  const relevantWeights = weightHistory
    .filter(w => w.exerciseName === exerciseName && w.setNumber === setNumber)
    .sort((a, b) => b.timestamp - a.timestamp)

  return relevantWeights.length > 0 ? relevantWeights[0].weight : null
}

/**
 * Get progressive overload suggestion based on weight history
 */
export function getProgressiveOverloadSuggestion(
  weightHistory: WeightHistory[], 
  exerciseName: string, 
  setNumber: number
): number | null {
  const lastWeight = getLastUsedWeight(weightHistory, exerciseName, setNumber)
  
  if (!lastWeight) return null

  // Conservative progressive overload: 2.5-5 lbs increase
  const increment = lastWeight < 50 ? 2.5 : 5
  return lastWeight + increment
}

/**
 * Determine if an exercise is likely a barbell exercise for plate calculator
 */
export function isBarbellExercise(exerciseName: string): boolean {
  const barbellKeywords = [
    'squat', 'deadlift', 'bench press', 'row', 'press', 'curl',
    'barbell', 'bb ', 'overhead press', 'military press'
  ]
  
  const lowerName = exerciseName.toLowerCase()
  return barbellKeywords.some(keyword => lowerName.includes(keyword))
}

/**
 * Cache for weight history to avoid repeated API calls
 */
const weightHistoryCache = new Map<string, { data: WeightHistory[]; timestamp: number }>()
const CACHE_DURATION = 5 * 60 * 1000 // 5 minutes

export async function getCachedWeightHistory(exerciseName: string): Promise<WeightHistory[]> {
  const cacheKey = `${auth.currentUser?.uid}-${exerciseName}`
  const cached = weightHistoryCache.get(cacheKey)
  
  if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
    return cached.data
  }
  
  const data = await fetchWeightHistory(exerciseName)
  weightHistoryCache.set(cacheKey, { data, timestamp: Date.now() })
  
  return data
}

/**
 * Clear weight history cache (useful when new workout is completed)
 */
export function clearWeightHistoryCache(): void {
  weightHistoryCache.clear()
}


========================================
FILE: src/providers/app-provider-utils.ts
========================================

/**
 * App Provider Utilities
 * Shared utilities and hooks for the app provider
 */

import { useAppStore } from '../store'

// Hook to access the unified store
export const useApp = () => {
  const store = useAppStore()

  return {
    // Auth state
    user: store.user,
    profile: store.profile,
    authStatus: store.authStatus,

    // Subscription state
    subscription: store.subscription,
    subscriptionLoading: store.subscriptionLoading,

    // Workout state
    currentWorkout: store.currentWorkout,
    workoutWeights: store.workoutWeights,
    workoutHistory: store.workoutHistory,

    // UI state
    isOnline: store.isOnline,
    errors: store.errors,

    // Actions
    actions: {
      // Auth actions
      setUser: store.setUser,
      setProfile: store.setProfile,
      setAuthStatus: store.setAuthStatus,

      // Workout actions
      startWorkout: store.startWorkout,
      updateWorkoutProgress: store.updateWorkoutProgress,
      updateWeight: store.updateWeight,
      completeWorkout: store.completeWorkout,
      clearWorkout: store.clearWorkout,

      // Error actions
      addError: store.addError,
      resolveError: store.resolveError,
      clearErrors: store.clearErrors,

      // Utility actions
      reset: store.reset,
    },
  }
}

// App state utilities
export const appUtils = {
  getAuthStatusText: (status: string): string => {
    switch (status) {
      case 'loading':
        return 'Checking authentication...'
      case 'authenticated':
        return 'Signed in'
      case 'unauthenticated':
        return 'Not signed in'
      case 'error':
        return 'Authentication error'
      default:
        return 'Unknown status'
    }
  },

  getSubscriptionStatusText: (status?: string): string => {
    switch (status) {
      case 'active':
        return 'Active subscription'
      case 'canceled':
        return 'Canceled subscription'
      case 'incomplete':
        return 'Incomplete subscription'
      case 'past_due':
        return 'Payment overdue'
      case 'trialing':
        return 'Trial period'
      case 'unpaid':
        return 'Payment required'
      default:
        return 'No subscription'
    }
  },

  formatNotificationCount: (count: number): string => {
    if (count === 0) return ''
    if (count > 99) return '99+'
    return count.toString()
  },

  shouldShowUpgradePrompt: (subscription?: { status?: string; freeWorkoutsUsed?: number; freeWorkoutLimit?: number }): boolean => {
    if (!subscription) return true
    if (subscription.status === 'active') return false
    
    const used = subscription.freeWorkoutsUsed || 0
    const limit = subscription.freeWorkoutLimit || 10
    
    return used >= limit * 0.8 // Show when 80% of free workouts used
  }
}




========================================
FILE: src/providers/AppProvider.tsx
========================================

import { useEffect, type ReactNode } from 'react';
import { auth, db } from '../lib/firebase';
import { onAuthStateChanged, type User } from 'firebase/auth';
import { doc, onSnapshot } from 'firebase/firestore';
import { useAppStore } from '../store';
import { isProfileComplete } from '../session/types';
import type { UserProfile } from '../session/types';
import type { UserSubscription } from '../types/subscription';
import { ensureUserDocument } from '../lib/user-utils';
// Subscription service available but not used in this component
import ErrorBoundary from '../components/ErrorBoundary';

interface AppProviderProps {
  children: ReactNode;
}

export function AppProvider({ children }: AppProviderProps) {
  const {
    setUser,
    setProfile,
    setAuthStatus,
    setSubscription,
    setSubscriptionLoading,
    syncPendingOperations,
    setOnlineStatus,
    updateLastSyncTime,
  } = useAppStore();

  // Authentication state management
  useEffect(() => {
    let unsubDoc: (() => void) | null = null;
    let unsubSubscription: (() => void) | null = null;
    let unsubAuth: (() => void) | null = null;

    const setupAuthListener = () => {
      unsubAuth = onAuthStateChanged(auth, async (user: User | null) => {
      try {
        if (process.env.NODE_ENV === 'development') {
          console.log('🔐 Auth state changed:', user?.email || 'signed out');
        }

        // Cleanup existing listeners
        unsubDoc?.();
        unsubDoc = null;
        unsubSubscription?.();
        unsubSubscription = null;

        setUser(user);
        setProfile(null);
        setSubscription(null);

        if (!user) {
          if (process.env.NODE_ENV === 'development') {
            console.log('🔐 No user, setting status to signedOut');
          }
          setAuthStatus('signedOut');
          return;
        }

        // Delay to ensure auth stability
        setTimeout(async () => {
          try {
            await ensureUserDocument(user);

            const profileRef = doc(db, 'users', user.uid);
            unsubDoc = onSnapshot(profileRef,
              (snapshot) => {
                if (!snapshot.exists()) {
                  setProfile(null);
                  setAuthStatus('needsOnboarding');
                  return;
                }

                const profileData = snapshot.data() as UserProfile;
                setProfile(profileData);
                setAuthStatus(isProfileComplete(profileData) ? 'ready' : 'needsOnboarding');

                // Handle subscription data with robust manager
                if (profileData.subscription) {
                  // Validate subscription data integrity
                  const validatedSubscription = {
                    ...profileData.subscription,
                    freeWorkoutLimit: profileData.subscription.freeWorkoutLimit || 10,
                    workoutCount: profileData.subscription.workoutCount || 0,
                    freeWorkoutsUsed: profileData.subscription.freeWorkoutsUsed || 0,
                    updatedAt: profileData.subscription.updatedAt || Date.now(),
                  };
                  setSubscription(validatedSubscription);
                } else {
                  // Set default subscription if none exists
                  const defaultSubscription: UserSubscription = {
                    customerId: '',
                    status: 'incomplete',
                    workoutCount: 0,
                    freeWorkoutsUsed: 0,
                    freeWorkoutLimit: 10,
                    createdAt: Date.now(),
                    updatedAt: Date.now(),
                  };
                  setSubscription(defaultSubscription);
                }
                setSubscriptionLoading(false);
              },
              (error) => {
                console.error('Profile listener error:', error);

                if (error.code === 'permission-denied') {
                  unsubDoc?.();
                  unsubDoc = null;
                  setProfile(null);
                  setAuthStatus('signedOut');
                }
              }
            );

            await syncPendingOperations();
            updateLastSyncTime();
          } catch (error) {
            console.error('User initialization error:', error);
          }
        }, 100);
      } catch (error) {
        console.error('Auth state change error:', error);
      }
      });
    };

    setupAuthListener();

    return () => {
      if (unsubAuth) {
        unsubAuth();
      }
      unsubDoc?.();
      unsubSubscription?.();
    };
  }, [
    setUser,
    setProfile,
    setAuthStatus,
    setSubscription,
    setSubscriptionLoading,
    syncPendingOperations,
    updateLastSyncTime,
  ]);

  // Online/offline detection
  useEffect(() => {
    const handleOnline = () => {
      setOnlineStatus(true);
      syncPendingOperations();
    };

    const handleOffline = () => {
      setOnlineStatus(false);
    };

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    setOnlineStatus(navigator.onLine);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, [setOnlineStatus, syncPendingOperations]);

  // Periodic sync for pending operations
  useEffect(() => {
    const syncInterval = setInterval(() => {
      if (navigator.onLine) {
        syncPendingOperations();
      }
    }, 5 * 60 * 1000); // Every 5 minutes

    return () => clearInterval(syncInterval);
  }, [syncPendingOperations]);



  // Global error recovery
  useEffect(() => {
    const handleUnhandledRejection = (event: PromiseRejectionEvent) => {
      console.error('Unhandled promise rejection:', event.reason);

      if (event.reason?.code === 'permission-denied') {
        setAuthStatus('signedOut');
      }

      event.preventDefault();
    };

    const handleError = (event: ErrorEvent) => {
      console.error('Global error:', event.error);

      if (process.env.NODE_ENV === 'production') {
        // Integrate with error tracking service
        console.error('Production error reported:', {
          message: event.message,
          filename: event.filename,
          lineno: event.lineno,
          colno: event.colno,
          error: event.error,
        });
      }
    };

    window.addEventListener('unhandledrejection', handleUnhandledRejection);
    window.addEventListener('error', handleError);

    return () => {
      window.removeEventListener('unhandledrejection', handleUnhandledRejection);
      window.removeEventListener('error', handleError);
    };
  }, [setAuthStatus]);

  return (
    <ErrorBoundary level="component">
      {children}
    </ErrorBoundary>
  );
}

// Note: useApp hook has been moved to app-provider-utils.ts
// to fix Fast Refresh warnings. Import it from there instead.

========================================
FILE: src/routes/guards.tsx
========================================

import { Navigate } from 'react-router-dom'
import { useApp } from '../providers/app-provider-utils'
import type { ReactNode } from 'react'

// Landing gate at "/"
export function HomeGate({ authPage }: { authPage: ReactNode }) {
  const { authStatus, user } = useApp()

  // Development-only logging for debugging
  if (process.env.NODE_ENV === 'development') {
    console.log('[HOME] HomeGate:', authStatus, user?.email || 'no user')
  }

  if (authStatus === 'loading') return <ScreenLoader />
  if (authStatus === 'signedOut') return <>{authPage}</>
  if (authStatus === 'needsOnboarding') return <Navigate to="/onboarding" replace />
  return <Navigate to="/dashboard" replace />
}

// Require any signed-in user
export function RequireAuth({ children }: { children: ReactNode }) {
  const { authStatus } = useApp()

  if (authStatus === 'loading') return <ScreenLoader />
  if (authStatus === 'signedOut') return <Navigate to="/" replace />
  return <>{children}</>
}

// Require completed profile
export function RequireProfile({ children }: { children: ReactNode }) {
  const { authStatus } = useApp()

  if (authStatus === 'loading') return <ScreenLoader />
  if (authStatus === 'signedOut') return <Navigate to="/" replace />
  if (authStatus === 'needsOnboarding') return <Navigate to="/onboarding" replace />
  return <>{children}</>
}

// Simple full-screen loader using Tailwind classes
function ScreenLoader() {
  return (
    <div className="min-h-screen grid place-items-center bg-white">
      <div className="h-6 w-6 animate-spin rounded-full border-2 border-slate-300 border-t-slate-900 border-r-slate-900" />
    </div>
  )
}

========================================
FILE: src/store/index.ts
========================================

// Unified state management using Zustand
// Replaces multiple context providers for better performance and simpler state management

import { create } from 'zustand'
import { subscribeWithSelector } from 'zustand/middleware'
import { immer } from 'zustand/middleware/immer'
import { persist, createJSONStorage } from 'zustand/middleware'
import type { User } from 'firebase/auth'
import type { UserProfile } from '../session/types'
import type { UserSubscription } from '../types/subscription'

// Exercise and workout types
export interface Exercise {
  name: string
  description?: string
  sets: number
  reps: number | string
  formTips?: string[]
  safetyTips?: string[]
  restSeconds?: number
  usesWeight?: boolean
  muscleGroups?: string[]
  difficulty?: string
  weights?: Record<number, number | null>
}

export interface WorkoutPlan {
  exercises: Exercise[]
  workoutSummary?: {
    totalVolume: string
    primaryFocus: string
    expectedRPE: string
  }
}

// Types for the unified store
export interface AppState {
  // Authentication state
  user: User | null
  profile: UserProfile | null
  authStatus: 'loading' | 'signedOut' | 'needsOnboarding' | 'ready'
  
  // Subscription state
  subscription: UserSubscription | null
  subscriptionLoading: boolean
  
  // Workout state
  currentWorkout: WorkoutState | null
  workoutWeights: Record<number, Record<number, number | null>>
  workoutHistory: WorkoutHistoryItem[]
  
  // UI state
  isOnline: boolean
  lastSyncTime: number | null
  pendingOperations: PendingOperation[]
  
  // Error state
  errors: AppError[]
}

export interface WorkoutState {
  plan: WorkoutPlan
  type: string
  duration: number
  startTime: number
  currentExerciseIndex: number
  currentSetIndex: number
  isActive: boolean
}

export interface WorkoutHistoryItem {
  id: string
  timestamp: number
  workoutType: string
  duration: number
  exercises: Exercise[]
  completionRate: number
}

export interface PendingOperation {
  id: string
  type: 'weight_update' | 'workout_save' | 'profile_update'
  data: Record<string, unknown>
  timestamp: number
  retryCount: number
}

export interface AppError {
  id: string
  type: 'auth' | 'network' | 'validation' | 'unknown'
  message: string
  details?: Record<string, unknown>
  timestamp: number
  resolved: boolean
}



// Actions interface
export interface AppActions {
  // Auth actions
  setUser: (_user: User | null) => void
  setProfile: (_profile: UserProfile | null) => void
  setAuthStatus: (_status: AppState['authStatus']) => void

  // Subscription actions
  setSubscription: (_subscription: UserSubscription | null) => void
  setSubscriptionLoading: (_loading: boolean) => void

  // Workout actions
  startWorkout: (_plan: WorkoutPlan, _type: string, _duration: number) => void
  updateWorkoutProgress: (_exerciseIndex: number, _setIndex: number) => void
  updateWeight: (_exerciseIndex: number, _setIndex: number, _weight: number | null) => void
  completeWorkout: () => void
  clearWorkout: () => void
  
  // Data persistence actions
  addToHistory: (_workout: WorkoutHistoryItem) => void
  syncPendingOperations: () => Promise<void>
  addPendingOperation: (_operation: Omit<PendingOperation, 'id' | 'timestamp' | 'retryCount'>) => void

  // Error handling actions
  addError: (_error: Omit<AppError, 'id' | 'timestamp' | 'resolved'>) => void
  resolveError: (_errorId: string) => void
  clearErrors: () => void



  // Utility actions
  setOnlineStatus: (_isOnline: boolean) => void
  updateLastSyncTime: () => void
  reset: () => void
}

// Initial state
const initialState: AppState = {
  user: null,
  profile: null,
  authStatus: 'loading',
  subscription: null,
  subscriptionLoading: true,
  currentWorkout: null,
  workoutWeights: {},
  workoutHistory: [],
  isOnline: navigator.onLine,
  lastSyncTime: null,
  pendingOperations: [],
  errors: []
}

// Create the store with middleware
export const useAppStore = create<AppState & AppActions>()(
  subscribeWithSelector(
    immer(
      persist(
        (set, get) => ({
          ...initialState,
          
          // Auth actions
          setUser: (user) => set((state) => {
            state.user = user
          }),
          
          setProfile: (profile) => set((state) => {
            state.profile = profile
          }),
          
          setAuthStatus: (status) => set((state) => {
            state.authStatus = status
          }),
          
          // Subscription actions
          setSubscription: (subscription) => set((state) => {
            state.subscription = subscription
          }),
          
          setSubscriptionLoading: (loading) => set((state) => {
            state.subscriptionLoading = loading
          }),
          
          // Workout actions
          startWorkout: (plan, type, duration) => set((state) => {
            state.currentWorkout = {
              plan,
              type,
              duration,
              startTime: Date.now(),
              currentExerciseIndex: 0,
              currentSetIndex: 1,
              isActive: true
            }
            state.workoutWeights = {}
          }),
          
          updateWorkoutProgress: (exerciseIndex, setIndex) => set((state) => {
            if (state.currentWorkout) {
              state.currentWorkout.currentExerciseIndex = exerciseIndex
              state.currentWorkout.currentSetIndex = setIndex
            }
          }),
          
          updateWeight: (exerciseIndex, setIndex, weight) => set((state) => {
            if (!state.workoutWeights[exerciseIndex]) {
              state.workoutWeights[exerciseIndex] = {}
            }
            state.workoutWeights[exerciseIndex][setIndex] = weight
          }),
          
          completeWorkout: () => set((state) => {
            if (state.currentWorkout) {
              const workout: WorkoutHistoryItem = {
                id: `workout_${Date.now()}`,
                timestamp: Date.now(),
                workoutType: state.currentWorkout.type,
                duration: Math.round((Date.now() - state.currentWorkout.startTime) / 1000 / 60),
                exercises: state.currentWorkout.plan.exercises.map((ex: Exercise, i: number) => ({
                  ...ex,
                  weights: state.workoutWeights[i] || null
                })),
                completionRate: calculateCompletionRate(state.workoutWeights, state.currentWorkout.plan.exercises)
              }
              
              state.workoutHistory.unshift(workout)
              state.currentWorkout = null
              state.workoutWeights = {}
            }
          }),
          
          clearWorkout: () => set((state) => {
            state.currentWorkout = null
            state.workoutWeights = {}
          }),
          
          // Data persistence actions
          addToHistory: (workout) => set((state) => {
            state.workoutHistory.unshift(workout)
            // Keep only last 50 workouts in memory
            if (state.workoutHistory.length > 50) {
              state.workoutHistory = state.workoutHistory.slice(0, 50)
            }
          }),
          
          addPendingOperation: (operation) => set((state) => {
            const newOperation: PendingOperation = {
              ...operation,
              id: `op_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
              timestamp: Date.now(),
              retryCount: 0
            }
            state.pendingOperations.push(newOperation)
          }),
          
          syncPendingOperations: async () => {
            const { pendingOperations } = get()
            // Implementation will be added in the data persistence section
            if (process.env.NODE_ENV === 'development') {
              console.log('Syncing pending operations:', pendingOperations.length)
            }
          },
          
          // Error handling actions
          addError: (error) => set((state) => {
            const newError: AppError = {
              ...error,
              id: `err_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
              timestamp: Date.now(),
              resolved: false
            }
            state.errors.push(newError)
            // Keep only last 20 errors
            if (state.errors.length > 20) {
              state.errors = state.errors.slice(-20)
            }
          }),
          
          resolveError: (errorId) => set((state) => {
            const error = state.errors.find(e => e.id === errorId)
            if (error) {
              error.resolved = true
            }
          }),
          
          clearErrors: () => set((state) => {
            state.errors = []
          }),
          

          // Utility actions
          setOnlineStatus: (isOnline) => set((state) => {
            state.isOnline = isOnline
          }),
          
          updateLastSyncTime: () => set((state) => {
            state.lastSyncTime = Date.now()
          }),
          
          reset: () => set(() => ({ ...initialState }))
        }),
        {
          name: 'neurafit-app-store',
          storage: createJSONStorage(() => localStorage),
          partialize: (state) => ({
            // Only persist essential data
            workoutHistory: state.workoutHistory,
            lastSyncTime: state.lastSyncTime,
            // Don't persist sensitive or temporary data
            user: null,
            profile: null,
            subscription: null,
            currentWorkout: null,
            workoutWeights: {},
            errors: [],
            pendingOperations: []
          }),
          version: 1,
          migrate: (persistedState: unknown, _version: number) => {
            // Handle state migrations for future versions
            // _version parameter reserved for future use
            return persistedState
          }
        }
      )
    )
  )
)

// Helper function to calculate completion rate
function calculateCompletionRate(weights: Record<number, Record<number, number | null>>, exercises: Exercise[]): number {
  let totalSets = 0
  let completedSets = 0
  
  exercises.forEach((exercise, exerciseIndex) => {
    const exerciseWeights = weights[exerciseIndex] || {}
    const sets = exercise.sets || 0
    totalSets += sets
    
    for (let setIndex = 1; setIndex <= sets; setIndex++) {
      if (exerciseWeights[setIndex] !== null && exerciseWeights[setIndex] !== undefined) {
        completedSets++
      }
    }
  })
  
  return totalSets > 0 ? completedSets / totalSets : 0
}

// Selectors for common state access patterns
export const useAuth = () => useAppStore((state) => ({
  user: state.user,
  profile: state.profile,
  status: state.authStatus,
  setUser: state.setUser,
  setProfile: state.setProfile,
  setAuthStatus: state.setAuthStatus
}))

export const useSubscriptionStore = () => useAppStore((state) => ({
  subscription: state.subscription,
  loading: state.subscriptionLoading,
  setSubscription: state.setSubscription,
  setSubscriptionLoading: state.setSubscriptionLoading
}))

export const useWorkout = () => useAppStore((state) => ({
  currentWorkout: state.currentWorkout,
  workoutWeights: state.workoutWeights,
  workoutHistory: state.workoutHistory,
  startWorkout: state.startWorkout,
  updateWorkoutProgress: state.updateWorkoutProgress,
  updateWeight: state.updateWeight,
  completeWorkout: state.completeWorkout,
  clearWorkout: state.clearWorkout,
  addToHistory: state.addToHistory
}))

export const useErrors = () => useAppStore((state) => ({
  errors: state.errors,
  addError: state.addError,
  resolveError: state.resolveError,
  clearErrors: state.clearErrors
}))



// Expose store globally for performance monitoring and other utilities
if (typeof window !== 'undefined') {
  (window as Window & { __NEURAFIT_STORE__?: typeof useAppStore }).__NEURAFIT_STORE__ = useAppStore
}

========================================
FILE: src/session/types.ts
========================================

import type { UserSubscription } from '../types/subscription'

export type UserProfile = {
  experience?: string
  goals?: string[]
  equipment?: string[]
  personal?: { sex?: string; height?: string; weight?: string }
  injuries?: { list?: string[]; notes?: string }
  subscription?: UserSubscription
}

/**
 * Adjust this rule to your business criteria.
 * Minimal, stable rule: experience + at least one goal + height + weight.
 */
export function isProfileComplete(p?: UserProfile | null): boolean {
  if (!p) return false
  if (!p.experience) return false
  if (!p.goals || p.goals.length === 0) return false
  if (!p.personal?.height || !p.personal?.weight) return false
  return true
}

========================================
FILE: src/config/features.ts
========================================

/**
 * Feature flags configuration for NeuraFit
 */

export interface FeatureFlags {
  adaptivePersonalization: {
    enabled: boolean
    enableFeedbackUI: boolean
    enableIntensityCalibration: boolean
    enableTelemetry: boolean
  }
}

export const defaultFeatureFlags: FeatureFlags = {
  adaptivePersonalization: {
    enabled: true,
    enableFeedbackUI: true,
    enableIntensityCalibration: true,
    enableTelemetry: true
  }
}

/**
 * Get feature flags from environment or use defaults
 */
export function getFeatureFlags(): FeatureFlags {
  // In a production app, you might fetch these from a remote config service
  // For now, we'll use environment variables with fallbacks to defaults
  
  const adaptiveEnabled = import.meta.env.VITE_ADAPTIVE_PERSONALIZATION_ENABLED !== 'false'
  const feedbackEnabled = import.meta.env.VITE_ADAPTIVE_FEEDBACK_UI_ENABLED !== 'false'
  const calibrationEnabled = import.meta.env.VITE_ADAPTIVE_CALIBRATION_ENABLED !== 'false'
  const telemetryEnabled = import.meta.env.VITE_ADAPTIVE_TELEMETRY_ENABLED !== 'false'

  return {
    adaptivePersonalization: {
      enabled: adaptiveEnabled,
      enableFeedbackUI: feedbackEnabled,
      enableIntensityCalibration: calibrationEnabled,
      enableTelemetry: telemetryEnabled
    }
  }
}

/**
 * Check if a specific feature is enabled
 */
export function isFeatureEnabled(feature: keyof FeatureFlags): boolean {
  const flags = getFeatureFlags()
  return flags[feature].enabled
}

/**
 * Check if adaptive personalization is enabled
 */
export function isAdaptivePersonalizationEnabled(): boolean {
  return getFeatureFlags().adaptivePersonalization.enabled
}

/**
 * Check if feedback UI should be shown
 */
export function isFeedbackUIEnabled(): boolean {
  const flags = getFeatureFlags()
  return flags.adaptivePersonalization.enabled && flags.adaptivePersonalization.enableFeedbackUI
}

/**
 * Check if intensity calibration should be shown
 */
export function isIntensityCalibrationEnabled(): boolean {
  const flags = getFeatureFlags()
  return flags.adaptivePersonalization.enabled && flags.adaptivePersonalization.enableIntensityCalibration
}

/**
 * Check if telemetry should be collected
 */
export function isTelemetryEnabled(): boolean {
  const flags = getFeatureFlags()
  return flags.adaptivePersonalization.enabled && flags.adaptivePersonalization.enableTelemetry
}


========================================
FILE: src/config/onboarding.ts
========================================

/**
 * Centralized configuration for onboarding and profile data
 * This file contains all the constants used across onboarding and profile components
 * to ensure consistency and make updates easier.
 */

export const EXPERIENCE_LEVELS = ['Beginner', 'Intermediate', 'Expert']

export const GOALS = [
  'Weight Loss',
  'Build Muscle',
  'Strength',
  'Stamina',
  'Tone',
  'General Health',
  'Increase Flexibility',
  'Sports Performance',
  'Mental Health',
  'Injury Prevention',
]

// Equipment organized by popularity and accessibility (most to least common)
export const EQUIPMENT = [
  'Bodyweight',        // Most accessible - no equipment needed
  'Dumbbells',         // Most popular home equipment
  'Resistance Bands',  // Portable and versatile
  'Pull-Up Bar',       // Common home gym staple
  'Kettlebells',       // Functional training favorite
  'Barbells',          // Serious strength training
  'Weight Machines',   // Gym standard equipment
  'Medicine Balls',    // Functional and core training
  'Cable Machine',     // Gym versatility
  'Treadmill',         // Cardio equipment
  'Stationary Bike',   // Low-impact cardio
  'Rowing Machine',    // Full-body cardio
]

export const SEX_OPTIONS = ['Male', 'Female', 'Other']

export const HEIGHT_RANGES = ["<5'0", "5'0–5'5", "5'6–5'9", "5'10–6'1", "6'2–6'5", ">6'5"]

export const WEIGHT_RANGES = ['<120lb', '120–149', '150–179', '180–209', '210–239', '240+lb']

export const INJURY_OPTIONS = ['None', 'Knee', 'Lower Back', 'Shoulder', 'Ankle', 'Wrist/Elbow', 'Neck', 'Other']

// Type exports for better TypeScript support
export type ExperienceLevel = 'Beginner' | 'Intermediate' | 'Expert'
export type Goal = 'Weight Loss' | 'Build Muscle' | 'Strength' | 'Stamina' | 'Tone' | 'General Health' | 'Increase Flexibility' | 'Sports Performance' | 'Mental Health' | 'Injury Prevention'
export type Equipment = 'Bodyweight' | 'Dumbbells' | 'Resistance Bands' | 'Pull-Up Bar' | 'Kettlebells' | 'Barbells' | 'Weight Machines' | 'Medicine Balls' | 'Cable Machine' | 'Treadmill' | 'Stationary Bike' | 'Rowing Machine'
export type SexOption = 'Male' | 'Female' | 'Other'
export type HeightRange = "<5'0" | "5'0–5'5" | "5'6–5'9" | "5'10–6'1" | "6'2–6'5" | ">6'5"
export type WeightRange = '<120lb' | '120–149' | '150–179' | '180–209' | '210–239' | '240+lb'
export type InjuryOption = 'None' | 'Knee' | 'Lower Back' | 'Shoulder' | 'Ankle' | 'Wrist/Elbow' | 'Neck' | 'Other'


========================================
FILE: src/config/seo.ts
========================================

// SEO Configuration for NeuraFit
// Centralized SEO settings and utilities for optimal search engine optimization

export interface SEOConfig {
  title: string
  description: string
  keywords: string[]
  ogTitle?: string
  ogDescription?: string
  twitterTitle?: string
  twitterDescription?: string
  canonical?: string
  noindex?: boolean
  nofollow?: boolean
}

// Primary keywords for NeuraFit (based on search volume and competition analysis)
export const PRIMARY_KEYWORDS = [
  'AI workout generator',
  'personalized fitness app',
  'custom workout plans',
  'AI fitness trainer',
  'smart exercise planner',
  'adaptive training program',
  'fitness AI',
  'workout builder',
  'personal trainer app',
  'intelligent fitness coaching'
]

// Long-tail keywords for specific pages
export const LONG_TAIL_KEYWORDS = [
  'AI powered workout generator free',
  'personalized fitness plans based on equipment',
  'custom workout routine generator',
  'AI fitness app for beginners',
  'smart workout planner with progress tracking',
  'adaptive exercise program creator',
  'personalized strength training AI',
  'custom cardio workout generator',
  'AI home gym workout planner',
  'intelligent fitness coaching app'
]

// Page-specific SEO configurations
export const SEO_CONFIGS: Record<string, SEOConfig> = {
  home: {
    title: 'NeuraFit - #1 AI Workout Generator | Personalized Fitness Plans 2024',
    description: '🏋️ Get AI-powered workout plans in 30 seconds! Personalized for your goals, equipment & fitness level. Join 10,000+ users transforming their fitness with smart training plans. Free trial!',
    keywords: [
      ...PRIMARY_KEYWORDS,
      'free workout generator',
      'fitness app 2024',
      'AI personal trainer',
      'workout planner online',
      'custom fitness program'
    ],
    ogTitle: 'NeuraFit - #1 AI Workout Generator | Get Fit with Smart Training',
    ogDescription: '🏋️ Transform your fitness with AI-powered workout plans! Personalized training in 30 seconds. Join 10,000+ users getting stronger with intelligent fitness coaching. Try free!',
    twitterTitle: 'NeuraFit - #1 AI Workout Generator | Smart Fitness Training',
    twitterDescription: '🏋️ Get personalized AI workouts in 30 seconds! Smart training plans for your goals & equipment. Join 10,000+ users transforming their fitness. Free trial!'
  },
  
  generate: {
    title: 'AI Workout Generator - Create Custom Fitness Plans | NeuraFit',
    description: '⚡ Generate personalized workouts instantly with AI! Input your goals, equipment & fitness level. Get custom training plans tailored for maximum results. Start free!',
    keywords: [
      'AI workout generator',
      'custom workout creator',
      'personalized exercise planner',
      'fitness plan generator',
      'workout routine builder',
      'AI exercise program',
      'smart training planner',
      'custom fitness routine'
    ],
    ogTitle: 'AI Workout Generator - Create Your Perfect Training Plan',
    ogDescription: '⚡ Generate personalized workouts instantly! AI creates custom training plans based on your goals, equipment & fitness level. Try the smart workout generator free!',
    canonical: '/generate'
  },
  
  dashboard: {
    title: 'Fitness Dashboard - Track Your AI Workout Progress | NeuraFit',
    description: '📊 Monitor your fitness journey with intelligent progress tracking. View workout history, strength gains, and AI-powered insights. Your personal fitness command center.',
    keywords: [
      'fitness dashboard',
      'workout progress tracker',
      'AI fitness analytics',
      'exercise history',
      'fitness metrics',
      'workout statistics',
      'training progress',
      'fitness insights'
    ],
    noindex: true // Private user content
  },
  
  history: {
    title: 'Workout History - Review Your Fitness Journey | NeuraFit',
    description: '📈 Review all your completed workouts and track your fitness progress. Analyze performance trends and celebrate your achievements with detailed workout history.',
    keywords: [
      'workout history',
      'fitness progress tracking',
      'exercise log',
      'training history',
      'workout analytics',
      'fitness journey',
      'exercise statistics',
      'performance tracking'
    ],
    noindex: true // Private user content
  },
  
  subscription: {
    title: 'NeuraFit Pro - Unlimited AI Workouts & Premium Features',
    description: '🚀 Unlock unlimited AI workout generation, advanced analytics, and premium features. Transform your fitness with NeuraFit Pro. Plans starting at $9.99/month.',
    keywords: [
      'NeuraFit Pro',
      'premium fitness app',
      'unlimited AI workouts',
      'fitness app subscription',
      'premium workout generator',
      'advanced fitness features',
      'pro fitness app',
      'unlimited training plans'
    ],
    ogTitle: 'NeuraFit Pro - Unlimited AI Workouts & Premium Features',
    ogDescription: '🚀 Get unlimited AI workout generation, advanced analytics & premium features. Transform your fitness journey with NeuraFit Pro. Start your free trial today!'
  },
  
  privacy: {
    title: 'Privacy Policy - How NeuraFit Protects Your Data',
    description: 'Learn how NeuraFit protects your personal information and fitness data. Our comprehensive privacy policy explains our data practices and your rights.',
    keywords: [
      'NeuraFit privacy policy',
      'fitness app privacy',
      'data protection',
      'user privacy',
      'fitness data security'
    ]
  },
  
  terms: {
    title: 'Terms of Service - NeuraFit Usage Agreement',
    description: 'Read NeuraFit\'s terms of service and usage agreement. Understand your rights and responsibilities when using our AI workout generator platform.',
    keywords: [
      'NeuraFit terms of service',
      'fitness app terms',
      'usage agreement',
      'user agreement',
      'service terms'
    ]
  }
}

// Utility function to get SEO config for a page
export function getSEOConfig(page: string): SEOConfig {
  return SEO_CONFIGS[page] || SEO_CONFIGS.home
}

// Generate meta keywords string
export function generateKeywords(keywords: string[]): string {
  return keywords.join(', ')
}

// Generate structured data for different page types
export function generateStructuredData(type: 'WebApplication' | 'Article' | 'FAQPage', data: Record<string, unknown>) {
  const baseStructure = {
    '@context': 'https://schema.org',
    '@type': type,
    ...data
  }
  
  return JSON.stringify(baseStructure, null, 2)
}

// SEO best practices constants
export const SEO_CONSTANTS = {
  TITLE_MAX_LENGTH: 60,
  DESCRIPTION_MAX_LENGTH: 160,
  KEYWORDS_MAX_COUNT: 15,
  H1_MAX_LENGTH: 70,
  ALT_TEXT_MAX_LENGTH: 125,
  
  // Core Web Vitals targets
  LCP_TARGET: 2.5, // seconds
  FID_TARGET: 100, // milliseconds
  CLS_TARGET: 0.1, // score
  
  // Social media image dimensions
  OG_IMAGE_WIDTH: 1200,
  OG_IMAGE_HEIGHT: 630,
  TWITTER_IMAGE_WIDTH: 1200,
  TWITTER_IMAGE_HEIGHT: 600
}

// URL structure for SEO-friendly paths
export const SEO_URLS = {
  HOME: '/',
  GENERATE: '/generate',
  DASHBOARD: '/dashboard',
  HISTORY: '/history',
  PROFILE: '/profile',
  SUBSCRIPTION: '/subscription',
  PRIVACY: '/privacy',
  TERMS: '/terms',
  
  // Future content URLs for SEO expansion
  BLOG: '/blog',
  WORKOUTS: '/workouts',
  EXERCISES: '/exercises',
  GUIDES: '/fitness-guides',
  REVIEWS: '/reviews'
}

export default SEO_CONFIGS


========================================
FILE: src/types/global.d.ts
========================================

// Global type declarations for build-time constants and functions

declare global {
  // Build-time constants injected by Vite
  const __APP_VERSION__: string
  const __BUILD_TIME__: string
  
  // Global functions for update management
  interface Window {
    applyUpdate?: () => void
  }
}

export {}


========================================
FILE: src/types/subscription.ts
========================================

/**
 * Subscription types for NeuraFit Stripe integration
 */

export type SubscriptionStatus = 
  | 'active'
  | 'canceled' 
  | 'incomplete'
  | 'incomplete_expired'
  | 'past_due'
  | 'trialing'
  | 'unpaid'

export type SubscriptionPlan = {
  id: string
  name: string
  description: string
  price: number // in cents
  currency: string
  interval: 'month' | 'year'
  features: string[]
  stripePriceId: string
  popular?: boolean
}

export type UserSubscription = {
  // Stripe identifiers
  customerId: string
  subscriptionId?: string
  priceId?: string
  
  // Subscription status
  status: SubscriptionStatus
  currentPeriodStart?: number // Unix timestamp
  currentPeriodEnd?: number // Unix timestamp
  cancelAtPeriodEnd?: boolean
  canceledAt?: number // Unix timestamp
  
  // Plan details
  plan?: SubscriptionPlan
  
  // Usage tracking
  workoutCount: number
  freeWorkoutsUsed: number
  freeWorkoutLimit: number
  
  // Timestamps
  createdAt: number // Unix timestamp
  updatedAt: number // Unix timestamp
}

export type PaymentMethod = {
  id: string
  type: 'card'
  card: {
    brand: string
    last4: string
    expMonth: number
    expYear: number
  }
  isDefault: boolean
}

export type BillingHistory = {
  id: string
  amount: number
  currency: string
  status: 'succeeded' | 'pending' | 'failed'
  description: string
  created: number // Unix timestamp
  invoiceUrl?: string
}

// Subscription plans configuration
export const SUBSCRIPTION_PLANS: SubscriptionPlan[] = [
  {
    id: 'monthly',
    name: 'Monthly Pro',
    description: 'Unlimited AI-powered workouts',
    price: 999, // $9.99
    currency: 'usd',
    interval: 'month',
    stripePriceId: 'price_monthly_pro', // Replace with actual Stripe price ID
    features: [
      'Unlimited workout generation',
      'Advanced personalization',
      'Progress tracking',
      'Weight history',
      'Priority support'
    ]
  },
  {
    id: 'yearly',
    name: 'Yearly Pro',
    description: 'Unlimited AI-powered workouts (2 months free)',
    price: 9999, // $99.99 (equivalent to ~$8.33/month)
    currency: 'usd',
    interval: 'year',
    stripePriceId: 'price_yearly_pro', // Replace with actual Stripe price ID
    popular: true,
    features: [
      'Unlimited workout generation',
      'Advanced personalization',
      'Progress tracking',
      'Weight history',
      'Priority support',
      '2 months free'
    ]
  }
]

export const FREE_WORKOUT_LIMIT = 10

// Helper functions
export function isSubscriptionActive(subscription?: UserSubscription): boolean {
  if (!subscription) return false
  return subscription.status === 'active' || subscription.status === 'trialing'
}

export function canGenerateWorkout(subscription?: UserSubscription): boolean {
  if (!subscription) return false
  
  // If user has active subscription, they can generate unlimited workouts
  if (isSubscriptionActive(subscription)) {
    return true
  }
  
  // If no active subscription, check free workout limit
  return subscription.freeWorkoutsUsed < subscription.freeWorkoutLimit
}

export function getRemainingFreeWorkouts(subscription?: UserSubscription): number {
  if (!subscription) return FREE_WORKOUT_LIMIT
  if (isSubscriptionActive(subscription)) return Infinity
  return Math.max(0, subscription.freeWorkoutLimit - subscription.freeWorkoutsUsed)
}

export function formatPrice(priceInCents: number, currency: string = 'usd'): string {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: currency.toUpperCase(),
  }).format(priceInCents / 100)
}

export function getSubscriptionPlan(planId: string): SubscriptionPlan | undefined {
  return SUBSCRIPTION_PLANS.find(plan => plan.id === planId)
}


========================================
FILE: src/types/global.d.ts
========================================

// Global type declarations for build-time constants and functions

declare global {
  // Build-time constants injected by Vite
  const __APP_VERSION__: string
  const __BUILD_TIME__: string
  
  // Global functions for update management
  interface Window {
    applyUpdate?: () => void
  }
}

export {}


========================================
FILE: src/utils/orientation.ts
========================================

// Orientation lock utilities for mobile experience

export const lockOrientation = () => {
  // Try to lock to portrait orientation using the Screen Orientation API
  if ('screen' in window && 'orientation' in window.screen) {
    const screenOrientation = window.screen.orientation as { lock?: (_orientation: string) => Promise<void> }

    if ('lock' in screenOrientation && screenOrientation.lock) {
      screenOrientation.lock('portrait').catch((error: { message?: string; name?: string }) => {
        // Only log in development and for unexpected errors
        if (process.env.NODE_ENV === 'development' &&
            !error.message?.includes('not supported') &&
            error.name !== 'NotSupportedError') {
          console.log('Orientation lock failed:', error.name)
        }
      })
    }
  }
  
  // Fallback: Listen for orientation changes and show warning
  const handleOrientationChange = () => {
    const isLandscape = window.innerWidth > window.innerHeight
    const isMobile = window.innerWidth <= 768
    
    if (isLandscape && isMobile) {
      // Show landscape warning (handled by CSS)
      document.body.classList.add('landscape-warning')
    } else {
      document.body.classList.remove('landscape-warning')
    }
  }
  
  // Listen for orientation changes
  window.addEventListener('orientationchange', handleOrientationChange)
  window.addEventListener('resize', handleOrientationChange)
  
  // Initial check
  handleOrientationChange()
  
  // Return cleanup function
  return () => {
    window.removeEventListener('orientationchange', handleOrientationChange)
    window.removeEventListener('resize', handleOrientationChange)
  }
}

export const unlockOrientation = () => {
  if ('screen' in window && 'orientation' in window.screen) {
    const screenOrientation = window.screen.orientation as unknown as { unlock?: () => Promise<void> }

    if ('unlock' in screenOrientation && screenOrientation.unlock) {
      Promise.resolve(screenOrientation.unlock()).catch((error: { name?: string }) => {
        // Silently handle unlock failures as they're not critical
        if (process.env.NODE_ENV === 'development' &&
            error.name !== 'NotSupportedError') {
          console.log('Orientation unlock failed:', error.name)
        }
      })
    }
  }
}

// Prevent zoom on double tap (iOS Safari)
export const preventZoom = () => {
  let lastTouchEnd = 0
  
  const preventDoubleTapZoom = (event: TouchEvent) => {
    const now = new Date().getTime()
    if (now - lastTouchEnd <= 300) {
      event.preventDefault()
    }
    lastTouchEnd = now
  }
  
  document.addEventListener('touchend', preventDoubleTapZoom, { passive: false })
  
  return () => {
    document.removeEventListener('touchend', preventDoubleTapZoom)
  }
}


========================================
FILE: src/utils/timestamp.ts
========================================

// Utility functions for handling Firebase timestamps and date conversions

export type TimestampType = string | Date | { toDate(): Date } | undefined

/**
 * Converts various timestamp formats to a Date object
 */
export function convertToDate(timestamp: TimestampType): Date {
  if (!timestamp) {
    return new Date()
  }
  
  if (timestamp instanceof Date) {
    return timestamp
  }
  
  if (typeof timestamp === 'string') {
    return new Date(timestamp)
  }
  
  if (typeof timestamp === 'object' && 'toDate' in timestamp && typeof timestamp.toDate === 'function') {
    return timestamp.toDate()
  }
  
  return new Date()
}

/**
 * Formats a timestamp to a local date string
 */
export function formatTimestamp(timestamp: TimestampType): string {
  return convertToDate(timestamp).toLocaleDateString()
}

/**
 * Formats a timestamp to an ISO string for date inputs
 */
export function formatTimestampISO(timestamp: TimestampType): string {
  return convertToDate(timestamp).toISOString().split('T')[0]
}

/**
 * Checks if a timestamp represents a date within the last N days
 */
export function isWithinDays(timestamp: TimestampType, days: number): boolean {
  const date = convertToDate(timestamp)
  const now = new Date()
  const diffTime = Math.abs(now.getTime() - date.getTime())
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24))
  return diffDays <= days
}

========================================
SECTION 2: BACKEND CODE
========================================

========================================
FILE: functions/src/index.ts
========================================

import { onRequest } from 'firebase-functions/v2/https';
import { defineSecret } from 'firebase-functions/params';
import type { Request, Response } from 'express';
import OpenAI from 'openai';
import { getAdaptiveState, calculateRecentCompletionRate, generateProgressionNote } from './lib/personalization';
import { incrementWorkoutCount } from './lib/stripe';

// Export subscription functions
export { stripeWebhook } from './stripe-webhooks';
export {
  createPaymentIntent,
  cancelUserSubscription,
  reactivateUserSubscription,
  getCustomerPortalUrl,
  getSubscriptionDetails,
  getBillingHistory,
} from './subscription-functions';

// Define the secret
const openaiApiKey = defineSecret('OPENAI_API_KEY');

/**
 * AI-powered workout generator function
 */
export const generateWorkout = onRequest(
  {
    cors: [
      'http://localhost:5173', // local dev
      'https://neurafit-ai-2025.web.app', // Firebase Hosting
      'https://neurafit-ai-2025.firebaseapp.com',
    ],
    region: 'us-central1',
    secrets: [openaiApiKey],
  },
  async (req: Request, res: Response): Promise<void> => {
    // Handle preflight
    if (req.method === 'OPTIONS') {
      res.status(204).send('');
      return;
    }

    if (req.method !== 'POST') {
      res.status(405).send('Method Not Allowed');
      return;
    }

    try {
      // Initialize OpenAI client with the secret value
      const client = new OpenAI({
        apiKey: openaiApiKey.value(),
      });

      const {
        experience,
        goals,
        equipment,
        // personalInfo, // Removed for streamlined prompt
        injuries,
        workoutType,
        duration,
        uid,
        targetIntensity,
        progressionNote,
      } = req.body as {
        experience?: string;
        goals?: string | string[];
        equipment?: string | string[];
        personalInfo?: { sex?: string; heightRange?: string; height?: string; weightRange?: string; weight?: string };
        injuries?: { list?: string[]; notes?: string };
        workoutType?: string;
        duration?: number;
        uid?: string;
        targetIntensity?: number;
        progressionNote?: string;
      } || {};

      // Run subscription check and adaptive personalization in parallel if uid is provided
      let finalTargetIntensity = targetIntensity || 1.0;
      let finalProgressionNote = progressionNote || '';

      if (uid) {
        try {
          const { getFirestore } = await import('firebase-admin/firestore');
          const db = getFirestore();

          // Run subscription check and adaptive state fetch in parallel
          const [subscriptionResult, adaptiveResult] = await Promise.allSettled([
            // Subscription check
            (async () => {
              const userDoc = await db.collection('users').doc(uid).get();
              const userData = userDoc.data();
              const subscription = userData?.subscription as { status?: string; freeWorkoutsUsed?: number; freeWorkoutLimit?: number } | undefined;

              // Initialize subscription data for new users
              if (!subscription) {
                const initialSubscriptionData = {
                  status: 'incomplete',
                  workoutCount: 0,
                  freeWorkoutsUsed: 0,
                  freeWorkoutLimit: 5,
                  createdAt: Date.now(),
                  updatedAt: Date.now(),
                };

                await db.collection('users').doc(uid).set(
                  { subscription: initialSubscriptionData },
                  { merge: true }
                );

                console.log('Initialized subscription data for new user:', uid);
                return null; // New user, no limits
              } else {
                const isActive = subscription.status === 'active' || subscription.status === 'trialing';
                const freeWorkoutsUsed = subscription.freeWorkoutsUsed || 0;
                const freeWorkoutLimit = subscription.freeWorkoutLimit || 10;

                // Check if user can generate workout
                if (!isActive && freeWorkoutsUsed >= freeWorkoutLimit) {
                  return {
                    error: 'Subscription required',
                    message: 'You\'ve used all your free workouts. Please subscribe to continue.',
                    freeWorkoutsUsed,
                    freeWorkoutLimit,
                  };
                }
                return null; // User can generate workout
              }
            })(),
            // Adaptive personalization (only if no targetIntensity provided)
            !targetIntensity ? (async () => {
              const adaptiveState = await getAdaptiveState(uid);
              let recentCompletion = adaptiveState.recentCompletionRate;
              if (recentCompletion === undefined) {
                recentCompletion = await calculateRecentCompletionRate(uid);
              }
              return {
                difficultyScalar: adaptiveState.difficultyScalar,
                lastFeedback: adaptiveState.lastFeedback,
                recentCompletion,
              };
            })() : Promise.resolve(null)
          ]);

          // Handle subscription check result
          if (subscriptionResult.status === 'fulfilled' && subscriptionResult.value) {
            res.status(402).json(subscriptionResult.value);
            return;
          }
          if (subscriptionResult.status === 'rejected') {
            console.error('Error checking subscription:', subscriptionResult.reason);
            // Continue with workout generation if subscription check fails
          }

          // Handle adaptive personalization result
          if (adaptiveResult.status === 'fulfilled' && adaptiveResult.value) {
            finalTargetIntensity = adaptiveResult.value.difficultyScalar;
            finalProgressionNote = generateProgressionNote(1.0, finalTargetIntensity, adaptiveResult.value.lastFeedback);
          } else if (adaptiveResult.status === 'rejected') {
            console.error('Error fetching adaptive state:', adaptiveResult.reason);
            // Continue with defaults
          }

        } catch (error) {
          console.error('Error in parallel database operations:', error);
          // Continue with workout generation if database operations fail
        }
      }

      // Streamlined prompt - removed unused imports

      // Filter out undefined values from arrays and ensure string types
      const filteredGoals = Array.isArray(goals)
        ? goals.filter((g): g is string => Boolean(g))
        : [goals].filter((g): g is string => Boolean(g));
      const filteredEquipment = Array.isArray(equipment)
        ? equipment.filter((e): e is string => Boolean(e))
        : [equipment].filter((e): e is string => Boolean(e));

      // Comprehensive workout type context for all 18 common types
      const getWorkoutTypeContext = (type: string) => {
        const contexts = {
          'Full Body': 'Focus: Total body conditioning. Style: 6-12 reps, compound movements. Equipment: Mixed.',
          'Upper Body': 'Focus: Chest, back, shoulders, arms. Style: 6-15 reps, push/pull balance. Equipment: Weights preferred.',
          'Lower Body': 'Focus: Legs, glutes, calves. Style: 8-15 reps, squats/lunges/deadlifts. Equipment: Weights preferred.',
          'Cardio': 'Focus: Cardiovascular endurance. Style: Time-based, continuous movement. Equipment: Bodyweight preferred.',
          'HIIT': 'Focus: Fat burning, conditioning. Style: 30s work/15s rest intervals, explosive movements. Equipment: Minimal.',
          'Core Focus': 'Focus: Abdominals, obliques, stability. Style: 10-20 reps, isometric holds. Equipment: Bodyweight.',
          'Strength': 'Focus: Maximum strength, power. Style: 3-8 reps, heavy compound movements. Equipment: Weights required.',
          'Circuit': 'Focus: Conditioning, variety. Style: 8-15 reps, minimal rest between exercises. Equipment: Mixed.',
          'Push': 'Focus: Chest, shoulders, triceps. Style: 6-12 reps, pressing movements. Equipment: Weights preferred.',
          'Pull': 'Focus: Back, biceps, rear delts. Style: 6-12 reps, pulling movements. Equipment: Weights preferred.',
          'Legs/Glutes': 'Focus: Lower body power, shape. Style: 8-15 reps, hip-dominant movements. Equipment: Weights preferred.',
          'Chest/Triceps': 'Focus: Chest development, tricep strength. Style: 6-15 reps, pressing focus. Equipment: Weights preferred.',
          'Back/Biceps': 'Focus: Back width/thickness, bicep size. Style: 6-15 reps, pulling focus. Equipment: Weights preferred.',
          'Shoulders': 'Focus: Deltoid development, stability. Style: 8-15 reps, multi-angle pressing. Equipment: Weights preferred.',
          'Arms': 'Focus: Biceps, triceps, forearms. Style: 8-15 reps, isolation movements. Equipment: Weights preferred.',
          'Yoga': 'Focus: Flexibility, mindfulness, balance. Style: 30-90s holds, flowing sequences. Equipment: Bodyweight only.',
          'Pilates': 'Focus: Core strength, stability, control. Style: 8-15 controlled reps, precise movements. Equipment: Bodyweight.',
          'Functional': 'Focus: Real-world movement patterns. Style: 8-15 reps, multi-plane movements. Equipment: Mixed.'
        };
        return contexts[type as keyof typeof contexts] || contexts['Full Body'];
      };

      // Build injury context if injuries are present
      const injuryContext = injuries?.list && injuries.list.length > 0
        ? `\n\nIMPORTANT - INJURY CONSIDERATIONS:
- User has reported injuries: ${injuries.list.join(', ')}
${injuries.notes ? `- Additional notes: ${injuries.notes}` : ''}
- Avoid exercises that stress these areas
- Provide modifications when appropriate
- Prioritize safety over intensity`
        : '';

      // Build intensity context if provided
      const intensityContext = finalTargetIntensity !== 1.0 || finalProgressionNote
        ? `\n\nINTENSITY GUIDANCE:
- Target intensity scalar: ${finalTargetIntensity.toFixed(2)}x baseline
${finalProgressionNote ? `- Progression note: ${finalProgressionNote}` : ''}
- Adjust sets, reps, or rest periods accordingly`
        : '';

      // Streamlined prompt optimized for speed while maintaining quality
      const prompt = `Create a ${duration}-min ${workoutType || 'Strength'} workout for ${experience || 'Beginner'} level.

SPECS: Equipment: ${filteredEquipment.join(', ') || 'bodyweight'} | Goals: ${filteredGoals.join(', ') || 'fitness'} | Type: ${workoutType || 'Strength'}
${getWorkoutTypeContext(workoutType || 'Strength')}${injuryContext}${intensityContext}

RULES:
1. CREATE new exercises dynamically (no preset lists)
2. Match ${workoutType || 'Strength'} workout type exactly
3. Include 7-8 exercises: 2 warm-up, 4-5 main, 1-2 cool-down
4. Descriptions: 100+ chars with form cues and breathing

JSON OUTPUT (no markdown):
{
  "exercises": [{
    "name": "Exercise Name",
    "description": "Step-by-step with breathing cues",
    "sets": 3,
    "reps": "8-12",
    "formTips": ["tip1", "tip2", "tip3"],
    "safetyTips": ["safety1", "safety2"],
    "restSeconds": 60,
    "usesWeight": true,
    "muscleGroups": ["muscle1", "muscle2"],
    "difficulty": "${(experience || 'beginner').toLowerCase()}"
  }],
  "workoutSummary": {
    "totalVolume": "volume estimate",
    "primaryFocus": "focus areas",
    "expectedRPE": "intensity"
  }
}`.trim();

      // Use GPT-4.1-nano for ultra-fast generation (<10s target) with low latency
      console.log('⚡ Using GPT-4.1-nano for ultra-fast workout generation');
      const completion = await client.chat.completions.create({
        model: 'gpt-4.1-nano',
        temperature: 0.4, // Slightly higher for more creative exercise selection
        max_tokens: 1500, // Optimized for speed while maintaining quality
        messages: [
          {
            role: 'system',
            content: 'You are an expert certified personal trainer (NASM-CPT, CSCS) with 10+ years of experience. Create dynamic, varied workouts tailored to each request. Generate exercises creatively based on the workout type - never use a preset list. Output only valid JSON with no markdown formatting or code blocks.',
          },
          { role: 'user', content: prompt },
        ],
      });

      const text = completion.choices?.[0]?.message?.content ?? '';

      // Clean JSON text by removing markdown code blocks if present
      const cleanedText = text.replace(/^```json\s*/, '').replace(/\s*```$/, '').trim();

      // Validate JSON output
      try {
        const json = JSON.parse(cleanedText) as {
          exercises: {
            name: string;
            description: string;
            sets: number;
            reps: number | string;
            formTips: string[];
            safetyTips: string[];
            restSeconds: number;
            usesWeight: boolean;
            muscleGroups: string[];
            difficulty: string;
          }[];
          workoutSummary: {
            totalVolume: string;
            primaryFocus: string;
            expectedRPE: string;
          };
        };

        // Professional workout validation and quality scoring
        const { validateWorkoutPlan } = await import('./lib/exerciseValidation');
        const { scoreWorkoutQuality } = await import('./lib/workoutQualityScorer');

        const userProfileForValidation = {
          experience,
          injuries: injuries?.list || [],
          duration: duration || 30, // Default to 30 minutes if not specified
          goals: filteredGoals,
          equipment: filteredEquipment,
          workoutType,
        };

        const validationResult = validateWorkoutPlan(json, userProfileForValidation);
        const qualityScore = scoreWorkoutQuality(json, userProfileForValidation);

        // Log validation and quality metrics for monitoring
        console.info('Workout Quality Score:', qualityScore.overall, qualityScore.breakdown);

        if (validationResult.errors.length > 0) {
          console.warn('Workout validation errors:', validationResult.errors);
        }
        if (validationResult.warnings.length > 0) {
          console.info('Workout validation warnings:', validationResult.warnings);
        }

        // Reject workouts with critical safety issues or very low quality
        if (!validationResult.isValid) {
          console.error('Generated workout failed safety validation:', validationResult.errors);
          res.status(502).json({
            error: 'Generated workout failed safety validation',
            validationErrors: validationResult.errors,
            raw: text,
          });
          return;
        }

        // Warn about low-quality workouts but don't reject (for now)
        if (qualityScore.overall < 60) {
          console.warn('Generated workout has low quality score:', qualityScore.overall, qualityScore.feedback);
        }

        // Add metadata to response including validation and quality results
        const response = {
          ...json,
          metadata: {
            targetIntensity: finalTargetIntensity,
            progressionNote: finalProgressionNote || undefined,
            validation: {
              warnings: validationResult.warnings,
              suggestions: validationResult.suggestions,
            },
            qualityScore: {
              overall: qualityScore.overall,
              breakdown: qualityScore.breakdown,
              feedback: qualityScore.feedback,
              recommendations: qualityScore.recommendations,
            },
          },
        };

        // Increment workout count after successful generation
        if (uid) {
          try {
            await incrementWorkoutCount(uid);
          } catch (error) {
            console.error('Error incrementing workout count:', error);
            // Don't fail the request if workout count increment fails
          }
        }

        res.json(response);
        return;
      } catch (parseError) {
        console.error('JSON parsing error:', parseError);
        console.error('Original text:', text);
        console.error('Cleaned text:', cleanedText);
        res.status(502).json({ error: 'Bad AI JSON', raw: cleanedText });
        return;
      }
    } catch (e) {
      console.error('Workout generation error', e);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }
  }
);

========================================
FILE: functions/src/stripe-webhooks.ts
========================================

import { onRequest } from 'firebase-functions/v2/https';
import { defineSecret } from 'firebase-functions/params';
import type { Request, Response } from 'express';
import Stripe from 'stripe';
import { getUserByCustomerId, updateUserSubscription, UserSubscriptionData, getStripeClient } from './lib/stripe';

// Extended Stripe types to include properties that exist but aren't in the official types
interface ExtendedStripeSubscription extends Omit<Stripe.Subscription, 'canceled_at'> {
  current_period_start: number;
  current_period_end: number;
  cancel_at_period_end: boolean;
  canceled_at?: number | null;
}

interface ExtendedStripeInvoice extends Stripe.Invoice {
  subscription?: string;
}

// Define Stripe secrets
const stripeWebhookSecret = defineSecret('STRIPE_WEBHOOK_SECRET');
const stripeSecretKey = defineSecret('STRIPE_SECRET_KEY');

/**
 * Stripe webhook handler for subscription events
 * Enhanced with better error handling and monitoring
 */
export const stripeWebhook = onRequest(
  {
    cors: false, // Webhooks should not have CORS enabled
    region: 'us-central1',
    secrets: [stripeWebhookSecret, stripeSecretKey],
    timeoutSeconds: 60, // Increase timeout for webhook processing
    memory: '512MiB', // Increase memory for better performance
  },
  async (req: Request, res: Response): Promise<void> => {
    const startTime = Date.now();
    const sig = req.headers['stripe-signature'] as string;
    const eventId = req.headers['stripe-event-id'] as string || 'unknown';

    console.log(`📡 Webhook received: ${eventId} at ${new Date().toISOString()}`);

    let event: Stripe.Event;

    try {
      // Validate request method
      if (req.method !== 'POST') {
        console.error(`❌ Invalid method: ${req.method}`);
        res.status(405).json({ error: 'Method not allowed' });
        return;
      }

      // Get raw body for signature verification
      let body: string | Buffer;
      if (typeof req.body === 'string') {
        body = req.body;
      } else if (Buffer.isBuffer(req.body)) {
        body = req.body;
      } else {
        // If body is already parsed, we can't verify signature
        // For development/testing, we'll skip signature verification
        console.warn('⚠️ Webhook body is already parsed, skipping signature verification');
        event = req.body as Stripe.Event;
      }

      if (!event!) {
        // Verify webhook signature
        const stripe = getStripeClient(stripeSecretKey.value());
        event = stripe.webhooks.constructEvent(body!, sig, stripeWebhookSecret.value());
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Unknown error';
      console.error('Webhook signature verification failed:', errorMessage);
      res.status(400).send(`Webhook Error: ${errorMessage}`);
      return;
    }

    console.log('Received Stripe webhook event:', event.type);

    try {
      console.log(`🔔 Processing webhook event: ${event.type} (ID: ${event.id})`);

      switch (event.type) {
      case 'customer.subscription.created':
        await handleSubscriptionCreated(event.data.object as Stripe.Subscription);
        break;

      case 'customer.subscription.updated':
        await handleSubscriptionUpdated(event.data.object as Stripe.Subscription);
        break;

      case 'customer.subscription.deleted':
        await handleSubscriptionDeleted(event.data.object as Stripe.Subscription);
        break;

      case 'invoice.payment_succeeded':
        await handlePaymentSucceeded(event.data.object as Stripe.Invoice);
        break;

      case 'invoice.payment_failed':
        await handlePaymentFailed(event.data.object as Stripe.Invoice);
        break;

      default:
        console.log(`Unhandled event type: ${event.type}`);
      }

      const processingTime = Date.now() - startTime;
      console.log(`✅ Successfully processed webhook event: ${event.type} (ID: ${event.id}) in ${processingTime}ms`);

      res.json({
        received: true,
        eventId: event.id,
        eventType: event.type,
        processingTime,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      const processingTime = Date.now() - startTime;
      console.error(`❌ Error processing webhook event ${event.type} (ID: ${event.id}) after ${processingTime}ms:`, error);

      res.status(500).json({
        error: 'Webhook processing failed',
        eventId: event.id,
        eventType: event.type,
        processingTime,
        message: error instanceof Error ? error.message : 'Unknown error',
        timestamp: new Date().toISOString()
      });
    }
  }
);

/**
 * Handle subscription created event with enhanced retry logic
 */
async function handleSubscriptionCreated(subscription: Stripe.Subscription) {
  console.log(`📝 Processing subscription created: ${subscription.id} for customer: ${subscription.customer}`);

  try {
    const uid = await getUserByCustomerId(subscription.customer as string);
    if (!uid) {
      console.error(`❌ User not found for customer: ${subscription.customer}`);

      // For subscription created events, we might need to wait for the user profile to be created
      // This can happen if the webhook arrives before the payment intent completion
      console.log(`⏳ Scheduling retry for subscription created: ${subscription.id}`);
      throw new Error(`User not found for customer: ${subscription.customer} - will retry`);
    }

    const extendedSubscription = subscription as unknown as ExtendedStripeSubscription;
    const subscriptionData: Partial<UserSubscriptionData> = {
      subscriptionId: subscription.id,
      customerId: subscription.customer as string,
      priceId: subscription.items.data[0]?.price.id,
      status: subscription.status as UserSubscriptionData['status'],
      currentPeriodStart: extendedSubscription.current_period_start * 1000,
      currentPeriodEnd: extendedSubscription.current_period_end * 1000,
      cancelAtPeriodEnd: extendedSubscription.cancel_at_period_end,
      // Ensure free workout limit is set to 10
      freeWorkoutLimit: 10,
    };

    // Only add canceledAt if it exists
    if (extendedSubscription.canceled_at != null) {
      subscriptionData.canceledAt = extendedSubscription.canceled_at * 1000;
    }

    console.log(`📝 Updating subscription for user ${uid}:`, {
      subscriptionId: subscriptionData.subscriptionId,
      status: subscriptionData.status,
      customerId: subscriptionData.customerId,
      freeWorkoutLimit: subscriptionData.freeWorkoutLimit
    });

    await updateUserSubscription(uid, subscriptionData);
    console.log(`✅ Successfully created subscription for user: ${uid}`);

  } catch (error) {
    console.error(`❌ Failed to handle subscription created ${subscription.id}:`, error);
    throw error; // Re-throw to trigger webhook retry
  }
}

/**
 * Handle subscription updated event with enhanced logging
 */
async function handleSubscriptionUpdated(subscription: Stripe.Subscription) {
  console.log(`📝 Processing subscription updated: ${subscription.id} for customer: ${subscription.customer}`);
  console.log(`📊 Subscription status: ${subscription.status}`);

  try {
    const uid = await getUserByCustomerId(subscription.customer as string);
    if (!uid) {
      console.error(`❌ User not found for customer: ${subscription.customer}`);
      throw new Error(`User not found for customer: ${subscription.customer}`);
    }

    const extendedSubscription = subscription as unknown as ExtendedStripeSubscription;
    const subscriptionData: Partial<UserSubscriptionData> = {
      subscriptionId: subscription.id,
      customerId: subscription.customer as string,
      priceId: subscription.items.data[0]?.price.id,
      status: subscription.status as UserSubscriptionData['status'],
      currentPeriodStart: extendedSubscription.current_period_start * 1000,
      currentPeriodEnd: extendedSubscription.current_period_end * 1000,
      cancelAtPeriodEnd: extendedSubscription.cancel_at_period_end,
      // Ensure free workout limit is preserved
      freeWorkoutLimit: 10,
    };

    // Only add canceledAt if it exists
    if (extendedSubscription.canceled_at != null) {
      subscriptionData.canceledAt = extendedSubscription.canceled_at * 1000;
    }

    console.log(`📝 Updating subscription for user ${uid}:`, {
      subscriptionId: subscriptionData.subscriptionId,
      status: subscriptionData.status,
      customerId: subscriptionData.customerId,
      cancelAtPeriodEnd: subscriptionData.cancelAtPeriodEnd,
      freeWorkoutLimit: subscriptionData.freeWorkoutLimit
    });

    await updateUserSubscription(uid, subscriptionData);

    // Verify subscription status after update
    console.log(`🔍 Verified subscription status for user ${uid}: ${subscriptionData.status}`);
    console.log(`✅ Successfully updated subscription for user: ${uid}`);

  } catch (error) {
    console.error(`❌ Failed to handle subscription updated ${subscription.id}:`, error);
    throw error; // Re-throw to trigger webhook retry
  }
}

/**
 * Handle subscription deleted event
 */
async function handleSubscriptionDeleted(subscription: Stripe.Subscription) {
  console.log('Processing subscription deleted:', subscription.id);

  const uid = await getUserByCustomerId(subscription.customer as string);
  if (!uid) {
    console.error('User not found for customer:', subscription.customer);
    return;
  }

  const extendedSubscription = subscription as unknown as ExtendedStripeSubscription;
  const subscriptionData: Partial<UserSubscriptionData> = {
    status: 'canceled',
  };

  // Use Stripe's canceled_at if available, otherwise fallback to current time
  subscriptionData.canceledAt =
    extendedSubscription.canceled_at != null ? extendedSubscription.canceled_at * 1000 : Date.now();

  await updateUserSubscription(uid, subscriptionData);
  console.log('Subscription deleted for user:', uid);
}

/**
 * Handle successful payment
 */
async function handlePaymentSucceeded(invoice: Stripe.Invoice) {
  console.log('Processing payment succeeded:', invoice.id);

  const extendedInvoice = invoice as ExtendedStripeInvoice;
  if (!extendedInvoice.subscription) {
    console.log('No subscription associated with invoice:', invoice.id);
    return;
  }

  const uid = await getUserByCustomerId(invoice.customer as string);
  if (!uid) {
    console.error('User not found for customer:', invoice.customer);
    return;
  }

  try {
    // Get the full subscription details from Stripe
    const stripe = getStripeClient(process.env.STRIPE_SECRET_KEY!);
    const subscription = await stripe.subscriptions.retrieve(extendedInvoice.subscription as string);
    const extendedSubscription = subscription as unknown as ExtendedStripeSubscription;

    // Payment succeeded, update subscription with full details
    const subscriptionData: Partial<UserSubscriptionData> = {
      subscriptionId: subscription.id,
      customerId: subscription.customer as string,
      priceId: subscription.items.data[0]?.price.id,
      status: subscription.status as UserSubscriptionData['status'],
      currentPeriodStart: extendedSubscription.current_period_start * 1000,
      currentPeriodEnd: extendedSubscription.current_period_end * 1000,
      cancelAtPeriodEnd: extendedSubscription.cancel_at_period_end,
      // Ensure free workout limit is set
      freeWorkoutLimit: 10,
    };

    // Only add canceledAt if it exists
    if (extendedSubscription.canceled_at != null) {
      subscriptionData.canceledAt = extendedSubscription.canceled_at * 1000;
    }

    console.log(`📝 Payment succeeded - updating subscription for user ${uid}:`, {
      subscriptionId: subscriptionData.subscriptionId,
      status: subscriptionData.status,
      customerId: subscriptionData.customerId,
      freeWorkoutLimit: subscriptionData.freeWorkoutLimit
    });

    await updateUserSubscription(uid, subscriptionData);
    console.log('✅ Payment succeeded and subscription updated for user:', uid, 'Status:', subscriptionData.status);
  } catch (error) {
    console.error('❌ Error processing payment success:', error);
    // Fallback to basic status update - use actual subscription status, not hardcoded 'active'
    try {
      const stripe = getStripeClient(process.env.STRIPE_SECRET_KEY!);
      const subscription = await stripe.subscriptions.retrieve(extendedInvoice.subscription as string);
      await updateUserSubscription(uid, {
        status: subscription.status as UserSubscriptionData['status'],
        customerId: subscription.customer as string,
        freeWorkoutLimit: 10
      });
      console.log('✅ Fallback update completed with status:', subscription.status);
    } catch (fallbackError) {
      console.error('❌ Fallback update also failed:', fallbackError);
    }
  }
}

/**
 * Handle failed payment
 */
async function handlePaymentFailed(invoice: Stripe.Invoice) {
  console.log('Processing payment failed:', invoice.id);

  const extendedInvoice = invoice as ExtendedStripeInvoice;
  if (!extendedInvoice.subscription) return;

  const uid = await getUserByCustomerId(invoice.customer as string);
  if (!uid) {
    console.error('User not found for customer:', invoice.customer);
    return;
  }

  // Payment failed, subscription might be past_due
  const subscriptionData: Partial<UserSubscriptionData> = {
    status: 'past_due',
  };

  await updateUserSubscription(uid, subscriptionData);
  console.log('Payment failed for user:', uid);
}

========================================
FILE: functions/src/subscription-functions.ts
========================================

import { onCall } from 'firebase-functions/v2/https';
import { defineSecret } from 'firebase-functions/params';
import Stripe from 'stripe';
import {
  createOrGetCustomer,
  createSubscription,
  cancelSubscription,
  reactivateSubscription,
  getStripeClient,
} from './lib/stripe';
import * as functions from 'firebase-functions/v2';

// Extended Stripe types to include properties that exist but aren't in the official types
interface ExtendedStripeSubscription extends Omit<Stripe.Subscription, 'canceled_at'> {
  current_period_start: number;
  current_period_end: number;
  cancel_at_period_end: boolean;
  canceled_at?: number | null;
}

interface ExtendedStripeInvoice extends Stripe.Invoice {
  payment_intent?: Stripe.PaymentIntent | string;
}

// Define Stripe secret key
const stripeSecretKey = defineSecret('STRIPE_SECRET_KEY');

/**
 * Create a payment intent for subscription
 */
export const createPaymentIntent = onCall(
  {
    region: 'us-central1',
    secrets: [stripeSecretKey],
  },
  async (request) => {
    const { auth, data } = request;

    if (!auth) {
      throw new functions.https.HttpsError('unauthenticated', 'Authentication required');
    }

    const { priceId } = data;
    if (!priceId) {
      throw new functions.https.HttpsError('invalid-argument', 'Price ID is required');
    }

    try {
      // Get or create customer
      const customerId = await createOrGetCustomer(
        auth.uid,
        auth.token.email || '',
        auth.token.name,
        stripeSecretKey.value()
      );

      // Create subscription
      const subscription = await createSubscription(customerId, priceId, auth.uid, stripeSecretKey.value());

      const invoice = subscription.latest_invoice as string | ExtendedStripeInvoice;
      let paymentIntent: Stripe.PaymentIntent | string | undefined;

      if (typeof invoice === 'string') {
        const stripeInstance = getStripeClient(stripeSecretKey.value());
        const fullInvoice = await stripeInstance.invoices.retrieve(invoice, {
          expand: ['payment_intent'],
        });
        paymentIntent = (fullInvoice as ExtendedStripeInvoice).payment_intent;
      } else {
        paymentIntent = invoice?.payment_intent;
      }

      let clientSecret: string | null | undefined;
      if (typeof paymentIntent === 'string') {
        const stripeInstance = getStripeClient(stripeSecretKey.value());
        const pi = await stripeInstance.paymentIntents.retrieve(paymentIntent);
        clientSecret = pi.client_secret;
      } else {
        clientSecret = paymentIntent?.client_secret;
      }

      if (!clientSecret) {
        console.error('No client secret available for subscription:', subscription.id);
        throw new functions.https.HttpsError('internal', 'Payment initialization failed: No client secret available');
      }

      return {
        subscriptionId: subscription.id,
        clientSecret: clientSecret,
        customerId,
      };
    } catch (error) {
      console.error('Error creating payment intent:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      throw new functions.https.HttpsError('internal', `Failed to create payment intent: ${errorMessage}`);
    }
  }
);

/**
 * Cancel user subscription
 */
export const cancelUserSubscription = onCall(
  {
    region: 'us-central1',
    secrets: [stripeSecretKey],
  },
  async (request) => {
    const { auth, data } = request;

    if (!auth) {
      throw new functions.https.HttpsError('unauthenticated', 'Authentication required');
    }

    const { subscriptionId } = data;
    if (!subscriptionId) {
      throw new functions.https.HttpsError('invalid-argument', 'Subscription ID is required');
    }

    try {
      const subscription = await cancelSubscription(subscriptionId, stripeSecretKey.value());
      const extendedSubscription = subscription as unknown as ExtendedStripeSubscription;

      return {
        success: true,
        cancelAtPeriodEnd: subscription.cancel_at_period_end,
        currentPeriodEnd: extendedSubscription.current_period_end * 1000,
      };
    } catch (error) {
      console.error('Error canceling subscription:', error);
      throw new functions.https.HttpsError('internal', 'Failed to cancel subscription');
    }
  }
);

/**
 * Reactivate user subscription
 */
export const reactivateUserSubscription = onCall(
  {
    region: 'us-central1',
    secrets: [stripeSecretKey],
  },
  async (request) => {
    const { auth, data } = request;

    if (!auth) {
      throw new functions.https.HttpsError('unauthenticated', 'Authentication required');
    }

    const { subscriptionId } = data;
    if (!subscriptionId) {
      throw new functions.https.HttpsError('invalid-argument', 'Subscription ID is required');
    }

    try {
      const subscription = await reactivateSubscription(subscriptionId, stripeSecretKey.value());

      return {
        success: true,
        cancelAtPeriodEnd: subscription.cancel_at_period_end,
        status: subscription.status,
      };
    } catch (error) {
      console.error('Error reactivating subscription:', error);
      throw new functions.https.HttpsError('internal', 'Failed to reactivate subscription');
    }
  }
);

/**
 * Get customer portal URL for subscription management
 */
export const getCustomerPortalUrl = onCall(
  {
    region: 'us-central1',
    secrets: [stripeSecretKey],
  },
  async (request) => {
    const { auth, data } = request;

    if (!auth) {
      throw new functions.https.HttpsError('unauthenticated', 'Authentication required');
    }

    const { customerId, returnUrl } = data;
    if (!customerId) {
      throw new functions.https.HttpsError('invalid-argument', 'Customer ID is required');
    }

    try {
      const stripeInstance = getStripeClient(stripeSecretKey.value());
      const session = await stripeInstance.billingPortal.sessions.create({
        customer: customerId,
        return_url: returnUrl || 'https://neurafit-ai-2025.web.app/profile',
      });

      return {
        url: session.url,
      };
    } catch (error) {
      console.error('Error creating customer portal session:', error);
      throw new functions.https.HttpsError('internal', 'Failed to create customer portal session');
    }
  }
);

/**
 * Get subscription details
 */
export const getSubscriptionDetails = onCall(
  {
    region: 'us-central1',
    secrets: [stripeSecretKey],
  },
  async (request) => {
    const { auth, data } = request;

    if (!auth) {
      throw new functions.https.HttpsError('unauthenticated', 'Authentication required');
    }

    const { subscriptionId } = data;
    if (!subscriptionId) {
      throw new functions.https.HttpsError('invalid-argument', 'Subscription ID is required');
    }

    try {
      const stripeInstance = getStripeClient(stripeSecretKey.value());
      const subscription = await stripeInstance.subscriptions.retrieve(subscriptionId, {
        expand: ['default_payment_method', 'latest_invoice'],
      });

      const extendedSubscription = subscription as unknown as ExtendedStripeSubscription;
      if (!subscription.items.data[0]) {
        throw new functions.https.HttpsError('not-found', 'Subscription has no items');
      }

      return {
        id: subscription.id,
        status: subscription.status,
        currentPeriodStart: extendedSubscription.current_period_start * 1000,
        currentPeriodEnd: extendedSubscription.current_period_end * 1000,
        cancelAtPeriodEnd: subscription.cancel_at_period_end,
        canceledAt: extendedSubscription.canceled_at ? extendedSubscription.canceled_at * 1000 : null,
        priceId: subscription.items.data[0].price.id,
        amount: subscription.items.data[0].price.unit_amount,
        currency: subscription.items.data[0].price.currency,
        interval: subscription.items.data[0].price.recurring?.interval,
      };
    } catch (error) {
      console.error('Error getting subscription details:', error);
      throw new functions.https.HttpsError('internal', 'Failed to get subscription details');
    }
  }
);

/**
 * Get billing history
 */
export const getBillingHistory = onCall(
  {
    region: 'us-central1',
    secrets: [stripeSecretKey],
  },
  async (request) => {
    const { auth, data } = request;

    if (!auth) {
      throw new functions.https.HttpsError('unauthenticated', 'Authentication required');
    }

    const { customerId, limit = 10 } = data;
    if (!customerId) {
      throw new functions.https.HttpsError('invalid-argument', 'Customer ID is required');
    }

    if (typeof limit !== 'number' || limit < 1 || limit > 100) {
      throw new functions.https.HttpsError('invalid-argument', 'Limit must be between 1 and 100');
    }

    try {
      const stripeInstance = getStripeClient(stripeSecretKey.value());
      const invoices = await stripeInstance.invoices.list({
        customer: customerId,
        limit,
        expand: ['data.payment_intent'],
      });

      return {
        invoices: invoices.data.map((invoice) => ({
          id: invoice.id,
          amount: invoice.amount_paid,
          currency: invoice.currency,
          status: invoice.status,
          description: invoice.description || `Invoice ${invoice.number}`,
          created: invoice.created * 1000,
          invoiceUrl: invoice.hosted_invoice_url,
          pdfUrl: invoice.invoice_pdf,
        })),
      };
    } catch (error) {
      console.error('Error getting billing history:', error);
      throw new functions.https.HttpsError('internal', 'Failed to get billing history');
    }
  }
);

========================================
FILE: functions/src/lib/exerciseDatabase.ts
========================================

/**
 * Professional exercise database with evidence-based programming
 * Provides exercise templates and programming guidelines for AI workout generation
 */

export interface ExerciseTemplate {
  name: string;
  category: 'compound' | 'isolation' | 'cardio' | 'mobility' | 'core';
  muscleGroups: string[];
  equipment: string[];
  difficulty: 'beginner' | 'intermediate' | 'advanced';
  contraindications: string[];
  description: string;
  formTips: string[];
  safetyTips: string[];
  progressions: string[];
  regressions: string[];
  usesWeight: boolean;
}

export interface ProgrammingGuidelines {
  strength: {
    sets: [number, number];
    reps: [number, number];
    restSeconds: [number, number];
    intensity: string;
  };
  hypertrophy: {
    sets: [number, number];
    reps: [number, number];
    restSeconds: [number, number];
    intensity: string;
  };
  endurance: {
    sets: [number, number];
    reps: [number, number];
    restSeconds: [number, number];
    intensity: string;
  };
}

// Evidence-based programming guidelines by goal
export const PROGRAMMING_GUIDELINES: ProgrammingGuidelines = {
  strength: {
    sets: [3, 6],
    reps: [1, 6],
    restSeconds: [150, 300], // Increased minimum for strength training
    intensity: '85-100% 1RM',
  },
  hypertrophy: {
    sets: [3, 5],
    reps: [6, 12],
    restSeconds: [75, 150], // Increased for better recovery
    intensity: '65-85% 1RM',
  },
  endurance: {
    sets: [2, 4],
    reps: [12, 25],
    restSeconds: [45, 90], // Increased minimum for adequate recovery
    intensity: '40-65% 1RM',
  },
};

// Core compound movement templates
export const COMPOUND_EXERCISES: ExerciseTemplate[] = [
  {
    name: 'Bodyweight Squat',
    category: 'compound',
    muscleGroups: ['quadriceps', 'glutes', 'hamstrings', 'core'],
    equipment: ['bodyweight'],
    difficulty: 'beginner',
    contraindications: ['knee'],
    description:
      'Stand with feet shoulder-width apart, toes slightly turned out. Lower your body by pushing hips back and bending knees, keeping chest up and weight on heels. Descend until thighs are parallel to floor. Drive through heels to return to starting position. Breathe in on the way down, out on the way up.',
    formTips: [
      'Keep knees tracking over toes, not caving inward',
      'Maintain neutral spine with chest up throughout movement',
      'Drive through heels, not toes, when standing up',
    ],
    safetyTips: [
      'Stop if you feel knee pain and reduce range of motion',
      'Keep weight evenly distributed across both feet',
      'Start with partial range of motion if mobility is limited',
    ],
    progressions: ['Goblet Squat', 'Jump Squat', 'Single-Leg Squat'],
    regressions: ['Chair-Assisted Squat', 'Wall Squat', 'Partial Range Squat'],
    usesWeight: false,
  },
  {
    name: 'Push-Up',
    category: 'compound',
    muscleGroups: ['chest', 'shoulders', 'triceps', 'core'],
    equipment: ['bodyweight'],
    difficulty: 'beginner',
    contraindications: ['wrist', 'shoulder'],
    description:
      'Start in plank position with hands slightly wider than shoulders, body in straight line from head to heels. Lower chest toward floor by bending elbows, keeping them at 45-degree angle to body. Push back up to starting position. Breathe in on the way down, out on the way up.',
    formTips: [
      'Maintain straight line from head to heels throughout movement',
      'Keep elbows at 45-degree angle, not flared out to sides',
      'Lower chest to within 2-3 inches of floor for full range',
    ],
    safetyTips: [
      'Modify on knees if unable to maintain proper form',
      'Stop if you feel wrist or shoulder pain',
      'Keep core engaged to prevent lower back sagging',
    ],
    progressions: ['Decline Push-Up', 'Diamond Push-Up', 'Single-Arm Push-Up'],
    regressions: ['Knee Push-Up', 'Incline Push-Up', 'Wall Push-Up'],
    usesWeight: false,
  },
  {
    name: 'Dumbbell Deadlift',
    category: 'compound',
    muscleGroups: ['hamstrings', 'glutes', 'lower back', 'traps'],
    equipment: ['dumbbells'],
    difficulty: 'intermediate',
    contraindications: ['lower back'],
    description:
      'Stand with feet hip-width apart, holding dumbbells at sides. Hinge at hips by pushing butt back, keeping slight bend in knees. Lower dumbbells along legs until you feel stretch in hamstrings. Drive hips forward to return to standing. Breathe in on the way down, out on the way up.',
    formTips: [
      'Keep dumbbells close to legs throughout entire movement',
      'Maintain neutral spine - no rounding or excessive arching',
      'Initiate movement with hip hinge, not knee bend',
    ],
    safetyTips: [
      'Start with light weight to master movement pattern',
      'Stop if you feel lower back pain or rounding',
      'Keep shoulders pulled back and chest up',
    ],
    progressions: ['Romanian Deadlift', 'Single-Leg Deadlift', 'Sumo Deadlift'],
    regressions: ['Dumbbell Rack Pull', 'Kettlebell Deadlift', 'Bodyweight Hip Hinge'],
    usesWeight: true,
  },
];

// Isolation exercise templates
export const ISOLATION_EXERCISES: ExerciseTemplate[] = [
  {
    name: 'Dumbbell Bicep Curl',
    category: 'isolation',
    muscleGroups: ['biceps'],
    equipment: ['dumbbells'],
    difficulty: 'beginner',
    contraindications: ['wrist'],
    description:
      'Stand with feet hip-width apart, holding dumbbells at sides with palms facing forward. Keeping elbows stationary at sides, curl weights up by contracting biceps. Slowly lower back to starting position with control. Breathe out on the way up, in on the way down.',
    formTips: [
      'Keep elbows pinned to sides throughout movement',
      'Control the weight on both up and down phases',
      'Squeeze biceps at the top of the movement',
    ],
    safetyTips: [
      'Avoid swinging or using momentum to lift weight',
      'Start with lighter weight to establish proper form',
      'Stop if you feel elbow or wrist discomfort',
    ],
    progressions: ['Hammer Curl', 'Concentration Curl', '21s Curl'],
    regressions: ['Resistance Band Curl', 'Assisted Curl', 'Partial Range Curl'],
    usesWeight: true,
  },
];

// Cardio exercise templates
export const CARDIO_EXERCISES: ExerciseTemplate[] = [
  {
    name: 'High Knees',
    category: 'cardio',
    muscleGroups: ['quadriceps', 'hip flexors', 'calves'],
    equipment: ['bodyweight'],
    difficulty: 'beginner',
    contraindications: ['knee', 'ankle'],
    description:
      'Stand tall with feet hip-width apart. Lift one knee up toward chest, then quickly switch to lift other knee. Continue alternating at a rapid pace while pumping arms. Land softly on balls of feet. Maintain steady breathing throughout.',
    formTips: [
      'Lift knees to hip height or as high as comfortable',
      'Stay light on feet with quick, bouncy steps',
      'Keep core engaged and posture upright',
    ],
    safetyTips: [
      'Land softly to reduce impact on joints',
      'Modify by marching in place if high impact is uncomfortable',
      'Stop if you feel knee or ankle pain',
    ],
    progressions: ['High Knees with Resistance Band', 'High Knees to Burpee'],
    regressions: ['Marching in Place', 'Slow High Knees', 'Seated High Knees'],
    usesWeight: false,
  },
];

// Mobility and warm-up templates
export const MOBILITY_EXERCISES: ExerciseTemplate[] = [
  {
    name: 'Arm Circles',
    category: 'mobility',
    muscleGroups: ['shoulders', 'upper back'],
    equipment: ['bodyweight'],
    difficulty: 'beginner',
    contraindications: [],
    description:
      'Stand with feet shoulder-width apart, arms extended out to sides at shoulder height. Make small circles with arms, gradually increasing size. Perform in both forward and backward directions. Keep movements controlled and smooth.',
    formTips: [
      'Start with small circles and gradually increase size',
      'Keep arms straight and parallel to floor',
      'Maintain good posture with shoulders down and back',
    ],
    safetyTips: [
      'Move slowly and controlled, especially if shoulders are tight',
      'Stop if you feel any sharp pain or discomfort',
      'Reduce range of motion if needed',
    ],
    progressions: ['Arm Circles with Light Weights'],
    regressions: ['Seated Arm Circles', 'Smaller Range Arm Circles'],
    usesWeight: false,
  },
];

/**
 * Get exercise recommendations based on user profile and workout goals
 */
export function getExerciseRecommendations(
  userProfile: {
    experience?: string;
    goals?: string[];
    equipment?: string[];
    injuries?: string[];
    workoutType?: string;
  }
): ExerciseTemplate[] {
  const allExercises = [
    ...COMPOUND_EXERCISES,
    ...ISOLATION_EXERCISES,
    ...CARDIO_EXERCISES,
    ...MOBILITY_EXERCISES,
  ];

  return allExercises.filter((exercise) => {
    // Filter by available equipment
    if (userProfile.equipment && userProfile.equipment.length > 0) {
      const hasRequiredEquipment = exercise.equipment.some((eq) =>
        userProfile.equipment!.some(
          (userEq) =>
            userEq.toLowerCase().includes(eq.toLowerCase()) || eq.toLowerCase().includes(userEq.toLowerCase())
        )
      );
      if (!hasRequiredEquipment) return false;
    }

    // Filter by experience level
    if (userProfile.experience?.toLowerCase() === 'beginner' && exercise.difficulty === 'advanced') {
      return false;
    }

    // Filter by injury contraindications
    if (userProfile.injuries && userProfile.injuries.length > 0) {
      const hasContraindication = exercise.contraindications.some((contraindication) =>
        userProfile.injuries!.some((injury) =>
          injury.toLowerCase().includes(contraindication.toLowerCase())
        )
      );
      if (hasContraindication) return false;
    }

    // Filter by workout type
    if (userProfile.workoutType) {
      const workoutType = userProfile.workoutType.toLowerCase();
      if (workoutType.includes('strength') && exercise.category === 'cardio') return false;
      if (workoutType.includes('cardio') && exercise.category === 'isolation') return false;
      if (workoutType.includes('mobility') && exercise.category !== 'mobility') return false;
    }

    return true;
  });
}

/**
 * Get programming recommendations based on goals
 */
export function getProgrammingRecommendations(
  goals: string[],
  _experience: string
): Partial<ProgrammingGuidelines[keyof ProgrammingGuidelines]> {
  const primaryGoal = goals[0]?.toLowerCase() || 'general health';

  if (primaryGoal.includes('strength')) {
    return PROGRAMMING_GUIDELINES.strength;
  } else if (primaryGoal.includes('muscle') || primaryGoal.includes('tone')) {
    return PROGRAMMING_GUIDELINES.hypertrophy;
  } else if (primaryGoal.includes('stamina') || primaryGoal.includes('endurance')) {
    return PROGRAMMING_GUIDELINES.endurance;
  }

  // Default to hypertrophy for general fitness
  return PROGRAMMING_GUIDELINES.hypertrophy;
}

========================================
FILE: functions/src/lib/exerciseValidation.ts
========================================

/**
 * Professional exercise validation and safety checking system
 * Ensures AI-generated workouts meet fitness industry standards
 */

export interface ExerciseValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
  suggestions: string[];
}

export interface Exercise {
  name: string;
  description: string;
  sets: number;
  reps: number | string;
  formTips: string[];
  safetyTips: string[];
  restSeconds: number;
  usesWeight: boolean;
  muscleGroups?: string[];
  difficulty?: string;
}

export interface WorkoutPlan {
  exercises: Exercise[];
  workoutSummary?: {
    totalVolume: string;
    primaryFocus: string;
    expectedRPE: string;
  };
}

// Exercise contraindications based on common injuries
const INJURY_CONTRAINDICATIONS: Record<string, string[]> = {
  knee: [
    'deep squat',
    'lunge',
    'jump',
    'plyometric',
    'box jump',
    'burpee',
    'single leg squat',
    'pistol squat',
    'jump squat',
    'split squat',
  ],
  'lower back': [
    'deadlift',
    'good morning',
    'bent over row',
    'overhead press',
    'sit up',
    'russian twist',
    'toe touch',
    'superman',
  ],
  shoulder: [
    'overhead press',
    'behind neck',
    'upright row',
    'lateral raise',
    'military press',
    'handstand',
    'pull up',
    'dip',
  ],
  ankle: ['jump', 'plyometric', 'calf raise', 'box jump', 'burpee', 'running', 'sprinting', 'agility'],
  wrist: ['push up', 'plank', 'handstand', 'burpee', 'mountain climber'],
  neck: ['overhead press', 'behind neck', 'headstand', 'neck bridge'],
};

/**
 * Validates a complete workout plan for safety and quality
 */
export function validateWorkoutPlan(
  plan: WorkoutPlan,
  userProfile: {
    experience?: string;
    injuries?: string[];
    duration: number;
    goals?: string[];
  }
): ExerciseValidationResult {
  const result: ExerciseValidationResult = {
    isValid: true,
    errors: [],
    warnings: [],
    suggestions: [],
  };

  if (!plan.exercises || plan.exercises.length === 0) {
    result.errors.push('Workout must contain at least one exercise');
    result.isValid = false;
    return result;
  }

  // Validate individual exercises
  plan.exercises.forEach((exercise, index) => {
    const exerciseResult = validateExercise(exercise, userProfile);

    if (!exerciseResult.isValid) {
      result.isValid = false;
    }

    exerciseResult.errors.forEach((error) =>
      result.errors.push(`Exercise ${index + 1} (${exercise.name}): ${error}`)
    );
    exerciseResult.warnings.forEach((warning) =>
      result.warnings.push(`Exercise ${index + 1} (${exercise.name}): ${warning}`)
    );
    exerciseResult.suggestions.forEach((suggestion) =>
      result.suggestions.push(`Exercise ${index + 1} (${exercise.name}): ${suggestion}`)
    );
  });

  // Validate workout structure
  validateWorkoutStructure(plan, userProfile, result);

  // Check for injury contraindications
  validateInjuryCompliance(plan, userProfile.injuries || [], result);

  // Validate time feasibility
  validateTimeFeasibility(plan, userProfile.duration, result);

  return result;
}

/**
 * Validates an individual exercise
 */
function validateExercise(
  exercise: Exercise,
  userProfile: { experience?: string; goals?: string[] }
): ExerciseValidationResult {
  const result: ExerciseValidationResult = {
    isValid: true,
    errors: [],
    warnings: [],
    suggestions: [],
  };

  // Required fields validation
  if (!exercise.name || exercise.name.trim().length === 0) {
    result.errors.push('Exercise name is required');
    result.isValid = false;
  }

  if (!exercise.description || exercise.description.trim().length < 50) {
    result.errors.push('Exercise description must be at least 50 characters with proper technique guidance');
    result.isValid = false;
  }

  if (!exercise.sets || exercise.sets < 1 || exercise.sets > 10) {
    result.errors.push('Sets must be between 1 and 10');
    result.isValid = false;
  }

  if (!exercise.reps) {
    result.errors.push('Reps specification is required');
    result.isValid = false;
  }

  // Rest period validation with exercise-specific requirements
  const exerciseName = exercise.name.toLowerCase();
  let minRestSeconds = 30; // Default minimum
  const maxRestSeconds = 300;

  // Determine minimum rest based on exercise type
  if (
    exerciseName.includes('squat') ||
    exerciseName.includes('deadlift') ||
    exerciseName.includes('press') ||
    exerciseName.includes('row')
  ) {
    minRestSeconds = 120; // Compound movements need more rest
  } else if (
    exerciseName.includes('curl') ||
    exerciseName.includes('extension') ||
    exerciseName.includes('raise') ||
    exerciseName.includes('fly')
  ) {
    minRestSeconds = 60; // Isolation exercises
  } else if (exerciseName.includes('warm') || exerciseName.includes('mobility')) {
    minRestSeconds = 15; // Warm-up movements
  } else if (exerciseName.includes('plank') || exerciseName.includes('hold')) {
    minRestSeconds = 45; // Isometric exercises
  }

  if (exercise.restSeconds < minRestSeconds) {
    result.warnings.push(
      `Rest period may be short: ${exercise.restSeconds}s (typical minimum ${minRestSeconds}s for this exercise type)`
    );
  } else if (exercise.restSeconds > maxRestSeconds) {
    result.warnings.push(`Rest period very long: ${exercise.restSeconds}s (consider ${maxRestSeconds}s maximum)`);
  }

  // Form tips validation
  if (!exercise.formTips || exercise.formTips.length === 0) {
    result.warnings.push('Form tips are highly recommended for exercise safety');
  } else if (exercise.formTips.length > 3) {
    result.suggestions.push('Consider limiting form tips to 3 most critical points for clarity');
  }

  // Safety tips validation
  if (!exercise.safetyTips || exercise.safetyTips.length === 0) {
    result.warnings.push('Safety tips are essential for injury prevention');
  } else if (exercise.safetyTips.length > 3) {
    result.suggestions.push('Consider limiting safety tips to 3 most important points');
  }

  // Experience-appropriate difficulty
  if (userProfile.experience?.toLowerCase() === 'beginner' && exercise.difficulty === 'advanced') {
    result.warnings.push('Advanced exercise may be too challenging for beginner');
  }

  return result;
}

/**
 * Validates overall workout structure and programming
 */
function validateWorkoutStructure(
  plan: WorkoutPlan,
  userProfile: { duration: number; goals?: string[] },
  result: ExerciseValidationResult
): void {
  const exercises = plan.exercises;
  const hasWarmup = exercises.some(
    (ex) => ex.name.toLowerCase().includes('warm') || ex.name.toLowerCase().includes('mobility') || ex.difficulty === 'beginner'
  );

  const hasCooldown = exercises.some(
    (ex) =>
      ex.name.toLowerCase().includes('cool') ||
      ex.name.toLowerCase().includes('stretch') ||
      ex.name.toLowerCase().includes('recovery')
  );

  // Warm-up validation
  if (!hasWarmup && userProfile.duration >= 20) {
    result.warnings.push('Workouts 20+ minutes should include warm-up exercises');
  }

  // Cool-down validation
  if (!hasCooldown && userProfile.duration >= 30) {
    result.warnings.push('Workouts 30+ minutes should include cool-down/stretching');
  }

  // Movement pattern balance
  const muscleGroups = exercises
    .flatMap((ex) => ex.muscleGroups || [])
    .reduce((acc, group) => {
      acc[group] = (acc[group] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

  const pushMovements = (muscleGroups['chest'] || 0) + (muscleGroups['shoulders'] || 0);
  const pullMovements = (muscleGroups['back'] || 0) + (muscleGroups['biceps'] || 0);

  if (pushMovements > 0 && pullMovements === 0) {
    result.warnings.push('Consider adding pulling movements to balance push exercises');
  }
  if (pullMovements > 0 && pushMovements === 0) {
    result.warnings.push('Consider adding pushing movements to balance pull exercises');
  }
}

/**
 * Validates compliance with injury limitations
 */
function validateInjuryCompliance(
  plan: WorkoutPlan,
  injuries: string[],
  result: ExerciseValidationResult
): void {
  if (injuries.length === 0) return;

  plan.exercises.forEach((exercise, index) => {
    injuries.forEach((injury) => {
      const contraindications = INJURY_CONTRAINDICATIONS[injury.toLowerCase()] || [];
      const exerciseName = exercise.name.toLowerCase();

      const hasContraindication = contraindications.some((contraindicated) =>
        exerciseName.includes(contraindicated)
      );

      if (hasContraindication) {
        result.errors.push(
          `Exercise ${index + 1} (${exercise.name}) may be contraindicated for ${injury} injury`
        );
        result.isValid = false;
      }
    });
  });
}

/**
 * Validates workout fits within time constraints
 */
function validateTimeFeasibility(
  plan: WorkoutPlan,
  targetDuration: number,
  result: ExerciseValidationResult
): void {
  let estimatedTime = 0;

  plan.exercises.forEach((exercise) => {
    // Estimate work time (assuming 3 seconds per rep average)
    let workTime = 0;
    if (typeof exercise.reps === 'string') {
      if (exercise.reps.includes('s')) {
        workTime = parseInt(exercise.reps) || 30;
      } else if (exercise.reps.includes('-')) {
        // Handle ranges like "8-12"
        const [minReps, maxReps] = exercise.reps.split('-').map(Number);
        workTime = ((minReps + maxReps) / 2) * 3;
      } else {
        workTime = 30; // Default for time-based
      }
    } else {
      workTime = exercise.reps * 3; // 3 seconds per rep estimate
    }

    const totalWorkTime = workTime * exercise.sets;
    const totalRestTime = exercise.restSeconds * (exercise.sets - 1);

    estimatedTime += totalWorkTime + totalRestTime;
  });

  // Convert to minutes
  estimatedTime = Math.ceil(estimatedTime / 60);

  if (estimatedTime > targetDuration * 1.2) {
    result.warnings.push(
      `Estimated workout time (${estimatedTime}min) exceeds target duration (${targetDuration}min) by >20%`
    );
  }

  if (estimatedTime < targetDuration * 0.7) {
    result.suggestions.push(
      `Workout may be shorter than expected (${estimatedTime}min vs ${targetDuration}min target)`
    );
  }
}

========================================
FILE: functions/src/lib/personalization.ts
========================================

import { getFirestore, Timestamp } from 'firebase-admin/firestore';
import { initializeApp, getApps } from 'firebase-admin/app';

// Initialize Firebase Admin if not already initialized
if (getApps().length === 0) {
  initializeApp();
}

/**
 * Adaptive personalization state for workout difficulty tuning
 */
export type AdaptiveState = {
  difficultyScalar: number; // 0.6-1.4, where 1.0 is baseline
  lastFeedback: 'easy' | 'right' | 'hard' | null;
  lastUpdatedAt: Timestamp;
  recentCompletionRate?: number; // 0-1 over last N workouts
};

/**
 * Workout completion data for calculating recent performance
 */
type WorkoutData = {
  exercises: Array<{
    sets: number;
    weights?: Record<number, number | null>; // setNumber -> weight (null = skipped)
  }>;
  timestamp: Timestamp;
};

/**
 * Get the current adaptive state for a user, creating default if none exists
 */
export async function getAdaptiveState(uid: string): Promise<AdaptiveState> {
  const db = getFirestore();
  const docRef = db.collection('users').doc(uid).collection('personalization').doc('adaptive');

  try {
    const doc = await docRef.get();

    if (doc.exists) {
      const data = doc.data() as AdaptiveState;
      return {
        difficultyScalar: data.difficultyScalar || 1.0,
        lastFeedback: data.lastFeedback || null,
        lastUpdatedAt: data.lastUpdatedAt || Timestamp.now(),
        recentCompletionRate: data.recentCompletionRate,
      };
    } else {
      // Create default state
      const defaultState: AdaptiveState = {
        difficultyScalar: 1.0,
        lastFeedback: null,
        lastUpdatedAt: Timestamp.now(),
        recentCompletionRate: undefined,
      };

      await docRef.set(defaultState);
      return defaultState;
    }
  } catch (error) {
    console.error('Error getting adaptive state:', error);
    // Return safe default on error
    return {
      difficultyScalar: 1.0,
      lastFeedback: null,
      lastUpdatedAt: Timestamp.now(),
      recentCompletionRate: undefined,
    };
  }
}

/**
 * Update adaptive state based on user feedback and recent completion rate
 */
export async function updateAdaptiveState(
  uid: string,
  signal: 'easy' | 'right' | 'hard',
  recentCompletion: number
): Promise<AdaptiveState> {
  const db = getFirestore();
  const docRef = db.collection('users').doc(uid).collection('personalization').doc('adaptive');

  try {
    // Get current state
    const currentState = await getAdaptiveState(uid);

    // Compute new scalar
    const newScalar = computeNextScalar(currentState.difficultyScalar, signal, recentCompletion);

    const updatedState: AdaptiveState = {
      difficultyScalar: newScalar,
      lastFeedback: signal,
      lastUpdatedAt: Timestamp.now(),
      recentCompletionRate: recentCompletion,
    };

    await docRef.set(updatedState, { merge: true });

    console.log(`Updated adaptive state for ${uid}:`, {
      signal,
      recentCompletion,
      oldScalar: currentState.difficultyScalar,
      newScalar,
    });

    // Log telemetry event (server-side logging)
    console.log('TELEMETRY: adaptive_state_updated', {
      uid: uid.substring(0, 8) + '...', // Partial UID for privacy
      oldScalar: Math.round(currentState.difficultyScalar * 100) / 100,
      newScalar: Math.round(newScalar * 100) / 100,
      scalarChange: Math.round((newScalar - currentState.difficultyScalar) * 100) / 100,
      signal,
      recentCompletion: Math.round(recentCompletion * 100) / 100,
    });

    return updatedState;
  } catch (error) {
    console.error('Error updating adaptive state:', error);
    throw error;
  }
}

/**
 * Compute the next difficulty scalar based on feedback and completion rate
 */
export function computeNextScalar(
  prevScalar: number,
  signal: 'easy' | 'right' | 'hard',
  recentCompletion?: number
): number {
  let newScalar = prevScalar;

  // Apply feedback adjustment
  switch (signal) {
  case 'easy':
    newScalar += 0.1; // Increase difficulty
    break;
  case 'hard':
    newScalar -= 0.1; // Decrease difficulty
    break;
  case 'right':
    newScalar += 0.02; // Progressive overload
    break;
  }

  // Apply completion rate bias if available
  if (recentCompletion !== undefined) {
    if (recentCompletion < 0.6) {
      newScalar -= 0.05; // Bias downward for low completion
    } else if (recentCompletion > 0.9) {
      newScalar += 0.05; // Bias upward for high completion
    }
  }

  // Clamp to safe bounds
  return Math.max(0.6, Math.min(1.4, newScalar));
}

/**
 * Calculate recent completion rate from user's workout history
 */
export async function calculateRecentCompletionRate(uid: string, lookbackCount = 5): Promise<number> {
  const db = getFirestore();

  try {
    const workoutsRef = db.collection('users').doc(uid).collection('workouts');
    const query = workoutsRef.orderBy('timestamp', 'desc').limit(lookbackCount);
    const snapshot = await query.get();

    if (snapshot.empty) {
      return 0.8; // Default completion rate for new users
    }

    let totalSets = 0;
    let completedSets = 0;

    snapshot.docs.forEach((doc) => {
      const workout = doc.data() as WorkoutData;

      if (workout.exercises && Array.isArray(workout.exercises)) {
        workout.exercises.forEach((exercise) => {
          if (exercise.weights && typeof exercise.weights === 'object') {
            const setCount = exercise.sets || Object.keys(exercise.weights).length;
            totalSets += setCount;

            // Count completed sets (non-null weights)
            Object.values(exercise.weights).forEach((weight) => {
              if (weight !== null && weight !== undefined) {
                completedSets++;
              }
            });
          } else {
            // Fallback: assume all sets completed if no weight data
            totalSets += exercise.sets || 0;
            completedSets += exercise.sets || 0;
          }
        });
      }
    });

    if (totalSets === 0) {
      return 0.8; // Default if no set data available
    }

    const completionRate = completedSets / totalSets;
    console.log(`Calculated completion rate for ${uid}:`, {
      completedSets,
      totalSets,
      completionRate,
      workoutCount: snapshot.size,
    });

    return Math.max(0, Math.min(1, completionRate));
  } catch (error) {
    console.error('Error calculating completion rate:', error);
    return 0.8; // Safe default on error
  }
}

/**
 * Generate progression note for AI prompt based on adaptive state
 */
export function generateProgressionNote(
  prevScalar: number,
  newScalar: number,
  feedback: 'easy' | 'right' | 'hard' | null
): string {
  const intensityChange = ((newScalar - 1.0) - (prevScalar - 1.0)) * 100;

  if (!feedback) {
    return newScalar > 1.0
      ? `Increase difficulty ~${Math.round((newScalar - 1.0) * 100)}% safely`
      : newScalar < 1.0
        ? `Decrease difficulty ~${Math.round((1.0 - newScalar) * 100)}% safely`
        : 'Maintain baseline difficulty';
  }

  const feedbackText = {
    easy: 'user rated last workout too easy',
    hard: 'user rated last workout too hard',
    right: 'user rated last workout just right',
  }[feedback];

  if (Math.abs(intensityChange) < 1) {
    return `${feedbackText}; maintain current difficulty level`;
  }

  return intensityChange > 0
    ? `${feedbackText}; increase difficulty ~${Math.round(Math.abs(intensityChange))}% safely`
    : `${feedbackText}; decrease difficulty ~${Math.round(Math.abs(intensityChange))}% safely`;
}

========================================
FILE: functions/src/lib/promptEnhancements.ts
========================================

/**
 * Professional prompt enhancements for AI workout generation
 * Provides coaching expertise and evidence-based guidance
 */

export interface PromptContext {
  experience?: string;
  goals?: string[];
  equipment?: string[];
  injuries?: string[];
  workoutType?: string;
  duration: number;
  targetIntensity: number;
  progressionNote?: string;
}

/**
 * Generate professional coaching context for the AI prompt
 */
export function generateCoachingContext(context: PromptContext): string {
  const coachingPoints: string[] = [];

  // Experience-based coaching
  switch (context.experience) {
  case 'Beginner':
    coachingPoints.push(
      'BEGINNER FOCUS: Prioritize movement quality over intensity. Teach fundamental patterns.',
      'Use 2-3 sets maximum per exercise to prevent overload and allow adaptation.',
      'Include detailed setup and execution cues in descriptions.',
      'Provide clear regression options for challenging movements.'
    );
    break;
  case 'Intermediate':
    coachingPoints.push(
      'INTERMEDIATE FOCUS: Challenge with progressive overload while maintaining form.',
      'Use 3-4 sets per exercise with moderate to challenging loads.',
      'Include advanced technique cues and common mistake corrections.',
      'Introduce movement variations and unilateral work.'
    );
    break;
  case 'Expert':
  case 'Advanced':
    coachingPoints.push(
      'ADVANCED FOCUS: Implement complex movement patterns and high-intensity techniques.',
      'Use 3-6 sets with varied rep ranges and advanced progressions.',
      'Include biomechanical optimization cues and performance tips.',
      'Challenge with compound movements and athletic variations.'
    );
    break;
  }

  // Goal-specific coaching
  context.goals?.forEach((goal) => {
    const goalLower = goal.toLowerCase();

    if (goalLower.includes('strength')) {
      coachingPoints.push(
        'STRENGTH COACHING: Focus on compound movements with 3-6 reps at high intensity.',
        'Emphasize proper bracing, tension, and force production.',
        'Use longer rest periods (2-3 minutes) for full recovery between sets.'
      );
    }

    if (goalLower.includes('muscle') || goalLower.includes('tone')) {
      coachingPoints.push(
        'HYPERTROPHY COACHING: Use 6-12 rep range with moderate loads.',
        'Focus on time under tension and mind-muscle connection.',
        'Include both compound and isolation exercises for complete development.'
      );
    }

    if (goalLower.includes('weight loss')) {
      coachingPoints.push(
        'FAT LOSS COACHING: Incorporate circuit-style training with shorter rest periods.',
        'Emphasize compound movements that burn more calories.',
        'Include metabolic finishers or cardio intervals when appropriate.'
      );
    }

    if (goalLower.includes('stamina') || goalLower.includes('endurance')) {
      coachingPoints.push(
        'ENDURANCE COACHING: Use higher rep ranges (12-20+) with shorter rest.',
        'Focus on movement efficiency and breathing patterns.',
        'Include cardio intervals and circuit training elements.'
      );
    }
  });

  // Injury-specific coaching
  if (context.injuries && context.injuries.length > 0) {
    coachingPoints.push(
      'INJURY CONSIDERATIONS: Modify exercises to work around limitations.',
      'Provide alternative movements that target same muscle groups safely.',
      'Include corrective exercises and mobility work when appropriate.',
      'Emphasize pain-free range of motion and proper movement patterns.'
    );
  }

  return coachingPoints.join('\n- ');
}

/**
 * Generate exercise selection guidelines based on context
 */
export function generateExerciseSelectionGuidelines(context: PromptContext): string {
  const guidelines: string[] = [];

  // Equipment-based selection
  if (!context.equipment || context.equipment.includes('Bodyweight')) {
    guidelines.push(
      'BODYWEIGHT FOCUS: Emphasize fundamental movement patterns.',
      'Use push-up variations, squat patterns, and core stability exercises.',
      'Include plyometric and cardio elements for variety and challenge.'
    );
  }

  if (context.equipment?.includes('Dumbbells')) {
    guidelines.push(
      'DUMBBELL TRAINING: Utilize unilateral work and stabilization challenges.',
      'Include compound movements like dumbbell deadlifts and presses.',
      'Use single-arm variations to challenge core stability.'
    );
  }

  if (context.equipment?.includes('Barbells')) {
    guidelines.push(
      'BARBELL TRAINING: Focus on heavy compound movements.',
      'Include squats, deadlifts, presses, and rows as primary exercises.',
      'Use bilateral loading for maximum strength development.'
    );
  }

  // Workout type specific guidelines
  if (context.workoutType?.toLowerCase().includes('hiit')) {
    guidelines.push(
      'HIIT STRUCTURE: Alternate high-intensity work with active recovery.',
      'Use 20-45 second work intervals with 10-30 second rest periods.',
      'Include explosive movements and compound exercises.'
    );
  }

  if (context.workoutType?.toLowerCase().includes('strength')) {
    guidelines.push(
      'STRENGTH STRUCTURE: Build around major compound movements.',
      'Use progressive loading with adequate rest between exercises.',
      'Include accessory work to support main lifts.'
    );
  }

  if (context.workoutType?.toLowerCase().includes('cardio')) {
    guidelines.push(
      'CARDIO STRUCTURE: Maintain elevated heart rate throughout session.',
      'Use circuit training or interval methods.',
      'Include both steady-state and interval components.'
    );
  }

  return guidelines.join('\n- ');
}

/**
 * Generate safety and form emphasis based on context
 */
export function generateSafetyEmphasis(context: PromptContext): string {
  const safetyPoints: string[] = [
    'UNIVERSAL SAFETY PRINCIPLES:',
    '- Always prioritize proper form over load or speed',
    '- Include proper breathing cues (exhale on exertion)',
    '- Emphasize controlled movement in both concentric and eccentric phases',
    '- Provide clear setup and alignment cues',
    '- Include modification options for different fitness levels',
  ];

  // Injury-specific safety
  context.injuries?.forEach((injury) => {
    const injuryLower = injury.toLowerCase();

    if (injuryLower.includes('knee')) {
      safetyPoints.push(
        '- KNEE SAFETY: Avoid deep knee flexion, ensure proper tracking',
        '- Modify jumping and pivoting movements',
        '- Include knee-friendly alternatives like wall sits or glute bridges'
      );
    }

    if (injuryLower.includes('back') || injuryLower.includes('spine')) {
      safetyPoints.push(
        '- BACK SAFETY: Maintain neutral spine alignment',
        '- Avoid spinal flexion under load',
        '- Include core activation cues and bracing techniques'
      );
    }

    if (injuryLower.includes('shoulder')) {
      safetyPoints.push(
        '- SHOULDER SAFETY: Avoid overhead movements if impingement present',
        '- Include scapular stability and mobility work',
        '- Modify pressing movements to pain-free ranges'
      );
    }
  });

  // Experience-based safety
  if (context.experience === 'Beginner') {
    safetyPoints.push(
      '- BEGINNER SAFETY: Start with bodyweight or light resistance',
      '- Focus on learning movement patterns before adding load',
      '- Include detailed setup instructions and common mistake warnings'
    );
  }

  return safetyPoints.join('\n');
}

/**
 * Generate progression and regression options
 */
export function generateProgressionGuidance(context: PromptContext): string {
  const progressionPoints: string[] = [
    'PROGRESSION PRINCIPLES:',
    '- Increase difficulty gradually (10% rule)',
    '- Progress complexity before intensity',
    '- Master bodyweight before adding external load',
    '- Use time, range of motion, or stability challenges as progressions',
  ];

  if (context.targetIntensity > 1.1) {
    progressionPoints.push(
      '- INTENSITY INCREASE: User ready for moderate challenge increase',
      '- Add 1-2 reps, reduce rest by 10-15 seconds, or increase range of motion',
      '- Include more challenging exercise variations'
    );
  } else if (context.targetIntensity < 0.9) {
    progressionPoints.push(
      '- INTENSITY DECREASE: User needs recovery or easier variations',
      '- Reduce reps by 2-3, increase rest by 15-30 seconds',
      '- Use regression options and assisted movements'
    );
  }

  progressionPoints.push(
    'REGRESSION OPTIONS:',
    '- Reduce range of motion for mobility limitations',
    '- Use assisted variations (bands, partner, or equipment support)',
    '- Decrease load or switch to bodyweight alternatives',
    '- Modify tempo to slower, more controlled movements'
  );

  return progressionPoints.join('\n- ');
}

/**
 * Generate complete professional coaching prompt enhancement
 */
export function generateProfessionalPromptEnhancement(context: PromptContext): string {
  return `
PROFESSIONAL COACHING EXPERTISE:
- ${generateCoachingContext(context)}

EXERCISE SELECTION STRATEGY:
- ${generateExerciseSelectionGuidelines(context)}

${generateSafetyEmphasis(context)}

${generateProgressionGuidance(context)}

QUALITY STANDARDS:
- Each exercise description must include: setup, execution, key cues, and breathing
- Form tips should address the most common technique errors
- Safety tips must include injury prevention and modification options
- Rest periods should be physiologically appropriate for the training goal
- Exercise difficulty should match user experience level
- Workout structure should follow logical progression (warm-up → main work → cool-down)

PROFESSIONAL LANGUAGE:
- Use clear, instructional language without jargon
- Provide specific, actionable cues
- Include positive reinforcement and motivation
- Address common concerns and mistakes proactively
- Maintain encouraging but authoritative tone throughout
`.trim();
}

========================================
FILE: functions/src/lib/stripe.ts
========================================

import Stripe from 'stripe';
import { getFirestore } from 'firebase-admin/firestore';
import { initializeApp, getApps } from 'firebase-admin/app';

// Initialize Firebase Admin if not already initialized
if (getApps().length === 0) {
  initializeApp();
}

export const db = getFirestore();

// Stripe client will be initialized with the secret key when needed
let stripeClient: Stripe | null = null;

export function getStripeClient(secretKey: string): Stripe {
  if (!stripeClient) {
    stripeClient = new Stripe(secretKey);
  }
  return stripeClient;
}

// Export the stripe client for use in other modules
export const stripe = stripeClient;

// Subscription status mapping from Stripe to our types
export type SubscriptionStatus =
  | 'active'
  | 'canceled'
  | 'incomplete'
  | 'incomplete_expired'
  | 'past_due'
  | 'trialing'
  | 'unpaid';

export interface UserSubscriptionData {
  customerId: string;
  subscriptionId?: string;
  priceId?: string;
  status: SubscriptionStatus;
  currentPeriodStart?: number;
  currentPeriodEnd?: number;
  cancelAtPeriodEnd?: boolean;
  canceledAt?: number;
  workoutCount: number;
  freeWorkoutsUsed: number;
  freeWorkoutLimit: number;
  createdAt: number;
  updatedAt: number;
}

/**
 * Create or retrieve a Stripe customer for a user
 */
export async function createOrGetCustomer(
  uid: string,
  email: string,
  name?: string,
  stripeSecretKey?: string
): Promise<string> {
  try {
    const stripeInstance = stripeSecretKey ? getStripeClient(stripeSecretKey) : getStripeClient(process.env.STRIPE_SECRET_KEY!);

    // Check if user already has a customer ID
    const userDoc = await db.collection('users').doc(uid).get();
    const userData = userDoc.data();

    if (userData?.subscription?.customerId) {
      // Verify the customer still exists in Stripe
      try {
        await stripeInstance.customers.retrieve(userData.subscription.customerId);
        return userData.subscription.customerId;
      } catch (error) {
        console.log('Customer not found in Stripe, creating new one:', error);
      }
    }

    // Create new customer
    const customer = await stripeInstance.customers.create({
      email,
      name,
      metadata: {
        firebaseUID: uid,
      },
    });

    // Initialize subscription data in Firestore
    const subscriptionData: UserSubscriptionData = {
      customerId: customer.id,
      status: 'incomplete',
      workoutCount: 0,
      freeWorkoutsUsed: 0,
      freeWorkoutLimit: 10,
      createdAt: Date.now(),
      updatedAt: Date.now(),
    };

    await db.collection('users').doc(uid).set(
      {
        subscription: subscriptionData,
      },
      { merge: true }
    );

    return customer.id;
  } catch (error) {
    console.error('Error creating/getting customer:', error);
    throw new Error('Failed to create or get Stripe customer');
  }
}

/**
 * Create a subscription for a user
 */
export async function createSubscription(
  customerId: string,
  priceId: string,
  uid: string,
  stripeSecretKey?: string
): Promise<Stripe.Subscription> {
  const stripeInstance = stripeSecretKey ? getStripeClient(stripeSecretKey) : getStripeClient(process.env.STRIPE_SECRET_KEY!);

  try {
    // First, check for existing subscriptions for this customer
    console.log('Checking for existing subscriptions for customer:', customerId);
    const existingSubscriptions = await stripeInstance.subscriptions.list({
      customer: customerId,
      status: 'all',
      limit: 10,
    });

    console.log(`Found ${existingSubscriptions.data.length} existing subscriptions`);

    // Cancel any incomplete subscriptions to avoid conflicts
    for (const sub of existingSubscriptions.data) {
      if (sub.status === 'incomplete' || sub.status === 'incomplete_expired') {
        console.log('Canceling incomplete subscription:', sub.id);
        try {
          await stripeInstance.subscriptions.cancel(sub.id);
          console.log('Successfully canceled incomplete subscription:', sub.id);
        } catch (cancelError) {
          // This is expected if the subscription was already deleted by Stripe (e.g., expired)
          const errorMessage = cancelError instanceof Error ? cancelError.message : 'Unknown error';
          if (errorMessage.includes('No such subscription') || errorMessage.includes('resource_missing')) {
            console.log('Subscription already deleted (expected):', sub.id);
          } else {
            console.warn('Failed to cancel incomplete subscription:', sub.id, errorMessage);
          }
        }
      }
    }

    // Check if there's already an active subscription with the same price
    const activeSubscription = existingSubscriptions.data.find(
      (sub) =>
        (sub.status === 'active' || sub.status === 'trialing') &&
        sub.items.data.some((item) => item.price.id === priceId)
    );

    if (activeSubscription) {
      console.log('Found existing active subscription:', activeSubscription.id);
      return activeSubscription;
    }

    console.log('Creating new subscription...');
    console.log('Creating subscription with customer:', customerId, 'price:', priceId);

    const subscription = await stripeInstance.subscriptions.create({
      customer: customerId,
      items: [{ price: priceId }],
      payment_behavior: 'default_incomplete',
      payment_settings: {
        save_default_payment_method: 'on_subscription',
        payment_method_types: ['card']
      },
      expand: ['latest_invoice.payment_intent'],
      metadata: {
        firebaseUID: uid,
      },
      // Ensure automatic tax calculation if needed
      automatic_tax: { enabled: false },
    });

    console.log('Subscription created:', subscription.id, 'status:', subscription.status);

    // Log invoice details for debugging
    const invoice = subscription.latest_invoice as string | Stripe.Invoice | null;
    let expandedInvoice: Stripe.Invoice | null = null;

    if (typeof invoice === 'string') {
      expandedInvoice = await stripeInstance.invoices.retrieve(invoice, {
        expand: ['payment_intent'],
      });
    } else if (invoice) {
      expandedInvoice = invoice;
    }

    if (expandedInvoice) {
      console.log('Invoice:', expandedInvoice.id, 'status:', expandedInvoice.status);
      const invoiceWithPaymentIntent = expandedInvoice as Stripe.Invoice & { payment_intent?: Stripe.PaymentIntent | string };
      console.log(
        'Payment intent on invoice:',
        invoiceWithPaymentIntent.payment_intent
          ? typeof invoiceWithPaymentIntent.payment_intent === 'string'
            ? invoiceWithPaymentIntent.payment_intent
            : invoiceWithPaymentIntent.payment_intent.id
          : 'none'
      );
    }

    // If no payment intent exists on the invoice, this might be a zero-amount invoice
    // or there might be an issue with the subscription setup
    const invoiceWithPaymentIntent = expandedInvoice as Stripe.Invoice & { payment_intent?: Stripe.PaymentIntent | string };
    if (expandedInvoice && !invoiceWithPaymentIntent.payment_intent) {
      console.log('No payment intent found on invoice');
      console.log('Invoice amount_due:', expandedInvoice.amount_due);
      console.log('Invoice currency:', expandedInvoice.currency);
      console.log('Invoice total:', expandedInvoice.total);

      // Check if this is a zero-amount invoice (like a trial)
      if (expandedInvoice.amount_due === 0) {
        console.log('Zero-amount invoice, no payment intent needed');
        return subscription;
      }

      // For non-zero invoices without payment intents, this indicates an issue with subscription setup
      console.log('Invoice has amount due but no payment intent - this should not happen with default_incomplete');
      console.log('Attempting to finalize the invoice to trigger payment intent creation...');

      try {
        // Try to finalize the invoice which should create a payment intent
        const finalizedInvoice = await stripeInstance.invoices.finalizeInvoice(expandedInvoice.id!, {
          expand: ['payment_intent'],
        });

        console.log('Invoice finalized:', finalizedInvoice.id, 'status:', finalizedInvoice.status);

        const finalizedInvoiceWithPI = finalizedInvoice as Stripe.Invoice & { payment_intent?: Stripe.PaymentIntent | string };
        if (finalizedInvoiceWithPI.payment_intent) {
          console.log('Payment intent created after finalization:',
            typeof finalizedInvoiceWithPI.payment_intent === 'string'
              ? finalizedInvoiceWithPI.payment_intent
              : finalizedInvoiceWithPI.payment_intent.id
          );

          // Return the subscription with the finalized invoice
          return {
            ...subscription,
            latest_invoice: finalizedInvoice,
          } as Stripe.Subscription;
        }

        // If still no payment intent, create one manually as last resort
        console.log('Still no payment intent after finalization, creating manually...');
        const paymentIntent = await stripeInstance.paymentIntents.create({
          amount: finalizedInvoice.amount_due,
          currency: finalizedInvoice.currency,
          customer: customerId,
          payment_method_types: ['card'],
          metadata: {
            invoice_id: finalizedInvoice.id || '',
            subscription_id: subscription.id,
            firebaseUID: uid,
          },
        });

        console.log('Manual payment intent created:', paymentIntent.id);

        // Return the subscription with the manual payment intent
        return {
          ...subscription,
          latest_invoice: {
            ...finalizedInvoice,
            payment_intent: paymentIntent,
          },
        } as Stripe.Subscription;

      } catch (piError) {
        console.error('Error handling invoice without payment intent:', piError);
        throw piError;
      }
    }

    return subscription;
  } catch (error) {
    console.error('Error creating subscription:', error);
    throw new Error('Failed to create subscription');
  }
}

/**
 * Update user subscription data in Firestore
 */
export async function updateUserSubscription(
  uid: string,
  subscriptionData: Partial<UserSubscriptionData>
): Promise<void> {
  try {
    console.log(`📝 Updating subscription for user ${uid}:`, subscriptionData);

    // Get current subscription data to preserve important fields
    const userRef = db.collection('users').doc(uid);
    const currentDoc = await userRef.get();
    const currentSubscription = currentDoc.data()?.subscription as UserSubscriptionData || {};

    // Ensure critical fields are preserved and validated
    const updatedSubscription: Partial<UserSubscriptionData> = {
      ...currentSubscription,
      ...subscriptionData,
      // Ensure free workout limit is always 10
      freeWorkoutLimit: 10,
      // Preserve workout counts if not explicitly updated
      workoutCount: subscriptionData.workoutCount ?? currentSubscription.workoutCount ?? 0,
      freeWorkoutsUsed: subscriptionData.freeWorkoutsUsed ?? currentSubscription.freeWorkoutsUsed ?? 0,
      // Always update timestamp
      updatedAt: Date.now(),
      // Preserve creation timestamp
      createdAt: currentSubscription.createdAt ?? Date.now(),
    };

    // Validate subscription period for active subscriptions
    if (updatedSubscription.status === 'active' &&
        updatedSubscription.currentPeriodStart &&
        updatedSubscription.currentPeriodEnd) {
      const duration = updatedSubscription.currentPeriodEnd - updatedSubscription.currentPeriodStart;
      const expectedDuration = 30 * 24 * 60 * 60 * 1000; // 30 days
      const tolerance = 24 * 60 * 60 * 1000; // 1 day tolerance

      if (Math.abs(duration - expectedDuration) > tolerance) {
        console.warn(`⚠️ Subscription period is not exactly 30 days: ${duration / (24 * 60 * 60 * 1000)} days`);
      }
    }

    await userRef.set(
      {
        subscription: updatedSubscription,
      },
      { merge: true }
    );

    console.log(`✅ Successfully updated subscription for user ${uid}:`, {
      status: updatedSubscription.status,
      customerId: updatedSubscription.customerId,
      subscriptionId: updatedSubscription.subscriptionId,
      workoutCount: updatedSubscription.workoutCount,
      freeWorkoutsUsed: updatedSubscription.freeWorkoutsUsed,
    });

    // Verify the update was successful
    const updatedDoc = await userRef.get();
    const updatedData = updatedDoc.data();
    console.log(`🔍 Verified subscription status for user ${uid}:`, updatedData?.subscription?.status);

  } catch (error) {
    console.error(`❌ Error updating user subscription for ${uid}:`, error);
    throw new Error(`Failed to update user subscription: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

/**
 * Get user by Stripe customer ID with enhanced lookup
 */
export async function getUserByCustomerId(customerId: string): Promise<string | null> {
  try {
    console.log(`🔍 Looking up user for customer ID: ${customerId}`);

    // First, try to find user by customer ID in subscription
    const usersRef = db.collection('users');
    const query = usersRef.where('subscription.customerId', '==', customerId);
    const snapshot = await query.get();

    if (!snapshot.empty) {
      const userId = snapshot.docs[0].id;
      console.log(`✅ Found user by customer ID: ${userId}`);
      return userId;
    }

    // If not found, try to get customer from Stripe and match by email
    console.log('🔍 Customer ID not found in profiles, checking Stripe for email...');

    try {
      const stripeInstance = getStripeClient(process.env.STRIPE_SECRET_KEY!);
      const customer = await stripeInstance.customers.retrieve(customerId) as Stripe.Customer;

      if (customer.email) {
        console.log(`📧 Found customer email: ${customer.email}`);

        // Look up user by email
        const emailQuery = usersRef.where('email', '==', customer.email);
        const emailSnapshot = await emailQuery.get();

        if (!emailSnapshot.empty) {
          const userId = emailSnapshot.docs[0].id;
          console.log(`✅ Found user by email: ${userId}`);

          // Update the user's profile with the customer ID for future lookups
          await updateUserSubscription(userId, { customerId });
          console.log('📝 Updated user profile with customer ID');

          return userId;
        }
      }
    } catch (stripeError) {
      console.error('Error fetching customer from Stripe:', stripeError);
    }

    console.log(`❌ No user found for customer ID: ${customerId}`);
    return null;
  } catch (error) {
    console.error('Error getting user by customer ID:', error);
    return null;
  }
}

/**
 * Cancel a subscription
 */
export async function cancelSubscription(
  subscriptionId: string,
  stripeSecretKey?: string
): Promise<Stripe.Subscription> {
  const stripeInstance = stripeSecretKey ? getStripeClient(stripeSecretKey) : getStripeClient(process.env.STRIPE_SECRET_KEY!);

  try {
    return await stripeInstance.subscriptions.update(subscriptionId, {
      cancel_at_period_end: true,
    });
  } catch (error) {
    console.error('Error canceling subscription:', error);
    throw new Error('Failed to cancel subscription');
  }
}

/**
 * Reactivate a subscription
 */
export async function reactivateSubscription(
  subscriptionId: string,
  stripeSecretKey?: string
): Promise<Stripe.Subscription> {
  const stripeInstance = stripeSecretKey ? getStripeClient(stripeSecretKey) : getStripeClient(process.env.STRIPE_SECRET_KEY!);

  try {
    return await stripeInstance.subscriptions.update(subscriptionId, {
      cancel_at_period_end: false,
    });
  } catch (error) {
    console.error('Error reactivating subscription:', error);
    throw new Error('Failed to reactivate subscription');
  }
}

/**
 * Increment workout count for a user
 */
export async function incrementWorkoutCount(uid: string): Promise<void> {
  try {
    const userRef = db.collection('users').doc(uid);
    const userDoc = await userRef.get();
    const userData = userDoc.data();

    if (!userData?.subscription) {
      // Initialize subscription data if it doesn't exist
      const subscriptionData: UserSubscriptionData = {
        customerId: '',
        status: 'incomplete',
        workoutCount: 1,
        freeWorkoutsUsed: 1,
        freeWorkoutLimit: 10,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      };

      await userRef.set(
        {
          subscription: subscriptionData,
        },
        { merge: true }
      );
    } else {
      // Increment counters
      const currentSubscription = userData.subscription as UserSubscriptionData;
      const isActive = currentSubscription.status === 'active' || currentSubscription.status === 'trialing';

      await userRef.set(
        {
          subscription: {
            ...currentSubscription,
            workoutCount: (currentSubscription.workoutCount || 0) + 1,
            freeWorkoutsUsed: isActive
              ? currentSubscription.freeWorkoutsUsed || 0
              : (currentSubscription.freeWorkoutsUsed || 0) + 1,
            updatedAt: Date.now(),
          },
        },
        { merge: true }
      );
    }
  } catch (error) {
    console.error('Error incrementing workout count:', error);
    throw new Error('Failed to increment workout count');
  }
}

========================================
FILE: functions/src/lib/workoutQualityScorer.ts
========================================

/**
 * Professional workout quality scoring system
 * Evaluates AI-generated workouts against fitness industry standards
 */

export interface QualityScore {
  overall: number; // 0-100
  breakdown: {
    programming: number; // Evidence-based set/rep/rest schemes
    safety: number; // Injury prevention and contraindications
    progression: number; // Appropriate difficulty scaling
    balance: number; // Movement pattern and muscle group balance
    specificity: number; // Goal alignment and exercise selection
    feasibility: number; // Time and equipment constraints
  };
  feedback: string[];
  recommendations: string[];
}

export interface WorkoutPlan {
  exercises: Array<{
    name: string;
    description: string;
    sets: number;
    reps: number | string;
    formTips: string[];
    safetyTips: string[];
    restSeconds: number;
    usesWeight: boolean;
    muscleGroups?: string[];
    difficulty?: string;
  }>;
  workoutSummary?: {
    totalVolume: string;
    primaryFocus: string;
    expectedRPE: string;
  };
}

export interface UserProfile {
  experience?: string;
  goals?: string[];
  equipment?: string[];
  injuries?: string[];
  duration: number;
  workoutType?: string;
}

/**
 * Evaluates workout quality against professional standards
 */
export function scoreWorkoutQuality(workout: WorkoutPlan, userProfile: UserProfile): QualityScore {
  const score: QualityScore = {
    overall: 0,
    breakdown: {
      programming: 0,
      safety: 0,
      progression: 0,
      balance: 0,
      specificity: 0,
      feasibility: 0,
    },
    feedback: [],
    recommendations: [],
  };

  // Score each component
  score.breakdown.programming = scoreProgramming(workout, userProfile, score);
  score.breakdown.safety = scoreSafety(workout, userProfile, score);
  score.breakdown.progression = scoreProgression(workout, userProfile, score);
  score.breakdown.balance = scoreBalance(workout, userProfile, score);
  score.breakdown.specificity = scoreSpecificity(workout, userProfile, score);
  score.breakdown.feasibility = scoreFeasibility(workout, userProfile, score);

  // Calculate overall score (weighted average)
  const weights = {
    programming: 0.2,
    safety: 0.25, // Highest weight - safety first
    progression: 0.15,
    balance: 0.15,
    specificity: 0.15,
    feasibility: 0.1,
  };

  score.overall = Math.round(
    Object.entries(score.breakdown).reduce((total, [key, value]) => {
      return total + value * (weights[key as keyof typeof weights] ?? 0);
    }, 0)
  );

  // Add overall feedback based on score
  if (score.overall >= 90) {
    score.feedback.push('Excellent workout quality - meets professional standards');
  } else if (score.overall >= 80) {
    score.feedback.push('Good workout quality with minor areas for improvement');
  } else if (score.overall >= 70) {
    score.feedback.push('Acceptable workout quality but needs refinement');
  } else {
    score.feedback.push('Workout quality below professional standards - significant improvements needed');
  }

  return score;
}

/**
 * Score evidence-based programming principles
 */
function scoreProgramming(workout: WorkoutPlan, userProfile: UserProfile, score: QualityScore): number {
  let programmingScore = 100;
  const exercises = workout.exercises;

  // Check set/rep schemes and rest periods
  exercises.forEach((exercise) => {
    // Sets validation
    if (exercise.sets < 1 || exercise.sets > 8) {
      programmingScore -= 10;
      score.feedback.push(`${exercise.name}: Unusual set count (${exercise.sets})`);
    }

    // Enhanced rest periods validation based on exercise type
    const exerciseName = exercise.name.toLowerCase();
    let minRestSeconds = 30;
    let optimalRestSeconds = 60;

    // Determine appropriate rest based on exercise type
    if (
      exerciseName.includes('squat') ||
      exerciseName.includes('deadlift') ||
      exerciseName.includes('press') ||
      exerciseName.includes('row')
    ) {
      minRestSeconds = 120;
      optimalRestSeconds = 150;
    } else if (
      exerciseName.includes('curl') ||
      exerciseName.includes('extension') ||
      exerciseName.includes('raise') ||
      exerciseName.includes('fly')
    ) {
      minRestSeconds = 60;
      optimalRestSeconds = 75;
    } else if (exerciseName.includes('jump') || exerciseName.includes('sprint') || exerciseName.includes('burpee')) {
      minRestSeconds = 45;
      optimalRestSeconds = 60;
    }

    if (exercise.restSeconds < minRestSeconds) {
      programmingScore -= 20; // Heavy penalty for inadequate rest
      score.feedback.push(
        `${exercise.name}: Rest period too short (${exercise.restSeconds}s, need ${minRestSeconds}s+)`
      );
    } else if (exercise.restSeconds < optimalRestSeconds) {
      programmingScore -= 10; // Moderate penalty for suboptimal rest
      score.recommendations.push(`${exercise.name}: Consider longer rest (${optimalRestSeconds}s optimal)`);
    } else if (exercise.restSeconds > 300) {
      programmingScore -= 5;
      score.feedback.push(`${exercise.name}: Rest period very long (${exercise.restSeconds}s)`);
    }

    // Rep scheme validation
    if (typeof exercise.reps === 'number') {
      if (exercise.reps < 1 || exercise.reps > 30) {
        programmingScore -= 10;
        score.feedback.push(`${exercise.name}: Rep count outside typical range`);
      }
    } else if (typeof exercise.reps === 'string') {
      // Basic validation for string reps (e.g., "8-12" or "30s")
      if (!/^\d+-\d+$|^\d+s$/.test(exercise.reps)) {
        programmingScore -= 5;
        score.feedback.push(`${exercise.name}: Unusual rep format (${exercise.reps})`);
      }
    }
  });

  // Check for progressive structure
  const hasWarmup = exercises.some(
    (ex) => ex.name.toLowerCase().includes('warm') || ex.difficulty === 'beginner'
  );

  if (!hasWarmup && userProfile.duration >= 20) {
    programmingScore -= 15;
    score.recommendations.push('Include dynamic warm-up for injury prevention');
  }

  return Math.max(0, programmingScore);
}

/**
 * Score safety considerations and injury prevention
 */
function scoreSafety(workout: WorkoutPlan, userProfile: UserProfile, score: QualityScore): number {
  let safetyScore = 100;
  const exercises = workout.exercises;
  const injuries = userProfile.injuries || [];

  // Check for injury contraindications
  const contraindications: Record<string, string[]> = {
    knee: ['deep squat', 'lunge', 'jump', 'plyometric'],
    'lower back': ['deadlift', 'good morning', 'bent over row', 'sit up'],
    shoulder: ['overhead press', 'behind neck', 'upright row'],
    ankle: ['jump', 'plyometric', 'calf raise'],
    wrist: ['push up', 'plank', 'handstand'],
    neck: ['overhead press', 'behind neck', 'headstand'],
  };

  injuries.forEach((injury) => {
    const contraindicatedMovements = contraindications[injury.toLowerCase()] || [];
    exercises.forEach((exercise) => {
      const exerciseName = exercise.name.toLowerCase();
      const hasContraindication = contraindicatedMovements.some((movement) => exerciseName.includes(movement));

      if (hasContraindication) {
        safetyScore -= 25;
        score.feedback.push(`${exercise.name}: May be contraindicated for ${injury} injury`);
      }
    });
  });

  // Check for safety tips
  exercises.forEach((exercise) => {
    if (!exercise.safetyTips || exercise.safetyTips.length === 0) {
      safetyScore -= 5;
      score.recommendations.push(`${exercise.name}: Add safety tips for injury prevention`);
    }

    if (!exercise.formTips || exercise.formTips.length === 0) {
      safetyScore -= 5;
      score.recommendations.push(`${exercise.name}: Add form cues for proper technique`);
    }
  });

  return Math.max(0, safetyScore);
}

/**
 * Score progression appropriateness
 */
function scoreProgression(workout: WorkoutPlan, userProfile: UserProfile, score: QualityScore): number {
  let progressionScore = 100;
  const exercises = workout.exercises;
  const experience = userProfile.experience?.toLowerCase() || 'beginner';

  exercises.forEach((exercise) => {
    const difficulty = exercise.difficulty?.toLowerCase() || 'intermediate';

    // Check experience-difficulty alignment
    if (experience === 'beginner' && difficulty === 'advanced') {
      progressionScore -= 20;
      score.feedback.push(`${exercise.name}: Too advanced for beginner level`);
    }

    if (experience === 'expert' && difficulty === 'beginner' && exercises.length < 3) {
      progressionScore -= 10;
      score.recommendations.push('Consider more challenging variations for experienced users');
    }
  });

  return Math.max(0, progressionScore);
}

/**
 * Score movement pattern and muscle group balance
 */
function scoreBalance(workout: WorkoutPlan, userProfile: UserProfile, score: QualityScore): number {
  let balanceScore = 100;
  const exercises = workout.exercises;

  // Analyze muscle group distribution
  const muscleGroups: Record<string, number> = {};
  exercises.forEach((exercise) => {
    if (exercise.muscleGroups) {
      exercise.muscleGroups.forEach((group) => {
        muscleGroups[group] = (muscleGroups[group] || 0) + 1;
      });
    }
  });

  // Check push/pull balance
  const pushGroups = ['chest', 'shoulders', 'triceps'];
  const pullGroups = ['back', 'biceps', 'rear delts'];

  const pushCount = pushGroups.reduce((sum, group) => sum + (muscleGroups[group] || 0), 0);
  const pullCount = pullGroups.reduce((sum, group) => sum + (muscleGroups[group] || 0), 0);

  if (pushCount > 0 && pullCount === 0) {
    balanceScore -= 15;
    score.recommendations.push('Add pulling movements to balance pushing exercises');
  }

  if (pullCount > 0 && pushCount === 0) {
    balanceScore -= 15;
    score.recommendations.push('Add pushing movements to balance pulling exercises');
  }

  // Check for lower body inclusion in full-body workouts
  const lowerBodyGroups = ['quadriceps', 'hamstrings', 'glutes', 'calves'];
  const lowerBodyCount = lowerBodyGroups.reduce((sum, group) => sum + (muscleGroups[group] || 0), 0);

  if (userProfile.workoutType?.toLowerCase().includes('full') && lowerBodyCount === 0) {
    balanceScore -= 20;
    score.feedback.push('Full-body workout should include lower body exercises');
  }

  return Math.max(0, balanceScore);
}

/**
 * Score goal specificity and exercise selection
 */
function scoreSpecificity(workout: WorkoutPlan, userProfile: UserProfile, score: QualityScore): number {
  let specificityScore = 100;
  const goals = userProfile.goals || [];
  const exercises = workout.exercises;

  goals.forEach((goal) => {
    const goalLower = goal.toLowerCase();

    if (goalLower.includes('strength')) {
      // Should have compound movements with lower rep ranges
      const hasCompound = exercises.some(
        (ex) =>
          ex.name.toLowerCase().includes('squat') ||
          ex.name.toLowerCase().includes('deadlift') ||
          ex.name.toLowerCase().includes('press')
      );

      if (!hasCompound) {
        specificityScore -= 15;
        score.recommendations.push('Include compound movements for strength goals');
      }
    }

    if (goalLower.includes('cardio') || goalLower.includes('stamina')) {
      // Should have cardio or circuit-style exercises
      const hasCardio = exercises.some(
        (ex) => ex.name.toLowerCase().includes('jump') || ex.name.toLowerCase().includes('run') || ex.restSeconds < 45
      );

      if (!hasCardio) {
        specificityScore -= 15;
        score.recommendations.push('Include cardio elements for endurance goals');
      }
    }
  });

  return Math.max(0, specificityScore);
}

/**
 * Score time and equipment feasibility
 */
function scoreFeasibility(workout: WorkoutPlan, userProfile: UserProfile, score: QualityScore): number {
  let feasibilityScore = 100;
  const exercises = workout.exercises;
  const targetDuration = userProfile.duration;
  const availableEquipment = userProfile.equipment || [];

  // Estimate workout duration
  let estimatedTime = 0;
  exercises.forEach((exercise) => {
    let workTime = 30; // Default seconds per set
    if (typeof exercise.reps === 'number') {
      workTime = exercise.reps * 3; // 3 seconds per rep
    } else if (typeof exercise.reps === 'string') {
      if (exercise.reps.includes('s')) {
        workTime = parseInt(exercise.reps, 10) || 30;
      } else if (exercise.reps.includes('-')) {
        const [min, max] = exercise.reps.split('-').map(Number);
        workTime = ((min + (max ?? min)) / 2) * 3;
      }
    }

    const totalWorkTime = workTime * exercise.sets;
    const totalRestTime = exercise.restSeconds * (exercise.sets - 1);
    estimatedTime += totalWorkTime + totalRestTime;
  });

  estimatedTime = Math.ceil(estimatedTime / 60); // Convert to minutes

  // Check time feasibility
  if (estimatedTime > targetDuration * 1.3) {
    feasibilityScore -= 20;
    score.feedback.push(
      `Estimated time (${estimatedTime}min) significantly exceeds target (${targetDuration}min)`
    );
  }

  if (estimatedTime < targetDuration * 0.6) {
    feasibilityScore -= 10;
    score.recommendations.push(`Workout may be shorter than expected (${estimatedTime}min vs ${targetDuration}min)`);
  }

  // Check equipment requirements
  exercises.forEach((exercise) => {
    if (exercise.usesWeight && availableEquipment.length > 0) {
      const needsEquipment = !availableEquipment.some(
        (eq) =>
          eq.toLowerCase().includes('dumbbell') ||
          eq.toLowerCase().includes('barbell') ||
          eq.toLowerCase().includes('weight')
      );

      if (needsEquipment && !availableEquipment.includes('Bodyweight')) {
        feasibilityScore -= 10;
        score.feedback.push(`${exercise.name}: Requires equipment not in user's list`);
      }
    }
  });

  return Math.max(0, feasibilityScore);
}
========================================
SECTION 3: CONFIGURATION FILES
========================================

========================================
FILE: package.json
========================================

{
  "name": "neurafit",
  "private": true,
  "version": "1.0.1",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "build:deploy": "vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "deploy": "npm run build && firebase deploy --only hosting",
    "deploy:full": "npm run build && firebase deploy",
    "version:patch": "npm version patch && npm run deploy",
    "version:minor": "npm version minor && npm run deploy",
    "version:major": "npm version major && npm run deploy"
  },
  "dependencies": {
    "@stripe/react-stripe-js": "^4.0.2",
    "@stripe/stripe-js": "^7.9.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "firebase": "^12.3.0",
    "immer": "^10.1.3",
    "lucide-react": "^0.544.0",
    "react": "^19.1.1",
    "react-dom": "^19.1.1",
    "react-router-dom": "^7.9.1",
    "tailwind-merge": "^3.3.1",
    "zustand": "^5.0.8"
  },
  "devDependencies": {
    "@eslint/js": "^9.36.0",
    "@tailwindcss/vite": "^4.1.13",
    "@types/node": "^24.5.2",
    "@types/react": "^19.1.13",
    "@types/react-dom": "^19.1.9",
    "@typescript-eslint/eslint-plugin": "^8.44.1",
    "@typescript-eslint/parser": "^8.44.1",
    "@vitejs/plugin-react": "^5.0.3",
    "eslint": "^9.36.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.20",
    "globals": "^16.4.0",
    "tailwindcss": "^4.1.13",
    "terser": "^5.44.0",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.44.0",
    "vite": "^7.1.7"
  }
}


========================================
FILE: tsconfig.json
========================================

{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}


========================================
FILE: tsconfig.app.json
========================================

{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "types": ["vite/client", "node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": false,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}


========================================
FILE: tsconfig.node.json
========================================

{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": [],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}


========================================
FILE: vite.config.ts
========================================

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import tailwind from '@tailwindcss/vite'
import { resolve } from 'path'

/**
 * Simplified Vite Configuration for NeuraFit
 * React/TypeScript application with Firebase, Tailwind CSS, and Stripe
 */
export default defineConfig({
  // Path resolution
  resolve: {
    alias: {
      '@': resolve(__dirname, './src'),
    },
  },

  // Plugins
  plugins: [
    react(),
    tailwind(),
  ],

  // Development server
  server: {
    port: 5173,
    host: 'localhost',
  },

  // Build configuration
  build: {
    target: 'es2020',
    outDir: 'dist',
    sourcemap: false,
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom'],
          router: ['react-router-dom'],
          firebase: ['firebase/app', 'firebase/auth', 'firebase/firestore', 'firebase/functions'],
          ui: ['lucide-react', 'class-variance-authority', 'clsx', 'tailwind-merge'],
          state: ['zustand', 'immer'],
          stripe: ['@stripe/stripe-js', '@stripe/react-stripe-js'],
        },
      },
    },
  },

  // Global constants
  define: {
    __APP_VERSION__: JSON.stringify(process.env.npm_package_version || '1.0.0'),
    __BUILD_TIME__: JSON.stringify(new Date().toISOString()),
    global: 'globalThis',
  },

})

========================================
FILE: firebase.json
========================================

{
  "functions": [
    {
      "source": "functions",
      "codebase": "default",
      "ignore": [
        "node_modules",
        ".git",
        "firebase-debug.log",
        "firebase-debug.*.log",
        "*.local"
      ],
      "predeploy": [
        "node \"$RESOURCE_DIR\"/node_modules/typescript/lib/tsc.js -p \"$RESOURCE_DIR\"/tsconfig.json"
      ]
    }
  ],
  "hosting": {
    "public": "dist",
    "rewrites": [{ "source": "**", "destination": "/index.html" }],
    "headers": [
      {
        "source": "/**",
        "headers": [
          { "key": "Strict-Transport-Security", "value": "max-age=31536000; includeSubDomains; preload" },
          { "key": "Content-Security-Policy",
            "value": "default-src 'self'; script-src 'self' https://js.stripe.com https://www.googletagmanager.com https://www.google-analytics.com https://apis.google.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; img-src 'self' data: https: blob:; font-src 'self' https://fonts.gstatic.com data:; connect-src 'self' https://firestore.googleapis.com https://www.googleapis.com https://identitytoolkit.googleapis.com https://securetoken.googleapis.com https://firebase.googleapis.com https://www.google-analytics.com https://analytics.google.com https://stats.g.doubleclick.net https://accounts.google.com; frame-src https://js.stripe.com https://hooks.stripe.com https://accounts.google.com https://content-firebaseappcheck.googleapis.com https://*.firebaseapp.com; frame-ancestors 'none'; base-uri 'self'; form-action 'self'" },
          { "key": "Referrer-Policy", "value": "strict-origin-when-cross-origin" },
          { "key": "Permissions-Policy", "value": "geolocation=(), microphone=(), camera=()" },
          { "key": "X-Content-Type-Options", "value": "nosniff" }
        ]
      },
      {
        "source": "/assets/**",
        "headers": [{ "key": "Cache-Control", "value": "public, max-age=31536000, immutable" }]
      }
    ]
  },
  "firestore": {
    "database": "(default)",
    "location": "nam5",
    "rules": "firestore.rules",
    "indexes": "firestore.indexes.json"
  }
}


========================================
FILE: firestore.rules
========================================

/**
 * Firestore Security Rules
 *
 * Comprehensive security rules for the Neurafit application
 * These rules ensure data privacy and prevent unauthorized access
 */

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for common validations
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(uid) {
      return request.auth.uid == uid;
    }

    function validateSubscriptionData(subscription) {
      return subscription is map &&
             ('customerId' in subscription ? subscription.customerId is string : true) &&
             ('subscriptionId' in subscription ? subscription.subscriptionId is string : true) &&
             ('priceId' in subscription ? subscription.priceId is string : true) &&
             ('status' in subscription ? subscription.status is string : true) &&
             ('currentPeriodStart' in subscription ? subscription.currentPeriodStart is number : true) &&
             ('currentPeriodEnd' in subscription ? subscription.currentPeriodEnd is number : true) &&
             ('cancelAtPeriodEnd' in subscription ? subscription.cancelAtPeriodEnd is bool : true) &&
             ('canceledAt' in subscription ? subscription.canceledAt is number : true) &&
             ('workoutCount' in subscription ? subscription.workoutCount is number : true) &&
             ('freeWorkoutsUsed' in subscription ? subscription.freeWorkoutsUsed is number : true) &&
             ('freeWorkoutLimit' in subscription ? subscription.freeWorkoutLimit is number : true) &&
             ('createdAt' in subscription ? subscription.createdAt is number : true) &&
             ('updatedAt' in subscription ? subscription.updatedAt is number : true);
    }

    function isBasicUserData() {
      let data = request.resource.data;
      // Allow basic user documents with minimal fields
      // For merge operations, uid might not be in the request data, so check existing resource
      let uidValid = ('uid' in data && data.uid is string && data.uid == request.auth.uid) ||
                     (!('uid' in data) && resource != null && resource.data.uid == request.auth.uid);

      return uidValid &&
             (!('email' in data) || data.email is string) &&
             (!('onboarded' in data) || data.onboarded is bool) &&
             (!('displayName' in data) || data.displayName is string) &&
             (!('photoURL' in data) || data.photoURL is string) &&
             (!('provider' in data) || data.provider is string) &&
             (!('created_at' in data) || data.created_at is timestamp) &&
             (!('updated_at' in data) || data.updated_at is timestamp);
    }

    function isValidUserData() {
      let data = request.resource.data;
      // Full validation for complete user documents
      // For merge operations, uid might not be in the request data, so check existing resource
      let uidValid = ('uid' in data && data.uid is string && data.uid == request.auth.uid) ||
                     (!('uid' in data) && resource != null && resource.data.uid == request.auth.uid);

      return uidValid &&
             (!('email' in data) || data.email is string) &&
             (!('onboarded' in data) || data.onboarded is bool) &&
             (!('displayName' in data) || data.displayName is string) &&
             (!('photoURL' in data) || data.photoURL is string) &&
             (!('provider' in data) || data.provider is string) &&
             // Optional fields validation (if present)
             (!('experience' in data) || (data.experience is string && data.experience in ['Beginner', 'Intermediate', 'Advanced'])) &&
             (!('goals' in data) || data.goals is list) &&
             (!('equipment' in data) || data.equipment is list) &&
             (!('injuries' in data) || data.injuries is list) &&
             (!('sex' in data) || data.sex is string) &&
             (!('age' in data) || data.age is number) &&
             (!('height_ft' in data) || data.height_ft is number) &&
             (!('height_in' in data) || data.height_in is number) &&
             (!('height_total_inches' in data) || data.height_total_inches is number) &&
             (!('weight_lb' in data) || data.weight_lb is number) &&
             (!('injury_details' in data) || data.injury_details is string) &&
             (!('health_consent' in data) || data.health_consent is bool) &&
             (!('created_at' in data) || data.created_at is timestamp) &&
             (!('updated_at' in data) || data.updated_at is timestamp) &&
             // Subscription fields validation
             (!('subscription' in data) || validateSubscriptionData(data.subscription));
    }



    // User profiles - allow users to read and manage their own data
    match /users/{uid} {
      allow read: if isAuthenticated() && isOwner(uid);
      // Allow users to create and update their own documents (permissive for onboarding)
      allow create, update: if isAuthenticated() && isOwner(uid);

      // User subcollections (workouts, etc.) - allow users to manage their own data
      match /{subcollection}/{docId} {
        allow read, write: if isAuthenticated() && isOwner(uid);
      }
    }

    // Workouts - TEMPORARILY COMPLETELY OPEN FOR DEBUGGING
    match /workouts/{docId} {
      allow read, write: if true;
    }

    // Deny all other access
    match /{document=**} {
      allow read, write: if false;
    }
  }
}

========================================
FILE: firestore.indexes.json
========================================

{
  "indexes": [
    {
      "collectionGroup": "workouts",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "userId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "createdAt",
          "order": "DESCENDING"
        }
      ],
      "density": "SPARSE_ALL"
    },
    {
      "collectionGroup": "workouts",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "userId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "date",
          "order": "DESCENDING"
        }
      ],
      "density": "SPARSE_ALL"
    },
    {
      "collectionGroup": "workouts",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "userId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "status",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "createdAt",
          "order": "DESCENDING"
        }
      ],
      "density": "SPARSE_ALL"
    }
  ],
  "fieldOverrides": []
}

========================================
FILE: functions/package.json
========================================

{
  "name": "functions",
  "scripts": {
    "build": "tsc",
    "build:watch": "tsc --watch",
    "lint": "eslint .",
    "serve": "npm run build && firebase emulators:start --only functions",
    "shell": "npm run build && firebase functions:shell",
    "start": "npm run shell",
    "deploy": "firebase deploy --only functions",
    "logs": "firebase functions:log"
  },
  "engines": {
    "node": "22"
  },
  "main": "lib/index.js",
  "dependencies": {
    "firebase-admin": "^12.6.0",
    "firebase-functions": "^6.0.1",
    "openai": "^5.23.0",
    "stripe": "^18.5.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.36.0",
    "@typescript-eslint/eslint-plugin": "^8.45.0",
    "@typescript-eslint/parser": "^8.45.0",
    "eslint": "^9.36.0",
    "firebase-functions-test": "^3.1.0",
    "typescript": "^5.7.3",
    "typescript-eslint": "^8.45.0"
  },
  "private": true
}


========================================
FILE: functions/tsconfig.json
========================================

{
  "compilerOptions": {
    "module": "commonjs",
    "esModuleInterop": true,
    "moduleResolution": "node",
    "noImplicitReturns": true,
    "noUnusedLocals": true,
    "outDir": "lib",
    "sourceMap": true,
    "strict": true,
    "target": "es2017"
  },
  "compileOnSave": true,
  "include": [
    "src"
  ]
}


========================================
FILE: index.html
========================================

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />

    <!-- Favicon and Icons -->
    <link rel="icon" type="image/svg+xml" href="/logo.svg" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="shortcut icon" href="/favicon.ico" />

    <!-- Apple Touch Icons -->
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />

    <!-- Android Chrome Icons -->
    <link rel="icon" type="image/png" sizes="192x192" href="/android-chrome-192x192.png" />
    <link rel="icon" type="image/png" sizes="512x512" href="/android-chrome-512x512.png" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover" />

    <!-- Import Inter font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">

    <!-- Cache busting -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />

    <!-- Mobile app-like experience -->
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="apple-mobile-web-app-title" content="NeuraFit" />

    <!-- Screen orientation lock (portrait preferred) -->
    <meta name="screen-orientation" content="portrait" />
    <meta name="orientation" content="portrait" />

    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.json" />

    <!-- Enhanced SEO and Social Sharing Meta Tags -->
    <title>neurafit</title>
    <meta name="description" content="🏋️ Get AI-powered workout plans in 30 seconds! Personalized for your goals, equipment & fitness level. Join 10,000+ users transforming their fitness with smart training plans. Free trial!" />
    <meta name="keywords" content="AI workout generator, personalized fitness app, custom workout plans, AI fitness trainer, smart exercise planner, adaptive training program, fitness AI, workout builder, personal trainer app, strength training AI, cardio workouts, home gym workouts, fitness goals tracker, exercise routine generator, intelligent fitness coaching" />
    <meta name="author" content="NeuraFit Team" />
    <meta name="robots" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" />

    <!-- Additional SEO Meta Tags -->
    <meta name="application-name" content="NeuraFit" />
    <meta name="apple-mobile-web-app-title" content="NeuraFit - AI Workouts" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="msapplication-tap-highlight" content="no" />
    <meta name="theme-color" content="#1f2937" />

    <!-- Geo and Language Tags -->
    <meta name="geo.region" content="US" />
    <meta name="geo.placename" content="United States" />
    <meta name="language" content="English" />
    <meta name="distribution" content="global" />
    <meta name="rating" content="general" />

    <!-- App Store and Business Info -->
    <meta name="apple-itunes-app" content="app-id=neurafit-app" />
    <meta name="google-play-app" content="app-id=com.neurafit.app" />
    <meta name="msapplication-TileImage" content="/android-chrome-512x512.png" />
    <meta name="msapplication-square150x150logo" content="/android-chrome-192x192.png" />
    <meta name="msapplication-square310x310logo" content="/android-chrome-512x512.png" />

    <!-- Enhanced Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://neurafit-ai-2025.web.app/" />
    <meta property="og:title" content="NeuraFit - #1 AI Workout Generator | Get Fit with Smart Training" />
    <meta property="og:description" content="🏋️ Transform your fitness with AI-powered workout plans! Personalized training in 30 seconds. Join 10,000+ users getting stronger with intelligent fitness coaching. Try free!" />
    <meta property="og:image" content="https://neurafit-ai-2025.web.app/android-chrome-512x512.png" />
    <meta property="og:image:width" content="512" />
    <meta property="og:image:height" content="512" />
    <meta property="og:image:alt" content="NeuraFit AI Workout Generator - Personalized Fitness App" />
    <meta property="og:site_name" content="NeuraFit" />
    <meta property="og:locale" content="en_US" />
    <meta property="og:locale:alternate" content="en_GB" />
    <meta property="og:locale:alternate" content="en_CA" />
    <meta property="og:locale:alternate" content="en_AU" />

    <!-- Additional Open Graph Tags -->
    <meta property="article:author" content="NeuraFit Team" />
    <meta property="article:publisher" content="https://www.facebook.com/neurafit" />
    <meta property="fb:app_id" content="your-facebook-app-id" />

    <!-- Enhanced Twitter Cards -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@neurafit" />
    <meta name="twitter:creator" content="@neurafit" />
    <meta name="twitter:url" content="https://neurafit-ai-2025.web.app/" />
    <meta name="twitter:title" content="NeuraFit - #1 AI Workout Generator | Smart Fitness Training" />
    <meta name="twitter:description" content="🏋️ Get personalized AI workouts in 30 seconds! Smart training plans for your goals & equipment. Join 10,000+ users transforming their fitness. Free trial!" />
    <meta name="twitter:image" content="https://neurafit-ai-2025.web.app/android-chrome-512x512.png" />
    <meta name="twitter:image:alt" content="NeuraFit AI Workout Generator - Personalized Fitness Training App" />
    <meta name="twitter:app:name:iphone" content="NeuraFit" />
    <meta name="twitter:app:id:iphone" content="neurafit-ios-id" />
    <meta name="twitter:app:name:googleplay" content="NeuraFit" />
    <meta name="twitter:app:id:googleplay" content="com.neurafit.app" />

    <!-- Additional Meta Tags -->
    <meta name="theme-color" content="#1f2937" />
    <meta name="msapplication-TileColor" content="#1f2937" />
    <meta name="msapplication-config" content="/browserconfig.xml" />

    <!-- Canonical URL -->
    <link rel="canonical" href="https://neurafit-ai-2025.web.app/" />

    <!-- Structured Data (JSON-LD) for SEO -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "NeuraFit",
      "alternateName": "NeuraFit AI Workout Generator",
      "description": "AI-powered personalized workout generator that creates custom fitness plans tailored to your goals, experience level, and available equipment.",
      "url": "https://neurafit-ai-2025.web.app/",
      "applicationCategory": "HealthApplication",
      "operatingSystem": "Web, iOS, Android",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD",
        "availability": "https://schema.org/InStock"
      },
      "aggregateRating": {
        "@type": "AggregateRating",
        "ratingValue": "4.8",
        "ratingCount": "1247",
        "bestRating": "5",
        "worstRating": "1"
      },
      "author": {
        "@type": "Organization",
        "name": "NeuraFit Team",
        "url": "https://neurafit-ai-2025.web.app/"
      },
      "publisher": {
        "@type": "Organization",
        "name": "NeuraFit",
        "logo": {
          "@type": "ImageObject",
          "url": "https://neurafit-ai-2025.web.app/android-chrome-512x512.png",
          "width": 512,
          "height": 512
        }
      },
      "screenshot": "https://neurafit-ai-2025.web.app/android-chrome-512x512.png",
      "softwareVersion": "1.0.1",
      "datePublished": "2024-01-01",
      "dateModified": "2025-09-30",
      "keywords": "AI workout generator, personalized fitness, custom training plans, smart exercise planner, fitness AI, workout builder",
      "featureList": [
        "AI-powered workout generation",
        "Personalized training plans",
        "Equipment-based customization",
        "Progress tracking",
        "Adaptive difficulty",
        "Goal-oriented training"
      ],
      "applicationSubCategory": "Fitness & Health",
      "downloadUrl": "https://neurafit-ai-2025.web.app/",
      "installUrl": "https://neurafit-ai-2025.web.app/",
      "memoryRequirements": "50MB",
      "storageRequirements": "100MB"
    }
    </script>

    <!-- Organization Schema -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Organization",
      "name": "NeuraFit",
      "alternateName": "NeuraFit AI Fitness",
      "url": "https://neurafit-ai-2025.web.app/",
      "logo": "https://neurafit-ai-2025.web.app/android-chrome-512x512.png",
      "description": "Leading AI-powered fitness platform providing personalized workout plans and intelligent training solutions.",
      "foundingDate": "2024",
      "sameAs": [
        "https://www.facebook.com/neurafit",
        "https://www.twitter.com/neurafit",
        "https://www.instagram.com/neurafit",
        "https://www.linkedin.com/company/neurafit"
      ],
      "contactPoint": {
        "@type": "ContactPoint",
        "contactType": "customer service",
        "email": "support@neurafit.com",
        "availableLanguage": "English"
      }
    }
    </script>

    <!-- FAQ Schema -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "FAQPage",
      "mainEntity": [
        {
          "@type": "Question",
          "name": "How does NeuraFit's AI workout generator work?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "NeuraFit uses advanced AI algorithms to analyze your fitness goals, experience level, available equipment, and any injuries to create personalized workout plans. The AI considers hundreds of variables to generate optimal training routines tailored specifically for you."
          }
        },
        {
          "@type": "Question",
          "name": "Is NeuraFit free to use?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "NeuraFit offers a free tier with limited workout generations per month. For unlimited access to AI-powered workouts and advanced features, we offer affordable premium subscriptions starting at $9.99/month."
          }
        },
        {
          "@type": "Question",
          "name": "What types of workouts can NeuraFit generate?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "NeuraFit can generate various workout types including strength training, cardio, HIIT, bodyweight exercises, home workouts, gym routines, and specialized programs for different fitness goals like weight loss, muscle building, and endurance."
          }
        },
        {
          "@type": "Question",
          "name": "Do I need equipment to use NeuraFit workouts?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "No! NeuraFit can generate effective bodyweight workouts requiring no equipment. However, if you have gym equipment or home fitness gear, the AI will incorporate these tools to create more diverse and challenging routines."
          }
        }
      ]
    }
    </script>

    <style>
      /* Prevent zoom and ensure mobile-first experience */
      * {
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
      }

      /* Allow text selection for inputs and content areas */
      input, textarea, [contenteditable] {
        -webkit-user-select: text;
        -moz-user-select: text;
        -ms-user-select: text;
        user-select: text;
      }

      /* Prevent overscroll bounce on iOS */
      body {
        overscroll-behavior: none;
        -webkit-overflow-scrolling: touch;
        position: fixed;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      #root {
        width: 100%;
        height: 100%;
        overflow-y: auto;
        overflow-x: hidden;
        -webkit-overflow-scrolling: touch;
      }

      /* Landscape warning overlay */
      .landscape-warning::before {
        content: "📱 Please rotate your device to portrait mode for the best experience";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.95);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        z-index: 9999;
        font-size: 18px;
        font-weight: 500;
        padding: 40px 20px;
        line-height: 1.5;
      }
    </style>
  </head>
  <body>
    <div id="root" data-version="1.0.1" data-build-time="2025-09-30T18:13:44.859Z"></div>

    <!-- Firebase is now loaded directly in the main bundle -->

    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
========================================
END OF CODEBASE
========================================

Statistics:
  Total Files: 87
  Total Lines:    18377
  Generated: 2025-10-03 16:33:04
