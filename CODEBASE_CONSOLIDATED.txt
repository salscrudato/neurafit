================================================================================
NEURAFIT CODEBASE CONSOLIDATION
================================================================================
Generated: $(date)
This file contains all frontend and backend source code files with their full paths.

================================================================================
DIRECTORY STRUCTURE
================================================================================

Frontend Source:
src/App.tsx
src/components/AppHeader.tsx
src/components/CacheRecoveryBanner.tsx
src/components/DeferredRender.tsx
src/components/EnhancedRestTimer.tsx
src/components/ErrorBoundary.tsx
src/components/FeatureCard.tsx
src/components/Loading.tsx
src/components/MotivationalBanner.tsx
src/components/OfflineIndicator.tsx
src/components/PhoneAuthModal.tsx
src/components/ProgressiveOverloadTracker.tsx
src/components/RouteErrorBoundary.tsx
src/components/RouteWrapper.tsx
src/components/SkeletonLoader.tsx
src/components/SmartWeightInput.tsx
src/components/WorkoutFlowHeader.tsx
src/components/WorkoutProgress.tsx
src/config/features.ts
src/config/onboarding.ts
src/hooks/useAnalytics.ts
src/hooks/useFocusManagement.ts
src/hooks/useMicroInteractions.tsx
src/hooks/usePrefetch.ts
src/hooks/useRoutePrefetch.tsx
src/hooks/useScrollToTop.ts
src/hooks/useUpdateToast.tsx
src/hooks/useWorkoutPreload.ts
src/index.css
src/lib/__tests__/cache-manager.test.ts
src/lib/__tests__/errors.test.ts
src/lib/__tests__/requestManager.test.ts
src/lib/cache-manager.ts
src/lib/env.ts
src/lib/errorManager.ts
src/lib/errors.ts
src/lib/firebase-analytics.ts
src/lib/firebase.ts
src/lib/guest-session.ts
src/lib/logger.ts
src/lib/optimisticUpdates.ts
src/lib/requestManager.ts
src/lib/security.ts
src/lib/sentry.ts
src/lib/user-utils.ts
src/lib/utils.ts
src/lib/validators.ts
src/lib/weightHistory.ts
src/main.tsx
src/pages/Auth.tsx
src/pages/Dashboard.tsx
src/pages/Generate.tsx
src/pages/History.tsx
src/pages/NotFound.tsx
src/pages/Onboarding.tsx
src/pages/Privacy.tsx
src/pages/Profile.tsx
src/pages/Terms.tsx
src/pages/workout/Complete.tsx
src/pages/workout/Exercise.tsx
src/pages/workout/Preview.tsx
src/pages/workout/Rest.tsx
src/pages/WorkoutDetail.tsx
src/providers/app-provider-utils.ts
src/providers/AppProvider.tsx
src/routes/guards.tsx
src/schemas/index.ts
src/session/types.ts
src/store/index.ts
src/test/example.test.tsx
src/test/setup.ts
src/types/global.d.ts
src/types/profile.ts
src/ui/Button.tsx
src/ui/buttonVariants.ts
src/ui/Card.tsx
src/ui/cardVariants.ts
src/ui/index.ts
src/utils/haptic.ts
src/utils/orientation.ts
src/utils/timestamp.ts
src/vite-env.d.ts

Backend Functions:
functions/src/__tests__/duration.test.ts
functions/src/__tests__/exercise-context-validation.test.ts
functions/src/__tests__/exercise-progression.test.ts
functions/src/__tests__/exercise-similarity.test.ts
functions/src/__tests__/schema-validation.test.ts
functions/src/config.ts
functions/src/index.ts
functions/src/lib/appCheck.ts
functions/src/lib/cache.ts
functions/src/lib/deterministicSeed.ts
functions/src/lib/durationAdjustment.test.ts
functions/src/lib/durationAdjustment.ts
functions/src/lib/exerciseContextValidation.ts
functions/src/lib/exerciseDatabase.test.ts
functions/src/lib/exerciseDatabase.ts
functions/src/lib/exerciseProgression.ts
functions/src/lib/exerciseTaxonomy.ts
functions/src/lib/exerciseValidation.ts
functions/src/lib/idempotency.ts
functions/src/lib/jsonSchema/workoutPlan.schema.ts
functions/src/lib/periodization.ts
functions/src/lib/promptBuilder.enhanced.ts
functions/src/lib/promptBuilder.ts
functions/src/lib/promptEnhancements.ts
functions/src/lib/qualityScoring.ts
functions/src/lib/rateLimiter.ts
functions/src/lib/schemaValidator.ts
functions/src/lib/setPerformance.ts
functions/src/lib/streamingUtils.ts
functions/src/lib/workoutHistoryOptimizer.ts
functions/src/workout/generation.ts

================================================================================
FRONTEND SOURCE CODE
================================================================================


=================================================================================
FILE: src/App.tsx
=================================================================================
// src/App.tsx
import { useEffect, lazy, Suspense } from 'react';
import { Routes, Route, useLocation } from 'react-router-dom';

import ErrorBoundary from './components/ErrorBoundary';
import { RouteErrorBoundary } from './components/RouteErrorBoundary';
import { PublicRoute, AuthRoute, ProfileRoute } from './components/RouteWrapper';
import { UpdateToast } from './hooks/useUpdateToast';
import { CacheRecoveryBanner } from './components/CacheRecoveryBanner';
import { logger } from './lib/logger';
import { OfflineIndicator } from './components/OfflineIndicator';

// Lazy-loaded pages for optimal code splitting
const Auth = lazy(() => import('./pages/Auth'));
const Dashboard = lazy(() => import('./pages/Dashboard'));
const Onboarding = lazy(() => import('./pages/Onboarding'));
const Generate = lazy(() => import('./pages/Generate'));
const Preview = lazy(() => import('./pages/workout/Preview'));
const Exercise = lazy(() => import('./pages/workout/Exercise'));
const Rest = lazy(() => import('./pages/workout/Rest'));
const Complete = lazy(() => import('./pages/workout/Complete'));
const History = lazy(() => import('./pages/History'));
const WorkoutDetail = lazy(() => import('./pages/WorkoutDetail'));
const Profile = lazy(() => import('./pages/Profile'));
const Terms = lazy(() => import('./pages/Terms'));
const Privacy = lazy(() => import('./pages/Privacy'));
const NotFound = lazy(() => import('./pages/NotFound'));

import { AppProvider } from './providers/AppProvider';
import { HomeGate } from './routes/guards';
import { lockOrientation, preventZoom } from './utils/orientation';
import { usePageTracking } from './hooks/useAnalytics';
import { trackSessionStart } from './lib/firebase-analytics';
import { useRoutePrefetch } from './hooks/useRoutePrefetch';
import { useFocusManagement, useSkipLink } from './hooks/useFocusManagement';

/* ---------------------------------- */
/* Fallback shown while routes load   */
/* ---------------------------------- */
function RouteSkeleton() {
  return (
    <div
      role="status"
      aria-busy="true"
      className="flex min-h-[40vh] items-center justify-center p-6"
    >
      <div className="w-full max-w-md animate-pulse space-y-4" aria-hidden="true">
        <div className="h-4 rounded bg-slate-200 dark:bg-slate-700" />
        <div className="h-4 rounded bg-slate-200 dark:bg-slate-700" />
        <div className="h-4 rounded bg-slate-200 dark:bg-slate-700" />
      </div>
      <span className="sr-only">Loading content…</span>
    </div>
  );
}

/* ----------------------------------------------------------- */
/* Idle, network-aware warming of *probable next* route chunks */
/* ----------------------------------------------------------- */
interface NetworkInformationLite {
  saveData?: boolean;
  effectiveType?: string;
  downlink?: number;
}

function useWarmupLazyRoutes() {
  const location = useLocation();

  useEffect(() => {
    // Heuristic: only warm on "fast" conditions and when user isn’t saving data
    const connection = (navigator as Navigator & {
      connection?: NetworkInformationLite;
    }).connection;

    const isFast =
      !connection ||
      (connection.saveData !== true &&
        (((connection.effectiveType ?? '4g') === '4g') ||
          (connection.downlink ?? 0) > 2));

    if (!isFast) return;

    // Decide which groups to warm based on current area of app
    // Keep this list small to avoid defeating code-splitting.
    const common = [
      () => import('./pages/Dashboard'),
      () => import('./pages/Generate'),
      () => import('./pages/History'),
    ];

    const workout = [
      () => import('./pages/workout/Preview'),
      () => import('./pages/workout/Exercise'),
      () => import('./pages/workout/Rest'),
      () => import('./pages/workout/Complete'),
    ];

    const nextLoaders =
      location.pathname.startsWith('/workout') || location.pathname === '/generate'
        ? [...common, ...workout]
        : common;

    let cancelled = false;

    const runSequentially = () =>
      nextLoaders.reduce<Promise<void>>(
        (p, loader) =>
          p.then(async () => {
            if (cancelled) return;
            await loader();
          }),
        Promise.resolve()
      );

    const win = window as Window & {
      requestIdleCallback?: (
        cb: (deadline: { didTimeout: boolean; timeRemaining: () => number }) => void,
        opts?: { timeout?: number }
      ) => number;
      cancelIdleCallback?: (id: number) => void;
    };

    if (typeof win.requestIdleCallback === 'function') {
      const id = win.requestIdleCallback(() => void runSequentially(), { timeout: 2500 });
      return () => {
        cancelled = true;
        if (typeof win.cancelIdleCallback === 'function') win.cancelIdleCallback(id);
      };
    } else {
      const t = window.setTimeout(() => void runSequentially(), 1200);
      return () => {
        cancelled = true;
        clearTimeout(t);
      };
    }
  }, [location.pathname]);
}

function AppContent() {
  // Analytics
  usePageTracking();

  // Route prefetch on user intent (hover/focus/etc.)
  useRoutePrefetch();

  // A11y focus mgmt & skip link
  useFocusManagement();
  useSkipLink();

  // Background warmup of likely routes
  useWarmupLazyRoutes();

  // Handle mobile optimizations and analytics on mount
  useEffect(() => {
    const cleanupOrientation = lockOrientation();
    const cleanupZoom = preventZoom();

    trackSessionStart();

    const handleVersionUpdate = () => {
      logger.info('Version update detected by version manager');
    };

    window.addEventListener('versionUpdate', handleVersionUpdate);

    return () => {
      cleanupOrientation();
      cleanupZoom();
      window.removeEventListener('versionUpdate', handleVersionUpdate);
    };
  }, []);

  return (
    <ErrorBoundary level="critical">
      <div className="min-h-screen-mobile">
        {/* Offline Indicator */}
        <OfflineIndicator />

        {/* Cache Recovery Banner */}
        <CacheRecoveryBanner />

        <main id="main-content" role="main" tabIndex={-1}>
          <Suspense fallback={<RouteSkeleton />}>
            <Routes>
              {/* Public legal pages */}
              <Route
                path="/terms"
                element={
                  <RouteErrorBoundary routeName="Terms">
                    <PublicRoute lazy>
                      <Terms />
                    </PublicRoute>
                  </RouteErrorBoundary>
                }
              />
              <Route
                path="/privacy"
                element={
                  <RouteErrorBoundary routeName="Privacy">
                    <PublicRoute lazy>
                      <Privacy />
                    </PublicRoute>
                  </RouteErrorBoundary>
                }
              />

              {/* Landing route: determines user redirection */}
              <Route
                path="/"
                element={
                  <RouteErrorBoundary routeName="Home">
                    <HomeGate authPage={<Auth />} />
                  </RouteErrorBoundary>
                }
              />

              {/* Onboarding: requires authentication but not a complete profile */}
              <Route
                path="/onboarding"
                element={
                  <RouteErrorBoundary routeName="Onboarding">
                    <AuthRoute lazy>
                      <Onboarding />
                    </AuthRoute>
                  </RouteErrorBoundary>
                }
              />

              {/* Protected routes: require completed profile */}
              <Route
                path="/dashboard"
                element={
                  <RouteErrorBoundary routeName="Dashboard">
                    <ProfileRoute lazy>
                      <Dashboard />
                    </ProfileRoute>
                  </RouteErrorBoundary>
                }
              />
              <Route
                path="/generate"
                element={
                  <RouteErrorBoundary routeName="Generate">
                    <ProfileRoute lazy>
                      <Generate />
                    </ProfileRoute>
                  </RouteErrorBoundary>
                }
              />
              <Route
                path="/workout/preview"
                element={
                  <RouteErrorBoundary routeName="Workout Preview">
                    <ProfileRoute lazy>
                      <Preview />
                    </ProfileRoute>
                  </RouteErrorBoundary>
                }
              />
              <Route
                path="/workout/run"
                element={
                  <RouteErrorBoundary routeName="Workout Exercise">
                    <ProfileRoute lazy>
                      <Exercise />
                    </ProfileRoute>
                  </RouteErrorBoundary>
                }
              />
              <Route
                path="/workout/rest"
                element={
                  <RouteErrorBoundary routeName="Workout Rest">
                    <ProfileRoute lazy>
                      <Rest />
                    </ProfileRoute>
                  </RouteErrorBoundary>
                }
              />
              <Route
                path="/workout/complete"
                element={
                  <RouteErrorBoundary routeName="Workout Complete">
                    <ProfileRoute lazy>
                      <Complete />
                    </ProfileRoute>
                  </RouteErrorBoundary>
                }
              />
              <Route
                path="/history"
                element={
                  <RouteErrorBoundary routeName="History">
                    <ProfileRoute lazy>
                      <History />
                    </ProfileRoute>
                  </RouteErrorBoundary>
                }
              />
              <Route
                path="/workout/:workoutId"
                element={
                  <RouteErrorBoundary routeName="Workout Detail">
                    <ProfileRoute lazy>
                      <WorkoutDetail />
                    </ProfileRoute>
                  </RouteErrorBoundary>
                }
              />
              <Route
                path="/profile"
                element={
                  <RouteErrorBoundary routeName="Profile">
                    <ProfileRoute lazy>
                      <Profile />
                    </ProfileRoute>
                  </RouteErrorBoundary>
                }
              />

              {/* Catch-all 404 page */}
              <Route
                path="*"
                element={
                  <RouteErrorBoundary routeName="Not Found">
                    <PublicRoute lazy>
                      <NotFound />
                    </PublicRoute>
                  </RouteErrorBoundary>
                }
              />
            </Routes>
          </Suspense>
        </main>

        {/* Service Worker Update Toast */}
        <UpdateToast />
      </div>
    </ErrorBoundary>
  );
}

export default function App() {
  return (
    <AppProvider>
      <AppContent />
    </AppProvider>
  );
}
=================================================================================
FILE: src/components/AppHeader.tsx
=================================================================================
// src/components/AppHeader.tsx
import { useState, useMemo, useCallback, memo } from 'react'
import { useNavigate } from 'react-router-dom'
import { signOut } from 'firebase/auth'
import { auth } from '../lib/firebase'
import { Menu, X, Zap, Home, Dumbbell, History, User, LogOut, type LucideIcon } from 'lucide-react'
import { usePrefetchOnIdle, usePrefetchOnHover } from '../hooks/usePrefetch'
import { logger } from '../lib/logger'
import { useAppStore } from '../store'
import { clearGuestSession } from '../lib/guest-session'

// MenuItem component to properly use hooks - memoized to prevent re-renders
const MenuItem = memo(function MenuItem({
  path,
  icon: Icon,
  label,
  onClick
}: {
  path: string
  icon: LucideIcon
  label: string
  onClick: () => void
}) {
  const prefetchProps = usePrefetchOnHover(path)

  return (
    <button
      onClick={onClick}
      {...prefetchProps}
      className="w-full flex items-center gap-3 px-4 py-4 text-left rounded-xl hover:bg-gray-100 transition-colors text-gray-700 hover:text-gray-900 touch-manipulation min-h-[48px]"
      aria-label={`Navigate to ${label}`}
    >
      <Icon className="h-5 w-5" aria-hidden="true" />
      <span className="font-medium">{label}</span>
    </button>
  )
})

export default function AppHeader() {
  const [isMenuOpen, setIsMenuOpen] = useState(false)
  const nav = useNavigate()
  const { isGuest, setIsGuest, setAuthStatus } = useAppStore()

  // Prefetch critical routes on idle
  usePrefetchOnIdle(['/generate', '/history'], 2000)

  // Memoize menu items to prevent recreation on every render
  const menuItems = useMemo(() => [
    { label: 'Dashboard', path: '/dashboard', icon: Home },
    { label: 'Generate Workout', path: '/generate', icon: Dumbbell },
    { label: 'Workout History', path: '/history', icon: History },
    { label: 'Profile', path: '/profile', icon: User },
  ], [])

  // Memoize navigation handler to prevent recreation
  const handleNavigation = useCallback((path: string) => {
    nav(path)
    setIsMenuOpen(false)
  }, [nav])

  // Memoize sign out handler to prevent recreation
  const handleSignOut = useCallback(async () => {
    try {
      // Handle guest logout
      if (isGuest) {
        clearGuestSession()
        setIsGuest(false)
        setAuthStatus('signedOut')
        nav('/')
        setIsMenuOpen(false)
        return
      }

      // Handle authenticated user logout
      await signOut(auth)
      nav('/')
      setIsMenuOpen(false)
    } catch (e) {
      logger.error('Sign out failed', e as Error)
      alert('Sign out failed. Please try again.')
    }
  }, [nav, isGuest, setIsGuest, setAuthStatus])

  return (
    <>
      <header className="sticky top-0 z-50 bg-white/80 backdrop-blur-enhanced border-b border-gray-100" role="banner">
        <div className="mx-auto max-w-6xl px-4 sm:px-6 py-2 flex items-center justify-between">
          {/* Logo */}
          <button
            onClick={() => handleNavigation('/dashboard')}
            className="flex items-center gap-2 hover:opacity-80 transition-opacity min-h-[44px] min-w-[44px]"
            aria-label="NeuraFit - Go to Dashboard"
          >
            <div className="h-6 w-6 rounded-lg bg-gradient-to-tr from-blue-500 to-indigo-600 flex items-center justify-center">
              <Zap className="h-3 w-3 text-white" aria-hidden="true" />
            </div>
            <span className="text-lg font-semibold text-gray-900 tracking-tight">neurafit</span>
          </button>

          {/* Hamburger Menu Button */}
          <button
            onClick={() => setIsMenuOpen(!isMenuOpen)}
            className="p-3 rounded-lg hover:bg-gray-100 transition-colors touch-manipulation min-h-[44px] min-w-[44px] flex items-center justify-center"
            aria-label={isMenuOpen ? 'Close menu' : 'Open menu'}
            aria-expanded={isMenuOpen}
            aria-controls="mobile-menu"
          >
            {isMenuOpen ? (
              <X className="h-5 w-5 text-gray-700" aria-hidden="true" />
            ) : (
              <Menu className="h-5 w-5 text-gray-700" aria-hidden="true" />
            )}
          </button>
        </div>
      </header>

      {/* Mobile Menu Overlay */}
      {isMenuOpen && (
        <>
          {/* Backdrop */}
          <div
            className="fixed inset-0 z-40 bg-black/20 backdrop-blur-sm"
            onClick={() => setIsMenuOpen(false)}
            aria-hidden="true"
          />

          {/* Menu Panel */}
          <nav
            id="mobile-menu"
            className="fixed top-16 right-4 z-50 w-64 max-w-[calc(100vw-2rem)] bg-white/95 backdrop-blur-md rounded-2xl border border-gray-200 shadow-xl"
            role="navigation"
            aria-label="Main navigation"
            style={{
              right: 'max(1rem, env(safe-area-inset-right))',
            }}
          >
            <div className="p-2">
              {menuItems.map((item) => {
                const Icon = item.icon

                return (
                  <MenuItem
                    key={item.path}
                    path={item.path}
                    icon={Icon}
                    label={item.label}
                    onClick={() => handleNavigation(item.path)}
                  />
                )
              })}

              {/* Divider */}
              <div className="my-2 h-px bg-gray-200" role="separator" aria-hidden="true" />

              {/* Sign Out */}
              <button
                onClick={handleSignOut}
                className="w-full flex items-center gap-3 px-4 py-4 text-left rounded-xl hover:bg-red-50 transition-colors text-red-600 hover:text-red-700 touch-manipulation min-h-[48px]"
                aria-label="Sign out of NeuraFit"
              >
                <LogOut className="h-5 w-5" aria-hidden="true" />
                <span className="font-medium">Sign out</span>
              </button>
            </div>
          </nav>
        </>
      )}
    </>
  )
}

=================================================================================
FILE: src/components/CacheRecoveryBanner.tsx
=================================================================================
/**
 * Cache Recovery Banner Component
 * 
 * Displays a non-intrusive banner when cache issues are detected,
 * offering one-click cache clearing and app recovery.
 */

import React, { useState, useEffect } from 'react';
import { AlertCircle, RefreshCw, X } from 'lucide-react';
import { clearAllCaches } from '@/lib/cache-manager';

interface CacheRecoveryBannerProps {
  className?: string;
}

export const CacheRecoveryBanner = React.memo(function CacheRecoveryBanner({
  className = '',
}: CacheRecoveryBannerProps) {
  const [show, setShow] = useState(false);
  const [isClearing, setIsClearing] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    // Check for cache errors via error events
    const handleError = (event: ErrorEvent) => {
      const message = event.message?.toLowerCase() || '';
      
      // Detect common cache-related errors
      if (
        message.includes('cache') ||
        message.includes('storage') ||
        message.includes('quota') ||
        message.includes('network') ||
        event.filename?.includes('sw.js')
      ) {
        setShow(true);
        setError(event.message);
      }
    };

    // Listen for unhandled promise rejections
    const handleUnhandledRejection = (event: PromiseRejectionEvent) => {
      const message = event.reason?.message?.toLowerCase() || '';
      if (
        message.includes('cache') ||
        message.includes('storage') ||
        message.includes('quota')
      ) {
        setShow(true);
        setError(event.reason?.message);
      }
    };

    window.addEventListener('error', handleError);
    window.addEventListener('unhandledrejection', handleUnhandledRejection);

    return () => {
      window.removeEventListener('error', handleError);
      window.removeEventListener('unhandledrejection', handleUnhandledRejection);
    };
  }, []);

  const handleClearCache = async () => {
    setIsClearing(true);
    try {
      await clearAllCaches();
      setShow(false);
      setError(null);
      
      // Reload after a brief delay
      setTimeout(() => {
        window.location.reload();
      }, 500);
    } catch (err) {
      setError(`Failed to clear cache: ${err instanceof Error ? err.message : 'Unknown error'}`);
      setIsClearing(false);
    }
  };

  if (!show) return null;

  return (
    <div
      className={`fixed top-0 left-0 right-0 z-[9998] animate-slide-down ${className}`}
      role="alert"
      aria-live="assertive"
    >
      <div className="bg-amber-50 border-b border-amber-200 shadow-md">
        <div className="max-w-4xl mx-auto px-4 py-3 flex items-start gap-3">
          {/* Icon */}
          <AlertCircle className="w-5 h-5 text-amber-600 flex-shrink-0 mt-0.5" />

          {/* Content */}
          <div className="flex-1 min-w-0">
            <h3 className="text-sm font-semibold text-amber-900 mb-1">
              Cache Issue Detected
            </h3>
            <p className="text-sm text-amber-800 mb-2">
              We detected a potential cache issue. Clearing the cache can help resolve this.
            </p>
            {error && (
              <p className="text-xs text-amber-700 mb-2 font-mono bg-amber-100 px-2 py-1 rounded">
                {error}
              </p>
            )}
          </div>

          {/* Actions */}
          <div className="flex items-center gap-2 flex-shrink-0">
            <button
              onClick={handleClearCache}
              disabled={isClearing}
              className="inline-flex items-center gap-2 px-3 py-1.5 bg-amber-600 hover:bg-amber-700 disabled:bg-amber-400 text-white rounded-lg text-sm font-medium transition-colors"
              aria-label="Clear cache and reload"
            >
              <RefreshCw className={`w-4 h-4 ${isClearing ? 'animate-spin' : ''}`} />
              {isClearing ? 'Clearing...' : 'Clear Cache'}
            </button>
            <button
              onClick={() => setShow(false)}
              disabled={isClearing}
              className="inline-flex items-center justify-center w-8 h-8 text-amber-600 hover:bg-amber-100 rounded-lg transition-colors disabled:opacity-50"
              aria-label="Dismiss"
            >
              <X className="w-4 h-4" />
            </button>
          </div>
        </div>
      </div>
    </div>
  );
});


=================================================================================
FILE: src/components/DeferredRender.tsx
=================================================================================
/**
 * Deferred Render Component
 * 
 * Uses IntersectionObserver to defer rendering of heavy components
 * until they are about to enter the viewport. This improves initial
 * page load performance and reduces layout shift.
 */

import { useState, useEffect, useRef, type ReactNode } from 'react';

interface DeferredRenderProps {
  children: ReactNode;
  /** Placeholder to show while component is not visible */
  placeholder?: ReactNode;
  /** Root margin for IntersectionObserver (default: '200px' to load slightly before visible) */
  rootMargin?: string;
  /** Threshold for IntersectionObserver (default: 0) */
  threshold?: number;
  /** Minimum height for placeholder to prevent layout shift */
  minHeight?: string | number;
  /** Class name for wrapper */
  className?: string;
  /** Whether to unmount when out of view (default: false) */
  unmountOnExit?: boolean;
}

export function DeferredRender({
  children,
  placeholder,
  rootMargin = '200px',
  threshold = 0,
  minHeight,
  className,
  unmountOnExit = false,
}: DeferredRenderProps) {
  const [isVisible, setIsVisible] = useState(false);
  const [hasBeenVisible, setHasBeenVisible] = useState(false);
  const ref = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const element = ref.current;
    if (!element) return;

    // Create IntersectionObserver
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            setIsVisible(true);
            setHasBeenVisible(true);
            
            // If we don't need to unmount on exit, we can disconnect after first intersection
            if (!unmountOnExit) {
              observer.disconnect();
            }
          } else if (unmountOnExit) {
            setIsVisible(false);
          }
        });
      },
      {
        rootMargin,
        threshold,
      }
    );

    observer.observe(element);

    return () => {
      observer.disconnect();
    };
  }, [rootMargin, threshold, unmountOnExit]);

  // Determine what to render
  const shouldRenderChildren = unmountOnExit ? isVisible : hasBeenVisible;

  // Calculate style for wrapper
  const wrapperStyle: { minHeight?: string } = minHeight
    ? { minHeight: typeof minHeight === 'number' ? `${minHeight}px` : minHeight }
    : {};

  return (
    <div ref={ref} className={className} style={wrapperStyle}>
      {shouldRenderChildren ? children : placeholder}
    </div>
  );
}

/**
 * Skeleton placeholder for charts
 */
export function ChartSkeleton({ height = 200 }: { height?: number }) {
  return (
    <div
      className="animate-pulse bg-gradient-to-r from-gray-100 via-gray-200 to-gray-100 rounded-xl"
      style={{ height: `${height}px` }}
    >
      <div className="h-full flex items-center justify-center">
        <div className="text-gray-400 text-sm">Loading chart...</div>
      </div>
    </div>
  );
}

/**
 * Hook for manual IntersectionObserver usage
 */
// eslint-disable-next-line react-refresh/only-export-components
export function useIntersectionObserver(
  options: { rootMargin?: string; threshold?: number } = {}
): [{ current: HTMLDivElement | null }, boolean] {
  const [isIntersecting, setIsIntersecting] = useState(false);
  const ref = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const element = ref.current;
    if (!element) return;

    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          setIsIntersecting(entry.isIntersecting);
        });
      },
      options
    );

    observer.observe(element);

    return () => {
      observer.disconnect();
    };
  }, [options]);

  return [ref, isIntersecting];
}


=================================================================================
FILE: src/components/EnhancedRestTimer.tsx
=================================================================================
// src/components/EnhancedRestTimer.tsx
import { useEffect, useState, useRef } from 'react'
import { Play, Pause, SkipForward, Plus, Minus } from 'lucide-react'
import { CircularProgress, NextExercisePreview } from './WorkoutProgress'

interface EnhancedRestTimerProps {
  initialSeconds: number
  onComplete: () => void
  nextExercise?: {
    name: string
    sets: number
    reps: string | number
    restSeconds?: number
  }
  onTimeChange?: (_seconds: number) => void
}

export function EnhancedRestTimer({
  initialSeconds,
  onComplete,
  nextExercise,
  onTimeChange
}: EnhancedRestTimerProps) {
  const [totalSeconds, setTotalSeconds] = useState(Math.max(1, initialSeconds))
  const [remainingSeconds, setRemainingSeconds] = useState(Math.max(1, initialSeconds))
  const [isPaused, setIsPaused] = useState(false)
  const [isComplete, setIsComplete] = useState(false)
  
  const intervalRef = useRef<number | null>(null)

  // Timer logic
  useEffect(() => {
    if (isPaused || isComplete) return

    if (intervalRef.current !== null) {
      window.clearInterval(intervalRef.current)
    }

    intervalRef.current = window.setInterval(() => {
      setRemainingSeconds(prev => {
        if (prev <= 1) {
          setIsComplete(true)
          return 0
        }
        return prev - 1
      })
    }, 1000)

    return () => {
      if (intervalRef.current !== null) {
        window.clearInterval(intervalRef.current)
      }
    }
  }, [isPaused, isComplete])

  // Handle completion
  useEffect(() => {
    if (isComplete) {
      vibrate(500)
      onComplete()
    }
  }, [isComplete, onComplete])

  // Haptic feedback and document title
  useEffect(() => {
    if (isPaused || isComplete) return

    if (remainingSeconds === 3 || remainingSeconds === 2 || remainingSeconds === 1) {
      vibrate(100)
    }

    // Update document title
    document.title = `Rest: ${remainingSeconds}s - NeuraFit`

    return () => {
      document.title = 'NeuraFit'
    }
  }, [remainingSeconds, isPaused, isComplete])

  // Notify parent of time changes
  useEffect(() => {
    onTimeChange?.(remainingSeconds)
  }, [remainingSeconds, onTimeChange])



  const vibrate = (duration: number) => {
    try {
      if ('vibrate' in navigator && typeof navigator.vibrate === 'function') {
        navigator.vibrate(duration)
      }
    } catch {
      // Silently fail - vibration is enhancement only
      // Some browsers may throw errors even if the API exists
    }
  }

  const adjustTime = (delta: number) => {
    const newTotal = Math.max(1, totalSeconds + delta)
    const newRemaining = Math.max(0, remainingSeconds + delta)
    
    setTotalSeconds(newTotal)
    setRemainingSeconds(newRemaining)
    
    if (newRemaining === 0) {
      setIsComplete(true)
    }
  }

  const togglePause = () => {
    setIsPaused(prev => !prev)
  }

  const skip = () => {
    setRemainingSeconds(0)
    setIsComplete(true)
  }

  const progress = totalSeconds > 0 ? ((totalSeconds - remainingSeconds) / totalSeconds) * 100 : 100
  const minutes = Math.floor(remainingSeconds / 60)
  const seconds = remainingSeconds % 60

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 via-white to-indigo-50 relative">
      {/* Background decoration */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute -top-40 -right-40 w-80 h-80 bg-gradient-to-br from-blue-200/30 to-indigo-200/30 rounded-full blur-3xl" />
        <div className="absolute -bottom-40 -left-40 w-80 h-80 bg-gradient-to-tr from-indigo-200/30 to-blue-200/30 rounded-full blur-3xl" />
      </div>

      <main className="relative mx-auto max-w-4xl px-5 pb-20 pt-6">
        <div className="relative overflow-hidden rounded-3xl border border-gray-200 bg-white/70 backdrop-blur-sm p-6 md:p-8 shadow-lg text-center">
          <div className="absolute -right-16 -top-16 h-56 w-56 rounded-full bg-gradient-to-tr from-blue-400/20 to-indigo-400/20 blur-3xl" />
          
          <h1 className="text-3xl font-bold tracking-tight text-gray-900 mb-2">Rest Time</h1>
          <p className="text-gray-600 text-sm mb-8">
            {isPaused ? 'Timer paused' : isComplete ? 'Rest complete!' : 'Auto-continue when timer ends'}
          </p>

          {/* Main Timer Display */}
          <div className="flex justify-center mb-8">
            <CircularProgress progress={progress} size={200} strokeWidth={12}>
              <div className="text-center">
                <div className="text-4xl font-bold text-gray-900 mb-1">
                  {minutes}:{seconds.toString().padStart(2, '0')}
                </div>
                <div className="text-sm text-gray-600">
                  {isPaused ? 'Paused' : isComplete ? 'Done!' : 'Remaining'}
                </div>
              </div>
            </CircularProgress>
          </div>

          {/* Quick Time Adjustments */}
          <div className="flex items-center justify-center gap-4 mb-8">
            <button
              onClick={() => adjustTime(-15)}
              className="flex items-center gap-2 px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded-xl transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2"
              disabled={isComplete}
              aria-label="Decrease rest time by 15 seconds"
            >
              <Minus className="h-4 w-4" aria-hidden="true" />
              <span className="text-sm font-medium">15s</span>
            </button>

            <button
              onClick={togglePause}
              className={`flex items-center gap-2 px-6 py-3 rounded-xl font-medium transition-all duration-200 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2 ${
                isPaused
                  ? 'bg-green-500 hover:bg-green-600 text-white'
                  : 'bg-yellow-500 hover:bg-yellow-600 text-white'
              }`}
              disabled={isComplete}
              aria-label={isPaused ? 'Resume rest timer' : 'Pause rest timer'}
            >
              {isPaused ? <Play className="h-5 w-5" aria-hidden="true" /> : <Pause className="h-5 w-5" aria-hidden="true" />}
              <span>{isPaused ? 'Resume' : 'Pause'}</span>
            </button>

            <button
              onClick={() => adjustTime(15)}
              className="flex items-center gap-2 px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded-xl transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2"
              disabled={isComplete}
              aria-label="Increase rest time by 15 seconds"
            >
              <Plus className="h-4 w-4" aria-hidden="true" />
              <span className="text-sm font-medium">15s</span>
            </button>
          </div>

          {/* Skip Button */}
          <button
            onClick={skip}
            className="flex items-center gap-2 px-6 py-3 bg-blue-500 hover:bg-blue-600 text-white rounded-xl font-medium transition-colors mx-auto mb-8 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2"
            disabled={isComplete}
            aria-label="Skip rest period and continue to next exercise"
          >
            <SkipForward className="h-5 w-5" aria-hidden="true" />
            <span>Skip Rest</span>
          </button>

          {/* Next Exercise Preview */}
          {nextExercise && (
            <NextExercisePreview 
              nextExercise={nextExercise} 
              timeRemaining={remainingSeconds} 
            />
          )}
        </div>
      </main>
    </div>
  )
}

=================================================================================
FILE: src/components/ErrorBoundary.tsx
=================================================================================
import { Component, type ErrorInfo, type ReactNode } from 'react'
import { AlertTriangle, RefreshCw, Home, Bug } from 'lucide-react'
import { captureException, setContext } from '../lib/sentry'
import { logger } from '../lib/logger'

interface Props {
  children: ReactNode
  fallback?: ReactNode
  onError?: (_error: Error, _errorInfo: ErrorInfo) => void
  level?: 'page' | 'component' | 'critical'
}

interface State {
  hasError: boolean
  error: Error | null
  errorInfo: ErrorInfo | null
  errorId: string | null
}

export class ErrorBoundary extends Component<Props, State> {
  private retryCount = 0
  private readonly maxRetries = 3

  constructor(props: Props) {
    super(props)
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null,
      errorId: null
    }
  }

  static getDerivedStateFromError(error: Error): Partial<State> {
    // Generate unique error ID for tracking
    const errorId = `err_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    
    return {
      hasError: true,
      error,
      errorId
    }
  }

  override componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    const { onError, level = 'component' } = this.props

    // Update state with error info
    this.setState({ errorInfo })

    // Report error to monitoring service
    this.reportError(error, errorInfo, level)

    // Call custom error handler
    onError?.(error, errorInfo)
  }

  private reportError = (error: Error, errorInfo: ErrorInfo, level: string) => {
    // Build error context
    const errorContext = {
      message: error.message,
      stack: error.stack,
      componentStack: errorInfo.componentStack,
      level,
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      url: window.location.href,
      errorId: this.state.errorId
    }

    // Log error with context (automatically sent to Sentry in production)
    logger.error(
      `ErrorBoundary caught ${level} error: ${error.message}`,
      error,
      errorContext
    )

    // Set additional Sentry context
    setContext('errorBoundary', {
      level,
      errorId: this.state.errorId,
      componentStack: errorInfo.componentStack,
    })

    // Ensure error is captured by Sentry
    captureException(error, errorContext)
  }

  private handleRetry = () => {
    if (this.retryCount < this.maxRetries) {
      this.retryCount++
      this.setState({
        hasError: false,
        error: null,
        errorInfo: null,
        errorId: null
      })
    }
  }

  private handleReload = () => {
    window.location.reload()
  }

  private handleGoHome = () => {
    window.location.href = '/dashboard'
  }

  private renderErrorUI() {
    const { level = 'component' } = this.props
    const { error, errorId } = this.state
    const canRetry = this.retryCount < this.maxRetries

    // Critical errors get full-page treatment
    if (level === 'critical') {
      return (
        <div className="min-h-screen bg-gradient-to-br from-red-50 via-white to-orange-50 flex items-center justify-center p-4">
          <div className="max-w-md w-full bg-white rounded-2xl shadow-xl border border-red-100 p-8 text-center">
            <div className="w-16 h-16 bg-red-100 rounded-full flex items-center justify-center mx-auto mb-6">
              <AlertTriangle className="w-8 h-8 text-red-600" />
            </div>
            
            <h1 className="text-2xl font-bold text-gray-900 mb-2">
              Something went wrong
            </h1>
            
            <p className="text-gray-600 mb-6">
              We encountered a critical error. Please try refreshing the page or contact support if the problem persists.
            </p>
            
            <div className="space-y-3">
              <button
                onClick={this.handleReload}
                className="w-full flex items-center justify-center gap-2 px-4 py-3 bg-gradient-to-r from-blue-500 to-indigo-600 text-white rounded-xl font-medium hover:from-blue-600 hover:to-indigo-700 transition-all duration-200"
              >
                <RefreshCw className="w-4 h-4" />
                Refresh Page
              </button>
              
              <button
                onClick={this.handleGoHome}
                className="w-full flex items-center justify-center gap-2 px-4 py-3 bg-gray-100 text-gray-700 rounded-xl font-medium hover:bg-gray-200 transition-all duration-200"
              >
                <Home className="w-4 h-4" />
                Go to Dashboard
              </button>
            </div>
            
            {errorId && (
              <div className="mt-6 p-3 bg-gray-50 rounded-lg">
                <p className="text-xs text-gray-500">
                  Error ID: <code className="font-mono">{errorId}</code>
                </p>
              </div>
            )}
          </div>
        </div>
      )
    }

    // Component-level errors get inline treatment
    return (
      <div className="bg-red-50 border border-red-200 rounded-xl p-6 m-4">
        <div className="flex items-start gap-3">
          <div className="flex-shrink-0">
            <Bug className="w-5 h-5 text-red-600 mt-0.5" />
          </div>
          
          <div className="flex-1 min-w-0">
            <h3 className="text-sm font-medium text-red-800 mb-1">
              Component Error
            </h3>
            
            <p className="text-sm text-red-700 mb-3">
              {error?.message || 'An unexpected error occurred in this component.'}
            </p>
            
            <div className="flex gap-2">
              {canRetry && (
                <button
                  onClick={this.handleRetry}
                  className="inline-flex items-center gap-1 px-3 py-1.5 text-xs font-medium bg-red-100 text-red-700 rounded-lg hover:bg-red-200 transition-colors"
                >
                  <RefreshCw className="w-3 h-3" />
                  Retry ({this.maxRetries - this.retryCount} left)
                </button>
              )}
              
              <button
                onClick={this.handleReload}
                className="inline-flex items-center gap-1 px-3 py-1.5 text-xs font-medium bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 transition-colors"
              >
                <RefreshCw className="w-3 h-3" />
                Refresh Page
              </button>
            </div>
            
            {errorId && (
              <p className="text-xs text-red-600 mt-2 font-mono">
                ID: {errorId}
              </p>
            )}
          </div>
        </div>
      </div>
    )
  }

  override render() {
    if (this.state.hasError) {
      // Use custom fallback if provided
      if (this.props.fallback) {
        return this.props.fallback
      }
      
      return this.renderErrorUI()
    }

    return this.props.children
  }
}

export default ErrorBoundary

=================================================================================
FILE: src/components/FeatureCard.tsx
=================================================================================
import type { ReactElement } from 'react'

interface FeatureCardProps {
  icon: ReactElement
  title: string
  desc: string
  bgGradient: string
  iconBg: string
  accentColor: 'blue' | 'emerald' | 'orange'
}

const accentColorMap = {
  blue: {
    border: 'border-blue-100/60',
    glow: 'group-hover:shadow-blue-500/15',
    text: 'text-blue-600',
    shimmer: 'from-blue-500/5 via-indigo-500/5 to-purple-500/5'
  },
  emerald: {
    border: 'border-emerald-100/60',
    glow: 'group-hover:shadow-emerald-500/15',
    text: 'text-emerald-600',
    shimmer: 'from-emerald-500/5 via-teal-500/5 to-cyan-500/5'
  },
  orange: {
    border: 'border-orange-100/60',
    glow: 'group-hover:shadow-orange-500/15',
    text: 'text-orange-600',
    shimmer: 'from-orange-500/5 via-amber-500/5 to-yellow-500/5'
  }
} as const

/**
 * Premium Feature Card Component
 * Displays a feature with icon, title, and description
 * Includes hover effects and smooth animations
 */
export default function FeatureCard({
  icon,
  title,
  desc,
  bgGradient,
  iconBg,
  accentColor,
}: FeatureCardProps) {
  const colors = accentColorMap[accentColor]

  return (
    <div className={`group relative p-5 xs:p-6 sm:p-7 rounded-[20px] xs:rounded-[22px] sm:rounded-[24px] border ${colors.border} bg-white/70 backdrop-blur-xl hover:bg-white hover:shadow-2xl ${colors.glow} transition-all duration-700 hover:scale-[1.01] overflow-hidden shadow-lg shadow-gray-200/50`}>
      {/* Animated shimmer background */}
      <div className={`absolute inset-0 bg-gradient-to-r ${colors.shimmer} opacity-0 group-hover:opacity-100 transition-opacity duration-700`} />

      {/* Subtle gradient overlay on hover */}
      <div className={`absolute inset-0 bg-gradient-to-br ${bgGradient} opacity-30 group-hover:opacity-0 transition-opacity duration-700`} />

      <div className="relative z-10 flex items-start gap-4 xs:gap-4.5 sm:gap-5">
        {/* Premium Icon Container */}
        <div className="relative flex-shrink-0">
          <div className={`w-14 xs:w-15 sm:w-16 h-14 xs:h-15 sm:h-16 bg-gradient-to-br ${iconBg} rounded-[16px] xs:rounded-[18px] sm:rounded-[20px] flex items-center justify-center shadow-xl group-hover:scale-110 group-hover:rotate-6 transition-all duration-700`}>
            <div className="text-white">
              {icon}
            </div>
          </div>
          {/* Icon glow effect */}
          <div className={`absolute inset-0 bg-gradient-to-br ${iconBg} rounded-[16px] xs:rounded-[18px] sm:rounded-[20px] blur-xl opacity-0 group-hover:opacity-40 transition-opacity duration-700`} />
        </div>

        {/* Content */}
        <div className="flex-1 text-left pt-0.5 xs:pt-0.5 sm:pt-1">
          <h3 className="text-lg xs:text-lg sm:text-xl font-bold text-gray-900 mb-1.5 xs:mb-2 sm:mb-2.5 group-hover:text-gray-800 transition-colors duration-500 tracking-tight">
            {title}
          </h3>
          <p className="text-gray-600 text-sm xs:text-sm sm:text-[15px] leading-relaxed group-hover:text-gray-700 transition-colors duration-500 font-normal">
            {desc}
          </p>
        </div>

        {/* Subtle arrow indicator */}
        <div className={`flex-shrink-0 w-5 xs:w-5.5 sm:w-6 h-5 xs:h-5.5 sm:h-6 ${colors.text} opacity-0 group-hover:opacity-60 transition-all duration-500 group-hover:translate-x-1 mt-0.5 xs:mt-0.5 sm:mt-1`}>
          <svg className="w-full h-full" fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={2.5} aria-hidden="true">
            <path strokeLinecap="round" strokeLinejoin="round" d="M9 5l7 7-7 7" />
          </svg>
        </div>
      </div>
    </div>
  )
}


=================================================================================
FILE: src/components/Loading.tsx
=================================================================================
/**
 * Simplified Loading Components
 */

import React, { memo } from 'react'
import { Loader2, Brain } from 'lucide-react'

// Simple loading spinner
interface LoadingSpinnerProps {
  size?: 'sm' | 'md' | 'lg'
  text?: string
  fullScreen?: boolean
  className?: string
}

export const LoadingSpinner = memo(({
  size = 'md',
  text,
  fullScreen = false,
  className = ''
}: LoadingSpinnerProps) => {
  const sizeClasses = {
    sm: 'h-4 w-4',
    md: 'h-6 w-6',
    lg: 'h-8 w-8'
  }

  const spinner = (
    <div className={`flex flex-col items-center justify-center gap-3 ${className}`}>
      <Loader2
        className={`${sizeClasses[size]} animate-spin text-blue-600`}
        aria-hidden="true"
      />
      {text && (
        <p className="text-gray-600 font-medium">
          {text}
        </p>
      )}
    </div>
  )

  if (fullScreen) {
    return (
      <div
        className="fixed inset-0 bg-white/80 backdrop-blur-sm flex items-center justify-center z-50"
        role="status"
        aria-live="polite"
        aria-busy="true"
      >
        {spinner}
        <span className="sr-only">{text || 'Loading, please wait...'}</span>
      </div>
    )
  }

  return (
    <div role="status" aria-live="polite" aria-busy="true">
      {spinner}
      <span className="sr-only">{text || 'Loading...'}</span>
    </div>
  )
})

LoadingSpinner.displayName = 'LoadingSpinner'

// Simple skeleton component
export function SkeletonBase({
  className = '',
  variant = 'default'
}: {
  className?: string;
  variant?: 'default' | 'text' | 'circular' | 'rectangular';
}) {
  const variantClasses = {
    default: 'rounded',
    text: 'rounded-sm',
    circular: 'rounded-full',
    rectangular: 'rounded-lg'
  }

  return (
    <div
      className={`animate-pulse bg-gray-200 ${variantClasses[variant]} ${className}`}
      role="status"
      aria-label="Loading content"
    >
      <span className="sr-only">Loading...</span>
    </div>
  )
}

// Enhanced workout generation loading component
interface ProgressiveLoadingBarProps {
  isVisible: boolean
  onComplete?: () => void
  text?: string
}

export function ProgressiveLoadingBar({
  isVisible,
  onComplete: _onComplete,
  text = 'Generating your workout...'
}: ProgressiveLoadingBarProps) {
  if (!isVisible) return null

  return <EnhancedWorkoutLoader text={text} />
}

// Enhanced workout generation loader with AI-themed animations
interface EnhancedWorkoutLoaderProps {
  text?: string
}

export function EnhancedWorkoutLoader({
  text: _text = 'Generating your personalized workout...'
}: EnhancedWorkoutLoaderProps) {
  const [currentMessage, setCurrentMessage] = React.useState(0)

  const messages = React.useMemo(() => [
    'Analyzing your fitness profile...',
    'Selecting optimal exercises...',
    'Calculating perfect intensity...',
    'Personalizing your workout...',
    'Finalizing your training plan...'
  ], [])

  // Cycle through messages every 3.5 seconds to match ~17.5s average API response time
  // This ensures the animation completes one full cycle (5 messages × 3.5s = 17.5s)
  React.useEffect(() => {
    if (import.meta.env.MODE === 'development') {
      console.log('[LOADING] Animation started at:', new Date().toISOString())
    }

    const interval = setInterval(() => {
      setCurrentMessage((prev) => {
        const next = (prev + 1) % messages.length
        if (import.meta.env.MODE === 'development') {
          console.log(`[LOADING] Message ${next + 1}/${messages.length}: ${messages[next]}`)
        }
        return next
      })
    }, 3500)

    return () => {
      clearInterval(interval)
      if (import.meta.env.MODE === 'development') {
        console.log('[LOADING] Animation ended at:', new Date().toISOString())
      }
    }
  }, [messages])
  return (
    <div className="fixed inset-0 bg-gradient-to-br from-black/60 via-black/50 to-black/60 backdrop-blur-md flex items-center justify-center z-50 p-4">
      {/* Background animated elements */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute top-1/4 left-1/4 w-32 h-32 bg-gradient-to-r from-blue-400/20 to-indigo-400/20 rounded-full blur-xl animate-pulse" />
        <div className="absolute bottom-1/4 right-1/4 w-24 h-24 bg-gradient-to-r from-purple-400/20 to-pink-400/20 rounded-full blur-xl animate-pulse delay-1000" />
        <div className="absolute top-1/2 right-1/3 w-16 h-16 bg-gradient-to-r from-emerald-400/20 to-teal-400/20 rounded-full blur-xl animate-pulse delay-500" />
      </div>

      {/* Main loading card */}
      <div className="relative bg-gradient-to-br from-white/95 via-white/90 to-white/95 backdrop-blur-xl rounded-3xl p-8 sm:p-10 max-w-md w-full shadow-2xl shadow-black/20 border border-white/20 animate-breathe">
        {/* Animated border glow */}
        <div className="absolute inset-0 rounded-3xl bg-gradient-to-r from-blue-500/20 via-indigo-500/20 to-purple-500/20 blur-sm animate-pulse" />

        <div className="relative text-center space-y-6">
          {/* AI Brain Icon with pulsing animation */}
          <div className="relative mx-auto w-20 h-20 mb-6">
            <div className="absolute inset-0 bg-gradient-to-r from-blue-500 via-indigo-600 to-purple-600 rounded-2xl animate-pulse shadow-lg shadow-blue-500/30" />
            <div className="relative w-full h-full bg-gradient-to-br from-blue-500 via-indigo-600 to-purple-600 rounded-2xl flex items-center justify-center shadow-xl">
              <Brain className="w-10 h-10 text-white animate-pulse" />
            </div>
            {/* Orbiting dots */}
            <div className="absolute -inset-4">
              <div className="absolute top-0 left-1/2 w-2 h-2 bg-blue-400 rounded-full animate-spin origin-bottom transform -translate-x-1/2" style={{ animationDuration: '3s' }} />
              <div className="absolute bottom-0 left-1/2 w-2 h-2 bg-indigo-400 rounded-full animate-spin origin-top transform -translate-x-1/2" style={{ animationDuration: '3s', animationDelay: '1s' }} />
              <div className="absolute left-0 top-1/2 w-2 h-2 bg-purple-400 rounded-full animate-spin origin-right transform -translate-y-1/2" style={{ animationDuration: '3s', animationDelay: '2s' }} />
            </div>
          </div>

          {/* Enhanced loading text */}
          <div className="space-y-3">
            <h3 className="text-xl sm:text-2xl font-bold bg-gradient-to-r from-gray-900 via-gray-800 to-gray-900 bg-clip-text text-transparent leading-tight">
              AI is crafting your workout
            </h3>
            <div className="h-12 flex items-center justify-center">
              <p className="text-gray-600 font-medium text-sm sm:text-base leading-relaxed transition-all duration-500 ease-in-out">
                {messages[currentMessage]}
              </p>
            </div>
          </div>

          {/* Futuristic Loading Spinner */}
          <div className="flex justify-center items-center py-6">
            <div className="relative w-24 h-24">
              {/* Outer rotating ring */}
              <div className="absolute inset-0 rounded-full border-4 border-transparent border-t-blue-500 border-r-indigo-500 animate-spin" style={{ animationDuration: '1.5s' }} />

              {/* Middle rotating ring - opposite direction */}
              <div className="absolute inset-2 rounded-full border-4 border-transparent border-b-purple-500 border-l-pink-500 animate-spin" style={{ animationDuration: '2s', animationDirection: 'reverse' }} />

              {/* Inner pulsing core */}
              <div className="absolute inset-6 rounded-full bg-gradient-to-br from-blue-400 via-indigo-500 to-purple-600 animate-pulse shadow-lg shadow-blue-500/50" />

              {/* Center dot */}
              <div className="absolute inset-0 flex items-center justify-center">
                <div className="w-3 h-3 rounded-full bg-white shadow-lg animate-pulse" />
              </div>

              {/* Orbiting particles */}
              <div className="absolute inset-0">
                <div className="absolute top-0 left-1/2 w-2 h-2 bg-blue-400 rounded-full -translate-x-1/2 animate-ping" style={{ animationDuration: '2s' }} />
                <div className="absolute bottom-0 left-1/2 w-2 h-2 bg-indigo-400 rounded-full -translate-x-1/2 animate-ping" style={{ animationDuration: '2s', animationDelay: '0.5s' }} />
                <div className="absolute left-0 top-1/2 w-2 h-2 bg-purple-400 rounded-full -translate-y-1/2 animate-ping" style={{ animationDuration: '2s', animationDelay: '1s' }} />
                <div className="absolute right-0 top-1/2 w-2 h-2 bg-pink-400 rounded-full -translate-y-1/2 animate-ping" style={{ animationDuration: '2s', animationDelay: '1.5s' }} />
              </div>
            </div>
          </div>

          {/* Step indicator dots */}
          <div className="flex justify-center items-center space-x-2">
            {messages.map((_, index) => (
              <div
                key={index}
                className={`transition-all duration-500 rounded-full ${
                  index === currentMessage
                    ? 'w-8 h-2 bg-gradient-to-r from-blue-500 via-indigo-600 to-purple-600 shadow-md shadow-blue-500/30'
                    : index < currentMessage
                    ? 'w-2 h-2 bg-gradient-to-r from-blue-400 to-indigo-500'
                    : 'w-2 h-2 bg-gray-300'
                }`}
              />
            ))}
          </div>

          {/* Motivational message */}
          <div className="pt-2">
            <p className="text-xs text-gray-500 font-medium italic">
              Creating the perfect workout just for you...
            </p>
          </div>
        </div>
      </div>
    </div>
  )
}

// Simple skeleton loaders for common use cases
export function WorkoutHistorySkeleton() {
  return (
    <div className="space-y-4">
      {[...Array(3)].map((_, i) => (
        <div key={i} className="bg-white rounded-xl p-6 border border-gray-100">
          <div className="flex items-center justify-between mb-4">
            <SkeletonBase className="h-6 w-32" variant="text" />
            <SkeletonBase className="h-4 w-20" variant="text" />
          </div>
          <div className="space-y-2">
            <SkeletonBase className="h-4 w-full" variant="text" />
            <SkeletonBase className="h-4 w-3/4" variant="text" />
          </div>
        </div>
      ))}
    </div>
  )
}

export function WorkoutDetailSkeleton() {
  return (
    <div className="space-y-6">
      <SkeletonBase className="h-8 w-48" variant="text" />
      <div className="space-y-4">
        {[...Array(4)].map((_, i) => (
          <div key={i} className="border rounded-lg p-4">
            <SkeletonBase className="h-6 w-40 mb-2" variant="text" />
            <SkeletonBase className="h-4 w-24" variant="text" />
          </div>
        ))}
      </div>
    </div>
  )
}

// Profile form skeleton
export function ProfileFormSkeleton() {
  return (
    <div className="space-y-6">
      {[...Array(3)].map((_, i) => (
        <div key={i} className="bg-white rounded-xl p-6 border border-gray-200">
          <SkeletonBase className="h-6 w-40 mb-4" variant="text" />
          <div className="space-y-3">
            <SkeletonBase className="h-10 w-full rounded-lg" />
            <SkeletonBase className="h-10 w-full rounded-lg" />
          </div>
        </div>
      ))}
      <div className="flex gap-3">
        <SkeletonBase className="h-12 w-32 rounded-lg" />
        <SkeletonBase className="h-12 w-32 rounded-lg" />
      </div>
    </div>
  )
}

// Weight history skeleton
export function WeightHistorySkeleton() {
  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between mb-4">
        <SkeletonBase className="h-6 w-40" variant="text" />
        <SkeletonBase className="h-8 w-24 rounded-lg" />
      </div>
      <div className="space-y-3">
        {[...Array(5)].map((_, i) => (
          <div key={i} className="flex items-center justify-between p-4 bg-gray-50 rounded-lg">
            <div className="flex items-center gap-3">
              <SkeletonBase className="h-10 w-10 rounded-full" />
              <div className="space-y-2">
                <SkeletonBase className="h-4 w-32" variant="text" />
                <SkeletonBase className="h-3 w-24" variant="text" />
              </div>
            </div>
            <SkeletonBase className="h-6 w-16" variant="text" />
          </div>
        ))}
      </div>
    </div>
  )
}

// Inline loading button
interface LoadingButtonProps {
  loading?: boolean
  children: React.ReactNode
  className?: string
  disabled?: boolean
  onClick?: () => void
  type?: 'button' | 'submit' | 'reset'
}

export function LoadingButton({
  loading = false,
  children,
  className = '',
  disabled = false,
  onClick,
  type = 'button'
}: LoadingButtonProps) {
  return (
    <button
      type={type}
      onClick={onClick}
      disabled={disabled || loading}
      className={`relative ${className} ${(disabled || loading) ? 'opacity-50 cursor-not-allowed' : ''}`}
    >
      {loading && (
        <span className="absolute inset-0 flex items-center justify-center">
          <Loader2 className="h-4 w-4 animate-spin" />
        </span>
      )}
      <span className={loading ? 'invisible' : ''}>{children}</span>
    </button>
  )
}

// Default export for backward compatibility
export default LoadingSpinner

=================================================================================
FILE: src/components/MotivationalBanner.tsx
=================================================================================
// src/components/MotivationalBanner.tsx
import { memo, useMemo } from 'react'
import { Trophy, Target, Zap, TrendingUp, Award } from 'lucide-react'

interface MotivationalBannerProps {
  totalWorkouts: number
  weeklyWorkouts: number
  streak: number
  consistencyScore: number
}

export const MotivationalBanner = memo(function MotivationalBanner({
  totalWorkouts,
  weeklyWorkouts,
  streak,
  consistencyScore
}: MotivationalBannerProps) {
  // Memoize the motivational message calculation
  const motivation = useMemo(() => {
    const getMotivationalMessage = () => {
    if (streak >= 7) {
      return {
        icon: Trophy,
        title: `${streak} Day Streak! 🔥`,
        message: "You're on fire! This consistency is building incredible momentum.",
        color: "from-orange-500 to-red-500",
        bgColor: "from-orange-50 to-red-50"
      }
    }

    if (weeklyWorkouts >= 4) {
      return {
        icon: Award,
        title: "Crushing Your Goals!",
        message: `${weeklyWorkouts} workouts this week - you're exceeding expectations!`,
        color: "from-green-500 to-emerald-600",
        bgColor: "from-green-50 to-emerald-50"
      }
    }

    if (consistencyScore >= 80) {
      return {
        icon: Target,
        title: "Consistency Champion",
        message: `${Math.round(consistencyScore)}% consistency rate - you're building lasting habits!`,
        color: "from-purple-500 to-violet-600",
        bgColor: "from-purple-50 to-violet-50"
      }
    }

    if (totalWorkouts >= 10) {
      return {
        icon: TrendingUp,
        title: "Building Momentum",
        message: `${totalWorkouts} workouts completed - you're making real progress!`,
        color: "from-blue-500 to-cyan-600",
        bgColor: "from-blue-50 to-cyan-50"
      }
    }

    return {
      icon: Zap,
      title: "Keep Going Strong!",
      message: "Every workout brings you closer to your goals. You've got this!",
      color: "from-indigo-500 to-blue-600",
      bgColor: "from-indigo-50 to-blue-50"
    }
  }

    return getMotivationalMessage()
  }, [totalWorkouts, weeklyWorkouts, streak, consistencyScore])

  const Icon = motivation.icon

  return (
    <div className={`group relative overflow-hidden rounded-2xl bg-gradient-to-br ${motivation.bgColor} border border-white/80 shadow-lg hover:shadow-xl transition-all duration-500 hover:scale-[1.002] hover:-translate-y-1`}>
      <div className="absolute inset-0 bg-gradient-to-br from-white/50 via-white/30 to-transparent" />
      <div className="absolute -right-20 -top-20 h-40 w-40 rounded-full bg-white/30 blur-3xl group-hover:blur-2xl group-hover:scale-110 transition-all duration-700" />
      <div className="absolute -left-16 -bottom-16 h-32 w-32 rounded-full bg-white/20 blur-2xl group-hover:blur-3xl transition-all duration-700" />
      <div className="absolute inset-0 rounded-2xl ring-1 ring-inset ring-white/60 pointer-events-none" />
      <div className="relative p-4 sm:p-5">
        <div className="flex flex-col sm:flex-row sm:items-center gap-4 sm:gap-5">
          <div className={`w-14 h-14 sm:w-16 sm:h-16 rounded-xl bg-gradient-to-br ${motivation.color} flex items-center justify-center shadow-lg shadow-current/40 group-hover:shadow-xl group-hover:shadow-current/50 group-hover:scale-110 group-hover:rotate-3 transition-all duration-500 ring-2 ring-white/50`}>
            <Icon className="h-7 w-7 sm:h-8 sm:w-8 text-white drop-shadow-sm" />
          </div>
          <div className="flex-1 space-y-1">
            <h3 className="text-lg sm:text-xl font-bold text-slate-900 group-hover:text-slate-800 transition-colors duration-300 leading-tight tracking-tight drop-shadow-sm">
              {motivation.title}
            </h3>
            <p className="text-slate-700 text-sm sm:text-base leading-snug font-medium max-w-2xl">
              {motivation.message}
            </p>
          </div>
        </div>
      </div>
    </div>
  )
})

interface WeeklyGoalProgressProps {
  currentWorkouts: number
  goalWorkouts?: number
}

export const WeeklyGoalProgress = memo(function WeeklyGoalProgress({ currentWorkouts, goalWorkouts = 3 }: WeeklyGoalProgressProps) {
  const progress = Math.min((currentWorkouts / goalWorkouts) * 100, 100)
  const isComplete = currentWorkouts >= goalWorkouts

  return (
    <div className="bg-white/80 backdrop-blur-sm rounded-xl p-4 border border-slate-200/50 shadow-sm">
      <div className="flex items-center justify-between mb-3">
        <div>
          <h4 className="font-semibold text-slate-900">Weekly Goal</h4>
          <p className="text-sm text-slate-600">{currentWorkouts} of {goalWorkouts} workouts</p>
        </div>
        <div className={`text-2xl font-bold ${isComplete ? 'text-emerald-600' : 'text-slate-700'}`}>
          {Math.round(progress)}%
        </div>
      </div>

      <div className="w-full bg-slate-200 rounded-full h-2 mb-2">
        <div
          className={`h-2 rounded-full transition-all duration-500 ease-out ${
            isComplete
              ? 'bg-gradient-to-r from-emerald-500 to-emerald-600'
              : 'bg-gradient-to-r from-slate-500 to-slate-600'
          }`}
          style={{ width: `${progress}%` }}
        />
      </div>

      {isComplete && (
        <div className="flex items-center gap-1 text-emerald-600 text-sm font-medium">
          <Trophy className="h-4 w-4" />
          Goal achieved!
        </div>
      )}
    </div>
  )
})

interface NextWorkoutSuggestionProps {
  lastWorkoutType?: string
  daysSinceLastWorkout?: number
}

export const NextWorkoutSuggestion = memo(function NextWorkoutSuggestion({ daysSinceLastWorkout = 0 }: NextWorkoutSuggestionProps) {
  const suggestion = useMemo(() => {
    const getSuggestion = () => {
    if (daysSinceLastWorkout === 0) {
      return {
        title: "Great job today!",
        suggestion: "Take some time to recover, then come back stronger tomorrow.",
        urgency: "low"
      }
    }
    
    if (daysSinceLastWorkout === 1) {
      return {
        title: "Ready for another session?",
        suggestion: "Perfect timing for your next workout. Your muscles are recovered and ready!",
        urgency: "medium"
      }
    }
    
    if (daysSinceLastWorkout >= 3) {
      return {
        title: "Time to get back in there!",
        suggestion: "It's been a few days - your body is ready for some action!",
        urgency: "high"
      }
    }
    
    return {
      title: "Keep the momentum going",
      suggestion: "You're in a great rhythm. Ready for your next challenge?",
      urgency: "medium"
    }
  }

    return getSuggestion()
  }, [daysSinceLastWorkout])

  const urgencyColors = {
    low: "from-gray-500 to-gray-600",
    medium: "from-blue-500 to-indigo-600", 
    high: "from-orange-500 to-red-500"
  }

  return (
    <div className="bg-white/70 backdrop-blur-sm rounded-xl p-4 border border-gray-100/50 shadow-sm">
      <div className="flex items-center gap-3">
        <div className={`w-10 h-10 rounded-lg bg-gradient-to-r ${urgencyColors[suggestion.urgency as keyof typeof urgencyColors]} flex items-center justify-center`}>
          <Zap className="h-5 w-5 text-white" />
        </div>
        <div className="flex-1">
          <h4 className="font-semibold text-gray-900 text-sm">{suggestion.title}</h4>
          <p className="text-xs text-gray-600 mt-1">{suggestion.suggestion}</p>
        </div>
      </div>
    </div>
  )
})

=================================================================================
FILE: src/components/OfflineIndicator.tsx
=================================================================================
/**
 * Offline Indicator Component
 * 
 * Shows a banner when the user is offline and provides
 * helpful information about offline functionality
 */

import React, { useState, useEffect } from 'react'
import { WifiOff, RefreshCw } from 'lucide-react'

interface OfflineIndicatorProps {
  className?: string
}

export const OfflineIndicator = React.memo(function OfflineIndicator({
  className = ''
}: OfflineIndicatorProps) {
  const [isOnline, setIsOnline] = useState(navigator.onLine)
  const [showReconnected, setShowReconnected] = useState(false)

  useEffect(() => {
    const handleOnline = () => {
      setIsOnline(true)
      setShowReconnected(true)
      
      // Hide reconnected message after 3 seconds
      setTimeout(() => {
        setShowReconnected(false)
      }, 3000)
    }

    const handleOffline = () => {
      setIsOnline(false)
      setShowReconnected(false)
    }

    window.addEventListener('online', handleOnline)
    window.addEventListener('offline', handleOffline)

    return () => {
      window.removeEventListener('online', handleOnline)
      window.removeEventListener('offline', handleOffline)
    }
  }, [])

  // Don't render anything if online and not showing reconnected message
  if (isOnline && !showReconnected) {
    return null
  }

  return (
    <div
      className={`fixed top-0 left-0 right-0 z-50 ${className}`}
      role="alert"
      aria-live="assertive"
    >
      {!isOnline ? (
        <div className="bg-orange-500 text-white px-4 py-3 shadow-lg">
          <div className="max-w-4xl mx-auto flex items-center justify-between gap-3">
            <div className="flex items-center gap-3">
              <WifiOff className="w-5 h-5 flex-shrink-0" />
              <div>
                <p className="font-medium text-sm">You're offline</p>
                <p className="text-xs opacity-90">
                  Some features may be limited. Check your connection.
                </p>
              </div>
            </div>
            <button
              onClick={() => window.location.reload()}
              className="flex items-center gap-2 px-3 py-1.5 bg-white/20 hover:bg-white/30 rounded-lg text-sm font-medium transition-colors"
              aria-label="Retry connection"
            >
              <RefreshCw className="w-4 h-4" />
              Retry
            </button>
          </div>
        </div>
      ) : (
        <div className="bg-green-500 text-white px-4 py-3 shadow-lg animate-slide-down">
          <div className="max-w-4xl mx-auto flex items-center gap-3">
            <div className="w-5 h-5 flex-shrink-0 flex items-center justify-center">
              <div className="w-2 h-2 bg-white rounded-full animate-pulse" />
            </div>
            <p className="font-medium text-sm">Back online!</p>
          </div>
        </div>
      )}
    </div>
  )
})

/**
 * Offline Error Message Component
 * 
 * Shows a friendly error message when an action fails due to being offline
 */
interface OfflineErrorMessageProps {
  action?: string
  onRetry?: () => void
  className?: string
}

export const OfflineErrorMessage = React.memo(function OfflineErrorMessage({
  action = 'complete this action',
  onRetry,
  className = ''
}: OfflineErrorMessageProps) {
  return (
    <div
      className={`bg-orange-50 border border-orange-200 rounded-lg p-4 ${className}`}
      role="alert"
    >
      <div className="flex items-start gap-3">
        <WifiOff className="w-5 h-5 text-orange-600 flex-shrink-0 mt-0.5" />
        <div className="flex-1">
          <h3 className="font-medium text-orange-900 text-sm mb-1">
            No internet connection
          </h3>
          <p className="text-orange-700 text-sm mb-3">
            You need to be online to {action}. Please check your connection and try again.
          </p>
          {onRetry && (
            <button
              onClick={onRetry}
              className="flex items-center gap-2 px-3 py-1.5 bg-orange-600 hover:bg-orange-700 text-white rounded-lg text-sm font-medium transition-colors"
            >
              <RefreshCw className="w-4 h-4" />
              Try Again
            </button>
          )}
        </div>
      </div>
    </div>
  )
})




=================================================================================
FILE: src/components/PhoneAuthModal.tsx
=================================================================================
import React, { useState, useEffect, useRef } from 'react'
import { X, Phone, Shield, RefreshCw } from 'lucide-react'

interface PhoneAuthModalProps {
  isOpen: boolean
  onClose: () => void
  onSubmitPhone: (phoneNumber: string) => Promise<void>
  onSubmitCode: (code: string) => Promise<void>
  step: 'phone' | 'code'
  loading: boolean
  error: string
  phoneNumber: string
}

export default function PhoneAuthModal({
  isOpen,
  onClose,
  onSubmitPhone,
  onSubmitCode,
  step,
  loading,
  error,
  phoneNumber,
}: PhoneAuthModalProps) {
  const [localPhoneNumber, setLocalPhoneNumber] = useState('')
  const [verificationCode, setVerificationCode] = useState('')
  const [resendCooldown, setResendCooldown] = useState(0)

  // Refs for auto-focus
  const phoneInputRef = useRef<HTMLInputElement>(null)
  const codeInputRef = useRef<HTMLInputElement>(null)

  // Auto-focus on input when modal opens or step changes
  useEffect(() => {
    if (!isOpen) return

    const timer = setTimeout(() => {
      if (step === 'phone' && phoneInputRef.current) {
        phoneInputRef.current.focus()
      } else if (step === 'code' && codeInputRef.current) {
        codeInputRef.current.focus()
      }
    }, 100)

    return () => clearTimeout(timer)
  }, [isOpen, step])

  // Handle Escape key to close modal
  useEffect(() => {
    if (!isOpen) return

    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        onClose()
      }
    }

    document.addEventListener('keydown', handleEscape)
    return () => document.removeEventListener('keydown', handleEscape)
  }, [isOpen, onClose])

  // Resend cooldown timer
  useEffect(() => {
    if (resendCooldown <= 0) return

    const timer = setInterval(() => {
      setResendCooldown(prev => Math.max(0, prev - 1))
    }, 1000)

    return () => clearInterval(timer)
  }, [resendCooldown])

  // Reset state when modal closes
  useEffect(() => {
    if (!isOpen) {
      setLocalPhoneNumber('')
      setVerificationCode('')
      setResendCooldown(0)
    }
  }, [isOpen])

  if (!isOpen) return null

  const handlePhoneSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    await onSubmitPhone(localPhoneNumber)
    // Start 60-second cooldown for resend
    setResendCooldown(60)
  }

  const handleCodeSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    await onSubmitCode(verificationCode)
  }

  const handleResendCode = async () => {
    if (resendCooldown > 0 || loading) return

    setVerificationCode('') // Clear existing code
    await onSubmitPhone(localPhoneNumber)
    setResendCooldown(60) // Start new cooldown
  }

  const handleBackToPhone = () => {
    setVerificationCode('')
    setResendCooldown(0)
    onClose()
  }

  const formatPhoneNumber = (value: string) => {
    // Remove all non-numeric characters
    const cleaned = value.replace(/\D/g, '')

    // Format as (XXX) XXX-XXXX (without +1 prefix for display)
    if (cleaned.length === 0) return ''
    if (cleaned.length <= 3) return `(${cleaned}`
    if (cleaned.length <= 6) return `(${cleaned.slice(0, 3)}) ${cleaned.slice(3)}`
    return `(${cleaned.slice(0, 3)}) ${cleaned.slice(3, 6)}-${cleaned.slice(6, 10)}`
  }

  const handlePhoneChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const formatted = formatPhoneNumber(e.target.value)
    setLocalPhoneNumber(formatted)
  }

  const handleCodeChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const code = e.target.value.replace(/\D/g, '').slice(0, 6)
    setVerificationCode(code)

    // Auto-submit when 6 digits are entered
    if (code.length === 6 && !loading) {
      // Small delay to show the last digit before submitting
      setTimeout(() => {
        if (code.length === 6) { // Double-check in case user deleted
          onSubmitCode(code)
        }
      }, 300)
    }
  }

  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center p-3 xs:p-4 sm:p-4 animate-fade-in"
      role="dialog"
      aria-modal="true"
      aria-labelledby="phone-auth-title"
    >
      {/* Backdrop */}
      <div
        className="absolute inset-0 bg-black/50 backdrop-blur-sm transition-opacity duration-300"
        onClick={onClose}
        aria-hidden="true"
      />

      {/* Modal */}
      <div className="relative bg-white rounded-2xl xs:rounded-2.5xl sm:rounded-3xl shadow-2xl max-w-md w-full p-6 xs:p-7 sm:p-8 animate-scale-in-smooth max-h-[90vh] overflow-y-auto" role="document">
        {/* Close button */}
        <button
          onClick={onClose}
          className="absolute top-3 xs:top-4 right-3 xs:right-4 text-gray-400 hover:text-gray-600 transition-colors p-1.5 xs:p-2 hover:bg-gray-100 rounded-full"
          aria-label="Close modal"
          type="button"
        >
          <X className="h-5 xs:h-5 w-5 xs:w-5" />
        </button>

        {/* Header */}
        <div className="text-center mb-6 xs:mb-7 sm:mb-8">
          <div className="inline-flex items-center justify-center w-14 xs:w-15 sm:w-16 h-14 xs:h-15 sm:h-16 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-xl xs:rounded-2xl sm:rounded-2xl mb-3 xs:mb-4 shadow-lg transition-transform duration-300 hover:scale-105">
            {step === 'phone' ? (
              <Phone className="h-7 xs:h-7.5 sm:h-8 w-7 xs:w-7.5 sm:w-8 text-white" aria-hidden="true" />
            ) : (
              <Shield className="h-7 xs:h-7.5 sm:h-8 w-7 xs:w-7.5 sm:w-8 text-white" aria-hidden="true" />
            )}
          </div>
          <h2 id="phone-auth-title" className="text-xl xs:text-xl sm:text-2xl font-bold text-gray-900 mb-1.5 xs:mb-2">
            {step === 'phone' ? 'Sign in with Phone' : 'Enter Verification Code'}
          </h2>
          <p className="text-gray-600 text-sm xs:text-sm sm:text-base">
            {step === 'phone'
              ? 'Enter your phone number to receive a verification code'
              : `We sent a code to ${phoneNumber}`
            }
          </p>
        </div>

        {/* Error message */}
        {error && (
          <div className="mb-5 xs:mb-6 sm:mb-6 p-3 xs:p-4 bg-red-50 border border-red-200 rounded-lg xs:rounded-xl animate-shake" role="alert" aria-live="polite">
            <div className="flex items-start gap-2.5">
              <div className="flex-shrink-0 mt-0.5">
                <svg className="h-4 xs:h-5 w-4 xs:w-5 text-red-600" fill="currentColor" viewBox="0 0 20 20" aria-hidden="true">
                  <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
                </svg>
              </div>
              <p className="text-xs xs:text-sm text-red-600 font-medium flex-1">{error}</p>
            </div>
          </div>
        )}

        {/* Phone number step */}
        {step === 'phone' && (
          <form onSubmit={handlePhoneSubmit} className="space-y-5 xs:space-y-6 sm:space-y-6">
            <div className="group">
              <label htmlFor="phone" className="block text-xs xs:text-sm font-medium text-gray-700 mb-1.5 xs:mb-2">
                Phone Number
              </label>
              <div className="relative">
                <Phone className="absolute left-3 xs:left-4 top-1/2 transform -translate-y-1/2 h-4.5 xs:h-5 w-4.5 xs:w-5 text-gray-400 group-focus-within:text-blue-500 transition-colors duration-300 flex-shrink-0" aria-hidden="true" />
                <input
                  ref={phoneInputRef}
                  id="phone"
                  type="tel"
                  value={localPhoneNumber}
                  onChange={handlePhoneChange}
                  placeholder="(555) 123-4567"
                  className="w-full pl-10 xs:pl-12 pr-3 xs:pr-4 py-3 xs:py-4 rounded-lg xs:rounded-xl sm:rounded-2xl border border-gray-200/80 bg-white/80 backdrop-blur-sm hover:bg-white hover:border-gray-300 hover:shadow-md font-medium placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500/20 focus:border-blue-500 transition-all duration-300 touch-manipulation min-h-[48px] text-base"
                  disabled={loading}
                  required
                  autoComplete="tel"
                  inputMode="tel"
                  aria-label="Phone number"
                  aria-describedby="phone-hint"
                />
                <div className="absolute inset-0 rounded-lg xs:rounded-xl sm:rounded-2xl bg-gradient-to-r from-blue-500/10 to-indigo-500/10 opacity-0 group-focus-within:opacity-100 transition-opacity duration-300 pointer-events-none" />
              </div>
              <p id="phone-hint" className="mt-1.5 xs:mt-2 text-[10px] xs:text-xs text-gray-500">
                US numbers only. Standard messaging rates may apply.
              </p>
            </div>

            <button
              type="submit"
              disabled={loading || !localPhoneNumber}
              className="relative w-full bg-gradient-to-r from-blue-600 via-indigo-600 to-purple-600 text-white px-4 xs:px-6 py-3 xs:py-4 rounded-lg xs:rounded-xl sm:rounded-2xl font-semibold hover:from-blue-700 hover:via-indigo-700 hover:to-purple-700 hover:shadow-xl hover:shadow-blue-500/25 transition-all duration-500 disabled:opacity-60 disabled:cursor-not-allowed disabled:hover:scale-100 hover:scale-[1.02] active:scale-[0.98] shadow-lg overflow-hidden group touch-manipulation min-h-[48px]"
              aria-label="Send verification code"
            >
              <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-500 animate-shimmer-slow" />
              <span className="relative z-10 flex items-center justify-center gap-2 text-sm xs:text-base">
                {loading && (
                  <div className="animate-spin rounded-full h-4 xs:h-4 w-4 xs:w-4 border-2 border-white border-t-transparent flex-shrink-0" role="status" aria-label="Loading" />
                )}
                {loading ? 'Sending code...' : 'Send Verification Code'}
              </span>
            </button>
          </form>
        )}

        {/* Verification code step */}
        {step === 'code' && (
          <form onSubmit={handleCodeSubmit} className="space-y-5 xs:space-y-6 sm:space-y-6">
            <div className="group">
              <label htmlFor="code" className="block text-xs xs:text-sm font-medium text-gray-700 mb-1.5 xs:mb-2">
                Verification Code
              </label>
              <div className="relative">
                <Shield className="absolute left-3 xs:left-4 top-1/2 transform -translate-y-1/2 h-4.5 xs:h-5 w-4.5 xs:w-5 text-gray-400 group-focus-within:text-blue-500 transition-colors duration-300 flex-shrink-0" aria-hidden="true" />
                <input
                  ref={codeInputRef}
                  id="code"
                  type="text"
                  value={verificationCode}
                  onChange={handleCodeChange}
                  placeholder="123456"
                  className="w-full pl-10 xs:pl-12 pr-3 xs:pr-4 py-3 xs:py-4 rounded-lg xs:rounded-xl sm:rounded-2xl border border-gray-200/80 bg-white/80 backdrop-blur-sm hover:bg-white hover:border-gray-300 hover:shadow-md font-medium placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500/20 focus:border-blue-500 transition-all duration-300 touch-manipulation min-h-[48px] text-base xs:text-lg sm:text-xl text-center tracking-widest"
                  disabled={loading}
                  required
                  autoComplete="one-time-code"
                  inputMode="numeric"
                  pattern="[0-9]*"
                  maxLength={6}
                  aria-label="Verification code"
                  aria-describedby="code-hint"
                />
                <div className="absolute inset-0 rounded-lg xs:rounded-xl sm:rounded-2xl bg-gradient-to-r from-blue-500/10 to-indigo-500/10 opacity-0 group-focus-within:opacity-100 transition-opacity duration-300 pointer-events-none" />
              </div>
              <p id="code-hint" className="mt-1.5 xs:mt-2 text-[10px] xs:text-xs text-gray-500 text-center">
                Enter the 6-digit code sent to your phone
              </p>
            </div>

            <button
              type="submit"
              disabled={loading || verificationCode.length !== 6}
              className="relative w-full bg-gradient-to-r from-blue-600 via-indigo-600 to-purple-600 text-white px-4 xs:px-6 py-3 xs:py-4 rounded-lg xs:rounded-xl sm:rounded-2xl font-semibold hover:from-blue-700 hover:via-indigo-700 hover:to-purple-700 hover:shadow-xl hover:shadow-blue-500/25 transition-all duration-500 disabled:opacity-60 disabled:cursor-not-allowed disabled:hover:scale-100 hover:scale-[1.02] active:scale-[0.98] shadow-lg overflow-hidden group touch-manipulation min-h-[48px]"
              aria-label="Verify code and sign in"
            >
              <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-500 animate-shimmer-slow" />
              <span className="relative z-10 flex items-center justify-center gap-2 text-sm xs:text-base">
                {loading && (
                  <div className="animate-spin rounded-full h-4 xs:h-4 w-4 xs:w-4 border-2 border-white border-t-transparent flex-shrink-0" role="status" aria-label="Loading" />
                )}
                {loading ? 'Verifying...' : 'Verify & Sign In'}
              </span>
            </button>

            {/* Resend code button */}
            <div className="flex items-center justify-center gap-2">
              <button
                type="button"
                onClick={handleResendCode}
                disabled={resendCooldown > 0 || loading}
                className="text-xs xs:text-sm text-gray-600 hover:text-blue-600 font-medium transition-all duration-200 hover:bg-blue-50 px-3 xs:px-4 py-1.5 xs:py-2 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-1.5 xs:gap-2"
                aria-label={resendCooldown > 0 ? `Resend code in ${resendCooldown} seconds` : 'Resend verification code'}
              >
                <RefreshCw className={`h-3.5 xs:h-4 w-3.5 xs:w-4 flex-shrink-0 ${loading ? 'animate-spin' : ''}`} />
                {resendCooldown > 0 ? `Resend (${resendCooldown}s)` : 'Resend code'}
              </button>
            </div>

            <button
              type="button"
              onClick={handleBackToPhone}
              className="w-full text-xs xs:text-sm text-gray-600 hover:text-blue-600 font-medium transition-all duration-200 hover:bg-blue-50 px-3 py-2 rounded-lg"
              aria-label="Use a different phone number"
            >
              Use a different phone number
            </button>
          </form>
        )}
      </div>
    </div>
  )
}


=================================================================================
FILE: src/components/ProgressiveOverloadTracker.tsx
=================================================================================
// src/components/ProgressiveOverloadTracker.tsx
import React, { useMemo } from 'react'
import { TrendingUp, Target, Award, Calendar } from 'lucide-react'

interface WorkoutSession {
  date: string
  exercises: {
    name: string
    sets: { weight: number | null; reps: number; completed: boolean }[]
  }[]
}

interface ProgressiveOverloadTrackerProps {
  exerciseName: string
  recentSessions: WorkoutSession[]
  currentWeight?: number | null
  targetReps?: number | string
}

interface ProgressMetrics {
  volumeProgression: number[]
  maxWeightProgression: number[]
  averageWeightProgression: number[]
  totalVolumeChange: number
  maxWeightChange: number
  consistencyScore: number
  recommendations: string[]
}

export const ProgressiveOverloadTracker = React.memo(function ProgressiveOverloadTracker({
  exerciseName,
  recentSessions,
  currentWeight,
  targetReps: _targetReps
}: ProgressiveOverloadTrackerProps) {
  const metrics = useMemo((): ProgressMetrics => {
    const exerciseData = recentSessions
      .map(session => ({
        date: session.date,
        exercise: session.exercises.find(ex => ex.name === exerciseName)
      }))
      .filter(data => data.exercise)
      .slice(-8) // Last 8 sessions

    if (exerciseData.length === 0) {
      return {
        volumeProgression: [],
        maxWeightProgression: [],
        averageWeightProgression: [],
        totalVolumeChange: 0,
        maxWeightChange: 0,
        consistencyScore: 0,
        recommendations: ['Complete more workouts to see progression analysis']
      }
    }

    // Calculate progressions
    const volumeProgression: number[] = []
    const maxWeightProgression: number[] = []
    const averageWeightProgression: number[] = []

    exerciseData.forEach(({ exercise }) => {
      if (!exercise) return

      const completedSets = exercise.sets.filter(set => set.completed && set.weight && set.weight > 0)
      
      if (completedSets.length === 0) {
        volumeProgression.push(0)
        maxWeightProgression.push(0)
        averageWeightProgression.push(0)
        return
      }

      // Volume = weight × reps × sets
      const totalVolume = completedSets.reduce((sum, set) => {
        return sum + (set.weight! * set.reps)
      }, 0)
      
      const maxWeight = Math.max(...completedSets.map(set => set.weight!))
      const avgWeight = completedSets.reduce((sum, set) => sum + set.weight!, 0) / completedSets.length

      volumeProgression.push(totalVolume)
      maxWeightProgression.push(maxWeight)
      averageWeightProgression.push(avgWeight)
    })

    // Calculate changes
    const totalVolumeChange = volumeProgression.length >= 2 && volumeProgression[0] !== undefined && volumeProgression[volumeProgression.length - 1] !== undefined
      ? ((volumeProgression[volumeProgression.length - 1]! - volumeProgression[0]!) / volumeProgression[0]!) * 100
      : 0

    const maxWeightChange = maxWeightProgression.length >= 2 && maxWeightProgression[0] !== undefined && maxWeightProgression[maxWeightProgression.length - 1] !== undefined
      ? ((maxWeightProgression[maxWeightProgression.length - 1]! - maxWeightProgression[0]!) / maxWeightProgression[0]!) * 100
      : 0

    // Consistency score (percentage of sessions where exercise was performed)
    const consistencyScore = (exerciseData.length / recentSessions.length) * 100

    // Generate recommendations
    const recommendations: string[] = []
    
    if (maxWeightChange > 10) {
      recommendations.push('Great strength gains! Consider focusing on volume next.')
    } else if (maxWeightChange < -5) {
      recommendations.push('Weight has decreased. Focus on recovery and form.')
    } else if (Math.abs(maxWeightChange) < 2) {
      recommendations.push('Try increasing weight by 2.5-5 lbs next session.')
    }

    if (totalVolumeChange > 15) {
      recommendations.push('Excellent volume progression! You\'re getting stronger.')
    } else if (totalVolumeChange < -10) {
      recommendations.push('Volume has decreased. Consider reducing weight to maintain reps.')
    }

    if (consistencyScore < 70) {
      recommendations.push('Try to perform this exercise more consistently for better results.')
    }

    if (currentWeight && maxWeightProgression.length > 0) {
      const lastMaxWeight = maxWeightProgression[maxWeightProgression.length - 1]
      if (lastMaxWeight && currentWeight > lastMaxWeight) {
        recommendations.push('New personal record! Great job pushing your limits.')
      }
    }

    if (recommendations.length === 0) {
      recommendations.push('Keep up the consistent training!')
    }

    return {
      volumeProgression,
      maxWeightProgression,
      averageWeightProgression,
      totalVolumeChange,
      maxWeightChange,
      consistencyScore,
      recommendations
    }
  }, [exerciseName, recentSessions, currentWeight])

  if (metrics.volumeProgression.length === 0) {
    return (
      <div className="rounded-2xl border border-gray-200 bg-white/70 backdrop-blur-sm p-4">
        <div className="flex items-center gap-2 mb-3">
          <TrendingUp className="h-4 w-4 text-gray-600" />
          <span className="font-medium text-gray-900">Progressive Overload</span>
        </div>
        <p className="text-sm text-gray-600">Complete more sessions to see your progression!</p>
      </div>
    )
  }

  return (
    <div className="rounded-2xl border border-gray-200 bg-white/70 backdrop-blur-sm p-4">
      <div className="flex items-center gap-2 mb-4">
        <TrendingUp className="h-4 w-4 text-blue-600" />
        <span className="font-medium text-gray-900">Progressive Overload</span>
      </div>

      {/* Key Metrics */}
      <div className="grid grid-cols-3 gap-4 mb-4">
        <div className="text-center p-3 bg-gradient-to-br from-blue-50 to-indigo-50 rounded-xl">
          <div className={`text-lg font-bold ${
            metrics.maxWeightChange > 0 ? 'text-green-600' : 
            metrics.maxWeightChange < 0 ? 'text-red-600' : 'text-gray-600'
          }`}>
            {metrics.maxWeightChange > 0 ? '+' : ''}{metrics.maxWeightChange.toFixed(1)}%
          </div>
          <div className="text-xs text-gray-600">Max Weight</div>
        </div>

        <div className="text-center p-3 bg-gradient-to-br from-green-50 to-emerald-50 rounded-xl">
          <div className={`text-lg font-bold ${
            metrics.totalVolumeChange > 0 ? 'text-green-600' : 
            metrics.totalVolumeChange < 0 ? 'text-red-600' : 'text-gray-600'
          }`}>
            {metrics.totalVolumeChange > 0 ? '+' : ''}{metrics.totalVolumeChange.toFixed(1)}%
          </div>
          <div className="text-xs text-gray-600">Total Volume</div>
        </div>

        <div className="text-center p-3 bg-gradient-to-br from-purple-50 to-pink-50 rounded-xl">
          <div className="text-lg font-bold text-purple-600">
            {metrics.consistencyScore.toFixed(0)}%
          </div>
          <div className="text-xs text-gray-600">Consistency</div>
        </div>
      </div>

      {/* Mini Progress Chart */}
      <div className="mb-4">
        <div className="text-sm font-medium text-gray-900 mb-2">Weight Progression</div>
        <div className="flex items-end gap-1 h-16 bg-gray-50 rounded-lg p-2">
          {metrics.maxWeightProgression.map((weight, index) => {
            const maxWeight = Math.max(...metrics.maxWeightProgression)
            const height = maxWeight > 0 ? (weight / maxWeight) * 100 : 0
            const isLatest = index === metrics.maxWeightProgression.length - 1
            
            return (
              <div
                key={index}
                className="flex-1 flex flex-col items-center"
              >
                <div
                  className={`w-full rounded-t transition-all duration-300 ${
                    isLatest 
                      ? 'bg-gradient-to-t from-blue-500 to-blue-400' 
                      : 'bg-gradient-to-t from-gray-300 to-gray-200'
                  }`}
                  style={{ height: `${height}%`, minHeight: '4px' }}
                />
                <div className="text-xs text-gray-500 mt-1">
                  {weight > 0 ? weight.toFixed(0) : '-'}
                </div>
              </div>
            )
          })}
        </div>
      </div>

      {/* Personal Records */}
      {metrics.maxWeightProgression.length > 0 && (
        <div className="mb-4">
          <div className="flex items-center gap-2 mb-2">
            <Award className="h-4 w-4 text-yellow-600" />
            <span className="text-sm font-medium text-gray-900">Personal Record</span>
          </div>
          <div className="p-3 bg-gradient-to-r from-yellow-50 to-orange-50 rounded-lg border border-yellow-200">
            <div className="text-lg font-bold text-yellow-700">
              {Math.max(...metrics.maxWeightProgression)} lbs
            </div>
            <div className="text-xs text-yellow-600">
              Your heaviest lift for this exercise
            </div>
          </div>
        </div>
      )}

      {/* Recommendations */}
      <div>
        <div className="flex items-center gap-2 mb-2">
          <Target className="h-4 w-4 text-green-600" />
          <span className="text-sm font-medium text-gray-900">Recommendations</span>
        </div>
        <div className="space-y-2">
          {metrics.recommendations.map((rec, index) => (
            <div key={index} className="p-2 bg-green-50 rounded-lg border border-green-200">
              <div className="text-sm text-green-700">{rec}</div>
            </div>
          ))}
        </div>
      </div>

      {/* Next Session Target */}
      {currentWeight && (
        <div className="mt-4 pt-4 border-t border-gray-200">
          <div className="flex items-center gap-2 mb-2">
            <Calendar className="h-4 w-4 text-blue-600" />
            <span className="text-sm font-medium text-gray-900">Next Session Target</span>
          </div>
          <div className="p-3 bg-blue-50 rounded-lg border border-blue-200">
            <div className="text-lg font-bold text-blue-700">
              {currentWeight + 2.5} lbs
            </div>
            <div className="text-xs text-blue-600">
              Progressive overload suggestion (+2.5 lbs)
            </div>
          </div>
        </div>
      )}
    </div>
  )
}, (prevProps, nextProps) => {
  // Custom comparison for optimal re-render prevention
  return (
    prevProps.exerciseName === nextProps.exerciseName &&
    prevProps.currentWeight === nextProps.currentWeight &&
    prevProps.targetReps === nextProps.targetReps &&
    prevProps.recentSessions.length === nextProps.recentSessions.length &&
    // Compare first and last session dates as a quick check
    prevProps.recentSessions[0]?.date === nextProps.recentSessions[0]?.date &&
    prevProps.recentSessions[prevProps.recentSessions.length - 1]?.date ===
      nextProps.recentSessions[nextProps.recentSessions.length - 1]?.date
  )
})

=================================================================================
FILE: src/components/RouteErrorBoundary.tsx
=================================================================================
import React, { Component, type ReactNode } from 'react'
import { AlertTriangle, RefreshCw, Home } from 'lucide-react'
import { logger } from '../lib/logger'

interface Props {
  children: ReactNode
  routeName?: string
  fallback?: ReactNode
}

interface State {
  hasError: boolean
  error: Error | null
  errorInfo: React.ErrorInfo | null
}

/**
 * Route-level error boundary for graceful error handling
 * Prevents entire app crashes by isolating errors to specific routes
 */
export class RouteErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props)
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null,
    }
  }

  static getDerivedStateFromError(error: Error): Partial<State> {
    return {
      hasError: true,
      error,
    }
  }

  override componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    const routeName = this.props.routeName || 'Unknown Route'

    // Log error with context
    logger.error(`Route Error: ${routeName}`, error, {
      componentStack: errorInfo.componentStack,
      routeName,
    })

    this.setState({
      error,
      errorInfo,
    })
  }

  handleReset = () => {
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null,
    })
  }

  handleGoHome = () => {
    window.location.href = '/'
  }

  override render() {
    if (this.state.hasError) {
      // Use custom fallback if provided
      if (this.props.fallback) {
        return this.props.fallback
      }

      // Default error UI
      return (
        <div className="min-h-screen bg-gradient-to-br from-gray-50 to-gray-100 flex items-center justify-center p-4">
          <div className="max-w-md w-full bg-white rounded-2xl shadow-xl p-8">
            <div className="flex flex-col items-center text-center">
              {/* Error Icon */}
              <div className="w-16 h-16 bg-red-100 rounded-full flex items-center justify-center mb-4">
                <AlertTriangle className="w-8 h-8 text-red-600" />
              </div>

              {/* Error Title */}
              <h1 className="text-2xl font-bold text-gray-900 mb-2">
                Something went wrong
              </h1>

              {/* Error Description */}
              <p className="text-gray-600 mb-6">
                {this.props.routeName 
                  ? `We encountered an error on the ${this.props.routeName} page.`
                  : 'We encountered an unexpected error.'
                }
              </p>

              {/* Error Details (Development Only) */}
              {import.meta.env.MODE === 'development' && this.state.error && (
                <div className="w-full mb-6 p-4 bg-gray-50 rounded-lg text-left">
                  <p className="text-xs font-mono text-gray-700 break-all">
                    {this.state.error.toString()}
                  </p>
                </div>
              )}

              {/* Action Buttons */}
              <div className="flex flex-col sm:flex-row gap-3 w-full">
                <button
                  onClick={this.handleReset}
                  className="flex-1 flex items-center justify-center gap-2 px-4 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
                >
                  <RefreshCw className="w-4 h-4" />
                  Try Again
                </button>
                <button
                  onClick={this.handleGoHome}
                  className="flex-1 flex items-center justify-center gap-2 px-4 py-3 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 transition-colors focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2"
                >
                  <Home className="w-4 h-4" />
                  Go Home
                </button>
              </div>

              {/* Help Text */}
              <p className="text-sm text-gray-500 mt-6">
                If this problem persists, please contact support.
              </p>
            </div>
          </div>
        </div>
      )
    }

    return this.props.children
  }
}

/**
 * Higher-order component to wrap routes with error boundary
 */
export function withRouteErrorBoundary<P extends object>(
  Component: React.ComponentType<P>,
  routeName?: string
) {
  return function WithErrorBoundary(props: P) {
    return (
      <RouteErrorBoundary routeName={routeName}>
        <Component {...props} />
      </RouteErrorBoundary>
    )
  }
}


=================================================================================
FILE: src/components/RouteWrapper.tsx
=================================================================================
// src/components/RouteWrapper.tsx

/**
 * Route Wrapper Components
 * Simplifies route definitions by providing reusable wrappers
 *
 * Enhancements:
 * - ErrorBoundary now wraps Suspense to catch lazy import errors.
 * - Boundary resets on navigation via location.key (avoids "stuck" error UI).
 * - Optional `fallback` prop to override the loading UI when `lazy` is true.
 * - Guard order preserved: Profile guard implies Auth guard.
 */

import { Suspense, type ReactNode } from 'react';
import { useLocation } from 'react-router-dom';
import { PageSkeleton } from './SkeletonLoader';
import ErrorBoundary from './ErrorBoundary';
import { RequireAuth, RequireProfile } from '../routes/guards';

interface RouteWrapperProps {
  children: ReactNode;
  requireAuth?: boolean;
  requireProfile?: boolean;
  /** When true, wraps children in <Suspense>. */
  lazy?: boolean;
  /** Optional custom fallback used when `lazy` is true. */
  fallback?: ReactNode;
}

/**
 * Unified route wrapper that handles common patterns:
 * - Error boundaries (outermost, keyed to navigation)
 * - Authentication guards
 * - Profile completion guards
 * - Optional lazy loading with Suspense (fallback customizable)
 */
export function RouteWrapper({
  children,
  requireAuth = false,
  requireProfile = false,
  lazy = false,
  fallback,
}: RouteWrapperProps) {
  const location = useLocation();

  let content = children;

  // Profile guard (includes auth)
  if (requireProfile) {
    content = <RequireProfile>{content}</RequireProfile>;
  }
  // Auth-only guard (when profile not required)
  else if (requireAuth) {
    content = <RequireAuth>{content}</RequireAuth>;
  }

  // Optional Suspense wrapper
  const maybeSuspense = lazy ? (
    <Suspense fallback={fallback ?? <PageSkeleton />}>{content}</Suspense>
  ) : (
    content
  );

  // Error boundary as the outermost wrapper.
  // Keyed by navigation so the boundary resets when the user routes.
  return (
    <ErrorBoundary key={location.key} level="page">
      {maybeSuspense}
    </ErrorBoundary>
  );
}

/**
 * Convenience wrappers
 */
type SimpleRouteProps = { children: ReactNode; lazy?: boolean; fallback?: ReactNode };

export function PublicRoute({ children, lazy = false, fallback }: SimpleRouteProps) {
  return (
    <RouteWrapper lazy={lazy} fallback={fallback}>
      {children}
    </RouteWrapper>
  );
}

export function AuthRoute({ children, lazy = false, fallback }: SimpleRouteProps) {
  return (
    <RouteWrapper requireAuth lazy={lazy} fallback={fallback}>
      {children}
    </RouteWrapper>
  );
}

export function ProfileRoute({ children, lazy = false, fallback }: SimpleRouteProps) {
  return (
    <RouteWrapper requireProfile lazy={lazy} fallback={fallback}>
      {children}
    </RouteWrapper>
  );
}
=================================================================================
FILE: src/components/SkeletonLoader.tsx
=================================================================================
/**
 * Skeleton Loader Components
 * Prevents layout shifts during lazy loading
 */

import React from 'react'

interface SkeletonProps {
  className?: string
  width?: string | number
  height?: string | number
  rounded?: boolean
  circle?: boolean
}

export const Skeleton: React.FC<SkeletonProps> = ({
  className = '',
  width,
  height,
  rounded = false,
  circle = false,
}) => {
  const style: React.CSSProperties = {}
  if (width) style.width = typeof width === 'number' ? `${width}px` : width
  if (height) style.height = typeof height === 'number' ? `${height}px` : height

  return (
    <div
      className={`animate-pulse bg-gray-200 ${
        circle ? 'rounded-full' : rounded ? 'rounded-lg' : ''
      } ${className}`}
      style={style}
      aria-hidden="true"
    />
  )
}

export const DashboardSkeleton: React.FC = () => {
  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-50 to-gray-100 p-6">
      <div className="max-w-4xl mx-auto space-y-6">
        {/* Header Skeleton */}
        <div className="flex items-center justify-between">
          <Skeleton width={200} height={32} rounded />
          <Skeleton circle width={40} height={40} />
        </div>

        {/* Stats Cards Skeleton */}
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
          {[1, 2, 3].map((i) => (
            <div key={i} className="bg-white rounded-2xl p-6 shadow-sm">
              <Skeleton width={100} height={20} className="mb-2" />
              <Skeleton width={60} height={32} />
            </div>
          ))}
        </div>

        {/* Main Action Card Skeleton */}
        <div className="bg-white rounded-2xl p-8 shadow-sm">
          <Skeleton width={250} height={28} className="mb-4" />
          <Skeleton width="100%" height={48} rounded />
        </div>

        {/* Recent Workouts Skeleton */}
        <div className="bg-white rounded-2xl p-6 shadow-sm">
          <Skeleton width={150} height={24} className="mb-4" />
          <div className="space-y-3">
            {[1, 2, 3].map((i) => (
              <div key={i} className="flex items-center justify-between p-4 bg-gray-50 rounded-lg">
                <div className="flex-1">
                  <Skeleton width={180} height={20} className="mb-2" />
                  <Skeleton width={120} height={16} />
                </div>
                <Skeleton width={60} height={32} rounded />
              </div>
            ))}
          </div>
        </div>
      </div>
    </div>
  )
}

export const WorkoutListSkeleton: React.FC = () => {
  return (
    <div className="space-y-4">
      {[1, 2, 3, 4].map((i) => (
        <div key={i} className="bg-white rounded-xl p-6 shadow-sm">
          <div className="flex items-start justify-between mb-4">
            <div className="flex-1">
              <Skeleton width={200} height={24} className="mb-2" />
              <Skeleton width={150} height={16} />
            </div>
            <Skeleton circle width={48} height={48} />
          </div>
          <div className="space-y-2">
            <Skeleton width="100%" height={12} />
            <Skeleton width="80%" height={12} />
          </div>
        </div>
      ))}
    </div>
  )
}

export const ExerciseCardSkeleton: React.FC = () => {
  return (
    <div className="bg-white rounded-2xl p-6 shadow-lg">
      <div className="flex items-center justify-between mb-6">
        <Skeleton width={180} height={28} />
        <Skeleton circle width={40} height={40} />
      </div>
      
      <div className="space-y-4">
        <div className="flex items-center gap-4">
          <Skeleton width={80} height={20} />
          <Skeleton width={100} height={20} />
        </div>
        
        <div className="bg-gray-50 rounded-xl p-4">
          <Skeleton width="100%" height={48} rounded className="mb-3" />
          <div className="flex gap-2">
            <Skeleton width={60} height={36} rounded />
            <Skeleton width={60} height={36} rounded />
            <Skeleton width={60} height={36} rounded />
          </div>
        </div>

        <div className="flex gap-3">
          <Skeleton width="50%" height={48} rounded />
          <Skeleton width="50%" height={48} rounded />
        </div>
      </div>
    </div>
  )
}

export const ProfileSkeleton: React.FC = () => {
  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-50 to-gray-100 p-6">
      <div className="max-w-2xl mx-auto space-y-6">
        {/* Header */}
        <div className="flex items-center gap-4 mb-8">
          <Skeleton circle width={80} height={80} />
          <div className="flex-1">
            <Skeleton width={150} height={28} className="mb-2" />
            <Skeleton width={200} height={16} />
          </div>
        </div>

        {/* Profile Sections */}
        {[1, 2, 3].map((i) => (
          <div key={i} className="bg-white rounded-2xl p-6 shadow-sm">
            <Skeleton width={120} height={24} className="mb-4" />
            <div className="space-y-3">
              {[1, 2, 3].map((j) => (
                <div key={j} className="flex items-center justify-between">
                  <Skeleton width={100} height={16} />
                  <Skeleton width={150} height={16} />
                </div>
              ))}
            </div>
          </div>
        ))}
      </div>
    </div>
  )
}

export const HistorySkeleton: React.FC = () => {
  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-50 to-gray-100 p-6">
      <div className="max-w-4xl mx-auto space-y-6">
        {/* Header */}
        <div className="flex items-center justify-between mb-6">
          <Skeleton width={150} height={32} />
          <Skeleton width={100} height={36} rounded />
        </div>

        {/* Workout Cards */}
        <div className="space-y-4">
          {[1, 2, 3, 4, 5].map((i) => (
            <div key={i} className="bg-white rounded-xl p-6 shadow-sm">
              <div className="flex items-start justify-between mb-4">
                <div className="flex-1">
                  <Skeleton width={180} height={24} className="mb-2" />
                  <Skeleton width={120} height={16} />
                </div>
                <Skeleton width={80} height={24} rounded />
              </div>
              
              <div className="grid grid-cols-3 gap-4 mb-4">
                {[1, 2, 3].map((j) => (
                  <div key={j}>
                    <Skeleton width={60} height={16} className="mb-1" />
                    <Skeleton width={40} height={20} />
                  </div>
                ))}
              </div>

              <Skeleton width="100%" height={8} rounded />
            </div>
          ))}
        </div>
      </div>
    </div>
  )
}

export const GenerateSkeleton: React.FC = () => {
  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-50 to-gray-100 p-6">
      <div className="max-w-2xl mx-auto space-y-6">
        <Skeleton width={250} height={32} className="mb-8" />
        
        {/* Form Sections */}
        {[1, 2, 3, 4].map((i) => (
          <div key={i} className="bg-white rounded-2xl p-6 shadow-sm">
            <Skeleton width={150} height={20} className="mb-4" />
            <div className="space-y-3">
              <Skeleton width="100%" height={48} rounded />
              <Skeleton width="100%" height={48} rounded />
            </div>
          </div>
        ))}

        <Skeleton width="100%" height={56} rounded />
      </div>
    </div>
  )
}

/**
 * Generic page skeleton for lazy-loaded routes
 */
export const PageSkeleton: React.FC = () => {
  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-50 to-gray-100 p-6">
      <div className="max-w-4xl mx-auto space-y-6">
        <Skeleton width={200} height={32} className="mb-6" />
        <div className="bg-white rounded-2xl p-8 shadow-sm">
          <Skeleton width="100%" height={24} className="mb-4" />
          <Skeleton width="100%" height={16} className="mb-2" />
          <Skeleton width="90%" height={16} className="mb-2" />
          <Skeleton width="95%" height={16} />
        </div>
      </div>
    </div>
  )
}


=================================================================================
FILE: src/components/SmartWeightInput.tsx
=================================================================================
// src/components/SmartWeightInput.tsx
import React, { useState, useMemo, useCallback, useEffect, useRef } from 'react'
import { TrendingUp, TrendingDown, Minus, Plus, RotateCcw, Zap } from 'lucide-react'

interface WeightHistory {
  exerciseName: string
  setNumber: number
  weight: number
  timestamp: number
  reps?: number
}

interface SmartWeightInputProps {
  exerciseName: string
  setNumber: number
  currentWeight: number | null
  onWeightChange: (_weight: number | null) => void
  isOptimistic?: boolean
  previousWeights?: WeightHistory[]
  targetReps?: number | string
}

export const SmartWeightInput = React.memo(function SmartWeightInput({
  exerciseName,
  setNumber,
  currentWeight,
  onWeightChange,
  isOptimistic = false,
  previousWeights = [],
  targetReps: _targetReps
}: SmartWeightInputProps) {
  const [inputValue, setInputValue] = useState(currentWeight?.toString() || '')
  const [showSuggestions, setShowSuggestions] = useState(false)
  const [isSubmitting, setIsSubmitting] = useState(false)
  const [validationError, setValidationError] = useState<string | null>(null)
  const debounceTimerRef = useRef<NodeJS.Timeout | undefined>(undefined)

  // Weight validation constants
  const MIN_WEIGHT = 0
  const MAX_WEIGHT = 1000

  // Sync input value when currentWeight changes externally
  useEffect(() => {
    setInputValue(currentWeight?.toString() || '')
  }, [currentWeight])

  // Calculate smart suggestions based on previous weights
  const suggestions = useMemo(() => {
    const relevantWeights = previousWeights
      .filter(w => w.exerciseName === exerciseName)
      .sort((a, b) => b.timestamp - a.timestamp)
      .slice(0, 5) // Last 5 sessions

    if (relevantWeights.length === 0) return []

    const lastWeight = relevantWeights[0]?.weight || 0
    const avgWeight = relevantWeights.reduce((sum, w) => sum + w.weight, 0) / relevantWeights.length

    const suggestions = []

    // Previous weight (safe option)
    if (lastWeight > 0) {
      suggestions.push({
        weight: lastWeight,
        label: 'Last used',
        type: 'previous' as const,
        confidence: 'high' as const
      })
    }

    // Progressive overload suggestions
    if (lastWeight > 0) {
      // Small increment (2.5-5 lbs)
      const smallIncrement = lastWeight + (lastWeight < 50 ? 2.5 : 5)
      suggestions.push({
        weight: smallIncrement,
        label: '+2.5-5 lbs',
        type: 'progressive' as const,
        confidence: 'medium' as const
      })

      // Larger increment (10% increase)
      const largeIncrement = Math.round(lastWeight * 1.1 * 2) / 2 // Round to nearest 0.5
      if (largeIncrement !== smallIncrement) {
        suggestions.push({
          weight: largeIncrement,
          label: '+10%',
          type: 'progressive' as const,
          confidence: 'low' as const
        })
      }
    }

    // Average weight from recent sessions
    if (avgWeight > 0 && Math.abs(avgWeight - lastWeight) > 2.5) {
      suggestions.push({
        weight: Math.round(avgWeight * 2) / 2,
        label: 'Recent avg',
        type: 'average' as const,
        confidence: 'medium' as const
      })
    }

    return suggestions.slice(0, 4) // Limit to 4 suggestions
  }, [exerciseName, previousWeights])

  // Quick increment buttons
  const quickIncrements = [2.5, 5, 10, 25]

  // Cleanup debounce timer on unmount
  useEffect(() => {
    const timer = debounceTimerRef.current
    return () => {
      if (timer) {
        clearTimeout(timer)
      }
    }
  }, [])

  const handleSubmit = useCallback(async () => {
    const weight = inputValue.trim() === '' ? null : parseFloat(inputValue)

    // Validate weight input
    if (weight !== null) {
      if (isNaN(weight)) {
        setValidationError('Please enter a valid number')
        return
      }
      if (weight < MIN_WEIGHT) {
        setValidationError(`Weight must be at least ${MIN_WEIGHT} lbs`)
        return
      }
      if (weight > MAX_WEIGHT) {
        setValidationError(`Weight must be less than ${MAX_WEIGHT} lbs`)
        return
      }
    }

    setValidationError(null)
    setIsSubmitting(true)
    try {
      onWeightChange(weight)
      setShowSuggestions(false)
      await new Promise(resolve => setTimeout(resolve, 200))
    } finally {
      setIsSubmitting(false)
    }
  }, [inputValue, onWeightChange])

  const handleKeyDown = useCallback((e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      handleSubmit()
      ;(e.target as HTMLInputElement).blur()
    } else if (e.key === 'Escape') {
      setShowSuggestions(false)
    }
  }, [handleSubmit])

  const handleSuggestionClick = useCallback((weight: number) => {
    setInputValue(weight.toString())
    onWeightChange(weight)
    setShowSuggestions(false)
  }, [onWeightChange])

  const adjustWeight = useCallback((delta: number) => {
    const current = parseFloat(inputValue) || 0
    const newWeight = Math.max(0, current + delta)
    setInputValue(newWeight.toString())
  }, [inputValue])

  const resetWeight = useCallback(() => {
    setInputValue('')
    onWeightChange(null)
  }, [onWeightChange])

  // Get trend indicator
  const getTrendIndicator = () => {
    if (previousWeights.length < 2) return null

    const recent = previousWeights
      .filter(w => w.exerciseName === exerciseName)
      .sort((a, b) => b.timestamp - a.timestamp)
      .slice(0, 3)

    if (recent.length < 2 || !recent[0] || !recent[recent.length - 1]) return null

    const trend = recent[0]!.weight - recent[recent.length - 1]!.weight
    if (Math.abs(trend) < 2.5) return null

    return trend > 0 ? 'up' : 'down'
  }

  const trend = getTrendIndicator()

  return (
    <div className={`rounded-2xl border backdrop-blur-sm p-4 transition-all duration-200 ${
      isOptimistic 
        ? 'border-blue-300 bg-blue-50/70 shadow-md' 
        : 'border-gray-200 bg-white/70'
    }`}>
      <div className="flex items-center justify-between gap-3 mb-4">
        <div className="flex-1">
          <div className="font-medium text-gray-900 flex items-center gap-2">
            Weight for Set {setNumber}
            {isOptimistic && (
              <div className="h-2 w-2 bg-blue-500 rounded-full animate-pulse" />
            )}
            {trend && (
              <div className={`flex items-center gap-1 text-xs px-2 py-1 rounded-full ${
                trend === 'up' 
                  ? 'bg-green-100 text-green-700' 
                  : 'bg-orange-100 text-orange-700'
              }`}>
                {trend === 'up' ? <TrendingUp className="h-3 w-3" /> : <TrendingDown className="h-3 w-3" />}
                {trend === 'up' ? 'Trending up' : 'Trending down'}
              </div>
            )}
          </div>
          <div className="text-sm text-gray-600">
            {isOptimistic ? 'Saving...' : 'Enter weight in lbs (optional)'}
          </div>
        </div>
      </div>

      {/* Weight Input with Quick Controls */}
      <div className="flex items-center gap-2 mb-4">
        <button
          onClick={() => adjustWeight(-2.5)}
          className="p-2 rounded-lg bg-gray-100 hover:bg-gray-200 transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2"
          disabled={isSubmitting}
          aria-label="Decrease weight by 2.5 lbs"
        >
          <Minus className="h-4 w-4" aria-hidden="true" />
        </button>

        <div className="flex-1 relative">
          <input
            type="number"
            value={inputValue}
            onChange={(e) => {
              setInputValue(e.target.value)
              setValidationError(null) // Clear error on input change
            }}
            onFocus={() => setShowSuggestions(true)}
            onBlur={() => setTimeout(() => setShowSuggestions(false), 200)}
            onKeyDown={handleKeyDown}
            placeholder="0"
            min={MIN_WEIGHT}
            max={MAX_WEIGHT}
            step="0.5"
            className={`w-full rounded-lg border ${validationError ? 'border-red-400' : 'border-gray-200'} bg-white px-4 py-3 text-center text-lg font-semibold text-gray-900 placeholder-gray-400 focus:border-blue-400 focus:outline-none focus:ring-2 focus:ring-blue-400/20`}
            disabled={isSubmitting}
            aria-label={`Weight for set ${setNumber} of ${exerciseName} in pounds`}
            aria-describedby={`weight-help-${setNumber}`}
            aria-invalid={!!validationError}
          />
          <div className="absolute right-3 top-1/2 -translate-y-1/2 text-sm text-gray-500">
            lbs
          </div>
        </div>

        <button
          onClick={() => adjustWeight(2.5)}
          className="p-2 rounded-lg bg-gray-100 hover:bg-gray-200 transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2"
          disabled={isSubmitting}
          aria-label="Increase weight by 2.5 lbs"
        >
          <Plus className="h-4 w-4" aria-hidden="true" />
        </button>

        <button
          onClick={resetWeight}
          className="p-2 rounded-lg bg-gray-100 hover:bg-gray-200 transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2"
          disabled={isSubmitting}
          aria-label="Clear weight"
        >
          <RotateCcw className="h-4 w-4" aria-hidden="true" />
        </button>
      </div>

      {/* Validation Error */}
      {validationError && (
        <div className="mb-3 text-sm text-red-600 flex items-center gap-2">
          <svg className="h-4 w-4" fill="currentColor" viewBox="0 0 20 20">
            <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
          </svg>
          {validationError}
        </div>
      )}

      {/* Quick Increment Buttons */}
      <div className="flex gap-2 mb-4">
        {quickIncrements.map(increment => (
          <button
            key={increment}
            onClick={() => adjustWeight(increment)}
            className="flex-1 px-3 py-2 text-sm font-medium bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors"
            disabled={isSubmitting}
          >
            +{increment}
          </button>
        ))}
      </div>

      {/* Smart Suggestions */}
      {showSuggestions && suggestions.length > 0 && (
        <div className="border-t border-gray-200 pt-4">
          <div className="flex items-center gap-2 mb-3">
            <Zap className="h-4 w-4 text-blue-600" />
            <span className="text-sm font-medium text-gray-900">Smart Suggestions</span>
          </div>
          <div className="grid grid-cols-2 gap-2">
            {suggestions.map((suggestion, index) => (
              <button
                key={index}
                onClick={() => handleSuggestionClick(suggestion.weight)}
                className={`p-3 rounded-lg border text-left transition-all hover:scale-[1.02] ${
                  suggestion.confidence === 'high'
                    ? 'border-green-200 bg-green-50 hover:bg-green-100'
                    : suggestion.confidence === 'medium'
                    ? 'border-blue-200 bg-blue-50 hover:bg-blue-100'
                    : 'border-orange-200 bg-orange-50 hover:bg-orange-100'
                }`}
              >
                <div className="font-semibold text-gray-900">
                  {suggestion.weight} lbs
                </div>
                <div className="text-xs text-gray-600">
                  {suggestion.label}
                </div>
              </button>
            ))}
          </div>
        </div>
      )}

      {/* Submit Button */}
      <button
        onClick={handleSubmit}
        disabled={isSubmitting}
        className={`w-full mt-4 px-4 py-3 rounded-xl font-medium transition-all duration-200 ${
          isSubmitting
            ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
            : 'bg-gradient-to-r from-blue-500 to-indigo-600 text-white hover:from-blue-600 hover:to-indigo-700 hover:scale-[1.02] shadow-md'
        }`}
      >
        {isSubmitting ? 'Saving...' : 'Save Weight'}
      </button>
    </div>
  )
}, (prevProps, nextProps) => {
  // Custom comparison for optimal re-render prevention
  return (
    prevProps.exerciseName === nextProps.exerciseName &&
    prevProps.setNumber === nextProps.setNumber &&
    prevProps.currentWeight === nextProps.currentWeight &&
    prevProps.isOptimistic === nextProps.isOptimistic &&
    prevProps.targetReps === nextProps.targetReps &&
    // Deep comparison for previousWeights array
    (prevProps.previousWeights?.length || 0) === (nextProps.previousWeights?.length || 0) &&
    (prevProps.previousWeights || []).every((prev, idx) => {
      const next = (nextProps.previousWeights || [])[idx]
      return next && prev.weight === next.weight && prev.timestamp === next.timestamp
    })
  )
})

=================================================================================
FILE: src/components/WorkoutFlowHeader.tsx
=================================================================================
// src/components/WorkoutFlowHeader.tsx
import { useState } from 'react'
import { useNavigate } from 'react-router-dom'
import { signOut } from 'firebase/auth'
import { auth } from '../lib/firebase'
import {
  Menu,
  X,
  Zap,
  Home,
  Dumbbell,
  History,
  User,
  LogOut,
  ArrowLeft,
  Pause,
  Play,
  SkipForward
} from 'lucide-react'
import { useAppStore } from '../store'
import { clearGuestSession } from '../lib/guest-session'

interface WorkoutFlowHeaderProps {
  title?: string
  showBackButton?: boolean
  showWorkoutControls?: boolean
  onBack?: () => void
  onPause?: () => void
  onResume?: () => void
  onSkip?: () => void
  isPaused?: boolean
  className?: string
}

export default function WorkoutFlowHeader({
  title = "Workout",
  showBackButton = true,
  showWorkoutControls = false,
  onBack,
  onPause,
  onResume,
  onSkip,
  isPaused = false,
  className = ""
}: WorkoutFlowHeaderProps) {
  const [isMenuOpen, setIsMenuOpen] = useState(false)
  const nav = useNavigate()
  const { isGuest, setIsGuest, setAuthStatus } = useAppStore()

  const menuItems = [
    { label: 'Dashboard', path: '/dashboard', icon: Home },
    { label: 'Generate Workout', path: '/generate', icon: Dumbbell },
    { label: 'Workout History', path: '/history', icon: History },
    { label: 'Profile', path: '/profile', icon: User },
  ]

  const handleNavigation = (path: string) => {
    nav(path)
    setIsMenuOpen(false)
  }

  const handleSignOut = async () => {
    try {
      // Handle guest logout
      if (isGuest) {
        clearGuestSession()
        setIsGuest(false)
        setAuthStatus('signedOut')
        nav('/')
        setIsMenuOpen(false)
        return
      }

      // Handle authenticated user logout
      await signOut(auth)
      nav('/')
      setIsMenuOpen(false)
    } catch (e) {
      if (import.meta.env.MODE === 'development') {
        console.error('Sign out failed', e)
      }
      alert('Sign out failed. Please try again.')
    }
  }

  const handleBack = () => {
    if (onBack) {
      onBack()
    } else {
      nav(-1)
    }
  }

  return (
    <>
      <header className={`sticky top-0 z-50 bg-gradient-to-r from-white/95 via-white/90 to-white/95 backdrop-blur-xl border-b border-gray-200/60 shadow-lg shadow-gray-200/20 ${className}`}>
        <div className="mx-auto max-w-6xl px-4 sm:px-6 py-3 flex items-center justify-between">
          {/* Left Section */}
          <div className="flex items-center gap-4">
            {showBackButton && (
              <button
                onClick={handleBack}
                className="p-2 rounded-xl hover:bg-gray-100/80 transition-all duration-200 touch-manipulation min-h-[44px] min-w-[44px] flex items-center justify-center group"
                aria-label="Go back"
              >
                <ArrowLeft className="h-5 w-5 text-gray-700 group-hover:text-gray-900 transition-colors" />
              </button>
            )}
            
            {/* Logo and Title */}
            <div className="flex items-center gap-3">
              <div className="h-8 w-8 rounded-xl bg-gradient-to-tr from-blue-500 via-blue-600 to-indigo-600 flex items-center justify-center shadow-lg shadow-blue-500/25">
                <Zap className="h-4 w-4 text-white" />
              </div>
              <div>
                <h1 className="text-lg sm:text-xl font-bold text-gray-900 tracking-tight leading-tight">
                  {title}
                </h1>
                <div className="text-xs text-gray-500 font-medium">
                  neurafit
                </div>
              </div>
            </div>
          </div>

          {/* Center Section - Workout Controls */}
          {showWorkoutControls && (
            <div className="hidden sm:flex items-center gap-2">
              {isPaused ? (
                <button
                  onClick={onResume}
                  className="flex items-center gap-2 px-4 py-2 bg-gradient-to-r from-green-500 to-emerald-600 text-white rounded-xl font-medium hover:from-green-600 hover:to-emerald-700 transition-all duration-200 shadow-lg hover:shadow-xl hover:scale-105 active:scale-95"
                >
                  <Play className="h-4 w-4" />
                  Resume
                </button>
              ) : (
                <button
                  onClick={onPause}
                  className="flex items-center gap-2 px-4 py-2 bg-gradient-to-r from-yellow-500 to-orange-600 text-white rounded-xl font-medium hover:from-yellow-600 hover:to-orange-700 transition-all duration-200 shadow-lg hover:shadow-xl hover:scale-105 active:scale-95"
                >
                  <Pause className="h-4 w-4" />
                  Pause
                </button>
              )}
              
              {onSkip && (
                <button
                  onClick={onSkip}
                  className="flex items-center gap-2 px-4 py-2 bg-gradient-to-r from-slate-500 to-gray-600 text-white rounded-xl font-medium hover:from-slate-600 hover:to-gray-700 transition-all duration-200 shadow-lg hover:shadow-xl hover:scale-105 active:scale-95"
                >
                  <SkipForward className="h-4 w-4" />
                  Skip
                </button>
              )}
            </div>
          )}

          {/* Right Section - Menu Button */}
          <button
            onClick={() => setIsMenuOpen(!isMenuOpen)}
            className="p-3 rounded-xl hover:bg-gray-100/80 transition-all duration-200 touch-manipulation min-h-[44px] min-w-[44px] flex items-center justify-center group"
            aria-label="Toggle menu"
          >
            {isMenuOpen ? (
              <X className="h-5 w-5 text-gray-700 group-hover:text-gray-900 transition-colors" />
            ) : (
              <Menu className="h-5 w-5 text-gray-700 group-hover:text-gray-900 transition-colors" />
            )}
          </button>
        </div>

        {/* Mobile Workout Controls */}
        {showWorkoutControls && (
          <div className="sm:hidden px-4 pb-3">
            <div className="flex items-center justify-center gap-2">
              {isPaused ? (
                <button
                  onClick={onResume}
                  className="flex items-center gap-2 px-4 py-2 bg-gradient-to-r from-green-500 to-emerald-600 text-white rounded-xl font-medium hover:from-green-600 hover:to-emerald-700 transition-all duration-200 shadow-lg hover:shadow-xl hover:scale-105 active:scale-95"
                >
                  <Play className="h-4 w-4" />
                  Resume
                </button>
              ) : (
                <button
                  onClick={onPause}
                  className="flex items-center gap-2 px-4 py-2 bg-gradient-to-r from-yellow-500 to-orange-600 text-white rounded-xl font-medium hover:from-yellow-600 hover:to-orange-700 transition-all duration-200 shadow-lg hover:shadow-xl hover:scale-105 active:scale-95"
                >
                  <Pause className="h-4 w-4" />
                  Pause
                </button>
              )}
              
              {onSkip && (
                <button
                  onClick={onSkip}
                  className="flex items-center gap-2 px-4 py-2 bg-gradient-to-r from-slate-500 to-gray-600 text-white rounded-xl font-medium hover:from-slate-600 hover:to-gray-700 transition-all duration-200 shadow-lg hover:shadow-xl hover:scale-105 active:scale-95"
                >
                  <SkipForward className="h-4 w-4" />
                  Skip
                </button>
              )}
            </div>
          </div>
        )}
      </header>

      {/* Mobile Menu Overlay */}
      {isMenuOpen && (
        <>
          {/* Backdrop */}
          <div 
            className="fixed inset-0 z-40 bg-black/20 backdrop-blur-sm"
            onClick={() => setIsMenuOpen(false)}
          />
          
          {/* Menu Panel */}
          <div
            className="fixed top-20 right-4 z-50 w-64 max-w-[calc(100vw-2rem)] bg-white/95 backdrop-blur-md rounded-2xl border border-gray-200 shadow-xl"
            style={{
              right: 'max(1rem, env(safe-area-inset-right))',
            }}
          >
            <div className="p-2">
              {menuItems.map((item) => {
                const Icon = item.icon
                return (
                  <button
                    key={item.path}
                    onClick={() => handleNavigation(item.path)}
                    className="w-full flex items-center gap-3 px-4 py-4 text-left rounded-xl hover:bg-gray-100 transition-colors text-gray-700 hover:text-gray-900 touch-manipulation min-h-[48px]"
                  >
                    <Icon className="h-5 w-5" />
                    <span className="font-medium">{item.label}</span>
                  </button>
                )
              })}

              {/* Divider */}
              <div className="my-2 h-px bg-gray-200" />

              {/* Sign Out */}
              <button
                onClick={handleSignOut}
                className="w-full flex items-center gap-3 px-4 py-4 text-left rounded-xl hover:bg-red-50 transition-colors text-red-600 hover:text-red-700 touch-manipulation min-h-[48px]"
              >
                <LogOut className="h-5 w-5" />
                <span className="font-medium">Sign out</span>
              </button>
            </div>
          </div>
        </>
      )}
    </>
  )
}

=================================================================================
FILE: src/components/WorkoutProgress.tsx
=================================================================================
// src/components/WorkoutProgress.tsx
import React, { memo } from 'react'
import { CheckCircle, Clock, Zap, Flame, Rocket, Sparkles, Target, PartyPopper } from 'lucide-react'

interface CircularProgressProps {
  progress: number // 0-100
  size?: number
  strokeWidth?: number
  className?: string
  children?: React.ReactNode
}

export const CircularProgress = memo(function CircularProgress({
  progress,
  size = 120,
  strokeWidth = 8,
  className = '',
  children
}: CircularProgressProps) {
  const radius = (size - strokeWidth) / 2
  const circumference = radius * 2 * Math.PI
  const offset = circumference - (progress / 100) * circumference

  return (
    <div className={`relative inline-flex items-center justify-center ${className}`}>
      <svg
        width={size}
        height={size}
        className="transform -rotate-90"
      >
        {/* Background circle */}
        <circle
          cx={size / 2}
          cy={size / 2}
          r={radius}
          stroke="currentColor"
          strokeWidth={strokeWidth}
          fill="transparent"
          className="text-gray-200"
        />
        {/* Progress circle */}
        <circle
          cx={size / 2}
          cy={size / 2}
          r={radius}
          stroke="currentColor"
          strokeWidth={strokeWidth}
          fill="transparent"
          strokeDasharray={circumference}
          strokeDashoffset={offset}
          className="text-blue-500 transition-all duration-500 ease-out"
          strokeLinecap="round"
        />
      </svg>
      {/* Content */}
      <div className="absolute inset-0 flex items-center justify-center">
        {children}
      </div>
    </div>
  )
})

interface WorkoutProgressHeaderProps {
  currentExercise: number
  totalExercises: number
  currentSet: number
  totalSets: number
  overallProgress: number
  exerciseName: string
}

export const WorkoutProgressHeader = memo(function WorkoutProgressHeader({
  currentExercise,
  totalExercises,
  currentSet,
  totalSets,
  overallProgress,
  exerciseName
}: WorkoutProgressHeaderProps) {
  return (
    <div className="bg-white/90 backdrop-blur-md border-b border-gray-100 sticky top-0 z-40">
      <div className="max-w-4xl mx-auto px-6 py-4">
        {/* Overall Progress */}
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center gap-3">
            <CircularProgress progress={overallProgress} size={48} strokeWidth={4}>
              <span className="text-xs font-bold text-gray-700">
                {Math.round(overallProgress)}%
              </span>
            </CircularProgress>
            <div>
              <div className="text-sm font-medium text-gray-900">
                Exercise {currentExercise} of {totalExercises}
              </div>
              <div className="text-xs text-gray-600">
                Overall Progress
              </div>
            </div>
          </div>

          {/* Exercise Progress */}
          <div className="text-right">
            <div className="text-sm font-medium text-gray-900">
              Set {currentSet} of {totalSets}
            </div>
            <div className="text-xs text-gray-600">
              Current Exercise
            </div>
          </div>
        </div>

        {/* Exercise Name */}
        <div className="text-center">
          <h2 className="text-lg font-bold text-gray-900 truncate">
            {exerciseName}
          </h2>
        </div>

        {/* Progress Bar */}
        <div className="mt-3">
          <div className="w-full bg-gray-200 rounded-full h-2">
            <div
              className="bg-gradient-to-r from-blue-500 to-indigo-600 h-2 rounded-full transition-all duration-500 ease-out"
              style={{ width: `${overallProgress}%` }}
            />
          </div>
        </div>
      </div>
    </div>
  )
}, (prev, next) => {
  // Custom comparison for optimal re-render prevention
  return (
    prev.currentExercise === next.currentExercise &&
    prev.totalExercises === next.totalExercises &&
    prev.currentSet === next.currentSet &&
    prev.totalSets === next.totalSets &&
    prev.overallProgress === next.overallProgress &&
    prev.exerciseName === next.exerciseName
  )
})

interface SetProgressIndicatorProps {
  currentSet: number
  totalSets: number
  completedSets: number[]
  skippedSets: number[]
}

export const SetProgressIndicator = memo(function SetProgressIndicator({
  currentSet,
  totalSets,
  completedSets,
  skippedSets
}: SetProgressIndicatorProps) {
  return (
    <div className="flex items-center justify-center gap-2 py-4">
      {Array.from({ length: totalSets }, (_, i) => {
        const setNumber = i + 1
        const isCompleted = completedSets.includes(setNumber)
        const isSkipped = skippedSets.includes(setNumber)
        const isCurrent = setNumber === currentSet
        
        return (
          <div
            key={setNumber}
            className={`relative flex items-center justify-center w-8 h-8 rounded-full border-2 transition-all duration-300 ${
              isCompleted
                ? 'bg-green-500 border-green-500 text-white'
                : isSkipped
                ? 'bg-red-100 border-red-300 text-red-600'
                : isCurrent
                ? 'bg-blue-500 border-blue-500 text-white animate-pulse'
                : 'bg-gray-100 border-gray-300 text-gray-600'
            }`}
          >
            {isCompleted ? (
              <CheckCircle className="h-4 w-4" />
            ) : (
              <span className="text-xs font-bold">{setNumber}</span>
            )}
            
            {isCurrent && (
              <div className="absolute -inset-1 rounded-full border-2 border-blue-300 animate-ping" />
            )}
          </div>
        )
      })}
    </div>
  )
})

interface MotivationalMessageProps {
  progress: number
  completedSets: number
  totalSets: number
  exerciseName: string
}

export const MotivationalMessage = memo(function MotivationalMessage({
  progress: _progress,
  completedSets,
  totalSets,
  exerciseName
}: MotivationalMessageProps) {
  // Use exercise completion percentage for motivational messages, not overall workout progress
  const exerciseCompletionPct = Math.round((completedSets / totalSets) * 100)

  const getMotivationalMessage = () => {
    if (exerciseCompletionPct >= 90) return { text: "Almost there! Finish strong!", icon: <Zap className="h-4 w-4" /> }
    if (exerciseCompletionPct >= 75) return { text: "You're crushing it! Keep going!", icon: <Flame className="h-4 w-4" /> }
    if (exerciseCompletionPct >= 50) return { text: "Halfway there! You've got this!", icon: <Zap className="h-4 w-4" /> }
    if (exerciseCompletionPct >= 25) return { text: "Great start! Building momentum!", icon: <Rocket className="h-4 w-4" /> }
    if (completedSets > 0) return { text: "Nice work! One set at a time!", icon: <Sparkles className="h-4 w-4" /> }
    return { text: "Let's do this! You're stronger than you think!", icon: <Target className="h-4 w-4" /> }
  }

  const getCompletionMessage = () => {
    if (exerciseCompletionPct === 100) return { text: `${exerciseName} completed!`, icon: <PartyPopper className="h-4 w-4" /> }
    if (exerciseCompletionPct >= 75) return { text: `${exerciseCompletionPct}% complete - almost done!`, icon: null }
    if (exerciseCompletionPct >= 50) return { text: `${exerciseCompletionPct}% complete - keep it up!`, icon: null }
    if (exerciseCompletionPct > 0) return { text: `${exerciseCompletionPct}% complete - great progress!`, icon: null }
    return { text: "Ready to start? You've got this!", icon: null }
  }

  const motivationalMessage = getMotivationalMessage()
  const completionMessage = getCompletionMessage()

  return (
    <div className="text-center py-4 px-6">
      <div className="bg-gradient-to-r from-blue-50 to-indigo-50 rounded-2xl p-4 border border-blue-100">
        <div className="flex items-center justify-center gap-2 text-lg font-semibold text-gray-900 mb-1">
          {motivationalMessage.icon}
          <span>{motivationalMessage.text}</span>
        </div>
        <div className="flex items-center justify-center gap-2 text-sm text-gray-600">
          {completionMessage.icon}
          <span>{completionMessage.text}</span>
        </div>
      </div>
    </div>
  )
})

interface NextExercisePreviewProps {
  nextExercise?: {
    name: string
    sets: number
    reps: string | number
    restSeconds?: number
  }
  timeRemaining: number
}

export const NextExercisePreview = memo(function NextExercisePreview({ nextExercise, timeRemaining }: NextExercisePreviewProps) {
  if (!nextExercise) return null

  return (
    <div className="bg-gradient-to-r from-gray-50 to-blue-50 rounded-2xl p-4 border border-gray-200">
      <div className="flex items-center gap-3 mb-2">
        <div className="flex items-center gap-1 text-blue-600">
          <Clock className="h-4 w-4" />
          <span className="text-sm font-medium">{timeRemaining}s</span>
        </div>
        <div className="text-sm text-gray-600">Next up:</div>
      </div>

      <div className="text-lg font-semibold text-gray-900 mb-1">
        {nextExercise.name}
      </div>

      <div className="text-sm text-gray-600">
        {nextExercise.sets} sets × {nextExercise.reps} reps
        {nextExercise.restSeconds && (
          <span className="ml-2">• {nextExercise.restSeconds}s rest</span>
        )}
      </div>
    </div>
  )
})

interface WorkoutStatsProps {
  startTime: number
  completedSets: number
  totalSets: number
  completedExercises: number
  totalExercises: number
}

export const WorkoutStats = memo(function WorkoutStats({
  startTime,
  completedSets,
  totalSets,
  completedExercises,
  totalExercises
}: WorkoutStatsProps) {
  const elapsedMinutes = Math.floor((Date.now() - startTime) / 1000 / 60)
  const completionRate = Math.round((completedSets / totalSets) * 100)

  return (
    <div className="grid grid-cols-3 gap-4 p-4">
      <div className="text-center">
        <div className="text-2xl font-bold text-blue-600">{elapsedMinutes}</div>
        <div className="text-xs text-gray-600">Minutes</div>
      </div>

      <div className="text-center">
        <div className="text-2xl font-bold text-green-600">{completionRate}%</div>
        <div className="text-xs text-gray-600">Complete</div>
      </div>

      <div className="text-center">
        <div className="text-2xl font-bold text-indigo-600">
          {completedExercises}/{totalExercises}
        </div>
        <div className="text-xs text-gray-600">Exercises</div>
      </div>
    </div>
  )
})

=================================================================================
FILE: src/config/features.ts
=================================================================================
/**
 * Feature flags configuration for NeuraFit
 */

export interface FeatureFlags {
  adaptivePersonalization: {
    enabled: boolean
    enableFeedbackUI: boolean
    enableIntensityCalibration: boolean
    enableTelemetry: boolean
  }
}

export const defaultFeatureFlags: FeatureFlags = {
  adaptivePersonalization: {
    enabled: true,
    enableFeedbackUI: true,
    enableIntensityCalibration: true,
    enableTelemetry: true
  }
}

/**
 * Get feature flags from environment or use defaults
 */
export function getFeatureFlags(): FeatureFlags {
  // In a production app, you might fetch these from a remote config service
  // For now, we'll use environment variables with fallbacks to defaults
  
  const adaptiveEnabled = import.meta.env['VITE_ADAPTIVE_PERSONALIZATION_ENABLED'] !== 'false'
  const feedbackEnabled = import.meta.env['VITE_ADAPTIVE_FEEDBACK_UI_ENABLED'] !== 'false'
  const calibrationEnabled = import.meta.env['VITE_ADAPTIVE_CALIBRATION_ENABLED'] !== 'false'
  const telemetryEnabled = import.meta.env['VITE_ADAPTIVE_TELEMETRY_ENABLED'] !== 'false'

  return {
    adaptivePersonalization: {
      enabled: adaptiveEnabled,
      enableFeedbackUI: feedbackEnabled,
      enableIntensityCalibration: calibrationEnabled,
      enableTelemetry: telemetryEnabled
    }
  }
}

/**
 * Check if a specific feature is enabled
 */
export function isFeatureEnabled(feature: keyof FeatureFlags): boolean {
  const flags = getFeatureFlags()
  return flags[feature].enabled
}

/**
 * Check if adaptive personalization is enabled
 */
export function isAdaptivePersonalizationEnabled(): boolean {
  return getFeatureFlags().adaptivePersonalization.enabled
}

/**
 * Check if feedback UI should be shown
 */
export function isFeedbackUIEnabled(): boolean {
  const flags = getFeatureFlags()
  return flags.adaptivePersonalization.enabled && flags.adaptivePersonalization.enableFeedbackUI
}

/**
 * Check if intensity calibration should be shown
 */
export function isIntensityCalibrationEnabled(): boolean {
  const flags = getFeatureFlags()
  return flags.adaptivePersonalization.enabled && flags.adaptivePersonalization.enableIntensityCalibration
}

/**
 * Check if telemetry should be collected
 */
export function isTelemetryEnabled(): boolean {
  const flags = getFeatureFlags()
  return flags.adaptivePersonalization.enabled && flags.adaptivePersonalization.enableTelemetry
}

=================================================================================
FILE: src/config/onboarding.ts
=================================================================================
/**
 * Centralized configuration for onboarding and profile data
 * This file contains all the constants used across onboarding and profile components
 * to ensure consistency and make updates easier.
 */

export const EXPERIENCE_LEVELS = ['Beginner', 'Intermediate', 'Expert']

export const GOALS = [
  'Weight Loss',
  'Build Muscle',
  'Strength',
  'Stamina',
  'Tone',
  'General Health',
  'Increase Flexibility',
  'Sports Performance',
  'Mental Health',
  'Injury Prevention',
]

// Equipment organized by popularity and accessibility (most to least common)
export const EQUIPMENT = [
  'Bodyweight',        // Most accessible - no equipment needed
  'Dumbbells',         // Most popular home equipment
  'Resistance Bands',  // Portable and versatile
  'Pull-Up Bar',       // Common home gym staple
  'Kettlebells',       // Functional training favorite
  'Barbells',          // Serious strength training
  'Weight Machines',   // Gym standard equipment
  'Medicine Balls',    // Functional and core training
  'Cable Machine',     // Gym versatility
  'Treadmill',         // Cardio equipment
  'Stationary Bike',   // Low-impact cardio
  'Rowing Machine',    // Full-body cardio
]

export const SEX_OPTIONS = ['Male', 'Female', 'Other']

export const HEIGHT_RANGES = ["<5'0", "5'0–5'5", "5'6–5'9", "5'10–6'1", "6'2–6'5", ">6'5"]

export const WEIGHT_RANGES = ['<120lb', '120–149', '150–179', '180–209', '210–239', '240+lb']

export const INJURY_OPTIONS = ['None', 'Knee', 'Lower Back', 'Shoulder', 'Ankle', 'Wrist/Elbow', 'Neck', 'Other']

// Type exports for better TypeScript support
export type ExperienceLevel = 'Beginner' | 'Intermediate' | 'Expert'
export type Goal = 'Weight Loss' | 'Build Muscle' | 'Strength' | 'Stamina' | 'Tone' | 'General Health' | 'Increase Flexibility' | 'Sports Performance' | 'Mental Health' | 'Injury Prevention'
export type Equipment = 'Bodyweight' | 'Dumbbells' | 'Resistance Bands' | 'Pull-Up Bar' | 'Kettlebells' | 'Barbells' | 'Weight Machines' | 'Medicine Balls' | 'Cable Machine' | 'Treadmill' | 'Stationary Bike' | 'Rowing Machine'
export type SexOption = 'Male' | 'Female' | 'Other'
export type HeightRange = "<5'0" | "5'0–5'5" | "5'6–5'9" | "5'10–6'1" | "6'2–6'5" | ">6'5"
export type WeightRange = '<120lb' | '120–149' | '150–179' | '180–209' | '210–239' | '240+lb'
export type InjuryOption = 'None' | 'Knee' | 'Lower Back' | 'Shoulder' | 'Ankle' | 'Wrist/Elbow' | 'Neck' | 'Other'

=================================================================================
FILE: src/hooks/useAnalytics.ts
=================================================================================
import { useEffect } from 'react'
import { useLocation } from 'react-router-dom'
import { trackPageView } from '../lib/firebase-analytics'
import { logger } from '../lib/logger'

/**
 * Route metadata for analytics and SEO
 */
interface RouteMetadata {
  screenName: string
  title: string
}

/**
 * Map of routes to their metadata
 */
const ROUTE_METADATA: Record<string, RouteMetadata> = {
  '/': {
    screenName: 'home',
    title: 'NeuraFit - AI-Powered Fitness',
  },
  '/dashboard': {
    screenName: 'dashboard',
    title: 'Dashboard - NeuraFit',
  },
  '/generate': {
    screenName: 'generate_workout',
    title: 'Generate Workout - NeuraFit',
  },
  '/history': {
    screenName: 'workout_history',
    title: 'Workout History - NeuraFit',
  },
  '/profile': {
    screenName: 'profile',
    title: 'Profile - NeuraFit',
  },
  '/onboarding': {
    screenName: 'onboarding',
    title: 'Get Started - NeuraFit',
  },
  '/workout/preview': {
    screenName: 'workout_preview',
    title: 'Workout Preview - NeuraFit',
  },
  '/workout/run': {
    screenName: 'workout_exercise',
    title: 'Exercise - NeuraFit',
  },
  '/workout/rest': {
    screenName: 'workout_rest',
    title: 'Rest - NeuraFit',
  },
  '/workout/complete': {
    screenName: 'workout_complete',
    title: 'Workout Complete - NeuraFit',
  },
  '/terms': {
    screenName: 'terms',
    title: 'Terms of Service - NeuraFit',
  },
  '/privacy': {
    screenName: 'privacy',
    title: 'Privacy Policy - NeuraFit',
  },
}

/**
 * Get route metadata from pathname
 */
function getRouteMetadata(pathname: string): RouteMetadata {
  // Check exact match first
  if (ROUTE_METADATA[pathname]) {
    return ROUTE_METADATA[pathname]
  }

  // Handle dynamic routes
  if (pathname.startsWith('/workout/') && pathname.match(/^\/workout\/[a-zA-Z0-9-]+$/)) {
    return {
      screenName: 'workout_detail',
      title: 'Workout Detail - NeuraFit',
    }
  }

  // Default for unknown routes
  return {
    screenName: 'not_found',
    title: '404 Not Found - NeuraFit',
  }
}

/**
 * Hook to automatically track page views and update document title
 */
export function usePageTracking() {
  const location = useLocation()

  useEffect(() => {
    // Get route metadata
    const metadata = getRouteMetadata(location.pathname)

    // Update document title
    document.title = metadata.title

    // Track page view with screen name
    trackPageView(metadata.screenName, metadata.title)

    // Log page tracking
    logger.debug('Page tracked', {
      pathname: location.pathname,
      screenName: metadata.screenName,
      title: metadata.title,
    })
  }, [location])
}

=================================================================================
FILE: src/hooks/useFocusManagement.ts
=================================================================================
/**
 * Focus Management Hook
 *
 * Manages focus on route changes for accessibility.
 * Ensures screen readers announce page changes and focus is properly managed.
 */

import type React from 'react';
import { useEffect, useRef } from 'react';
import { useLocation } from 'react-router-dom';

/**
 * Hook to manage focus on route changes
 * 
 * This hook:
 * 1. Moves focus to the main content area on route change
 * 2. Announces the page change to screen readers
 * 3. Scrolls to top of page
 */
export function useFocusManagement() {
  const location = useLocation();
  const previousPathRef = useRef<string>('');

  useEffect(() => {
    // Skip on initial mount
    if (previousPathRef.current === '') {
      previousPathRef.current = location.pathname;
      return;
    }

    // Only run if path actually changed
    if (previousPathRef.current === location.pathname) {
      return;
    }

    previousPathRef.current = location.pathname;

    // Scroll to top
    window.scrollTo(0, 0);

    // Find and focus the main content area
    // Look for main element, or fallback to body
    const mainContent = document.querySelector('main') || document.querySelector('[role="main"]');
    
    if (mainContent instanceof HTMLElement) {
      // Make it focusable if it isn't already
      if (!mainContent.hasAttribute('tabindex')) {
        mainContent.setAttribute('tabindex', '-1');
      }
      
      // Focus it
      mainContent.focus();
      
      // Remove focus styling after focus (optional)
      mainContent.style.outline = 'none';
    } else {
      // Fallback: focus the body
      document.body.focus();
    }

    // Announce page change to screen readers
    announcePageChange();
  }, [location.pathname]);
}

/**
 * Announce page change to screen readers
 */
function announcePageChange() {
  // Create or get the live region
  let liveRegion = document.getElementById('route-announcer');
  
  if (!liveRegion) {
    liveRegion = document.createElement('div');
    liveRegion.id = 'route-announcer';
    liveRegion.setAttribute('role', 'status');
    liveRegion.setAttribute('aria-live', 'polite');
    liveRegion.setAttribute('aria-atomic', 'true');
    liveRegion.className = 'sr-only'; // Screen reader only
    liveRegion.style.position = 'absolute';
    liveRegion.style.left = '-10000px';
    liveRegion.style.width = '1px';
    liveRegion.style.height = '1px';
    liveRegion.style.overflow = 'hidden';
    document.body.appendChild(liveRegion);
  }

  // Announce the new page
  const pageTitle = document.title;
  liveRegion.textContent = `Navigated to ${pageTitle}`;

  // Clear after announcement
  setTimeout(() => {
    if (liveRegion) {
      liveRegion.textContent = '';
    }
  }, 1000);
}

/**
 * Hook to create a skip link for keyboard navigation
 * 
 * Usage: Add this to your main App component
 */
export function useSkipLink() {
  useEffect(() => {
    // Check if skip link already exists
    if (document.getElementById('skip-link')) {
      return;
    }

    // Create skip link
    const skipLink = document.createElement('a');
    skipLink.id = 'skip-link';
    skipLink.href = '#main-content';
    skipLink.textContent = 'Skip to main content';
    skipLink.className = 'skip-link';
    
    // Style the skip link (visible on focus)
    skipLink.style.position = 'absolute';
    skipLink.style.top = '-40px';
    skipLink.style.left = '0';
    skipLink.style.background = '#3b82f6';
    skipLink.style.color = 'white';
    skipLink.style.padding = '8px 16px';
    skipLink.style.textDecoration = 'none';
    skipLink.style.zIndex = '10000';
    skipLink.style.transition = 'top 0.2s';
    
    // Show on focus
    skipLink.addEventListener('focus', () => {
      skipLink.style.top = '0';
    });
    
    skipLink.addEventListener('blur', () => {
      skipLink.style.top = '-40px';
    });

    // Add to body
    document.body.insertBefore(skipLink, document.body.firstChild);

    // Cleanup
    return () => {
      const link = document.getElementById('skip-link');
      if (link) {
        link.remove();
      }
    };
  }, []);
}

/**
 * Hook to trap focus within a modal or dialog
 */
export function useFocusTrap(isActive: boolean, containerRef: React.RefObject<HTMLElement>) {
  useEffect(() => {
    if (!isActive || !containerRef.current) {
      return;
    }

    const container = containerRef.current;
    const focusableElements = container.querySelectorAll(
      'a[href], button:not([disabled]), textarea:not([disabled]), input:not([disabled]), select:not([disabled]), [tabindex]:not([tabindex="-1"])'
    );

    const firstElement = focusableElements[0] as HTMLElement;
    const lastElement = focusableElements[focusableElements.length - 1] as HTMLElement;

    // Focus first element
    firstElement?.focus();

    const handleTabKey = (e: KeyboardEvent) => {
      if (e.key !== 'Tab') {
        return;
      }

      if (e.shiftKey) {
        // Shift + Tab
        if (document.activeElement === firstElement) {
          e.preventDefault();
          lastElement?.focus();
        }
      } else {
        // Tab
        if (document.activeElement === lastElement) {
          e.preventDefault();
          firstElement?.focus();
        }
      }
    };

    container.addEventListener('keydown', handleTabKey);

    return () => {
      container.removeEventListener('keydown', handleTabKey);
    };
  }, [isActive, containerRef]);
}


=================================================================================
FILE: src/hooks/useMicroInteractions.tsx
=================================================================================
import { useState } from 'react'

// Shake animation for errors
export function useShake() {
  const [isShaking, setIsShaking] = useState(false)

  const shake = () => {
    setIsShaking(true)
    setTimeout(() => setIsShaking(false), 500)
  }

  const shakeClass = isShaking ? 'animate-shake' : ''

  return { shake, shakeClass }
}

// Bounce animation for success states
export function useBounce() {
  const [isBouncing, setIsBouncing] = useState(false)

  const bounce = () => {
    setIsBouncing(true)
    setTimeout(() => setIsBouncing(false), 600)
  }

  const bounceClass = isBouncing ? 'animate-bounce-once' : ''

  return { bounce, bounceClass }
}

=================================================================================
FILE: src/hooks/usePrefetch.ts
=================================================================================
/**
 * Route Prefetching Hook
 *
 * Prefetches route chunks on hover or idle to improve perceived performance
 * and reduce First Input Delay (FID) for navigation.
 *
 * CRITICAL: This module must be imported AFTER React is fully initialized.
 * All hooks are guarded to prevent execution before React is ready.
 */

import { useEffect, useCallback, useRef } from 'react';
import { logger } from '../lib/logger';

// Guard to ensure React is available before using hooks
if (!useEffect) {
  throw new Error(
    'CRITICAL: React hooks not available. This indicates a module loading order issue. ' +
    'Ensure React is initialized before importing usePrefetch hooks. ' +
    'Clear cache with: npm run clean:cache'
  );
}

// Map of route paths to their lazy-loaded modules
const routeModules: Record<string, () => Promise<unknown>> = {
  '/generate': () => import('../pages/Generate'),
  '/history': () => import('../pages/History'),
  '/profile': () => import('../pages/Profile'),
  '/workout/preview': () => import('../pages/workout/Preview'),
  '/workout/run': () => import('../pages/workout/Exercise'),
  '/workout/complete': () => import('../pages/workout/Complete'),
};

// Track which routes have been prefetched
const prefetchedRoutes = new Set<string>();

/**
 * Prefetch a route's code chunk
 */
export function prefetchRoute(path: string): void {
  // Skip if already prefetched
  if (prefetchedRoutes.has(path)) {
    return;
  }

  const moduleLoader = routeModules[path];
  if (!moduleLoader) {
    return;
  }

  // Mark as prefetched immediately to prevent duplicate requests
  prefetchedRoutes.add(path);

  // Prefetch the module
  moduleLoader()
    .then(() => {
      logger.debug('Route prefetched successfully', { path });
    })
    .catch((error) => {
      // Remove from set if prefetch failed so it can be retried
      prefetchedRoutes.delete(path);
      logger.warn('Failed to prefetch route', { path, error: String(error) });
    });
}

/**
 * Hook to prefetch routes on hover
 */
export function usePrefetchOnHover(path: string) {
  const hasTriggered = useRef(false);

  const handleMouseEnter = useCallback(() => {
    if (!hasTriggered.current) {
      hasTriggered.current = true;
      prefetchRoute(path);
    }
  }, [path]);

  return { onMouseEnter: handleMouseEnter };
}

/**
 * Hook to prefetch routes on idle
 * Uses requestIdleCallback to prefetch during browser idle time
 *
 * SAFE: Includes error handling to gracefully handle React initialization issues
 */
export function usePrefetchOnIdle(paths: string[], delay = 2000) {
  try {
    useEffect(() => {
      // Wait for initial delay before starting idle prefetch
      const timeoutId = setTimeout(() => {
        // Use requestIdleCallback if available, otherwise use setTimeout
        const scheduleIdlePrefetch = (callback: () => void) => {
          if ('requestIdleCallback' in window) {
            requestIdleCallback(callback, { timeout: 5000 });
          } else {
            setTimeout(callback, 0);
          }
        };

        // Prefetch each route during idle time
        paths.forEach((path, index) => {
          scheduleIdlePrefetch(() => {
            // Stagger prefetches to avoid blocking
            setTimeout(() => {
              prefetchRoute(path);
            }, index * 100);
          });
        });
      }, delay);

      return () => clearTimeout(timeoutId);
    }, [paths, delay]);
  } catch (error) {
    if (import.meta.env.DEV) {
      console.error('usePrefetchOnIdle error:', error);
    }
    logger.warn('Route prefetching disabled due to error', { error: String(error) });
  }
}

/**
 * Hook to prefetch critical routes immediately
 *
 * SAFE: Includes error handling to gracefully handle React initialization issues
 */
export function usePrefetchCritical(paths: string[]) {
  try {
    useEffect(() => {
      // Prefetch critical routes after a short delay to not block initial render
      const timeoutId = setTimeout(() => {
        paths.forEach((path) => {
          prefetchRoute(path);
        });
      }, 100);

      return () => clearTimeout(timeoutId);
    }, [paths]);
  } catch (error) {
    if (import.meta.env.DEV) {
      console.error('usePrefetchCritical error:', error);
    }
    logger.warn('Critical route prefetching disabled due to error', { error: String(error) });
  }
}

/**
 * Clear prefetch cache (useful for testing)
 */
export function clearPrefetchCache(): void {
  prefetchedRoutes.clear();
}


=================================================================================
FILE: src/hooks/useRoutePrefetch.tsx
=================================================================================
/**
 * Route Prefetching Hook
 * 
 * Injects <link rel="prefetch"> tags for next-hop routes to improve navigation performance.
 * Prefetches route chunks based on current location and likely next routes.
 */

import { useEffect } from 'react';
import { useLocation } from 'react-router-dom';

// Map of routes to their likely next routes
const ROUTE_PREFETCH_MAP: Record<string, string[]> = {
  '/': ['/dashboard', '/onboarding'],
  '/dashboard': ['/generate', '/history', '/profile'],
  '/generate': ['/workout/preview'],
  '/workout/preview': ['/workout/run'],
  '/workout/run': ['/workout/rest', '/workout/complete'],
  '/workout/rest': ['/workout/run'],
  '/workout/complete': ['/dashboard', '/history'],
  '/history': ['/dashboard'],
  '/profile': ['/dashboard'],
  '/onboarding': ['/dashboard'],
};

// Map of routes to their module paths
const ROUTE_MODULE_MAP: Record<string, string> = {
  '/onboarding': '/src/pages/Onboarding.tsx',
  '/generate': '/src/pages/Generate.tsx',
  '/workout/preview': '/src/pages/workout/Preview.tsx',
  '/workout/run': '/src/pages/workout/Exercise.tsx',
  '/workout/rest': '/src/pages/workout/Rest.tsx',
  '/workout/complete': '/src/pages/workout/Complete.tsx',
  '/history': '/src/pages/History.tsx',
  '/profile': '/src/pages/Profile.tsx',
};

/**
 * Prefetch a route module
 */
function prefetchRoute(route: string): void {
  const modulePath = ROUTE_MODULE_MAP[route];
  if (!modulePath) return;

  // Create prefetch link
  const link = document.createElement('link');
  link.rel = 'prefetch';
  link.as = 'script';
  link.href = modulePath;

  // Check if already prefetched
  const existing = document.querySelector(`link[href="${modulePath}"]`);
  if (existing) return;

  // Add to document head
  document.head.appendChild(link);
}

/**
 * Hook to automatically prefetch next-hop routes
 */
export function useRoutePrefetch() {
  const location = useLocation();

  useEffect(() => {
    // Get likely next routes based on current location
    const nextRoutes = ROUTE_PREFETCH_MAP[location.pathname] || [];

    // Prefetch each route after a short delay
    const timeoutId = setTimeout(() => {
      nextRoutes.forEach((route) => {
        prefetchRoute(route);
      });
    }, 1000); // Wait 1s after navigation to avoid blocking main thread

    return () => clearTimeout(timeoutId);
  }, [location.pathname]);
}

/**
 * Hook to prefetch specific routes on demand
 */
export function usePrefetchRoutes(routes: string[], delay = 0) {
  useEffect(() => {
    const timeoutId = setTimeout(() => {
      routes.forEach((route) => {
        prefetchRoute(route);
      });
    }, delay);

    return () => clearTimeout(timeoutId);
  }, [routes, delay]);
}

/**
 * Prefetch routes on hover (for links)
 */
export function usePrefetchOnHover(route: string) {
  const handleMouseEnter = () => {
    prefetchRoute(route);
  };

  return { onMouseEnter: handleMouseEnter };
}


=================================================================================
FILE: src/hooks/useScrollToTop.ts
=================================================================================
import { useEffect, useLayoutEffect } from 'react';
import { useLocation } from 'react-router-dom';

/**
 * Hook that scrolls the window to the top whenever the route changes.
 * Useful for ensuring users start at the top of each new page.
 *
 * Uses useLayoutEffect to ensure scroll happens before browser paint.
 *
 * @param options - Configuration options
 * @param options.behavior - Scroll behavior: 'auto' (instant) or 'smooth'
 * @param options.enabled - Whether scrolling is enabled (default: true)
 */
export function useScrollToTop(options: {
  behavior?: 'auto' | 'smooth';
  enabled?: boolean;
} = {}) {
  const { pathname } = useLocation();
  const { behavior = 'auto', enabled = true } = options;

  // Use layoutEffect to scroll before paint
  useLayoutEffect(() => {
    if (!enabled) return;

    // Save current scroll-behavior
    const htmlScrollBehavior = document.documentElement.style.scrollBehavior;
    const bodyScrollBehavior = document.body.style.scrollBehavior;

    // Temporarily disable smooth scrolling for instant scroll
    if (behavior === 'auto') {
      document.documentElement.style.scrollBehavior = 'auto';
      document.body.style.scrollBehavior = 'auto';
    }

    // Immediate scroll - multiple methods for maximum compatibility
    window.scrollTo(0, 0);
    document.documentElement.scrollTop = 0;
    document.body.scrollTop = 0;

    // Restore scroll-behavior
    document.documentElement.style.scrollBehavior = htmlScrollBehavior;
    document.body.style.scrollBehavior = bodyScrollBehavior;

    // Also set with behavior option if smooth
    if (behavior === 'smooth') {
      try {
        window.scrollTo({
          top: 0,
          left: 0,
          behavior: 'smooth'
        });
      } catch {
        // Fallback already handled above
      }
    }
  }, [pathname, behavior, enabled]);

  // Additional effect to handle any async content loading
  useEffect(() => {
    if (!enabled) return;

    const timeoutId = setTimeout(() => {
      window.scrollTo(0, 0);
      document.documentElement.scrollTop = 0;
      document.body.scrollTop = 0;
    }, 100);

    return () => clearTimeout(timeoutId);
  }, [pathname, enabled]);
}

/**
 * Hook specifically for workout flow pages that ensures scroll to top
 * on every navigation within the workout flow.
 */
export function useWorkoutScrollToTop() {
  useScrollToTop({ behavior: 'auto', enabled: true });
}


=================================================================================
FILE: src/hooks/useUpdateToast.tsx
=================================================================================
/**
 * Service Worker Update Toast Hook
 * 
 * Provides a user-friendly toast notification when a new version of the app is available.
 * Replaces automatic reload with user-controlled update flow.
 */

import { useEffect, useState } from 'react';
import { RefreshCw, X } from 'lucide-react';

interface UpdateToastState {
  show: boolean;
  updateAvailable: boolean;
}

// eslint-disable-next-line react-refresh/only-export-components
export function useUpdateToast() {
  const [state, setState] = useState<UpdateToastState>({
    show: false,
    updateAvailable: false,
  });

  useEffect(() => {
    // Listen for SW update messages
    const handleMessage = (event: MessageEvent) => {
      if (event.data && event.data.type === 'SW_UPDATED') {
        setState({ show: true, updateAvailable: true });
      }
    };

    // Listen for BroadcastChannel updates (more reliable)
    let channel: BroadcastChannel | null = null;
    if ('BroadcastChannel' in window) {
      channel = new BroadcastChannel('sw-updates');
      channel.addEventListener('message', handleMessage);
    }

    // Also listen to traditional postMessage
    navigator.serviceWorker?.addEventListener('message', handleMessage);

    return () => {
      channel?.removeEventListener('message', handleMessage);
      channel?.close();
      navigator.serviceWorker?.removeEventListener('message', handleMessage);
    };
  }, []);

  const handleUpdate = () => {
    window.location.reload();
  };

  const handleDismiss = () => {
    setState({ show: false, updateAvailable: false });
  };

  return {
    showToast: state.show,
    updateAvailable: state.updateAvailable,
    handleUpdate,
    handleDismiss,
  };
}

/**
 * Update Toast Component
 * 
 * Displays a toast notification when an app update is available.
 */
export function UpdateToast() {
  const { showToast, handleUpdate, handleDismiss } = useUpdateToast();

  if (!showToast) return null;

  return (
    <div
      className="fixed bottom-4 left-4 right-4 sm:left-auto sm:right-4 sm:w-96 sm:max-w-[calc(100vw-2rem)] z-[9999] animate-slide-up"
      role="alert"
      aria-live="polite"
      style={{
        right: 'max(1rem, env(safe-area-inset-right))',
      }}
    >
      <div className="bg-white rounded-xl shadow-2xl border border-gray-200 p-4 flex items-start gap-3">
        {/* Icon */}
        <div className="flex-shrink-0 w-10 h-10 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-full flex items-center justify-center">
          <RefreshCw className="w-5 h-5 text-white" />
        </div>

        {/* Content */}
        <div className="flex-1 min-w-0">
          <h3 className="text-sm font-semibold text-gray-900 mb-1">
            Update Available
          </h3>
          <p className="text-sm text-gray-600 mb-3">
            A new version of NeuraFit is ready. Refresh to get the latest features and improvements.
          </p>

          {/* Actions */}
          <div className="flex gap-2">
            <button
              onClick={handleUpdate}
              className="flex-1 sm:flex-none px-4 py-2 bg-gradient-to-r from-blue-500 to-indigo-600 text-white text-sm font-medium rounded-lg hover:from-blue-600 hover:to-indigo-700 transition-all duration-200 flex items-center justify-center gap-2"
            >
              <RefreshCw className="w-4 h-4" />
              Refresh Now
            </button>
            <button
              onClick={handleDismiss}
              className="px-4 py-2 bg-gray-100 text-gray-700 text-sm font-medium rounded-lg hover:bg-gray-200 transition-colors"
            >
              Later
            </button>
          </div>
        </div>

        {/* Close button */}
        <button
          onClick={handleDismiss}
          className="flex-shrink-0 w-6 h-6 flex items-center justify-center text-gray-400 hover:text-gray-600 transition-colors"
          aria-label="Dismiss update notification"
        >
          <X className="w-4 h-4" />
        </button>
      </div>
    </div>
  );
}


=================================================================================
FILE: src/hooks/useWorkoutPreload.ts
=================================================================================
import { useState, useEffect, useCallback } from 'react'
import { auth, db } from '../lib/firebase'
import { doc, getDoc, collection, query, orderBy, limit, getDocs } from 'firebase/firestore'
import { isAdaptivePersonalizationEnabled } from '../config/features'
import { logger } from '../lib/logger'
import type { UserProfile } from '../types/profile'

export interface RecentWorkout {
  workoutType: string
  timestamp: number
  completionRate?: number
  rpe?: number
  feedback?: 'easy' | 'right' | 'hard'
  exercises: Array<{ name: string }>
}

export interface PreloadedData {
  profile: UserProfile | null
  targetIntensity: number
  progressionNote: string
  recentWorkouts: RecentWorkout[]
  isLoading: boolean
  error: string | null
}

/**
 * Custom hook to pre-load workout generation data in the background
 * This reduces the time needed when the user clicks "Generate Workout"
 * @param isGuest - If true, skip preloading (guest users don't have profile data)
 */
export function useWorkoutPreload(isGuest: boolean = false) {
  const [preloadedData, setPreloadedData] = useState<PreloadedData>({
    profile: null,
    targetIntensity: 1.0,
    progressionNote: '',
    recentWorkouts: [],
    isLoading: isGuest ? false : true,
    error: null
  })

  // Fetch recent workouts and calculate adaptive intensity
  // OPTIMIZED: Fetch last 10 workouts, but only send 5 most recent to OpenAI
  const fetchWorkoutHistory = useCallback(async (uid: string) => {
    try {
      // Get recent workouts with feedback (fetch 10 for better metrics, send 5 to API)
      const workoutsRef = collection(db, 'users', uid, 'workouts')
      const workoutsQuery = query(workoutsRef, orderBy('timestamp', 'desc'), limit(10))
      const snapshot = await getDocs(workoutsQuery)

      if (snapshot.empty) {
        return {
          targetIntensity: 1.0,
          progressionNote: '',
          recentWorkouts: []
        }
      }

      // Build optimized workout history (only essential data)
      const recentWorkouts: RecentWorkout[] = []
      let lastFeedback: 'easy' | 'right' | 'hard' | null = null
      let recentCompletionRate = 0.8 // default
      let totalSets = 0
      let completedSets = 0

      snapshot.docs.forEach(doc => {
        const workout = doc.data()

        // Build workout history entry (optimized for token efficiency)
        const workoutEntry: RecentWorkout = {
          workoutType: workout['workoutType'] || 'Unknown',
          timestamp: workout['timestamp'] || Date.now(),
          completionRate: workout['completionRate'],
          rpe: workout['rpe'],
          feedback: workout['feedback'],
          // Only include exercise names (not full details)
          exercises: (workout['exercises'] || []).map((ex: { name?: string }) => ({
            name: ex.name || 'Unknown Exercise'
          }))
        }
        recentWorkouts.push(workoutEntry)

        // Get the most recent feedback
        if (!lastFeedback && workout['feedback']) {
          lastFeedback = workout['feedback']
        }

        // Calculate completion rate from all recent workouts
        if (workout['exercises'] && Array.isArray(workout['exercises'])) {
          workout['exercises'].forEach((exercise: { sets?: number; weights?: Record<string, number | null> }) => {
            if (exercise.weights && typeof exercise.weights === 'object') {
              const setCount = exercise.sets || Object.keys(exercise.weights).length
              totalSets += setCount

              Object.values(exercise.weights).forEach((weight: number | null) => {
                if (weight !== null) {
                  completedSets++
                }
              })
            } else {
              totalSets += exercise.sets || 0
              completedSets += exercise.sets || 0
            }
          })
        }
      })

      if (totalSets > 0) {
        recentCompletionRate = completedSets / totalSets
      }

      // Calculate target intensity based on feedback and completion rate
      let targetIntensity = 1.0
      let progressionNote = ''

      if (lastFeedback) {
        switch (lastFeedback) {
          case 'easy':
            targetIntensity = Math.min(1.4, 1.0 + 0.15) // Increase difficulty
            progressionNote = 'Increasing intensity based on your recent feedback that workouts felt easy.'
            break
          case 'hard':
            targetIntensity = Math.max(0.6, 1.0 - 0.15) // Decrease difficulty
            progressionNote = 'Reducing intensity based on your recent feedback that workouts felt challenging.'
            break
          case 'right':
            // Adjust slightly based on completion rate
            if (recentCompletionRate < 0.7) {
              targetIntensity = Math.max(0.6, 1.0 - 0.1)
              progressionNote = 'Slightly reducing intensity to improve completion rate.'
            } else if (recentCompletionRate > 0.9) {
              targetIntensity = Math.min(1.4, 1.0 + 0.1)
              progressionNote = 'Slightly increasing intensity based on excellent completion rate.'
            } else {
              progressionNote = 'Maintaining current intensity level based on your feedback.'
            }
            break
        }
      } else if (recentCompletionRate < 0.6) {
        targetIntensity = Math.max(0.6, 1.0 - 0.2)
        progressionNote = 'Reducing intensity to improve workout completion rate.'
      }

      return {
        targetIntensity,
        progressionNote,
        recentWorkouts // Return optimized workout history
      }
    } catch (error) {
      logger.error('Error fetching workout history', error)
      return {
        targetIntensity: 1.0,
        progressionNote: '',
        recentWorkouts: []
      }
    }
  }, [])

  // Pre-load all necessary data
  const preloadData = useCallback(async () => {
    const uid = auth.currentUser?.uid
    if (!uid) {
      setPreloadedData(prev => ({ ...prev, isLoading: false, error: 'No user authenticated' }))
      return
    }

    try {
      setPreloadedData(prev => ({ ...prev, isLoading: true, error: null }))

      // Run profile fetch and adaptive intensity fetch in parallel
      const [profileResult, workoutHistoryResult] = await Promise.allSettled([
        // Fetch user profile
        (async () => {
          const userDocRef = doc(db, 'users', uid)
          const snap = await getDoc(userDocRef)
          if (!snap.exists()) {
            throw new Error('Profile not found')
          }
          const profile = snap.data() as UserProfile
          // Basic completeness check
          const complete = !!(profile.experience && profile.goals?.length && profile.personal?.height && profile.personal?.weight)
          if (!complete) {
            throw new Error('Profile incomplete')
          }
          return profile
        })(),
        // Fetch workout history and adaptive intensity if enabled
        isAdaptivePersonalizationEnabled()
          ? fetchWorkoutHistory(uid)
          : Promise.resolve({ targetIntensity: 1.0, progressionNote: '', recentWorkouts: [] })
      ])

      // Handle results
      let profile: UserProfile | null = null
      let targetIntensity = 1.0
      let progressionNote = ''
      let recentWorkouts: RecentWorkout[] = []
      let error: string | null = null

      if (profileResult.status === 'fulfilled') {
        profile = profileResult.value
      } else {
        error = profileResult.reason?.message || 'Failed to load profile'
      }

      if (workoutHistoryResult.status === 'fulfilled') {
        targetIntensity = workoutHistoryResult.value.targetIntensity
        progressionNote = workoutHistoryResult.value.progressionNote
        recentWorkouts = workoutHistoryResult.value.recentWorkouts
      } else {
        logger.error('Error loading workout history', workoutHistoryResult.reason)
        // Don't set error for workout history failure, use defaults
      }

      setPreloadedData({
        profile,
        targetIntensity,
        progressionNote,
        recentWorkouts,
        isLoading: false,
        error
      })

    } catch (error) {
      logger.error('Error preloading workout data', error)
      setPreloadedData(prev => ({
        ...prev,
        isLoading: false,
        error: error instanceof Error ? error.message : 'Failed to preload data'
      }))
    }
  }, [fetchWorkoutHistory])

  // Trigger preload when component mounts or user changes
  // Skip for guest users
  useEffect(() => {
    if (isGuest) {
      return
    }

    const unsubscribe = auth.onAuthStateChanged((user) => {
      if (user) {
        preloadData()
      } else {
        setPreloadedData({
          profile: null,
          targetIntensity: 1.0,
          progressionNote: '',
          recentWorkouts: [],
          isLoading: false,
          error: 'No user authenticated'
        })
      }
    })

    return unsubscribe
  }, [preloadData, isGuest])

  return {
    preloadedData,
    refreshPreloadedData: preloadData
  }
}

=================================================================================
FILE: src/index.css
=================================================================================
@import "tailwindcss";

/* Futuristic loading animations */
.bg-gradient-radial {
  background: radial-gradient(circle, var(--tw-gradient-stops));
}

/* ============================================ */
/* CRITICAL: Prevent Horizontal Scrolling */
/* ============================================ */
* {
  /* Prevent any element from causing horizontal overflow */
  max-width: 100%;
}

html,
body {
  /* Prevent horizontal scrolling at root level */
  overflow-x: hidden;
  width: 100%;
  max-width: 100vw;
  position: relative;
}

/* Ensure all containers respect viewport width */
#root {
  overflow-x: hidden;
  width: 100%;
  max-width: 100vw;
}

/* Enhanced Mobile-First Design System */

/* Touch-friendly interactions */
@media (hover: none) and (pointer: coarse) {
  /* Mobile devices - increase touch targets */
  button,
  [role="button"],
  input[type="button"],
  input[type="submit"] {
    min-height: 44px;
    min-width: 44px;
  }

  /* Remove hover effects on touch devices */
  .hover\:scale-105:hover {
    transform: none;
  }

  /* Enhanced tap targets for links */
  a {
    min-height: 44px;
    display: inline-flex;
    align-items: center;
  }
}

/* Improved focus states for accessibility */
*:focus-visible {
  outline: 2px solid #3b82f6;
  outline-offset: 2px;
  border-radius: 4px;
}

/* Smooth scrolling for better UX */
html {
  scroll-behavior: smooth;
  /* Fix mobile viewport height issues */
  height: 100%;
  height: -webkit-fill-available;
}

/* Mobile-friendly viewport height that accounts for iOS safe areas */
.min-h-screen-mobile {
  min-height: 100vh;
  min-height: -webkit-fill-available;
  /* Ensure content fills the viewport properly on iOS */
  display: flex;
  flex-direction: column;
}

/* Touch target optimization - ensure minimum 44x44px for all interactive elements */
button,
a,
input[type="button"],
input[type="submit"],
input[type="reset"],
[role="button"],
[role="link"] {
  min-height: 44px;
  min-width: 44px;
}

/* Touch-friendly spacing for mobile */
@media (max-width: 768px) {
  button,
  a.button,
  [role="button"] {
    padding: 12px 16px;
  }
}

/* Custom utility classes for common patterns */
.card {
  background-color: white;
  border-radius: 1rem;
  box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
  padding: 1.5rem;
}

/* Standardized gradient utility classes */
.gradient-primary {
  background: linear-gradient(to bottom right, rgb(59 130 246) 0%, rgb(79 70 229) 100%);
}

.gradient-primary-hover {
  background: linear-gradient(to bottom right, rgb(37 99 235) 0%, rgb(67 56 202) 100%);
}

.gradient-success {
  background: linear-gradient(to bottom right, rgb(34 197 94) 0%, rgb(16 185 129) 100%);
}

.gradient-success-hover {
  background: linear-gradient(to bottom right, rgb(22 163 74) 0%, rgb(5 150 105) 100%);
}

.gradient-danger {
  background: linear-gradient(to bottom right, rgb(239 68 68) 0%, rgb(244 63 94) 100%);
}

.gradient-danger-hover {
  background: linear-gradient(to bottom right, rgb(220 38 38) 0%, rgb(225 29 72) 100%);
}

.gradient-warning {
  background: linear-gradient(to bottom right, rgb(245 158 11) 0%, rgb(249 115 22) 100%);
}

.gradient-warning-hover {
  background: linear-gradient(to bottom right, rgb(217 119 6) 0%, rgb(234 88 12) 100%);
}

.card-hover {
  background-color: white;
  border-radius: 1rem;
  box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
  padding: 1.5rem;
  transition: all 0.2s;
}

.card-hover:hover {
  box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
  transform: scale(1.01);
}

.gradient-bg {
  background: linear-gradient(to bottom right, rgb(249 250 251), rgb(243 244 246));
}

/* Enhanced safe area support for mobile devices (iOS notch/status bar) */
@supports (padding: max(0px)) {
  .safe-area-inset-top {
    padding-top: max(1rem, env(safe-area-inset-top));
  }

  .safe-area-inset-bottom {
    padding-bottom: max(1rem, env(safe-area-inset-bottom));
  }

  .safe-area-inset-left {
    padding-left: max(1rem, env(safe-area-inset-left));
  }

  .safe-area-inset-right {
    padding-right: max(1rem, env(safe-area-inset-right));
  }

  /* Additional safe area utilities for specific use cases */
  .safe-top {
    padding-top: env(safe-area-inset-top);
  }

  .safe-bottom {
    padding-bottom: env(safe-area-inset-bottom);
  }

  .safe-left {
    padding-left: env(safe-area-inset-left);
  }

  .safe-right {
    padding-right: env(safe-area-inset-right);
  }

  /* Margin variants for safe areas */
  .safe-mt {
    margin-top: env(safe-area-inset-top);
  }

  .safe-mb {
    margin-bottom: env(safe-area-inset-bottom);
  }

  /* iOS PWA specific: Ensure fixed elements respect safe areas */
  .fixed-bottom-safe {
    padding-bottom: max(1rem, env(safe-area-inset-bottom));
  }

  .fixed-top-safe {
    padding-top: max(0.5rem, env(safe-area-inset-top));
  }

  /* Prevent fixed/absolute positioned elements from causing horizontal overflow */
  .fixed-safe-right {
    right: max(1rem, env(safe-area-inset-right));
    max-width: calc(100vw - max(2rem, env(safe-area-inset-left) + env(safe-area-inset-right)));
  }

  .fixed-safe-left {
    left: max(1rem, env(safe-area-inset-left));
    max-width: calc(100vw - max(2rem, env(safe-area-inset-left) + env(safe-area-inset-right)));
  }
}

/* Improved text rendering */
body {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-rendering: optimizeLegibility;
  /* Enable momentum scrolling on iOS */
  -webkit-overflow-scrolling: touch;
  /* Improve scroll performance */
  scroll-behavior: smooth;
  /* Prevent iOS Safari from adjusting font size */
  -webkit-text-size-adjust: 100%;
  /* Ensure body takes full height on iOS */
  position: relative;
}

/* Smooth scrolling for all scrollable elements */
* {
  -webkit-overflow-scrolling: touch;
}

/* Better button and input styling */
button,
input,
select,
textarea {
  font-family: inherit;
}

/* Fix iOS Safari dark screen issue on input focus */
input,
textarea {
  -webkit-appearance: none;
  -webkit-tap-highlight-color: transparent;
}

/* Improve touch feedback for interactive elements */
button:active,
a:active,
[role="button"]:active {
  transform: scale(0.98);
  transition: transform 0.1s ease;
}

/* Prevent text selection on interactive elements during touch */
button,
a,
[role="button"] {
  -webkit-user-select: none;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation; /* Prevents double-tap zoom */
}

/* Allow text selection in inputs */
input,
textarea,
[contenteditable] {
  -webkit-user-select: text;
  user-select: text;
}

/* Touch-friendly minimum tap target sizes */
button,
a {
  min-height: 44px;
  min-width: 44px;
}

/* Prevent iOS zoom on input focus while maintaining accessibility */
@media screen and (max-width: 768px) {
  input[type="text"],
  input[type="email"],
  input[type="password"],
  input[type="number"],
  textarea,
  select {
    font-size: 16px; /* Prevents zoom on iOS */
  }
}

/* Enhanced loading states */
@keyframes pulse-subtle {
  0%,
  100% {
    opacity: 1;
  }
  50% {
    opacity: 0.8;
  }
}

.pulse-subtle {
  animation: pulse-subtle 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

/* Shimmer effect for skeleton loaders */
@keyframes shimmer {
  0% {
    transform: translateX(-100%);
  }
  100% {
    transform: translateX(100%);
  }
}

.animate-shimmer {
  animation: shimmer 2s infinite;
}

/* Enhanced animations for premium feel */
@keyframes float {
  0%, 100% {
    transform: translateY(0px);
  }
  50% {
    transform: translateY(-10px);
  }
}

@keyframes glow {
  0%, 100% {
    opacity: 0.5;
  }
  50% {
    opacity: 1;
  }
}

@keyframes slide-in-up {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slide-up {
  from {
    opacity: 0;
    transform: translateY(100%);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.animate-float {
  animation: float 6s ease-in-out infinite;
  will-change: transform;
}

.animate-glow {
  animation: glow 2s ease-in-out infinite;
}

.animate-slide-in-up {
  animation: slide-in-up 0.5s ease-out;
  will-change: transform, opacity;
}

.animate-slide-up {
  animation: slide-up 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  will-change: transform;
}

@keyframes loading-progress {
  0% {
    transform: translateX(-100%);
    opacity: 0.6;
  }
  50% {
    opacity: 1;
  }
  100% {
    transform: translateX(0%);
    opacity: 0.8;
  }
}

@keyframes breathe {
  0%, 100% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.02);
  }
}

.animate-breathe {
  animation: breathe 3s ease-in-out infinite;
}

/* Safe area padding for devices with home indicators */
.pb-safe {
  padding-bottom: env(safe-area-inset-bottom, 0.75rem);
}

/* Extra small screen responsive utilities - 375px to 428px phones */
@media (min-width: 375px) {
  /* Spacing utilities for xs breakpoint */
  .xs\:px-1 { padding-left: 0.25rem; padding-right: 0.25rem; }
  .xs\:px-2 { padding-left: 0.5rem; padding-right: 0.5rem; }
  .xs\:px-3 { padding-left: 0.75rem; padding-right: 0.75rem; }
  .xs\:px-4 { padding-left: 1rem; padding-right: 1rem; }
  .xs\:px-5 { padding-left: 1.25rem; padding-right: 1.25rem; }
  .xs\:py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
  .xs\:py-2\.5 { padding-top: 0.625rem; padding-bottom: 0.625rem; }
  .xs\:py-4 { padding-top: 1rem; padding-bottom: 1rem; }
  .xs\:py-4\.5 { padding-top: 1.125rem; padding-bottom: 1.125rem; }
  .xs\:py-10 { padding-top: 2.5rem; padding-bottom: 2.5rem; }
  .xs\:pt-1 { padding-top: 0.25rem; }
  .xs\:pt-2 { padding-top: 0.5rem; }
  .xs\:pt-9 { padding-top: 2.25rem; }
  .xs\:pb-safe { padding-bottom: env(safe-area-inset-bottom, 0.75rem); }

  /* Margin utilities */
  .xs\:mb-1\.5 { margin-bottom: 0.375rem; }
  .xs\:mb-2 { margin-bottom: 0.5rem; }
  .xs\:mb-3 { margin-bottom: 0.75rem; }
  .xs\:mb-4 { margin-bottom: 1rem; }
  .xs\:mb-7 { margin-bottom: 1.75rem; }
  .xs\:mb-9 { margin-bottom: 2.25rem; }
  .xs\:mb-12 { margin-bottom: 3rem; }
  .xs\:mb-14 { margin-bottom: 3.5rem; }
  .xs\:mt-0\.5 { margin-top: 0.125rem; }
  .xs\:mt-2 { margin-top: 0.5rem; }
  .xs\:gap-1\.5 { gap: 0.375rem; }
  .xs\:gap-2 { gap: 0.5rem; }
  .xs\:gap-2\.5 { gap: 0.625rem; }
  .xs\:gap-3 { gap: 0.75rem; }
  .xs\:gap-4 { gap: 1rem; }
  .xs\:gap-4\.5 { gap: 1.125rem; }

  /* Size utilities */
  .xs\:h-3\.5 { height: 0.875rem; }
  .xs\:h-4 { height: 1rem; }
  .xs\:h-4\.5 { height: 1.125rem; }
  .xs\:h-5 { height: 1.25rem; }
  .xs\:h-5\.5 { height: 1.375rem; }
  .xs\:h-7 { height: 1.75rem; }
  .xs\:h-7\.5 { height: 1.875rem; }
  .xs\:h-14 { height: 3.5rem; }
  .xs\:h-15 { height: 3.75rem; }
  .xs\:w-3\.5 { width: 0.875rem; }
  .xs\:w-4 { width: 1rem; }
  .xs\:w-4\.5 { width: 1.125rem; }
  .xs\:w-5 { width: 1.25rem; }
  .xs\:w-5\.5 { width: 1.375rem; }
  .xs\:w-7 { width: 1.75rem; }
  .xs\:w-7\.5 { width: 1.875rem; }
  .xs\:w-14 { width: 3.5rem; }
  .xs\:w-15 { width: 3.75rem; }
  .xs\:min-h-\[48px\] { min-height: 48px; }
  .xs\:min-h-\[56px\] { min-height: 56px; }

  /* Text utilities */
  .xs\:text-\[10px\] { font-size: 10px; }
  .xs\:text-\[11px\] { font-size: 11px; }
  .xs\:text-xs { font-size: 0.75rem; }
  .xs\:text-sm { font-size: 0.875rem; }
  .xs\:text-base { font-size: 1rem; }
  .xs\:text-lg { font-size: 1.125rem; }
  .xs\:text-2\.5xl { font-size: 1.75rem; }
  .xs\:text-3\.5xl { font-size: 2rem; }
  .xs\:leading-\[1\.12\] { line-height: 1.12; }

  /* Border radius */
  .xs\:rounded-lg { border-radius: 0.5rem; }
  .xs\:rounded-xl { border-radius: 0.75rem; }
  .xs\:rounded-2xl { border-radius: 1rem; }
  .xs\:rounded-2\.5xl { border-radius: 1.125rem; }
  .xs\:rounded-\[16px\] { border-radius: 16px; }
  .xs\:rounded-\[18px\] { border-radius: 18px; }
  .xs\:rounded-\[20px\] { border-radius: 20px; }

  /* Display utilities */
  .xs\:inline { display: inline; }
  .xs\:hidden { display: none; }
  .xs\:flex { display: flex; }
  .xs\:block { display: block; }
}

/* Improved gesture support */
.touch-manipulation {
  touch-action: manipulation;
}

.touch-pan-x {
  touch-action: pan-x;
}

.touch-pan-y {
  touch-action: pan-y;
}

/* Enhanced backdrop blur support */
@supports (backdrop-filter: blur(10px)) {
  .backdrop-blur-enhanced {
    backdrop-filter: blur(10px) saturate(180%);
    background-color: rgba(255, 255, 255, 0.8);
  }
}

@supports not (backdrop-filter: blur(10px)) {
  .backdrop-blur-enhanced {
    background-color: rgba(255, 255, 255, 0.95);
  }
}

/* Landscape warning overlay for mobile devices */
.landscape-warning {
  position: relative;
}

.landscape-warning::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.9);
  z-index: 9999;
  display: none;
}

.landscape-warning::after {
  content: 'Please rotate your device to portrait mode for the best experience';
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  text-align: center;
  font-size: 18px;
  font-weight: 600;
  padding: 20px;
  z-index: 10000;
  display: none;
  max-width: 80%;
}

/* Only show landscape warning on phones, not tablets */
@media screen and (orientation: landscape) and (max-width: 667px) and (max-height: 414px) {
  .landscape-warning::before,
  .landscape-warning::after {
    display: block;
  }
}

/* Improved dark mode support (future-proofing) */
@media (prefers-color-scheme: dark) {
  :root {
    --bg-primary: #1f2937;
    --bg-secondary: #374151;
    --text-primary: #f9fafb;
    --text-secondary: #d1d5db;
  }
}

/* Better print styles */
@media print {
  .no-print {
    display: none !important;
  }

  * {
    background: transparent !important;
    color: black !important;
    box-shadow: none !important;
    text-shadow: none !important;
  }
}

.animate-shimmer {
  animation: shimmer 2s ease-in-out infinite;
}

.animate-shimmer-slow {
  animation: shimmer 3s ease-in-out infinite;
}

.animate-shimmer-fast {
  animation: shimmer 1s ease-in-out infinite;
}

/* Advanced Micro-Interactions */

/* Fade in up animation */
@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translate3d(0, 30px, 0);
  }
  to {
    opacity: 1;
    transform: translate3d(0, 0, 0);
  }
}

.animate-fade-in-up {
  animation: fadeInUp 0.6s cubic-bezier(0.4, 0, 0.2, 1) forwards;
}

/* Shake animation for errors */
@keyframes shake {
  0%,
  100% {
    transform: translateX(0);
  }
  10%,
  30%,
  50%,
  70%,
  90% {
    transform: translateX(-4px);
  }
  20%,
  40%,
  60%,
  80% {
    transform: translateX(4px);
  }
}

.animate-shake {
  animation: shake 0.5s cubic-bezier(0.36, 0.07, 0.19, 0.97);
}

/* Bounce once animation */
@keyframes bounceOnce {
  0%,
  20%,
  53%,
  80%,
  100% {
    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
    transform: translate3d(0, 0, 0);
  }
  40%,
  43% {
    animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);
    transform: translate3d(0, -15px, 0);
  }
  70% {
    animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);
    transform: translate3d(0, -7px, 0);
  }
  90% {
    transform: translate3d(0, -2px, 0);
  }
}

.animate-bounce-once {
  animation: bounceOnce 0.6s ease-out;
}

/* Scale in animation */
@keyframes scaleIn {
  from {
    opacity: 0;
    transform: scale(0.9);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

.animate-scale-in {
  animation: scaleIn 0.2s cubic-bezier(0.4, 0, 0.2, 1);
}

/* Slide in from right */
@keyframes slideInRight {
  from {
    opacity: 0;
    transform: translateX(100%);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

.animate-slide-in-right {
  animation: slideInRight 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

/* ========================================
   ENHANCED DESIGN SYSTEM
   ======================================== */

/* Staggered Animation System */
@keyframes staggerFadeIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.animate-stagger-1 {
  animation: staggerFadeIn 0.6s cubic-bezier(0.4, 0, 0.2, 1) 0.1s both;
}

.animate-stagger-2 {
  animation: staggerFadeIn 0.6s cubic-bezier(0.4, 0, 0.2, 1) 0.2s both;
}

.animate-stagger-3 {
  animation: staggerFadeIn 0.6s cubic-bezier(0.4, 0, 0.2, 1) 0.3s both;
}

.animate-stagger-4 {
  animation: staggerFadeIn 0.6s cubic-bezier(0.4, 0, 0.2, 1) 0.4s both;
}

.animate-stagger-5 {
  animation: staggerFadeIn 0.6s cubic-bezier(0.4, 0, 0.2, 1) 0.5s both;
}

/* Reduced Motion Support */
@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }

  .animate-stagger-1,
  .animate-stagger-2,
  .animate-stagger-3,
  .animate-stagger-4,
  .animate-stagger-5 {
    animation: none;
    opacity: 1;
    transform: none;
  }
}

/* Enhanced Shadow System - Multi-layer depth */
.shadow-depth-sm {
  box-shadow:
    0 1px 2px rgba(0, 0, 0, 0.04),
    0 2px 4px rgba(0, 0, 0, 0.04),
    0 4px 8px rgba(0, 0, 0, 0.04);
}

.shadow-depth-md {
  box-shadow:
    0 2px 4px rgba(0, 0, 0, 0.04),
    0 4px 8px rgba(0, 0, 0, 0.06),
    0 8px 16px rgba(0, 0, 0, 0.08);
}

.shadow-depth-lg {
  box-shadow:
    0 2px 8px rgba(0, 0, 0, 0.04),
    0 8px 24px rgba(0, 0, 0, 0.06),
    0 16px 48px rgba(0, 0, 0, 0.08);
}

.shadow-depth-xl {
  box-shadow:
    0 4px 12px rgba(0, 0, 0, 0.05),
    0 12px 32px rgba(0, 0, 0, 0.08),
    0 24px 64px rgba(0, 0, 0, 0.12);
}

/* Colored shadow variants for cards */
.shadow-blue-depth {
  box-shadow:
    0 2px 8px rgba(59, 130, 246, 0.08),
    0 8px 24px rgba(59, 130, 246, 0.12),
    0 16px 48px rgba(59, 130, 246, 0.16);
}

.shadow-slate-depth {
  box-shadow:
    0 2px 8px rgba(100, 116, 139, 0.06),
    0 8px 24px rgba(100, 116, 139, 0.08),
    0 16px 48px rgba(100, 116, 139, 0.10);
}

.shadow-indigo-depth {
  box-shadow:
    0 2px 8px rgba(99, 102, 241, 0.08),
    0 8px 24px rgba(99, 102, 241, 0.12),
    0 16px 48px rgba(99, 102, 241, 0.16);
}

/* Inner border effect for depth */
.border-inner {
  position: relative;
}

.border-inner::before {
  content: '';
  position: absolute;
  inset: 0;
  border-radius: inherit;
  border: 1px solid rgba(255, 255, 255, 0.4);
  pointer-events: none;
}

/* Sophisticated color tints */
.bg-tint-blue {
  background: linear-gradient(135deg,
    rgba(255, 255, 255, 0.98) 0%,
    rgba(239, 246, 255, 0.95) 50%,
    rgba(255, 255, 255, 0.98) 100%);
}

.bg-tint-slate {
  background: linear-gradient(135deg,
    rgba(255, 255, 255, 0.98) 0%,
    rgba(248, 250, 252, 0.95) 50%,
    rgba(255, 255, 255, 0.98) 100%);
}

.bg-tint-indigo {
  background: linear-gradient(135deg,
    rgba(255, 255, 255, 0.98) 0%,
    rgba(238, 242, 255, 0.95) 50%,
    rgba(255, 255, 255, 0.98) 100%);
}

/* Button micro-interaction enhancements */
.btn-press-effect {
  transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
}

.btn-press-effect:active {
  transform: scale(0.97);
}

/* Haptic-like feedback */
@keyframes hapticPulse {
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(0.98);
  }
  100% {
    transform: scale(1);
  }
}

.haptic-feedback:active {
  animation: hapticPulse 0.2s cubic-bezier(0.4, 0, 0.2, 1);
}

/* Gradient animation for hero text - Premium effect */
@keyframes gradient-x {
  0%, 100% {
    background-position: 0% 50%;
  }
  50% {
    background-position: 100% 50%;
  }
}

.animate-gradient-x {
  background-size: 200% 200%;
  animation: gradient-x 8s ease infinite;
}

/* Enhanced floating animation with will-change for performance */
@keyframes float-enhanced {
  0%, 100% {
    transform: translateY(0px);
  }
  50% {
    transform: translateY(-20px);
  }
}

.animate-float-enhanced {
  animation: float-enhanced 6s ease-in-out infinite;
  will-change: transform;
}

/* Smooth fade in animation */
@keyframes fade-in {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

.animate-fade-in {
  animation: fade-in 0.3s ease-out;
}

/* Button press feedback animation */
@keyframes button-press {
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(0.98);
  }
  100% {
    transform: scale(1);
  }
}

.animate-button-press {
  animation: button-press 0.2s cubic-bezier(0.4, 0, 0.2, 1);
}

/* Smooth scale animation for modals */
@keyframes scale-in-smooth {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

.animate-scale-in-smooth {
  animation: scale-in-smooth 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

/* Enhanced focus ring animation */
@keyframes focus-ring {
  0% {
    box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4);
  }
  70% {
    box-shadow: 0 0 0 6px rgba(59, 130, 246, 0);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(59, 130, 246, 0);
  }
}

.focus-ring-animation:focus {
  animation: focus-ring 0.6s ease-out;
}

/* Smooth color transition for interactive elements */
.transition-colors-smooth {
  transition: color 0.3s cubic-bezier(0.4, 0, 0.2, 1),
              background-color 0.3s cubic-bezier(0.4, 0, 0.2, 1),
              border-color 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

/* Enhanced shadow transition */
.transition-shadow-smooth {
  transition: box-shadow 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

/* Prevent layout shift on button hover */
.button-stable-hover {
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.button-stable-hover:hover {
  transform: translateY(-1px);
}

/* Improved contrast for accessibility */
.high-contrast-text {
  color: #1f2937; /* gray-900 */
  font-weight: 500;
}

/* Better focus states for keyboard navigation */
.focus-visible-enhanced:focus-visible {
  outline: 2px solid #3b82f6;
  outline-offset: 3px;
  border-radius: 4px;
}

/* Slide in animation for onboarding steps */
@keyframes slide-in-up {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.animate-slide-in-up {
  animation: slide-in-up 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

/* Pulse animation for progress indicator */
@keyframes pulse-subtle {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.7;
  }
}

.animate-pulse-subtle {
  animation: pulse-subtle 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

/* Smooth height transition for step content */
.transition-height-smooth {
  transition: height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

/* Reduced motion support for accessibility */
@media (prefers-reduced-motion: reduce) {
  .animate-float-enhanced,
  .animate-fade-in,
  .animate-button-press,
  .animate-scale-in-smooth,
  .animate-slide-in-up,
  .animate-pulse-subtle,
  .focus-ring-animation:focus,
  .button-stable-hover:hover {
    animation: none;
    transition: none;
  }
}
=================================================================================
FILE: src/lib/__tests__/cache-manager.test.ts
=================================================================================
/**
 * Cache Manager Tests
 *
 * Tests for version detection, cache invalidation, and recovery
 */

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import {
  getCurrentAppVersion,
  checkVersionMismatch,
  clearAllCaches,
  getVersionInfo,
} from '../cache-manager';

// eslint-disable-next-line @typescript-eslint/no-explicit-any
declare const global: any;

describe('Cache Manager', () => {
  beforeEach(() => {
    // Clear localStorage before each test
    localStorage.clear();
    sessionStorage.clear();

    // Mock the root element
    const root = document.createElement('div');
    root.id = 'root';
    root.setAttribute('data-version', '1.0.17');
    root.setAttribute('data-build-time', '2025-10-16T12:00:00.000Z');
    document.body.appendChild(root);

    // Mock fetch for manifest
    global.fetch = vi.fn();
  });

  afterEach(() => {
    const root = document.getElementById('root');
    if (root) {
      root.remove();
    }
    vi.clearAllMocks();
  });

  describe('getCurrentAppVersion', () => {
    it('should return version from root element', () => {
      const version = getCurrentAppVersion();
      expect(version).toBe('1.0.17');
    });

    it('should return "unknown" if root element missing', () => {
      const root = document.getElementById('root');
      if (root) root.remove();
      const version = getCurrentAppVersion();
      expect(version).toBe('unknown');
    });
  });

  describe('checkVersionMismatch', () => {
    it('should return false on first visit', async () => {
      const result = await checkVersionMismatch();
      expect(result).toBe(false);
      expect(localStorage.getItem('app-version')).toBe('1.0.17');
    });

    it('should return false when versions match', async () => {
      localStorage.setItem('app-version', '1.0.17');
      const result = await checkVersionMismatch();
      expect(result).toBe(false);
    });

    it('should return true when version changes', async () => {
      localStorage.setItem('app-version', '1.0.16');

      const result = await checkVersionMismatch();
      expect(result).toBe(true);
      expect(localStorage.getItem('app-version')).toBe('1.0.17');
    });

    it('should update stored version after mismatch', async () => {
      localStorage.setItem('app-version', '1.0.16');
      await checkVersionMismatch();
      expect(localStorage.getItem('app-version')).toBe('1.0.17');
    });
  });

  describe('getVersionInfo', () => {
    it('should return version info object', () => {
      const info = getVersionInfo();
      expect(info).toHaveProperty('appVersion');
      expect(info).toHaveProperty('buildTime');
      expect(info.appVersion).toBe('1.0.17');
    });

    it('should include manifest ETag if stored', async () => {
      localStorage.setItem('manifest-etag', 'abc123');
      const info = getVersionInfo();
      expect(info.manifestETag).toBe('abc123');
    });
  });

  describe('clearAllCaches', () => {
    it('should clear localStorage', async () => {
      localStorage.setItem('test-key', 'test-value');
      await clearAllCaches();
      expect(localStorage.getItem('test-key')).toBeNull();
    });

    it('should clear sessionStorage', async () => {
      sessionStorage.setItem('test-key', 'test-value');
      await clearAllCaches();
      expect(sessionStorage.getItem('test-key')).toBeNull();
    });

    it('should set cache-cleared timestamp', async () => {
      await clearAllCaches();
      const timestamp = localStorage.getItem('cache-cleared-at');
      expect(timestamp).toBeTruthy();
      expect(new Date(timestamp!).getTime()).toBeGreaterThan(0);
    });
  });

  describe('Integration', () => {
    it('should handle version update flow', async () => {
      // First visit
      let result = await checkVersionMismatch();
      expect(result).toBe(false);
      expect(localStorage.getItem('app-version')).toBe('1.0.17');

      // Simulate version change
      const root = document.getElementById('root');
      if (root) {
        root.setAttribute('data-version', '1.0.18');
      }

      // Second check detects mismatch
      result = await checkVersionMismatch();
      expect(result).toBe(true);
      expect(localStorage.getItem('app-version')).toBe('1.0.18');
    });
  });
});


=================================================================================
FILE: src/lib/__tests__/errors.test.ts
=================================================================================
/**
 * Tests for Error Handling System
 */

import { describe, it, expect, vi, beforeEach } from 'vitest'
import {
  AppError,
  AuthError,
  NetworkError,
  ValidationError,
  WorkoutGenerationError,
  TimeoutError,
  OfflineError,
  ErrorHandler,
  retryWithBackoff
} from '../errors'

describe('AppError', () => {
  it('should create an AppError with all properties', () => {
    const error = new AppError(
      'Test error',
      'UNKNOWN_ERROR',
      'medium',
      'User friendly message',
      { component: 'Test' }
    )

    expect(error.message).toBe('Test error')
    expect(error.code).toBe('UNKNOWN_ERROR')
    expect(error.severity).toBe('medium')
    expect(error.userMessage).toBe('User friendly message')
    expect(error.context.component).toBe('Test')
    expect(error.retryable).toBe(false)
  })

  it('should convert to JSON correctly', () => {
    const error = new AppError(
      'Test error',
      'NETWORK_ERROR',
      'high',
      'Network failed',
      { userId: '123' }
    )

    const json = error.toJSON()

    expect(json.name).toBe('AppError')
    expect(json.message).toBe('Test error')
    expect(json.code).toBe('NETWORK_ERROR')
    expect(json.severity).toBe('high')
    expect(json.userMessage).toBe('Network failed')
    expect(json.context.userId).toBe('123')
  })
})

describe('Specific Error Classes', () => {
  it('should create AuthError with correct defaults', () => {
    const error = new AuthError('Auth failed')

    expect(error.code).toBe('AUTH_ERROR')
    expect(error.severity).toBe('high')
    expect(error.retryable).toBe(false)
  })

  it('should create NetworkError with correct defaults', () => {
    const error = new NetworkError('Network failed')

    expect(error.code).toBe('NETWORK_ERROR')
    expect(error.severity).toBe('medium')
    expect(error.retryable).toBe(true)
  })

  it('should create ValidationError with correct defaults', () => {
    const error = new ValidationError('Invalid input', 'Please check your input')

    expect(error.code).toBe('VALIDATION_ERROR')
    expect(error.severity).toBe('low')
    expect(error.retryable).toBe(false)
  })

  it('should create WorkoutGenerationError with correct defaults', () => {
    const error = new WorkoutGenerationError('Generation failed')

    expect(error.code).toBe('WORKOUT_GENERATION_ERROR')
    expect(error.severity).toBe('high')
    expect(error.retryable).toBe(true)
  })

  it('should create TimeoutError with correct defaults', () => {
    const error = new TimeoutError('Request timed out')

    expect(error.code).toBe('TIMEOUT_ERROR')
    expect(error.severity).toBe('medium')
    expect(error.retryable).toBe(true)
  })

  it('should create OfflineError with correct defaults', () => {
    const error = new OfflineError('You are offline')

    expect(error.code).toBe('OFFLINE_ERROR')
    expect(error.severity).toBe('medium')
    expect(error.retryable).toBe(true)
  })
})

describe('ErrorHandler', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('should handle AppError correctly', () => {
    const error = new NetworkError('Network failed')
    const handled = ErrorHandler.handle(error)

    expect(handled).toBe(error)
    expect(handled.code).toBe('NETWORK_ERROR')
  })

  it('should convert regular Error to AppError', () => {
    const error = new Error('Regular error')
    const handled = ErrorHandler.handle(error)

    expect(handled).toBeInstanceOf(AppError)
    expect(handled.code).toBe('UNKNOWN_ERROR')
    expect(handled.originalError).toBe(error)
  })

  it('should normalize unknown errors', () => {
    const error = 'String error'
    const normalized = ErrorHandler.normalize(error)

    expect(normalized).toBeInstanceOf(AppError)
    expect(normalized.message).toBe('String error')
  })

  it('should detect retryable errors', () => {
    const networkError = new NetworkError('Network failed')
    const authError = new AuthError('Auth failed')

    expect(ErrorHandler.isRetryable(networkError)).toBe(true)
    expect(ErrorHandler.isRetryable(authError)).toBe(false)
  })

  it('should detect retryable errors by message', () => {
    const error = new Error('Network timeout occurred')

    expect(ErrorHandler.isRetryable(error)).toBe(true)
  })
})

describe('retryWithBackoff', () => {
  it('should succeed on first try', async () => {
    const fn = vi.fn().mockResolvedValue('success')

    const result = await retryWithBackoff(fn, { maxRetries: 3 })

    expect(result).toBe('success')
    expect(fn).toHaveBeenCalledTimes(1)
  })

  it('should retry on failure', async () => {
    const fn = vi.fn()
      .mockRejectedValueOnce(new NetworkError('Failed'))
      .mockResolvedValue('success')

    const result = await retryWithBackoff(fn, {
      maxRetries: 3,
      baseDelay: 10
    })

    expect(result).toBe('success')
    expect(fn).toHaveBeenCalledTimes(2)
  })

  it('should not retry non-retryable errors', async () => {
    const fn = vi.fn().mockRejectedValue(new AuthError('Auth failed'))

    await expect(
      retryWithBackoff(fn, { maxRetries: 3, baseDelay: 10 })
    ).rejects.toThrow('Auth failed')

    expect(fn).toHaveBeenCalledTimes(1)
  })

  it('should call onRetry callback', async () => {
    const fn = vi.fn()
      .mockRejectedValueOnce(new NetworkError('Failed'))
      .mockResolvedValue('success')

    const onRetry = vi.fn()

    await retryWithBackoff(fn, {
      maxRetries: 3,
      baseDelay: 10,
      onRetry
    })

    expect(onRetry).toHaveBeenCalledTimes(1)
    expect(onRetry).toHaveBeenCalledWith(1, expect.any(NetworkError))
  })

  it('should throw after max retries', async () => {
    const fn = vi.fn().mockRejectedValue(new NetworkError('Failed'))

    await expect(
      retryWithBackoff(fn, { maxRetries: 2, baseDelay: 10 })
    ).rejects.toThrow('Failed')

    expect(fn).toHaveBeenCalledTimes(3) // Initial + 2 retries
  })
})


=================================================================================
FILE: src/lib/__tests__/requestManager.test.ts
=================================================================================
/**
 * Tests for Request Manager
 */

import { describe, it, expect, vi, beforeEach } from 'vitest'
import {
  dedupedFetch,
  createManagedFetch,
  clearRequestCache,
  clearCacheEntry,
  getCacheStats,
  cleanupExpiredCache
} from '../requestManager'

describe('dedupedFetch', () => {
  beforeEach(() => {
    clearRequestCache()
  })

  it('should deduplicate concurrent requests', async () => {
    const fetcher = vi.fn().mockResolvedValue('result')

    // Make two concurrent requests with the same key
    const [result1, result2] = await Promise.all([
      dedupedFetch('test-key', fetcher),
      dedupedFetch('test-key', fetcher)
    ])

    expect(result1).toBe('result')
    expect(result2).toBe('result')
    expect(fetcher).toHaveBeenCalledTimes(1) // Only called once
  })

  it('should cache results with TTL', async () => {
    const fetcher = vi.fn().mockResolvedValue('result')

    // First call
    const result1 = await dedupedFetch('test-key', fetcher, { cacheTTL: 5000 })
    
    // Second call should use cache
    const result2 = await dedupedFetch('test-key', fetcher, { cacheTTL: 5000 })

    expect(result1).toBe('result')
    expect(result2).toBe('result')
    expect(fetcher).toHaveBeenCalledTimes(1)
  })

  it('should bypass cache with forceRefresh', async () => {
    const fetcher = vi.fn()
      .mockResolvedValueOnce('result1')
      .mockResolvedValueOnce('result2')

    // First call
    await dedupedFetch('test-key', fetcher, { cacheTTL: 5000 })
    
    // Second call with forceRefresh
    const result = await dedupedFetch('test-key', fetcher, {
      cacheTTL: 5000,
      forceRefresh: true
    })

    expect(result).toBe('result2')
    expect(fetcher).toHaveBeenCalledTimes(2)
  })

  it('should handle errors correctly', async () => {
    const fetcher = vi.fn().mockRejectedValue(new Error('Fetch failed'))

    await expect(
      dedupedFetch('test-key', fetcher)
    ).rejects.toThrow('Fetch failed')

    expect(fetcher).toHaveBeenCalledTimes(1)
  })
})

describe('createManagedFetch', () => {
  beforeEach(() => {
    clearRequestCache()
    vi.clearAllMocks()
  })

  it('should create a managed fetch instance', () => {
    const manager = createManagedFetch('test-component')

    expect(manager).toHaveProperty('fetch')
    expect(manager).toHaveProperty('cancelAll')
    expect(manager).toHaveProperty('cancel')
  })

  it('should cancel all requests', async () => {
    const manager = createManagedFetch('test-component')

    // Mock fetch
    globalThis.fetch = vi.fn().mockImplementation(() =>
      new Promise((resolve) => setTimeout(resolve, 1000))
    )

    // Start a request
    const promise = manager.fetch('https://example.com/api')

    // Cancel all
    manager.cancelAll()

    // Request should be aborted
    await expect(promise).rejects.toThrow()
  })

  it('should cancel specific request', async () => {
    const manager = createManagedFetch('test-component')

    // Mock fetch
    globalThis.fetch = vi.fn().mockImplementation(() =>
      new Promise((resolve) => setTimeout(resolve, 1000))
    )

    // Start a request with a key
    const promise = manager.fetch('https://example.com/api', {
      key: 'test-request'
    })

    // Cancel specific request
    manager.cancel('test-request')

    // Request should be aborted
    await expect(promise).rejects.toThrow()
  })
})

describe('Cache Management', () => {
  beforeEach(() => {
    clearRequestCache()
  })

  it('should clear cache entry', async () => {
    const fetcher = vi.fn().mockResolvedValue('result')

    // Add to cache
    await dedupedFetch('test-key', fetcher, { cacheTTL: 5000 })

    // Clear specific entry
    clearCacheEntry('test-key')

    // Should fetch again
    await dedupedFetch('test-key', fetcher, { cacheTTL: 5000 })

    expect(fetcher).toHaveBeenCalledTimes(2)
  })

  it('should get cache stats', async () => {
    const fetcher = vi.fn().mockResolvedValue('result')

    // Add some entries
    await dedupedFetch('key1', fetcher, { cacheTTL: 5000 })
    await dedupedFetch('key2', fetcher, { cacheTTL: 5000 })

    const stats = getCacheStats()

    expect(stats.total).toBeGreaterThanOrEqual(2)
    expect(stats.valid).toBeGreaterThanOrEqual(2)
  })

  it('should cleanup expired cache entries', async () => {
    const fetcher = vi.fn().mockResolvedValue('result')

    // Add entry with very short TTL
    await dedupedFetch('test-key', fetcher, { cacheTTL: 1 })

    // Wait for expiration
    await new Promise(resolve => setTimeout(resolve, 10))

    // Cleanup
    const cleaned = cleanupExpiredCache()

    expect(cleaned).toBeGreaterThanOrEqual(1)
  })
})


=================================================================================
FILE: src/lib/cache-manager.ts
=================================================================================
/**
 * Cache Manager - Robust Cache Busting & Version Management
 * 
 * Handles:
 * - Version detection and mismatch handling
 * - Manifest validation and ETag tracking
 * - Aggressive cache invalidation
 * - Service worker update detection
 * - Automatic cache clearing on version mismatch
 */

const STORAGE_KEYS = {
  CURRENT_VERSION: 'app-version',
  MANIFEST_ETAG: 'manifest-etag',
  LAST_SW_CHECK: 'last-sw-check',
  CACHE_CLEARED: 'cache-cleared-at',
} as const;

const CHECK_INTERVAL = 5 * 60 * 1000; // 5 minutes
const SW_CHECK_INTERVAL = 2 * 60 * 1000; // 2 minutes

interface VersionInfo {
  appVersion: string;
  buildTime: string;
  manifestETag?: string;
}

/**
 * Get current app version from HTML root element
 */
export function getCurrentAppVersion(): string {
  const root = document.getElementById('root');
  return root?.getAttribute('data-version') || 'unknown';
}

/**
 * Get stored version from localStorage
 */
function getStoredVersion(): string | null {
  return localStorage.getItem(STORAGE_KEYS.CURRENT_VERSION);
}

/**
 * Store current version to localStorage
 */
function storeCurrentVersion(version: string): void {
  localStorage.setItem(STORAGE_KEYS.CURRENT_VERSION, version);
}

/**
 * Fetch manifest and get ETag
 */
async function getManifestETag(): Promise<string | null> {
  try {
    const response = await fetch('/manifest.json', { cache: 'no-store' });
    return response.headers.get('etag') || response.headers.get('last-modified');
  } catch (error) {
    console.error('Failed to fetch manifest ETag:', error);
    return null;
  }
}

/**
 * Check if manifest has changed
 */
async function hasManifestChanged(): Promise<boolean> {
  const currentETag = await getManifestETag();
  const storedETag = localStorage.getItem(STORAGE_KEYS.MANIFEST_ETAG);

  if (!currentETag) return false;
  if (!storedETag) {
    localStorage.setItem(STORAGE_KEYS.MANIFEST_ETAG, currentETag);
    return false;
  }

  return currentETag !== storedETag;
}

/**
 * Update stored manifest ETag
 */
async function updateManifestETag(): Promise<void> {
  const eTag = await getManifestETag();
  if (eTag) {
    localStorage.setItem(STORAGE_KEYS.MANIFEST_ETAG, eTag);
  }
}

/**
 * Clear all caches and storage
 */
export async function clearAllCaches(): Promise<void> {
  try {
    // Unregister service workers
    if ('serviceWorker' in navigator) {
      const registrations = await navigator.serviceWorker.getRegistrations();
      for (const registration of registrations) {
        await registration.unregister();
      }
    }

    // Clear all caches
    if ('caches' in window) {
      const cacheNames = await caches.keys();
      for (const cacheName of cacheNames) {
        await caches.delete(cacheName);
      }
    }

    // Clear storage
    localStorage.clear();
    sessionStorage.clear();

    // Clear IndexedDB
    if ('indexedDB' in window) {
      const databases = await indexedDB.databases();
      for (const db of databases) {
        if (db.name) {
          indexedDB.deleteDatabase(db.name);
        }
      }
    }

    localStorage.setItem(STORAGE_KEYS.CACHE_CLEARED, new Date().toISOString());
  } catch (error) {
    console.error('Error clearing caches:', error);
  }
}

/**
 * Check for version mismatch and handle cache clearing
 */
export async function checkVersionMismatch(): Promise<boolean> {
  const currentVersion = getCurrentAppVersion();
  const storedVersion = getStoredVersion();

  if (!storedVersion) {
    // First visit
    storeCurrentVersion(currentVersion);
    await updateManifestETag();
    return false;
  }

  if (currentVersion !== storedVersion) {
    console.warn(
      `🔄 Version mismatch detected: ${storedVersion} → ${currentVersion}. Clearing cache...`
    );
    await clearAllCaches();
    storeCurrentVersion(currentVersion);
    await updateManifestETag();
    return true;
  }

  // Check manifest changes even if version is same
  if (await hasManifestChanged()) {
    console.warn('📦 Manifest changed detected. Clearing cache...');
    await clearAllCaches();
    await updateManifestETag();
    return true;
  }

  return false;
}

/**
 * Initialize cache manager with periodic checks
 */
export function initCacheManager(): void {
  // Initial check
  checkVersionMismatch().catch((error) => {
    console.error('Cache version check failed:', error);
  });

  // Periodic version checks
  setInterval(() => {
    checkVersionMismatch().catch((error) => {
      console.error('Periodic cache version check failed:', error);
    });
  }, CHECK_INTERVAL);

  // Aggressive service worker update checks
  if ('serviceWorker' in navigator) {
    setInterval(() => {
      navigator.serviceWorker.getRegistrations().then((registrations) => {
        for (const registration of registrations) {
          registration.update().catch((error) => {
            console.error('SW update check failed:', error);
          });
        }
      });
    }, SW_CHECK_INTERVAL);
  }
}

/**
 * Get version info for debugging
 */
export function getVersionInfo(): VersionInfo {
  return {
    appVersion: getCurrentAppVersion(),
    buildTime: document.getElementById('root')?.getAttribute('data-build-time') || 'unknown',
    manifestETag: localStorage.getItem(STORAGE_KEYS.MANIFEST_ETAG) || undefined,
  };
}


=================================================================================
FILE: src/lib/env.ts
=================================================================================
/**
 * Environment Variable Helper
 * Provides type-safe access to environment variables with proper index signature handling
 */

/**
 * Get environment variable with type safety
 * Handles noUncheckedIndexedAccess TypeScript strict mode
 */
function getEnv(key: string): string | undefined {
  return import.meta.env[key]
}

/**
 * Get environment variable or throw if not found
 */
function getRequiredEnv(key: string): string {
  const value = import.meta.env[key]
  if (value === undefined) {
    throw new Error(`Required environment variable ${key} is not defined`)
  }
  return value
}

/**
 * Check if running in development mode
 */
export const isDevelopment = getEnv('MODE') === 'development'

/**
 * Check if running in production mode
 */
export const isProduction = getEnv('MODE') === 'production'

/**
 * Get Node environment (development, production, test)
 */
export const nodeEnv = getEnv('NODE_ENV') ?? 'development'

/**
 * Workout function URL
 */
export const workoutFnUrl = getEnv('VITE_WORKOUT_FN_URL')

/**
 * Feature flags
 */
export const features = {
  adaptivePersonalization: getEnv('VITE_ADAPTIVE_PERSONALIZATION_ENABLED') === 'true',
  adaptiveFeedbackUI: getEnv('VITE_ADAPTIVE_FEEDBACK_UI_ENABLED') === 'true',
  adaptiveCalibration: getEnv('VITE_ADAPTIVE_CALIBRATION_ENABLED') === 'true',
  adaptiveTelemetry: getEnv('VITE_ADAPTIVE_TELEMETRY_ENABLED') === 'true',
} as const

/**
 * Export helper functions for custom usage
 */
export { getEnv, getRequiredEnv }


=================================================================================
FILE: src/lib/errorManager.ts
=================================================================================
// Simplified Error Management System
import type { AppError } from '../store'
import { useAppStore } from '../store'

// Simple error types
export const ErrorType = {
  AUTH: 'auth',
  NETWORK: 'network',
  VALIDATION: 'validation',
  UNKNOWN: 'unknown',
} as const

export type ErrorTypeValue = (typeof ErrorType)[keyof typeof ErrorType]

// User-friendly error messages
const ERROR_MESSAGES: Record<string, string> = {
  // Auth errors
  'auth/user-not-found': 'No account found with this email address',
  'auth/wrong-password': 'Incorrect password',
  'auth/email-already-in-use': 'An account with this email already exists',
  'auth/weak-password': 'Password must be at least 6 characters',
  'auth/invalid-email': 'Please enter a valid email address',
  'auth/too-many-requests': 'Too many failed attempts. Please try again later',
  'auth/network-request-failed': 'Network error. Please check your connection',

  // Network errors
  'network-error': 'Network connection failed. Please check your internet connection',
  'timeout': 'Request timed out. Please try again',
  'server-error': 'Server error. Please try again later',

  // Generic fallback
  'unknown-error': 'An unexpected error occurred. Please try again',
}

class SimpleErrorManager {
  // Main error handling method
  handle(error: unknown, type: ErrorTypeValue = ErrorType.UNKNOWN): void {
    const normalizedError = this.normalizeError(error)
    const errorCode = this.extractErrorCode(normalizedError)
    const userMessage = this.getUserMessage(errorCode, normalizedError.message)

    // Create app error
    const appError: AppError = {
      id: `error_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
      type,
      message: userMessage,
      timestamp: Date.now(),
      resolved: false,
      details: {
        code: errorCode,
        originalMessage: normalizedError.message,
        url: window.location.href,
        timestamp: Date.now(),
      },
    }

    // Add to store
    const store = useAppStore.getState()
    store.addError(appError)

    // Log in development
    if (import.meta.env.DEV) {
      console.error('Error:', {
        type,
        code: errorCode,
        message: normalizedError.message,
      })
    }
  }

  // Specific error handlers
  handleAuth = (error: unknown): void => this.handle(error, ErrorType.AUTH)
  handleNetwork = (error: unknown): void => this.handle(error, ErrorType.NETWORK)
  handleValidation = (error: unknown): void => this.handle(error, ErrorType.VALIDATION)

  // Async wrapper with error handling
  async wrapAsync<T>(
    fn: () => Promise<T>,
    errorType: ErrorTypeValue = ErrorType.UNKNOWN
  ): Promise<T | null> {
    try {
      return await fn()
    } catch (error) {
      this.handle(error, errorType)
      return null
    }
  }

  // Utility methods
  getErrorMessage(error: unknown): string {
    if (error instanceof Error) return error.message
    if (typeof error === 'string') return error
    return 'Unknown error'
  }

  getErrorCode(error: unknown): string | null {
    if (error && typeof error === 'object' && 'code' in error) {
      return String(error.code)
    }
    return null
  }

  // Private helper methods
  private normalizeError(error: unknown): Error {
    if (error instanceof Error) return error
    if (typeof error === 'string') return new Error(error)
    return new Error('Unknown error')
  }

  private extractErrorCode(error: Error): string | undefined {
    if ('code' in error) return (error as { code: string }).code
    if (error.name === 'AbortError') return 'timeout'
    if (error.message.includes('fetch')) return 'network-error'
    return undefined
  }

  private getUserMessage(code: string | undefined, originalMessage: string): string {
    if (code && ERROR_MESSAGES[code]) {
      return ERROR_MESSAGES[code]
    }

    // In production, use generic message for unknown errors
    if (import.meta.env.PROD) {
      return ERROR_MESSAGES['unknown-error'] || 'An unexpected error occurred'
    }

    // In development, show original message (sanitized)
    return originalMessage
      .replace(/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g, '[EMAIL]')
      .replace(/\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b/g, '[CARD]')
  }
}

// Create singleton instance
const errorManager = new SimpleErrorManager()

// Hook for React components
export const useErrorManager = () => ({
  handleError: errorManager.handle.bind(errorManager),
  handleAuth: errorManager.handleAuth,
  handleNetwork: errorManager.handleNetwork,
  handleValidation: errorManager.handleValidation,
  wrapAsync: errorManager.wrapAsync.bind(errorManager),
  getErrorMessage: errorManager.getErrorMessage.bind(errorManager),
  getErrorCode: errorManager.getErrorCode.bind(errorManager),
})

// Convenience functions
export const handleError = errorManager.handle.bind(errorManager)
export const handleAuthError = errorManager.handleAuth
export const handleNetworkError = errorManager.handleNetwork
export const handleValidationError = errorManager.handleValidation

// Export the manager instance
export { errorManager }

=================================================================================
FILE: src/lib/errors.ts
=================================================================================
/**
 * Standardized Error Handling System
 * 
 * Provides consistent error handling across the application with:
 * - Typed error classes
 * - User-friendly error messages
 * - Error logging and monitoring
 * - Retry mechanisms
 */

import { logger } from './logger'
import * as Sentry from '@sentry/react'

export type ErrorSeverity = 'low' | 'medium' | 'high' | 'critical'
export type ErrorCode =
  | 'AUTH_ERROR'
  | 'NETWORK_ERROR'
  | 'VALIDATION_ERROR'
  | 'WORKOUT_GENERATION_ERROR'
  | 'FIRESTORE_ERROR'
  | 'UNKNOWN_ERROR'
  | 'PERMISSION_DENIED'
  | 'TIMEOUT_ERROR'
  | 'OFFLINE_ERROR'

export interface ErrorContext {
  userId?: string
  component?: string
  action?: string
  metadata?: Record<string, unknown>
}

/**
 * Base application error class with enhanced context
 */
export class AppError extends Error {
  public readonly code: ErrorCode
  public readonly severity: ErrorSeverity
  public readonly userMessage: string
  public readonly context: ErrorContext
  public readonly originalError?: Error
  public readonly timestamp: number
  public readonly retryable: boolean

  constructor(
    message: string,
    code: ErrorCode,
    severity: ErrorSeverity,
    userMessage: string,
    context: ErrorContext = {},
    originalError?: Error,
    retryable: boolean = false
  ) {
    super(message)
    this.name = 'AppError'
    this.code = code
    this.severity = severity
    this.userMessage = userMessage
    this.context = context
    this.originalError = originalError
    this.timestamp = Date.now()
    this.retryable = retryable

    // Maintain proper stack trace
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, AppError)
    }
  }

  /**
   * Convert to plain object for logging
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      code: this.code,
      severity: this.severity,
      userMessage: this.userMessage,
      context: this.context,
      timestamp: this.timestamp,
      retryable: this.retryable,
      stack: this.stack,
      originalError: this.originalError ? {
        message: this.originalError.message,
        stack: this.originalError.stack
      } : undefined
    }
  }
}

/**
 * Authentication-related errors
 */
export class AuthError extends AppError {
  constructor(
    message: string,
    userMessage: string = 'Authentication failed. Please try signing in again.',
    context: ErrorContext = {},
    originalError?: Error
  ) {
    super(message, 'AUTH_ERROR', 'high', userMessage, context, originalError, false)
    this.name = 'AuthError'
  }
}

/**
 * Network-related errors
 */
export class NetworkError extends AppError {
  constructor(
    message: string,
    userMessage: string = 'Network error. Please check your connection and try again.',
    context: ErrorContext = {},
    originalError?: Error,
    retryable: boolean = true
  ) {
    super(message, 'NETWORK_ERROR', 'medium', userMessage, context, originalError, retryable)
    this.name = 'NetworkError'
  }
}

/**
 * Validation errors
 */
export class ValidationError extends AppError {
  constructor(
    message: string,
    userMessage: string,
    context: ErrorContext = {},
    originalError?: Error
  ) {
    super(message, 'VALIDATION_ERROR', 'low', userMessage, context, originalError, false)
    this.name = 'ValidationError'
  }
}

/**
 * Workout generation errors
 */
export class WorkoutGenerationError extends AppError {
  constructor(
    message: string,
    userMessage: string = 'Failed to generate workout. Please try again.',
    context: ErrorContext = {},
    originalError?: Error,
    retryable: boolean = true
  ) {
    super(message, 'WORKOUT_GENERATION_ERROR', 'high', userMessage, context, originalError, retryable)
    this.name = 'WorkoutGenerationError'
  }
}

/**
 * Firestore database errors
 */
export class FirestoreError extends AppError {
  constructor(
    message: string,
    userMessage: string = 'Database error. Please try again.',
    context: ErrorContext = {},
    originalError?: Error,
    retryable: boolean = true
  ) {
    super(message, 'FIRESTORE_ERROR', 'high', userMessage, context, originalError, retryable)
    this.name = 'FirestoreError'
  }
}

/**
 * Timeout errors
 */
export class TimeoutError extends AppError {
  constructor(
    message: string,
    userMessage: string = 'Request timed out. Please try again.',
    context: ErrorContext = {},
    originalError?: Error
  ) {
    super(message, 'TIMEOUT_ERROR', 'medium', userMessage, context, originalError, true)
    this.name = 'TimeoutError'
  }
}

/**
 * Offline errors
 */
export class OfflineError extends AppError {
  constructor(
    message: string,
    userMessage: string = 'You are offline. Please check your connection.',
    context: ErrorContext = {},
    originalError?: Error
  ) {
    super(message, 'OFFLINE_ERROR', 'medium', userMessage, context, originalError, true)
    this.name = 'OfflineError'
  }
}

/**
 * Error handler utility
 */
export class ErrorHandler {
  /**
   * Handle and log an error
   */
  static handle(error: Error | AppError, context: ErrorContext = {}): AppError {
    // Convert to AppError if needed
    const appError = error instanceof AppError 
      ? error 
      : new AppError(
          error.message,
          'UNKNOWN_ERROR',
          'medium',
          'An unexpected error occurred. Please try again.',
          context,
          error,
          true
        )

    // Log to console in development
    if (import.meta.env.MODE === 'development') {
      console.error('[ErrorHandler]', appError.toJSON())
    }

    // Log to application logger
    logger.error(appError.message, appError.originalError || appError, {
      code: appError.code,
      severity: appError.severity,
      context: appError.context
    })

    // Report to Sentry for high/critical errors
    if (appError.severity === 'high' || appError.severity === 'critical') {
      Sentry.captureException(appError.originalError || appError, {
        level: appError.severity === 'critical' ? 'fatal' : 'error',
        tags: {
          errorCode: appError.code,
          component: appError.context.component,
          action: appError.context.action
        },
        extra: {
          userMessage: appError.userMessage,
          context: appError.context,
          retryable: appError.retryable
        }
      })
    }

    return appError
  }

  /**
   * Convert unknown error to AppError
   */
  static normalize(error: unknown, context: ErrorContext = {}): AppError {
    if (error instanceof AppError) {
      return error
    }

    if (error instanceof Error) {
      return ErrorHandler.handle(error, context)
    }

    // Handle string errors
    if (typeof error === 'string') {
      return new AppError(
        error,
        'UNKNOWN_ERROR',
        'medium',
        error,
        context,
        undefined,
        true
      )
    }

    // Handle unknown error types
    return new AppError(
      'An unknown error occurred',
      'UNKNOWN_ERROR',
      'medium',
      'An unexpected error occurred. Please try again.',
      context,
      undefined,
      true
    )
  }

  /**
   * Check if error is retryable
   */
  static isRetryable(error: Error | AppError): boolean {
    if (error instanceof AppError) {
      return error.retryable
    }

    // Network errors are generally retryable
    if (error.name === 'NetworkError' || error.name === 'TimeoutError') {
      return true
    }

    // Check for specific error messages
    const retryableMessages = [
      'network',
      'timeout',
      'connection',
      'unavailable',
      'ECONNREFUSED',
      'ETIMEDOUT'
    ]

    return retryableMessages.some(msg => 
      error.message.toLowerCase().includes(msg.toLowerCase())
    )
  }
}

/**
 * Retry utility with exponential backoff
 */
export async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  options: {
    maxRetries?: number
    baseDelay?: number
    maxDelay?: number
    onRetry?: (attempt: number, error: Error) => void
  } = {}
): Promise<T> {
  const {
    maxRetries = 3,
    baseDelay = 1000,
    maxDelay = 10000,
    onRetry
  } = options

  let lastError: Error

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await fn()
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error))
      
      // Don't retry if not retryable
      if (!ErrorHandler.isRetryable(lastError)) {
        throw lastError
      }

      // Don't retry on last attempt
      if (attempt === maxRetries) {
        break
      }

      // Calculate delay with exponential backoff
      const delay = Math.min(baseDelay * Math.pow(2, attempt), maxDelay)
      
      // Call retry callback
      onRetry?.(attempt + 1, lastError)

      // Wait before retrying
      await new Promise(resolve => setTimeout(resolve, delay))
    }
  }

  throw lastError!
}


=================================================================================
FILE: src/lib/firebase-analytics.ts
=================================================================================
/**
 * Simplified Analytics Service for NeuraFit
 * Unified analytics, telemetry, and tracking system
 */

import { logger } from './logger'

// Simple analytics configuration
interface AnalyticsConfig {
  enabled: boolean
  debug: boolean
  maxEvents: number
}

// Analytics event structure
interface AnalyticsEvent {
  event: string
  timestamp: number
  data: Record<string, unknown>
}

class SimpleAnalytics {
  private config: AnalyticsConfig
  private events: AnalyticsEvent[] = []

  constructor() {
    this.config = {
      enabled: true,
      debug: import.meta.env.DEV,
      maxEvents: 100
    }
  }

  private track(event: string, data: Record<string, unknown> = {}): void {
    if (!this.config.enabled) return

    const analyticsEvent: AnalyticsEvent = {
      event,
      timestamp: Date.now(),
      data: {
        ...data,
        url: window.location.href,
        userAgent: navigator.userAgent.substring(0, 50)
      }
    }

    // Store event locally
    this.events.push(analyticsEvent)

    // Keep only recent events
    if (this.events.length > this.config.maxEvents) {
      this.events = this.events.slice(-this.config.maxEvents)
    }

    // Debug logging
    if (this.config.debug) {
      logger.debug('Analytics event', { event, data })
    }

    // Store in localStorage for debugging
    try {
      localStorage.setItem('nf_analytics_events', JSON.stringify(this.events.slice(-20)))
    } catch {
      // Ignore storage errors
    }
  }

  // User Authentication Events
  trackUserSignUp = (method: string): void => this.track('sign_up', { method })
  trackUserLogin = (method: string): void => this.track('login', { method })
  trackUserLogout = (): void => this.track('logout')

  // User Profile Events
  trackProfileComplete = (experience: string, goals: string[], equipment: string[]): void =>
    this.track('profile_complete', { experience, goals: goals.length, equipment: equipment.length })
  trackProfileUpdate = (field: string): void => this.track('profile_update', { field })

  // Page View Events
  trackPageView = (pageName: string, title?: string): void =>
    this.track('page_view', { page_title: title, page_name: pageName })

  // Workout Events (unified interface)
  trackWorkoutGenerated = (workoutType: string, duration?: number, exerciseCount?: number): void =>
    this.track('workout_generated', { workout_type: workoutType, duration, exercise_count: exerciseCount })
  trackWorkoutStarted = (workoutType: string): void => this.track('workout_started', { workout_type: workoutType })
  trackWorkoutCompleted = (workoutType: string, duration: number, completionRate: number): void =>
    this.track('workout_completed', { workout_type: workoutType, duration, completion_rate: completionRate })
  trackWorkoutAbandoned = (workoutType: string, progress: number): void =>
    this.track('workout_abandoned', { workout_type: workoutType, progress })

  // Exercise Events
  trackExerciseCompleted = (exerciseName: string, sets: number, reps: number): void =>
    this.track('exercise_completed', { exerciseName, sets, reps })
  trackExerciseSkipped = (exerciseName: string, reason: string): void =>
    this.track('exercise_skipped', { exerciseName, reason })
  trackRestCompleted = (duration: number): void => this.track('rest_completed', { duration })
  trackRestSkipped = (): void => this.track('rest_skipped')

  // Feature Usage Events
  trackFeatureUsed = (feature: string, context?: string): void =>
    this.track('feature_used', { feature, context })
  trackButtonClicked = (buttonName: string, location: string): void =>
    this.track('button_clicked', { button_name: buttonName, location })
  trackFormSubmitted = (formName: string, success: boolean): void =>
    this.track('form_submitted', { form_name: formName, success })

  // Custom Events
  trackCustomEvent = (eventName: string, parameters: Record<string, unknown>): void =>
    this.track(eventName, parameters)
  trackError = (error: string, context?: string): void =>
    this.track('error', { error, context })

  // Telemetry Events (simplified from telemetry.ts)
  trackAdaptiveFeedback = (feedback: 'easy' | 'right' | 'hard', rpe: number | null, completionRate: number): void =>
    this.track('adaptive_feedback', { feedback, rpe, completion_rate: completionRate })

  // Utility methods
  getEvents = (): AnalyticsEvent[] => [...this.events]
  clearEvents = (): void => { this.events = [] }
  setConfig = (config: Partial<AnalyticsConfig>): void => { this.config = { ...this.config, ...config } }
}

// Create singleton instance
const analytics = new SimpleAnalytics()

// Export all tracking functions
export const {
  trackUserSignUp,
  trackUserLogin,
  trackUserLogout,
  trackProfileComplete,
  trackProfileUpdate,
  trackPageView,
  trackWorkoutGenerated,
  trackWorkoutStarted,
  trackWorkoutCompleted,
  trackWorkoutAbandoned,
  trackExerciseCompleted,
  trackExerciseSkipped,
  trackRestCompleted,
  trackRestSkipped,
  trackFeatureUsed,
  trackButtonClicked,
  trackFormSubmitted,
  trackCustomEvent,
  trackError,
  trackAdaptiveFeedback
} = analytics

// Legacy compatibility exports
export const setUserAnalyticsProperties = (_userId: string, _properties: Record<string, unknown>): void => {}
export const setEnhancedUserProperties = (_userId: string, _userProfile: Record<string, unknown>): void => {}
export const trackSessionStart = (): void => analytics.trackCustomEvent('session_start', {})

// Export analytics instance
export { analytics }

=================================================================================
FILE: src/lib/firebase.ts
=================================================================================
// Simplified Firebase configuration using standard Firebase v9+ modular SDK
import { initializeApp, type FirebaseApp } from 'firebase/app'
import { getAuth, type Auth } from 'firebase/auth'
import { getFirestore, type Firestore } from 'firebase/firestore'
import { getFunctions, type Functions } from 'firebase/functions'
import { getAnalytics, type Analytics, isSupported } from 'firebase/analytics'
import { logger } from './logger'

// Validate required environment variables
const requiredEnvVars = [
  'VITE_FIREBASE_API_KEY',
  'VITE_FIREBASE_AUTH_DOMAIN',
  'VITE_FIREBASE_PROJECT_ID',
  'VITE_FIREBASE_STORAGE_BUCKET',
  'VITE_FIREBASE_MESSAGING_SENDER_ID',
  'VITE_FIREBASE_APP_ID',
] as const

const missingEnvVars = requiredEnvVars.filter(
  (varName) => !import.meta.env[varName]
)

if (missingEnvVars.length > 0) {
  throw new Error(
    `Missing required environment variables: ${missingEnvVars.join(', ')}\n` +
    'Please check your .env file and ensure all required variables are set.'
  )
}

// Firebase configuration from environment variables
const firebaseConfig = {
  apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
  authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
  projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,
  storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID,
  appId: import.meta.env.VITE_FIREBASE_APP_ID,
  measurementId: import.meta.env.VITE_FIREBASE_MEASUREMENT_ID,
}

// Initialize Firebase
logger.firebase('Initializing Firebase...')
const app: FirebaseApp = initializeApp(firebaseConfig)

// Initialize services
export const auth: Auth = getAuth(app)
export const db: Firestore = getFirestore(app)
export const fns: Functions = getFunctions(app)

logger.firebase('Firebase services initialized', {
  auth: '✓',
  firestore: '✓',
  functions: '✓',
})

// Initialize analytics conditionally
let analytics: Analytics | null = null
isSupported()
  .then((supported) => {
    if (supported) {
      analytics = getAnalytics(app)
      logger.firebase('Firebase Analytics initialized')
    }
  })
  .catch((error) => {
    // Analytics initialization failed - log in development only
    logger.warn('Firebase Analytics initialization failed', { error })
  })

// Simplified service getters (now synchronous)
export const getAuthInstance = (): Auth => auth
export const getFirestoreInstance = (): Firestore => db
export const getFunctionsInstance = (): Functions => fns
export const getAnalyticsInstance = (): Analytics | null => analytics


=================================================================================
FILE: src/lib/guest-session.ts
=================================================================================
/**
 * Guest Session Management
 * Handles guest user sessions without Firebase authentication
 */

import type { UserProfile } from '../session/types'

const GUEST_SESSION_KEY = 'nf_guest_session'
const GUEST_PROFILE_KEY = 'nf_guest_profile'

/**
 * Create a generic guest profile with neutral values
 */
export function createGuestProfile(): UserProfile {
  return {
    experience: 'Intermediate',
    goals: ['General Health'],
    equipment: ['Bodyweight'],
    personal: {
      sex: 'Other',
      height: "5'6–5'9",
      weight: '150–179'
    },
    injuries: {
      list: ['None'],
      notes: ''
    },
    isGuest: true
  }
}

/**
 * Initialize a guest session
 */
export function initializeGuestSession(): void {
  const guestProfile = createGuestProfile()
  
  // Store guest session flag
  sessionStorage.setItem(GUEST_SESSION_KEY, JSON.stringify({
    isGuest: true,
    createdAt: Date.now()
  }))
  
  // Store guest profile
  localStorage.setItem(GUEST_PROFILE_KEY, JSON.stringify(guestProfile))
}

/**
 * Check if current session is a guest session
 */
export function isGuestSession(): boolean {
  const session = sessionStorage.getItem(GUEST_SESSION_KEY)
  return session ? JSON.parse(session).isGuest === true : false
}

/**
 * Get the guest profile
 */
export function getGuestProfile(): UserProfile | null {
  const profile = localStorage.getItem(GUEST_PROFILE_KEY)
  return profile ? JSON.parse(profile) : null
}

/**
 * Clear guest session
 */
export function clearGuestSession(): void {
  sessionStorage.removeItem(GUEST_SESSION_KEY)
  localStorage.removeItem(GUEST_PROFILE_KEY)
}

/**
 * Check if user should be treated as guest (either in guest session or guest profile)
 */
export function isUserGuest(): boolean {
  return isGuestSession() || (getGuestProfile()?.isGuest === true)
}


=================================================================================
FILE: src/lib/logger.ts
=================================================================================
/**
 * Centralized logging utility for NeuraFit
 * 
 * Features:
 * - Environment-aware logging (dev only)
 * - Sentry integration for errors
 * - Type-safe logging methods
 * - Performance tracking
 * - Structured logging
 */

import * as Sentry from '@sentry/react'

// Check if we're in development mode
const isDevelopment = import.meta.env.DEV
const isProduction = import.meta.env.PROD

/**
 * Log levels
 */
export const LogLevel = {
  DEBUG: 'debug',
  INFO: 'info',
  WARN: 'warn',
  ERROR: 'error',
} as const

type LogLevelType = typeof LogLevel[keyof typeof LogLevel]

/**
 * Logger configuration
 */
interface LoggerConfig {
  enableConsole: boolean
  enableSentry: boolean
  minLevel: LogLevelType
}

const config: LoggerConfig = {
  enableConsole: isDevelopment,
  enableSentry: isProduction,
  minLevel: isDevelopment ? LogLevel.DEBUG : LogLevel.WARN,
}

/**
 * Format log message with timestamp and context
 */
function formatMessage(level: LogLevelType, message: string, context?: Record<string, unknown>): string {
  const timestamp = new Date().toISOString()
  const contextStr = context ? ` ${JSON.stringify(context)}` : ''
  return `[${timestamp}] [${level.toUpperCase()}] ${message}${contextStr}`
}

/**
 * Logger class
 */
class Logger {
  /**
   * Debug logging - development only
   */
  debug(message: string, context?: Record<string, unknown>): void {
    if (!config.enableConsole) return
    
    if (isDevelopment) {
      console.debug(formatMessage(LogLevel.DEBUG, message, context))
    }
  }

  /**
   * Info logging - development only
   */
  info(message: string, context?: Record<string, unknown>): void {
    if (!config.enableConsole) return
    
    if (isDevelopment) {
      console.info(formatMessage(LogLevel.INFO, message, context))
    }
  }

  /**
   * Warning logging - development + Sentry in production
   */
  warn(message: string, context?: Record<string, unknown>): void {
    if (config.enableConsole && isDevelopment) {
      console.warn(formatMessage(LogLevel.WARN, message, context))
    }

    if (config.enableSentry && isProduction) {
      Sentry.captureMessage(message, {
        level: 'warning',
        extra: context,
      })
    }
  }

  /**
   * Error logging - development + Sentry in production
   */
  error(message: string, error?: Error | unknown, context?: Record<string, unknown>): void {
    if (config.enableConsole && isDevelopment) {
      console.error(formatMessage(LogLevel.ERROR, message, context), error)
    }

    if (config.enableSentry) {
      if (error instanceof Error) {
        Sentry.captureException(error, {
          extra: { message, ...context },
        })
      } else {
        Sentry.captureMessage(message, {
          level: 'error',
          extra: { error, ...context },
        })
      }
    }
  }

  /**
   * Log Firebase initialization - silent in production
   */
  firebase(message: string, context?: Record<string, unknown>): void {
    if (isDevelopment) {
      console.log(`🔥 ${message}`, context || '')
    }
  }

  /**
   * Log performance metrics
   */
  performance(metric: string, duration: number, context?: Record<string, unknown>): void {
    if (isDevelopment) {
      console.log(`⚡ ${metric}: ${duration}ms`, context || '')
    }

    // Send to Sentry performance monitoring in production
    if (isProduction) {
      Sentry.addBreadcrumb({
        category: 'performance',
        message: metric,
        level: 'info',
        data: {
          duration,
          ...context,
        },
      })
    }
  }

  /**
   * Log user actions for debugging
   */
  action(action: string, context?: Record<string, unknown>): void {
    if (isDevelopment) {
      console.log(`👤 Action: ${action}`, context || '')
    }

    // Add breadcrumb for Sentry
    Sentry.addBreadcrumb({
      category: 'user-action',
      message: action,
      level: 'info',
      data: context,
    })
  }

  /**
   * Log API calls
   */
  api(method: string, endpoint: string, status?: number, context?: Record<string, unknown>): void {
    if (isDevelopment) {
      const statusEmoji = status && status >= 200 && status < 300 ? '✅' : '❌'
      console.log(`${statusEmoji} API ${method} ${endpoint}`, { status, ...context })
    }

    Sentry.addBreadcrumb({
      category: 'api',
      message: `${method} ${endpoint}`,
      level: status && status >= 400 ? 'error' : 'info',
      data: {
        method,
        endpoint,
        status,
        ...context,
      },
    })
  }

  /**
   * Group logs (development only)
   */
  group(label: string, callback: () => void): void {
    if (!isDevelopment) {
      callback()
      return
    }

    console.group(label)
    try {
      callback()
    } finally {
      console.groupEnd()
    }
  }

  /**
   * Time a function execution
   */
  async time<T>(label: string, fn: () => Promise<T> | T): Promise<T> {
    const startTime = globalThis.performance.now()

    try {
      const result = await fn()
      const duration = globalThis.performance.now() - startTime

      this.performance(label, duration)

      return result
    } catch (error) {
      const duration = globalThis.performance.now() - startTime
      this.error(`${label} failed after ${duration}ms`, error as Error)
      throw error
    }
  }

  /**
   * Assert condition - development only
   */
  assert(condition: boolean, message: string): void {
    if (!isDevelopment) return
    
    if (!condition) {
      console.error(`❌ Assertion failed: ${message}`)
      throw new Error(`Assertion failed: ${message}`)
    }
  }

  /**
   * Table logging - development only
   */
  table(data: unknown): void {
    if (isDevelopment && console.table) {
      console.table(data)
    }
  }
}

// Export singleton instance
export const logger = new Logger()

// Export convenience methods
export const { debug, info, warn, error, firebase, performance, action, api, group, time, assert, table } = logger

// Default export
export default logger


=================================================================================
FILE: src/lib/optimisticUpdates.ts
=================================================================================
// src/lib/optimisticUpdates.ts
import { useState, useCallback, useRef } from 'react'

export type OptimisticState<T> = {
  data: T
  isOptimistic: boolean
  error: string | null
  isLoading: boolean
}

export type OptimisticAction<T> = {
  optimisticUpdate: (_current: T) => T
  serverUpdate: () => Promise<T>
  onSuccess?: (_result: T) => void
  onError?: (_error: Error) => void
}

/**
 * Hook for managing optimistic updates with automatic rollback on failure
 */
export function useOptimisticUpdate<T>(initialData: T) {
  const [state, setState] = useState<OptimisticState<T>>({
    data: initialData,
    isOptimistic: false,
    error: null,
    isLoading: false
  })

  const rollbackRef = useRef<T | null>(null)

  const executeOptimisticUpdate = useCallback(async (action: OptimisticAction<T>) => {
    // Store current state for potential rollback
    rollbackRef.current = state.data

    // Apply optimistic update immediately
    const optimisticData = action.optimisticUpdate(state.data)
    setState(prev => ({
      ...prev,
      data: optimisticData,
      isOptimistic: true,
      error: null,
      isLoading: true
    }))

    try {
      // Execute server update
      const result = await action.serverUpdate()
      
      // Update with server response
      setState(prev => ({
        ...prev,
        data: result,
        isOptimistic: false,
        isLoading: false,
        error: null
      }))

      action.onSuccess?.(result)
      rollbackRef.current = null
    } catch (error) {
      // Rollback to previous state on error
      const rollbackData = rollbackRef.current || initialData
      setState(prev => ({
        ...prev,
        data: rollbackData,
        isOptimistic: false,
        isLoading: false,
        error: error instanceof Error ? error.message : 'An error occurred'
      }))

      action.onError?.(error instanceof Error ? error : new Error('Unknown error'))
      rollbackRef.current = null
    }
  }, [state.data, initialData])

  const updateData = useCallback((newData: T) => {
    setState(prev => ({
      ...prev,
      data: newData,
      isOptimistic: false,
      error: null
    }))
  }, [])

  const clearError = useCallback(() => {
    setState(prev => ({ ...prev, error: null }))
  }, [])

  return {
    ...state,
    executeOptimisticUpdate,
    updateData,
    clearError
  }
}

/**
 * Utility for creating optimistic workout weight updates
 */
export function createWeightUpdateAction(
  exerciseIndex: number,
  setNumber: number,
  weight: number | null,
  onServerUpdate: (_exerciseIndex: number, _setNumber: number, _weight: number | null) => Promise<void>
): OptimisticAction<Record<number, Record<number, number | null>>> {
  return {
    optimisticUpdate: (currentWeights) => ({
      ...currentWeights,
      [exerciseIndex]: {
        ...currentWeights[exerciseIndex],
        [setNumber]: weight
      }
    }),
    serverUpdate: async () => {
      await onServerUpdate(exerciseIndex, setNumber, weight)
      // Return the updated weights (in real implementation, this might come from server)
      const savedWeights = sessionStorage.getItem('nf_workout_weights')
      return savedWeights ? JSON.parse(savedWeights) : {}
    }
  }
}

/**
 * Utility for creating optimistic set completion updates
 */
export function createSetCompletionAction(
  exerciseIndex: number,
  setNumber: number,
  isComplete: boolean,
  weight?: number | null
): OptimisticAction<Record<number, Record<number, number | null>>> {
  return {
    optimisticUpdate: (currentWeights) => ({
      ...currentWeights,
      [exerciseIndex]: {
        ...currentWeights[exerciseIndex],
        [setNumber]: isComplete ? (weight !== undefined ? weight : 0) : null
      }
    }),
    serverUpdate: async () => {
      // Get current weights from session storage
      const savedWeights = sessionStorage.getItem('nf_workout_weights')
      const currentWeights = savedWeights ? JSON.parse(savedWeights) : {}

      const updatedWeights = {
        ...currentWeights,
        [exerciseIndex]: {
          ...currentWeights[exerciseIndex],
          [setNumber]: isComplete ? (weight !== undefined ? weight : 0) : null
        }
      }
      sessionStorage.setItem('nf_workout_weights', JSON.stringify(updatedWeights))
      return updatedWeights
    }
  }
}

// Debounce functionality moved to a shared utility if needed

/**
 * Cache utility for storing and retrieving data with expiration
 */
export class OptimisticCache<T> {
  private cache = new Map<string, { data: T; timestamp: number; ttl: number }>()

  set(key: string, data: T, ttlMs: number = 5 * 60 * 1000) {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl: ttlMs
    })
  }

  get(key: string): T | null {
    const entry = this.cache.get(key)
    if (!entry) return null

    if (Date.now() - entry.timestamp > entry.ttl) {
      this.cache.delete(key)
      return null
    }

    return entry.data
  }

  invalidate(key: string) {
    this.cache.delete(key)
  }

  clear() {
    this.cache.clear()
  }
}

// Global cache instances
export const workoutCache = new OptimisticCache<Record<string, unknown>>()
export const profileCache = new OptimisticCache<Record<string, unknown>>()

/**
 * Preloader utility for prefetching data
 */
export class DataPreloader {
  private static instance: DataPreloader
  private preloadQueue = new Set<string>()

  static getInstance() {
    if (!DataPreloader.instance) {
      DataPreloader.instance = new DataPreloader()
    }
    return DataPreloader.instance
  }

  async preload(key: string, fetcher: () => Promise<unknown>, cache: OptimisticCache<unknown>) {
    if (this.preloadQueue.has(key)) return
    
    this.preloadQueue.add(key)
    
    try {
      const data = await fetcher()
      cache.set(key, data)
    } catch (error) {
      console.warn(`Failed to preload ${key}:`, error)
    } finally {
      this.preloadQueue.delete(key)
    }
  }
}

export const preloader = DataPreloader.getInstance()

/**
 * Error boundary utility for graceful error handling
 */
export function createErrorHandler(fallback: () => void) {
  return (error: Error) => {
    console.error('Optimistic update failed:', error)
    
    // Log to analytics if available
    if (typeof window !== 'undefined' && 'gtag' in window) {
      (window as { gtag: (_event: string, _action: string, _params: Record<string, unknown>) => void }).gtag('event', 'exception', {
        description: error.message,
        fatal: false
      })
    }

    fallback()
  }
}

/**
 * Retry utility with exponential backoff
 */
export async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3,
  baseDelay: number = 1000
): Promise<T> {
  let lastError: Error

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await fn()
    } catch (error) {
      lastError = error instanceof Error ? error : new Error('Unknown error')
      
      if (attempt === maxRetries) break
      
      const delay = baseDelay * Math.pow(2, attempt)
      await new Promise(resolve => setTimeout(resolve, delay))
    }
  }

  throw lastError!
}

=================================================================================
FILE: src/lib/requestManager.ts
=================================================================================
/**
 * Request Management System
 * 
 * Provides:
 * - Request deduplication
 * - Automatic cancellation on component unmount
 * - Request caching
 * - Concurrent request limiting
 */

import { logger } from './logger'

/**
 * Pending requests map for deduplication
 */
const pendingRequests = new Map<string, Promise<unknown>>()

/**
 * Active abort controllers for cleanup
 */
const activeControllers = new Map<string, AbortController>()

/**
 * Request cache with TTL
 */
interface CacheEntry<T> {
  data: T
  timestamp: number
  ttl: number
}

const requestCache = new Map<string, CacheEntry<unknown>>()

/**
 * Deduplicated fetch - prevents duplicate concurrent requests
 */
export async function dedupedFetch<T>(
  key: string,
  fetcher: () => Promise<T>,
  options: {
    cacheTTL?: number // Cache time-to-live in milliseconds
    forceRefresh?: boolean // Bypass cache
  } = {}
): Promise<T> {
  const { cacheTTL = 0, forceRefresh = false } = options

  // Check cache first
  if (!forceRefresh && cacheTTL > 0) {
    const cached = requestCache.get(key) as CacheEntry<T> | undefined
    if (cached && Date.now() - cached.timestamp < cached.ttl) {
      logger.debug(`Cache hit for ${key}`)
      return cached.data
    }
  }

  // Check if request is already pending
  if (pendingRequests.has(key)) {
    logger.debug(`Deduplicating request for ${key}`)
    return pendingRequests.get(key) as Promise<T>
  }

  // Create new request
  const promise = fetcher()
    .then((data) => {
      // Cache the result
      if (cacheTTL > 0) {
        requestCache.set(key, {
          data,
          timestamp: Date.now(),
          ttl: cacheTTL
        })
      }
      return data
    })
    .finally(() => {
      // Remove from pending requests
      pendingRequests.delete(key)
    })

  pendingRequests.set(key, promise)
  return promise
}

/**
 * Managed fetch with automatic cancellation
 */
export function createManagedFetch(componentId: string) {
  const controllers = new Map<string, AbortController>()

  return {
    /**
     * Fetch with automatic cancellation support
     */
    fetch: async <T>(
      url: string,
      options: RequestInit & {
        key?: string // Unique key for deduplication
        cacheTTL?: number
        timeout?: number
      } = {}
    ): Promise<T> => {
      const { key = url, cacheTTL = 0, timeout = 60000, ...fetchOptions } = options

      // Create abort controller
      const controller = new AbortController()
      const requestKey = `${componentId}:${key}`
      
      // Store controller for cleanup
      controllers.set(requestKey, controller)
      activeControllers.set(requestKey, controller)

      // Set up timeout
      const timeoutId = setTimeout(() => {
        controller.abort()
      }, timeout)

      try {
        // Use deduplicated fetch
        const result = await dedupedFetch<T>(
          key,
          async () => {
            const response = await fetch(url, {
              ...fetchOptions,
              signal: controller.signal
            })

            if (!response.ok) {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`)
            }

            return response.json()
          },
          { cacheTTL }
        )

        return result
      } finally {
        clearTimeout(timeoutId)
        controllers.delete(requestKey)
        activeControllers.delete(requestKey)
      }
    },

    /**
     * Cancel all requests for this component
     */
    cancelAll: () => {
      controllers.forEach((controller, key) => {
        controller.abort()
        activeControllers.delete(key)
      })
      controllers.clear()
    },

    /**
     * Cancel specific request
     */
    cancel: (key: string) => {
      const requestKey = `${componentId}:${key}`
      const controller = controllers.get(requestKey)
      if (controller) {
        controller.abort()
        controllers.delete(requestKey)
        activeControllers.delete(requestKey)
      }
    }
  }
}

/**
 * React hook for managed fetch
 */
export function useManagedFetch(componentId: string) {
  // Create manager on mount
  const manager = createManagedFetch(componentId)

  // Cleanup on unmount
  if (typeof window !== 'undefined') {
    // Store cleanup function
    const cleanup = () => manager.cancelAll()
    
    // This will be called by the component's useEffect cleanup
    return {
      ...manager,
      cleanup
    }
  }

  return manager
}

/**
 * Concurrent request limiter
 */
export class ConcurrentRequestLimiter {
  private queue: Array<() => Promise<unknown>> = []
  private active = 0
  private maxConcurrent: number

  constructor(maxConcurrent: number = 6) {
    this.maxConcurrent = maxConcurrent
  }

  async add<T>(fn: () => Promise<T>): Promise<T> {
    // Wait if at capacity
    while (this.active >= this.maxConcurrent) {
      await new Promise(resolve => setTimeout(resolve, 100))
    }

    this.active++

    try {
      return await fn()
    } finally {
      this.active--
      this.processQueue()
    }
  }

  private processQueue() {
    if (this.queue.length > 0 && this.active < this.maxConcurrent) {
      const next = this.queue.shift()
      if (next) {
        next()
      }
    }
  }
}

/**
 * Global request limiter instance
 */
export const globalRequestLimiter = new ConcurrentRequestLimiter(6)

/**
 * Clear all caches
 */
export function clearRequestCache() {
  requestCache.clear()
  logger.debug('Request cache cleared')
}

/**
 * Clear specific cache entry
 */
export function clearCacheEntry(key: string) {
  requestCache.delete(key)
  logger.debug(`Cache entry cleared: ${key}`)
}

/**
 * Cancel all active requests (useful for logout)
 */
export function cancelAllRequests() {
  activeControllers.forEach(controller => controller.abort())
  activeControllers.clear()
  pendingRequests.clear()
  logger.debug('All active requests cancelled')
}

/**
 * Get cache statistics
 */
export function getCacheStats() {
  const now = Date.now()
  let validEntries = 0
  let expiredEntries = 0

  requestCache.forEach((entry) => {
    if (now - entry.timestamp < entry.ttl) {
      validEntries++
    } else {
      expiredEntries++
    }
  })

  return {
    total: requestCache.size,
    valid: validEntries,
    expired: expiredEntries,
    pendingRequests: pendingRequests.size,
    activeControllers: activeControllers.size
  }
}

/**
 * Clean up expired cache entries
 */
export function cleanupExpiredCache() {
  const now = Date.now()
  let cleaned = 0

  requestCache.forEach((entry, key) => {
    if (now - entry.timestamp >= entry.ttl) {
      requestCache.delete(key)
      cleaned++
    }
  })

  if (cleaned > 0) {
    logger.debug(`Cleaned up ${cleaned} expired cache entries`)
  }

  return cleaned
}

// Auto cleanup expired cache every 5 minutes
if (typeof window !== 'undefined') {
  setInterval(cleanupExpiredCache, 5 * 60 * 1000)
}


=================================================================================
FILE: src/lib/security.ts
=================================================================================
// Simplified Security Utilities
import { handleError } from './errorManager'
import { logger } from './logger'

class SecurityManager {
  constructor() {
    this.setupBasicSecurity()
  }

  // Basic security setup
  private setupBasicSecurity(): void {
    // Security initialization
    // Note: Console removal is handled by Vite's terser configuration in production
    // All logging should use the centralized logger utility instead
    logger.debug('Security manager initialized')
  }

  // Basic input sanitization
  public sanitizeInput(input: string): string {
    if (typeof input !== 'string') return ''

    return input
      .trim()
      .replace(/[<>]/g, '') // Remove HTML tags
      .replace(/javascript:/gi, '') // Remove javascript: protocols
      .substring(0, 1000) // Limit length
  }

  public sanitizeHTML(html: string): string {
    const div = document.createElement('div')
    div.textContent = html
    return div.innerHTML
  }

  public sanitizeURL(url: string): string {
    try {
      const parsed = new URL(url)

      // Only allow http/https protocols
      if (!['http:', 'https:'].includes(parsed.protocol)) {
        throw new Error('Invalid protocol')
      }

      return parsed.toString()
    } catch {
      return '#'
    }
  }

  // Simple secure API request
  public secureApiRequest(url: string, options: RequestInit = {}): Promise<Response> {
    // Add basic security headers
    const secureOptions: RequestInit = {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...options.headers
      },
      credentials: 'same-origin',
    }

    // Validate URL
    const sanitizedUrl = this.sanitizeURL(url)
    if (sanitizedUrl === '#') {
      return Promise.reject(new Error('Invalid URL'))
    }

    return fetch(sanitizedUrl, secureOptions)
      .catch(error => {
        handleError(error)
        throw error
      })
  }

  // Simple storage operations
  public secureSetItem(key: string, value: unknown): void {
    try {
      const sanitizedKey = this.sanitizeInput(key)
      const serializedValue = JSON.stringify(value)
      localStorage.setItem(sanitizedKey, serializedValue)
    } catch (error) {
      handleError(error)
    }
  }

  public secureGetItem<T = unknown>(key: string): T | null {
    try {
      const sanitizedKey = this.sanitizeInput(key)
      const item = localStorage.getItem(sanitizedKey)

      if (!item) return null

      return JSON.parse(item) as T
    } catch {
      return null
    }
  }
}

// Create singleton instance
const securityManager = new SecurityManager()

// Convenience functions
export const sanitizeInput = (input: string) => securityManager.sanitizeInput(input)
export const sanitizeHTML = (html: string) => securityManager.sanitizeHTML(html)
export const sanitizeURL = (url: string) => securityManager.sanitizeURL(url)
export const secureApiRequest = (url: string, options?: RequestInit) =>
  securityManager.secureApiRequest(url, options)
export const secureSetItem = (key: string, value: unknown) =>
  securityManager.secureSetItem(key, value)
export const secureGetItem = (key: string) => securityManager.secureGetItem(key)

// React hook for security utilities
export const useSecurity = () => ({
  sanitizeInput,
  sanitizeHTML,
  sanitizeURL,
  secureApiRequest,
  secureSetItem,
  secureGetItem,
})

// Export the manager instance
export { securityManager }

=================================================================================
FILE: src/lib/sentry.ts
=================================================================================
/**
 * Sentry Error Tracking Configuration
 *
 * Configures Sentry for error tracking and performance monitoring.
 */

import * as Sentry from '@sentry/react';
import { isProduction, isDevelopment } from './env';
import { logger } from './logger';

/**
 * Initialize Sentry
 * 
 * Call this once at app startup (in main.tsx)
 */
export function initSentry() {
  // Only initialize in production or if explicitly enabled in development
  const enableSentry = isProduction || import.meta.env['VITE_ENABLE_SENTRY'] === 'true';

  if (!enableSentry) {
    logger.debug('Sentry disabled in development');
    return;
  }

  const dsn = import.meta.env['VITE_SENTRY_DSN'];

  if (!dsn) {
    logger.warn('Sentry DSN not configured. Set VITE_SENTRY_DSN environment variable.');
    return;
  }

  Sentry.init({
    dsn,
    environment: isProduction ? 'production' : 'development',

    // Performance Monitoring
    integrations: [
      Sentry.browserTracingIntegration(),
    ],

    // Set tracesSampleRate to 1.0 to capture 100% of transactions for performance monitoring.
    // We recommend adjusting this value in production
    tracesSampleRate: isProduction ? 0.1 : 1.0,

    // Set sample rate for error events
    sampleRate: 1.0,

    // Release tracking
    release: import.meta.env['VITE_APP_VERSION'] || '1.0.0',

    // Before send hook to filter/modify events
    beforeSend(event, hint) {
      // Filter out certain errors
      const error = hint.originalException;

      // Don't send network errors in development
      if (isDevelopment && error instanceof Error) {
        if (error.message.includes('fetch') || error.message.includes('network')) {
          return null;
        }
      }

      // Filter out Firebase permission errors (these are expected)
      if (error instanceof Error && error.message.includes('permission-denied')) {
        return null;
      }

      // Sanitize sensitive data
      if (event.request?.headers) {
        delete event.request.headers['Authorization'];
        delete event.request.headers['Cookie'];
      }

      return event;
    },

    // Ignore certain errors
    ignoreErrors: [
      // Browser extensions
      'top.GLOBALS',
      'chrome-extension://',
      'moz-extension://',
      // Network errors
      'NetworkError',
      'Failed to fetch',
      'Load failed',
      // ResizeObserver errors (benign)
      'ResizeObserver loop limit exceeded',
      'ResizeObserver loop completed with undelivered notifications',
    ],

    // Don't report errors from certain URLs
    denyUrls: [
      // Browser extensions
      /extensions\//i,
      /^chrome:\/\//i,
      /^moz-extension:\/\//i,
    ],
  });

  logger.debug('Sentry initialized', { environment: isProduction ? 'production' : 'development' });
}

/**
 * Capture an exception manually
 */
export function captureException(error: Error, context?: Record<string, unknown>) {
  Sentry.captureException(error, {
    extra: context,
  });
}

/**
 * Capture a message manually
 */
export function captureMessage(message: string, level: Sentry.SeverityLevel = 'info') {
  Sentry.captureMessage(message, level);
}

/**
 * Set user context for error tracking
 */
export function setUserContext(user: { id: string; email?: string; username?: string }) {
  Sentry.setUser({
    id: user.id,
    email: user.email,
    username: user.username,
  });
}

/**
 * Clear user context (on logout)
 */
export function clearUserContext() {
  Sentry.setUser(null);
}

/**
 * Add breadcrumb for debugging
 */
export function addBreadcrumb(message: string, category: string, data?: Record<string, unknown>) {
  Sentry.addBreadcrumb({
    message,
    category,
    data,
    level: 'info',
  });
}

/**
 * Set custom context
 */
export function setContext(name: string, context: Record<string, unknown>) {
  Sentry.setContext(name, context);
}

/**
 * Start a performance transaction (span)
 */
export function startTransaction(name: string, op: string) {
  return Sentry.startSpan({
    name,
    op,
  }, (span) => span);
}

/**
 * Wrap a component with Sentry error boundary
 */
export const SentryErrorBoundary = Sentry.ErrorBoundary;

/**
 * Sentry profiler for React components
 */
export const SentryProfiler = Sentry.Profiler;


=================================================================================
FILE: src/lib/user-utils.ts
=================================================================================
import { db } from './firebase'
import { doc, getDoc, setDoc } from 'firebase/firestore'
import type { User } from 'firebase/auth'
import { logger } from './logger'
import { sanitizeInput } from './security'

/**
 * Ensures a user document exists in Firestore
 * Creates it with basic info if it doesn't exist
 */
export async function ensureUserDocument(user: User): Promise<void> {
  try {
    logger.debug('Ensuring user document', { uid: user.uid })

    const userDocRef = doc(db, 'users', user.uid)
    const userDoc = await getDoc(userDocRef)

    if (!userDoc.exists()) {
      logger.info('Creating user document', { uid: user.uid })

      // Sanitize user inputs
      const displayName = user.displayName ? sanitizeInput(user.displayName) : null
      const email = user.email ? user.email.toLowerCase().trim() : null

      await setDoc(
        userDocRef,
        {
          uid: user.uid,
          email,
          displayName,
          photoURL: user.photoURL || null,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        },
        { merge: true }
      )
      logger.info('User document created successfully', { uid: user.uid })
    } else {
      // Update updated_at if document exists
      await setDoc(
        userDocRef,
        {
          updated_at: new Date().toISOString(),
        },
        { merge: true }
      )
    }
  } catch (error) {
    logger.error('Error ensuring user document', error as Error, { uid: user.uid })
    throw new Error('Failed to ensure user document exists')
  }
}


=================================================================================
FILE: src/lib/utils.ts
=================================================================================
import { type ClassValue, clsx } from 'clsx'
import { twMerge } from 'tailwind-merge'

/**
 * Utility function to merge Tailwind CSS classes
 * Combines clsx for conditional classes and tailwind-merge for deduplication
 */
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

/**
 * Format duration in milliseconds to human readable format
 */
export function formatDuration(ms: number): string {
  const seconds = Math.floor(ms / 1000)
  const minutes = Math.floor(seconds / 60)
  const hours = Math.floor(minutes / 60)

  if (hours > 0) {
    return `${hours}h ${minutes % 60}m`
  } else if (minutes > 0) {
    return `${minutes}m ${seconds % 60}s`
  } else {
    return `${seconds}s`
  }
}

/**
 * Format number with commas
 */
export function formatNumber(num: number): string {
  return new Intl.NumberFormat().format(num)
}

/**
 * Clamp a number between min and max values
 */
export function clamp(value: number, min: number, max: number): number {
  return Math.min(Math.max(value, min), max)
}

/**
 * Capitalize first letter of a string
 */
export function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase()
}



=================================================================================
FILE: src/lib/validators.ts
=================================================================================
// Simplified validation utilities
import { handleValidationError } from './errorManager'

// Validation result interface
export interface ValidationResult {
  isValid: boolean
  errors: string[]
}

// Email validation
export const validateEmail = (email: string): ValidationResult => {
  const errors: string[] = []

  if (!email) {
    errors.push('Email is required')
  } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
    errors.push('Please enter a valid email address')
  }

  return {
    isValid: errors.length === 0,
    errors
  }
}

// Password validation
export const validatePassword = (password: string): ValidationResult => {
  const errors: string[] = []

  if (!password) {
    errors.push('Password is required')
  } else if (password.length < 6) {
    errors.push('Password must be at least 6 characters long')
  }

  return {
    isValid: errors.length === 0,
    errors
  }
}

// User profile validation
export const validateUserProfile = (profile: Record<string, unknown>): ValidationResult => {
  const errors: string[] = []

  // Experience validation
  if (!profile['experience']) {
    errors.push('Experience level is required')
  } else if (!['Beginner', 'Intermediate', 'Advanced', 'Expert'].includes(profile['experience'] as string)) {
    errors.push('Invalid experience level')
  }

  // Goals validation
  if (!profile['goals'] || !Array.isArray(profile['goals']) || profile['goals'].length === 0) {
    errors.push('At least one fitness goal is required')
  }

  // Personal info validation
  if (!profile['personal']) {
    errors.push('Personal information is required')
  } else {
    const { height, weight } = profile['personal'] as { height?: string | number; weight?: string | number }

    // Height can be a range string (e.g., "<5'0", "5'0–5'5", ">6'5") or a number
    if (!height) {
      errors.push('Height is required')
    } else if (typeof height === 'string') {
      // Validate it's a non-empty string (range values like "<5'0" are valid)
      if (height.trim() === '') {
        errors.push('Valid height is required')
      }
    } else if (typeof height === 'number' && (isNaN(height) || height <= 0)) {
      errors.push('Valid height is required')
    }

    // Weight can be a range string (e.g., "<120lb", "120–149", "240+lb") or a number
    if (!weight) {
      errors.push('Weight is required')
    } else if (typeof weight === 'string') {
      // Validate it's a non-empty string (range values like "<120lb" are valid)
      if (weight.trim() === '') {
        errors.push('Valid weight is required')
      }
    } else if (typeof weight === 'number' && (isNaN(weight) || weight <= 0)) {
      errors.push('Valid weight is required')
    }
  }

  return {
    isValid: errors.length === 0,
    errors
  }
}

// Weight entry validation
export const validateWeight = (weight: unknown): ValidationResult => {
  const errors: string[] = []

  if (weight === null || weight === undefined) {
    // Null/undefined is valid (represents skipped set)
    return { isValid: true, errors }
  }

  const weightNum = parseFloat(weight as string)

  if (isNaN(weightNum)) {
    errors.push('Weight must be a valid number')
  } else if (weightNum < 0) {
    errors.push('Weight cannot be negative')
  } else if (weightNum > 1000) {
    errors.push('Weight seems unreasonably high')
  }

  return {
    isValid: errors.length === 0,
    errors
  }
}

// Form validation helper
export const validateForm = (data: Record<string, unknown>, rules: Record<string, (_value: unknown) => ValidationResult>): ValidationResult => {
  const allErrors: string[] = []

  for (const [field, validator] of Object.entries(rules)) {
    const result = validator(data[field])

    if (!result.isValid) {
      allErrors.push(...result.errors.map(error => `${field}: ${error}`))
    }
  }

  return {
    isValid: allErrors.length === 0,
    errors: allErrors
  }
}

// Validation middleware for API calls
export const withValidation = <T extends (...args: unknown[]) => unknown>(
  fn: T,
  validator: (_data: unknown) => ValidationResult,
  dataExtractor?: (...args: Parameters<T>) => unknown
): T => {
  return ((...args: Parameters<T>) => {
    const data = dataExtractor ? dataExtractor(...args) : args[0]
    const validation = validator(data)

    if (!validation.isValid) {
      const errorMessage = validation.errors.join(', ')
      handleValidationError(new Error(errorMessage))
      throw new Error(errorMessage)
    }

    return fn(...args)
  }) as T
}

=================================================================================
FILE: src/lib/weightHistory.ts
=================================================================================
// src/lib/weightHistory.ts
import { auth, db } from './firebase'
import { collection, getDocs, orderBy, query, limit } from 'firebase/firestore'
import { logger } from './logger'

export interface WeightHistory {
  exerciseName: string
  setNumber: number
  weight: number
  timestamp: number
  reps?: number
  date: string
}

export interface WorkoutSession {
  date: string
  exercises: {
    name: string
    sets: { weight: number | null; reps: number; completed: boolean }[]
  }[]
}

/**
 * Fetch weight history for a specific exercise from Firestore
 */
export async function fetchWeightHistory(exerciseName: string, maxSessions = 10): Promise<WeightHistory[]> {
  try {
    const uid = auth.currentUser?.uid
    if (!uid) return []

    logger.debug(`Fetching weight history for ${exerciseName}`)

    const q = query(
      collection(db, 'users', uid, 'workouts'),
      orderBy('timestamp', 'desc'),
      limit(maxSessions)
    )

    const snap = await getDocs(q)
    const weightHistory: WeightHistory[] = []

    snap.docs.forEach(doc => {
      const data = doc.data()
      const exercises = data['exercises'] || []
      const timestamp = data['timestamp']?.toMillis() || Date.now()
      const date = new Date(timestamp).toISOString().split('T')[0]

      exercises.forEach((exercise: { name: string; weights?: Record<string, number> }) => {
        if (exercise.name === exerciseName && exercise.weights) {
          Object.entries(exercise.weights).forEach(([setNumber, weight]) => {
            if (weight && typeof weight === 'number' && weight > 0) {
              weightHistory.push({
                exerciseName: exercise.name,
                setNumber: parseInt(setNumber),
                weight: weight,
                timestamp,
                reps: (exercise as { reps?: number }).reps || 10,
                date: date || ''
              })
            }
          })
        }
      })
    })

    // Sort by timestamp descending (most recent first)
    weightHistory.sort((a, b) => b.timestamp - a.timestamp)

    logger.debug(`Found ${weightHistory.length} weight entries for ${exerciseName}`)
    return weightHistory

  } catch (error) {
    logger.error('Error fetching weight history', error as Error)
    return []
  }
}

/**
 * Fetch recent workout sessions for progressive overload analysis
 */
export async function fetchRecentSessions(maxSessions = 8): Promise<WorkoutSession[]> {
  try {
    const uid = auth.currentUser?.uid
    if (!uid) return []

    if (import.meta.env.MODE === 'development') {
      console.log('Fetching recent workout sessions')
    }

    const q = query(
      collection(db, 'users', uid, 'workouts'),
      orderBy('timestamp', 'desc'),
      limit(maxSessions)
    )

    const snap = await getDocs(q)
    const sessions: WorkoutSession[] = []

    snap.docs.forEach(doc => {
      const data = doc.data()
      const exercises = data['exercises'] || []
      const timestamp = data['timestamp']?.toMillis() || Date.now()
      const date = new Date(timestamp).toISOString().split('T')[0]

      const sessionExercises = exercises.map((exercise: { name: string; sets?: number; reps?: number | string; weights?: Record<string, number | null> }) => {
        const sets = []
        const totalSets = exercise.sets || 0
        const weights = exercise.weights || {}
        const reps = typeof exercise.reps === 'number' ? exercise.reps : (typeof exercise.reps === 'string' ? parseInt(exercise.reps) : 10)

        // Create set data for each set
        for (let setNum = 1; setNum <= totalSets; setNum++) {
          const weight = weights[setNum]
          sets.push({
            weight: weight && typeof weight === 'number' ? weight : null,
            reps,
            completed: weight !== null // Consider set completed if weight was entered
          })
        }

        return {
          name: exercise.name,
          sets
        }
      })

      sessions.push({
        date: date || '',
        exercises: sessionExercises
      })
    })

    if (import.meta.env.MODE === 'development') {
      console.log(`📈 Found ${sessions.length} recent sessions`)
    }
    return sessions

  } catch (error) {
    logger.error('Error fetching recent sessions', error)
    return []
  }
}

/**
 * Get the last used weight for a specific exercise and set
 */
export function getLastUsedWeight(weightHistory: WeightHistory[], exerciseName: string, setNumber: number): number | null {
  const relevantWeights = weightHistory
    .filter(w => w.exerciseName === exerciseName && w.setNumber === setNumber)
    .sort((a, b) => b.timestamp - a.timestamp)

  return relevantWeights.length > 0 && relevantWeights[0] ? relevantWeights[0].weight : null
}

/**
 * Get progressive overload suggestion based on weight history
 */
export function getProgressiveOverloadSuggestion(
  weightHistory: WeightHistory[], 
  exerciseName: string, 
  setNumber: number
): number | null {
  const lastWeight = getLastUsedWeight(weightHistory, exerciseName, setNumber)
  
  if (!lastWeight) return null

  // Conservative progressive overload: 2.5-5 lbs increase
  const increment = lastWeight < 50 ? 2.5 : 5
  return lastWeight + increment
}

/**
 * Determine if an exercise is likely a barbell exercise for plate calculator
 */
export function isBarbellExercise(exerciseName: string): boolean {
  const barbellKeywords = [
    'squat', 'deadlift', 'bench press', 'row', 'press', 'curl',
    'barbell', 'bb ', 'overhead press', 'military press'
  ]
  
  const lowerName = exerciseName.toLowerCase()
  return barbellKeywords.some(keyword => lowerName.includes(keyword))
}

/**
 * Cache for weight history to avoid repeated API calls
 */
const weightHistoryCache = new Map<string, { data: WeightHistory[]; timestamp: number }>()
const CACHE_DURATION = 5 * 60 * 1000 // 5 minutes

export async function getCachedWeightHistory(exerciseName: string): Promise<WeightHistory[]> {
  const cacheKey = `${auth.currentUser?.uid}-${exerciseName}`
  const cached = weightHistoryCache.get(cacheKey)
  
  if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
    return cached.data
  }
  
  const data = await fetchWeightHistory(exerciseName)
  weightHistoryCache.set(cacheKey, { data, timestamp: Date.now() })
  
  return data
}

/**
 * Clear weight history cache (useful when new workout is completed)
 */
export function clearWeightHistoryCache(): void {
  weightHistoryCache.clear()
}

=================================================================================
FILE: src/main.tsx
=================================================================================
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';

import App from './App';
import './index.css';
import { isDevelopment, isProduction } from './lib/env';
import { initSentry } from './lib/sentry';
import { initCacheManager } from './lib/cache-manager';

// Initialize Sentry for error tracking
initSentry();

// Initialize robust cache management
initCacheManager();

// In development, clear specific version-related localStorage keys
if (isDevelopment) {
  const versionKeys = ['current-deployment-version', 'page-etag', 'page-last-modified', 'manifest-version'];
  versionKeys.forEach((key) => {
    if (localStorage.getItem(key)) {
      console.log('Clearing localStorage key:', key);
      localStorage.removeItem(key);
    }
  });
}

// Render the application
const root = ReactDOM.createRoot(document.getElementById('root')!);
root.render(
  <BrowserRouter>
    <App />
  </BrowserRouter>
);

// Register service worker for PWA functionality with enhanced update flow
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker
      .register('/sw.js')
      .then((registration) => {
        if (isDevelopment) {
          console.log('✅ Service worker registered:', registration);
        }

        // Periodically check for updates in production
        let updateInterval: NodeJS.Timeout | undefined;
        if (isProduction) {
          // Check for updates more frequently (every 2 minutes)
          updateInterval = setInterval(() => {
            registration.update().catch((error) => {
              if (isDevelopment) {
                console.error('Error updating service worker:', error);
              }
            });
          }, 120000); // 2 minutes

          // Also check on visibility change (when user returns to tab)
          const handleVisibilityChange = () => {
            if (!document.hidden) {
              registration.update().catch((error) => {
                if (isDevelopment) {
                  console.error('Error updating service worker on visibility change:', error);
                }
              });
            }
          };
          document.addEventListener('visibilitychange', handleVisibilityChange);

          // Cleanup interval on unload
          window.addEventListener('beforeunload', () => {
            if (updateInterval) {
              clearInterval(updateInterval);
            }
            document.removeEventListener('visibilitychange', handleVisibilityChange);
          });
        }

        // Listen for update found
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          if (newWorker) {
            newWorker.addEventListener('statechange', () => {
              if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                if (isDevelopment) {
                  console.log('🔄 New service worker version available!');
                }
                // Show update notification to user (optional)
                // You can implement a toast/banner here
              }
            });
          }
        });
      })
      .catch((registrationError) => {
        if (isDevelopment) {
          console.error('❌ Service worker registration failed:', registrationError);
        }
      });
  });

  // Note: SW update handling is now done via UpdateToast component in App.tsx
  // This provides a better UX by asking the user to refresh instead of auto-reloading
}


=================================================================================
FILE: src/pages/Auth.tsx
=================================================================================
// src/pages/Auth.tsx
import { useEffect, useState, useCallback, useMemo } from 'react'
import { Link, useNavigate } from 'react-router-dom'
import { auth } from '../lib/firebase'
import {
  GoogleAuthProvider,
  signInWithPopup,
  signInWithRedirect,
  RecaptchaVerifier,
  signInWithPhoneNumber,
  type ConfirmationResult
} from 'firebase/auth'
import { Zap, Brain, Target, Shield, Smartphone, Zap as ZapIcon } from 'lucide-react'
import { trackUserSignUp, trackUserLogin } from '../lib/firebase-analytics'
import PhoneAuthModal from '../components/PhoneAuthModal'
import FeatureCard from '../components/FeatureCard'
import { logger } from '../lib/logger'
import { useInitializeGuestSession } from '../store'
import { initializeGuestSession } from '../lib/guest-session'

export default function Auth() {
  const nav = useNavigate()
  const initGuestSession = useInitializeGuestSession()
  const [loading, setLoading] = useState(false)

  // Phone authentication state
  const [showPhoneModal, setShowPhoneModal] = useState(false)
  const [phoneStep, setPhoneStep] = useState<'phone' | 'code'>('phone')
  const [phoneNumber, setPhoneNumber] = useState('')
  const [phoneError, setPhoneError] = useState('')
  const [confirmationResult, setConfirmationResult] = useState<ConfirmationResult | null>(null)
  const [recaptchaVerifier, setRecaptchaVerifier] = useState<RecaptchaVerifier | null>(null)

  // Initialize component and apply performance optimizations
  useEffect(() => {
    setLoading(false)

    // Respect reduced motion preference
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
      document.documentElement.style.setProperty('--animation-duration', '0.01ms')
    }
  }, [])

  // Initialize invisible reCAPTCHA when phone modal opens
  useEffect(() => {
    if (showPhoneModal && !recaptchaVerifier) {
      // Add delay to ensure DOM is ready and avoid race conditions
      const timer = setTimeout(() => {
        try {
          const container = document.getElementById('recaptcha-container')
          if (!container) {
            logger.error('reCAPTCHA container not found')
            setPhoneError('Verification system not ready. Please refresh the page.')
            return
          }

          // Create invisible reCAPTCHA verifier
          const verifier = new RecaptchaVerifier(auth, 'recaptcha-container', {
            size: 'invisible',
            callback: () => {
              // reCAPTCHA solved - will proceed with phone auth
              logger.debug('reCAPTCHA solved')
            },
            'expired-callback': () => {
              // reCAPTCHA expired - user needs to try again
              logger.warn('reCAPTCHA expired')
              setPhoneError('Verification expired. Please try again.')
            },
          })

          // Render the verifier to ensure it's ready
          verifier.render().then(() => {
            setRecaptchaVerifier(verifier)
            logger.debug('reCAPTCHA initialized successfully')
          }).catch((error) => {
            logger.error('Error rendering reCAPTCHA', error as Error)
            setPhoneError('Failed to initialize verification. Please refresh the page.')
          })
        } catch (error) {
          logger.error('Error initializing reCAPTCHA', error as Error)
          setPhoneError('Verification system error. Please refresh the page.')
        }
      }, 100)

      return () => clearTimeout(timer)
    }

    // Cleanup when modal closes
    if (!showPhoneModal && recaptchaVerifier) {
      try {
        recaptchaVerifier.clear()
      } catch (error) {
        logger.error('Error clearing reCAPTCHA', error as Error)
      }
      setRecaptchaVerifier(null)
    }

    return undefined
  }, [showPhoneModal, recaptchaVerifier])

  const googleLogin = useCallback(async () => {
    setLoading(true)

    try {
      // Use Firebase modular API for Google Auth
      const provider = new GoogleAuthProvider()
      provider.setCustomParameters({
        prompt: 'select_account'
      })

      try {
        // Attempt popup authentication first
        const result = await signInWithPopup(auth, provider)
        const isNewUser = result.user.metadata.creationTime === result.user.metadata.lastSignInTime
        if (isNewUser) {
          trackUserSignUp('google')
        } else {
          trackUserLogin('google')
        }
        // Success - AppProvider will handle navigation
      } catch (error) {
        const firebaseError = error as { code?: string; message?: string }
        // Suppress expected COOP errors in development
        if (import.meta.env.MODE === 'development' && !firebaseError.message?.includes('Cross-Origin-Opener-Policy')) {
          logger.debug('Popup failed, trying redirect', { code: firebaseError.code })
        }

        // Fallback to redirect if popup fails
        if (firebaseError.code === 'auth/popup-blocked' ||
            firebaseError.code === 'auth/popup-closed-by-user' ||
            (error as Error)?.message?.includes('Cross-Origin-Opener-Policy') ||
            (error as Error)?.message?.includes('window.closed')) {
          try {
            await signInWithRedirect(auth, provider)
            // Redirect initiated, no need to reset loading
            return
          } catch (redirectError) {
            logger.error('Redirect also failed', redirectError as Error)
            alert('Failed to sign in with Google. Please try again.')
          }
        } else if (firebaseError.code !== 'auth/cancelled-popup-request') {
          logger.error('Google sign-in error', error as Error, { code: firebaseError.code })
          alert('Failed to sign in with Google. Please try again.')
        }
        setLoading(false)
      }
    } catch (error) {
      logger.error('Failed to initialize Firebase Auth', error as Error)
      alert('Authentication service not available. Please try again.')
      setLoading(false)
    }
  }, [])

  const handlePhoneSignIn = useCallback(() => {
    setShowPhoneModal(true)
    setPhoneStep('phone')
    setPhoneError('')
    setPhoneNumber('')
  }, [])

  const handleContinueAsGuest = useCallback(() => {
    try {
      // Initialize guest session in store
      initGuestSession()

      // Initialize guest session in storage
      initializeGuestSession()

      logger.info('Guest session initialized')

      // Navigate directly to generate page
      nav('/generate')
    } catch (error) {
      logger.error('Failed to initialize guest session', error as Error)
      alert('Failed to start guest session. Please try again.')
    }
  }, [initGuestSession, nav])

  const handlePhoneSubmit = useCallback(async (phone: string) => {
    setLoading(true)
    setPhoneError('')

    try {
      // Clean phone number - remove formatting
      const cleanedPhone = phone.replace(/\D/g, '')

      // Validate phone number format (US numbers - should be 10 digits)
      if (cleanedPhone.length !== 10) {
        setPhoneError('Please enter a valid 10-digit US phone number')
        setLoading(false)
        return
      }

      // Automatically prepend +1 for US numbers
      const formattedPhone = `+1${cleanedPhone}`

      // Use reCAPTCHA verifier for phone authentication
      if (!recaptchaVerifier) {
        setPhoneError('Verification not ready. Please wait a moment and try again.')
        setLoading(false)
        return
      }

      logger.debug('Sending verification code', { phone: formattedPhone })
      const confirmation = await signInWithPhoneNumber(auth, formattedPhone, recaptchaVerifier)
      setConfirmationResult(confirmation)
      setPhoneNumber(phone)
      setPhoneStep('code')
      logger.info('Verification code sent successfully')
    } catch (error) {
      const firebaseError = error as { code?: string; message?: string }
      logger.error('Phone sign-in error', error as Error, { code: firebaseError.code })

      // Provide user-friendly error messages
      switch (firebaseError.code) {
        case 'auth/invalid-phone-number':
          setPhoneError('Invalid phone number format. Please check and try again.')
          break
        case 'auth/too-many-requests':
          setPhoneError('Too many attempts. Please wait a few minutes and try again.')
          break
        case 'auth/quota-exceeded':
          setPhoneError('SMS quota exceeded. Please try again later or contact support.')
          break
        case 'auth/invalid-app-credential':
          setPhoneError('Authentication service error. Please try again or use Google sign-in.')
          break
        case 'auth/captcha-check-failed':
          setPhoneError('Verification failed. Please refresh the page and try again.')
          // Clear and reinitialize reCAPTCHA
          if (recaptchaVerifier) {
            try {
              recaptchaVerifier.clear()
              setRecaptchaVerifier(null)
            } catch (clearError) {
              logger.error('Error clearing reCAPTCHA after failure', clearError as Error)
            }
          }
          break
        case 'auth/missing-phone-number':
          setPhoneError('Please enter a phone number.')
          break
        default:
          setPhoneError(firebaseError.message || 'Failed to send verification code. Please try again.')
      }
    } finally {
      setLoading(false)
    }
  }, [recaptchaVerifier])

  const handleCodeSubmit = useCallback(async (code: string) => {
    setLoading(true)
    setPhoneError('')

    try {
      if (!confirmationResult) {
        setPhoneError('Verification session expired. Please request a new code.')
        setPhoneStep('phone')
        setLoading(false)
        return
      }

      // Validate code format
      if (!/^\d{6}$/.test(code)) {
        setPhoneError('Please enter a valid 6-digit code.')
        setLoading(false)
        return
      }

      logger.debug('Verifying code')
      const result = await confirmationResult.confirm(code)
      const isNewUser = result.user.metadata.creationTime === result.user.metadata.lastSignInTime

      if (isNewUser) {
        trackUserSignUp('phone')
        logger.info('New user signed up via phone')
      } else {
        trackUserLogin('phone')
        logger.info('User logged in via phone')
      }

      // Success - close modal and AppProvider will handle navigation
      setShowPhoneModal(false)
      setPhoneStep('phone')
      setPhoneNumber('')
      setConfirmationResult(null)
    } catch (error) {
      const firebaseError = error as { code?: string; message?: string }
      logger.error('Code verification error', error as Error, { code: firebaseError.code })

      switch (firebaseError.code) {
        case 'auth/invalid-verification-code':
          setPhoneError('Invalid code. Please check and try again.')
          break
        case 'auth/code-expired':
          setPhoneError('Code expired. Please request a new one.')
          setPhoneStep('phone')
          setConfirmationResult(null)
          break
        case 'auth/session-expired':
          setPhoneError('Session expired. Please start over.')
          setPhoneStep('phone')
          setConfirmationResult(null)
          break
        default:
          setPhoneError(firebaseError.message || 'Failed to verify code. Please try again.')
      }
    } finally {
      setLoading(false)
    }
  }, [confirmationResult])

  const handleClosePhoneModal = useCallback(() => {
    setShowPhoneModal(false)
    setPhoneStep('phone')
    setPhoneNumber('')
    setPhoneError('')
    setConfirmationResult(null)
    if (recaptchaVerifier) {
      recaptchaVerifier.clear()
      setRecaptchaVerifier(null)
    }
  }, [recaptchaVerifier])

  // Memoize feature cards data to prevent unnecessary re-renders
  const featureCards = useMemo(() => [
    {
      icon: <Brain className="h-7 w-7" />,
      title: "AI-Powered Workouts",
      desc: "Personalized training plans that adapt to your progress and goals using advanced machine learning algorithms.",
      bgGradient: "from-blue-500/10 via-indigo-500/10 to-purple-500/10",
      iconBg: "from-blue-500 to-indigo-600",
      accentColor: "blue" as const,
    },
    {
      icon: <Target className="h-7 w-7" />,
      title: "Goal-Focused Training",
      desc: "Every workout is optimized to help you reach your specific fitness objectives faster and more efficiently.",
      bgGradient: "from-emerald-500/10 via-teal-500/10 to-cyan-500/10",
      iconBg: "from-emerald-500 to-teal-600",
      accentColor: "emerald" as const,
    },
    {
      icon: <Shield className="h-7 w-7" />,
      title: "Safety First",
      desc: "Built-in injury prevention with intelligent form guidance and personalized recovery recommendations.",
      bgGradient: "from-orange-500/10 via-amber-500/10 to-yellow-500/10",
      iconBg: "from-orange-500 to-amber-600",
      accentColor: "orange" as const,
    },
  ], [])

  return (
    <div className="min-h-screen bg-white text-gray-900 relative overflow-hidden" role="main" aria-label="NeuraFit Authentication Page">
      {/* Premium Background with Mesh Gradient */}
      <div className="absolute inset-0 bg-gradient-to-br from-slate-50 via-white to-blue-50/20" />
      <div className="absolute inset-0 bg-[radial-gradient(ellipse_at_top_right,rgba(59,130,246,0.12),transparent_50%)]" />
      <div className="absolute inset-0 bg-[radial-gradient(ellipse_at_bottom_left,rgba(16,185,129,0.08),transparent_50%)]" />

      {/* Animated Mesh Grid */}
      <div className="absolute inset-0 opacity-[0.015]">
        <div className="absolute inset-0" style={{
          backgroundImage: 'linear-gradient(rgba(0,0,0,0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(0,0,0,0.05) 1px, transparent 1px)',
          backgroundSize: '64px 64px'
        }} />
      </div>

      {/* Floating Orbs - More Subtle and Elegant */}
      <div className="absolute top-1/4 -left-20 w-96 h-96 bg-gradient-to-br from-blue-400/20 to-indigo-500/20 rounded-full blur-3xl animate-float-enhanced will-change-transform" />
      <div className="absolute top-1/3 -right-20 w-80 h-80 bg-gradient-to-br from-emerald-400/15 to-teal-500/15 rounded-full blur-3xl animate-float-enhanced will-change-transform" style={{ animationDelay: '2s' }} />
      <div className="absolute bottom-1/4 left-1/4 w-64 h-64 bg-gradient-to-br from-purple-400/10 to-pink-500/10 rounded-full blur-3xl animate-float-enhanced will-change-transform" style={{ animationDelay: '4s' }} />

      {/* Main Content Container */}
      <div className="relative max-w-lg mx-auto px-4 xs:px-5 sm:px-6 py-8 xs:py-10 sm:py-12 md:py-16 animate-fade-in-up safe-area-inset-top safe-area-inset-bottom" style={{ animationDelay: '0.1s', animationFillMode: 'both' }}>
        {/* Premium Header Badge */}
        <div className="flex items-center justify-center mb-8 xs:mb-9 sm:mb-10 md:mb-14">
          <div className="group inline-flex items-center gap-2 xs:gap-2.5 sm:gap-3 px-4 xs:px-5 sm:px-7 py-2 xs:py-2.5 sm:py-3.5 bg-white/60 backdrop-blur-xl border border-gray-200/60 rounded-full shadow-lg shadow-gray-200/50 hover:shadow-xl hover:shadow-blue-200/30 transition-all duration-700 hover:scale-[1.03] cursor-default touch-manipulation">
            <div className="relative">
              <div className="absolute inset-0 bg-gradient-to-r from-blue-500 to-indigo-500 rounded-full blur-md opacity-20 group-hover:opacity-40 transition-opacity duration-700" />
              <Zap className="h-3.5 xs:h-4 sm:h-4.5 w-3.5 xs:w-4 sm:w-4.5 text-blue-600 group-hover:text-indigo-600 transition-all duration-700 relative z-10" strokeWidth={2.5} />
            </div>
            <span className="text-[11px] xs:text-xs sm:text-sm font-semibold bg-gradient-to-r from-gray-700 to-gray-900 bg-clip-text text-transparent tracking-wide group-hover:from-blue-600 group-hover:to-indigo-600 transition-all duration-700">
              AI-Powered Fitness Technology
            </span>
          </div>
        </div>

        {/* Hero Title - Apple-inspired Typography */}
        <div className="text-center mb-10 xs:mb-12 sm:mb-14 md:mb-16">
          <h1 className="text-3xl xs:text-3.5xl sm:text-5xl md:text-6xl font-bold leading-[1.15] xs:leading-[1.12] sm:leading-[1.1] mb-6 xs:mb-7 sm:mb-8 md:mb-10 tracking-tight px-1 xs:px-2" role="heading" aria-level={1}>
            <span className="block mb-1.5 xs:mb-2 sm:mb-2.5 md:mb-3 text-gray-900">Transform Your Body</span>
            <span className="block mb-1.5 xs:mb-2 sm:mb-2.5 md:mb-3">
              <span className="text-gray-900">with </span>
              <span className="relative inline-block">
                <span className="bg-gradient-to-r from-blue-600 via-indigo-600 to-purple-600 bg-clip-text text-transparent animate-gradient-x">
                  AI-Powered
                </span>
                <div className="absolute -inset-1 bg-gradient-to-r from-blue-600/20 via-indigo-600/20 to-purple-600/20 blur-2xl -z-10 opacity-50" />
              </span>
            </span>
            <span className="relative inline-block">
              <span className="bg-gradient-to-r from-emerald-600 via-teal-600 to-cyan-600 bg-clip-text text-transparent animate-gradient-x">
                Precision
              </span>
              <div className="absolute -inset-1 bg-gradient-to-r from-emerald-600/20 via-teal-600/20 to-cyan-600/20 blur-2xl -z-10 opacity-50" />
            </span>
          </h1>
          <p className="text-gray-600 text-sm xs:text-base sm:text-lg leading-relaxed max-w-md mx-auto px-2 xs:px-3 sm:px-4 font-normal">
            Experience personalized workout plans that evolve with you. Our advanced AI
            analyzes your progress, adapts to your goals, and delivers{' '}
            <span className="text-blue-600 font-semibold">results that matter.</span>
          </p>
        </div>

        {/* Premium CTA Buttons */}
        <div className="space-y-3 xs:space-y-3.5 sm:space-y-4 mb-12 xs:mb-14 sm:mb-16 md:mb-20">
          <button
            onClick={googleLogin}
            disabled={loading}
            className="group relative w-full bg-white backdrop-blur-xl border border-gray-200 text-gray-800 px-4 xs:px-5 sm:px-6 py-4 xs:py-4.5 sm:py-5 rounded-[18px] xs:rounded-[20px] font-semibold hover:bg-gray-50 hover:border-gray-300 hover:shadow-2xl hover:shadow-gray-300/30 transition-all duration-700 disabled:opacity-60 disabled:cursor-not-allowed flex items-center justify-center gap-2.5 xs:gap-3 sm:gap-3.5 shadow-xl shadow-gray-200/40 hover:scale-[1.01] active:scale-[0.99] overflow-hidden touch-manipulation min-h-[52px] xs:min-h-[56px] sm:min-h-[60px]"
            aria-label="Sign in with Google"
            type="button"
          >
            {/* Animated gradient border effect */}
            <div className="absolute inset-0 rounded-[18px] xs:rounded-[20px] opacity-0 group-hover:opacity-100 transition-opacity duration-700 bg-gradient-to-r from-blue-500/10 via-purple-500/10 to-pink-500/10" />

            {/* Google glyph */}
            <svg className="h-5 xs:h-5.5 sm:h-5.5 w-5 xs:w-5.5 sm:w-5.5 transition-transform duration-500 group-hover:scale-110 group-hover:rotate-3 relative z-10 flex-shrink-0" viewBox="0 0 48 48" aria-hidden="true">
              <path fill="#EA4335" d="M24 9.5c3.94 0 7.48 1.53 10.2 4.02l6.8-6.8C36.84 2.61 30.77 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.96 6.18C12.3 13 17.74 9.5 24 9.5z"/>
              <path fill="#4285F4" d="M46.5 24c0-1.64-.15-3.22-.44-4.75H24v9.01h12.65c-.55 2.94-2.23 5.43-4.74 7.11l7.24 5.62C43.99 36.76 46.5 30.79 46.5 24z"/>
              <path fill="#FBBC05" d="M10.52 27.6A14.47 14.47 0 0 1 9.5 24c0-1.25.17-2.46.48-3.6l-7.96-6.18A24 24 0 0 0 0 24c0 3.84.9 7.47 2.5 10.68l8.02-7.08z"/>
              <path fill="#34A853" d="M24 48c6.48 0 11.92-2.14 15.9-5.83l-7.24-5.62c-2.01 1.36-4.59 2.16-8.66 2.16-6.26 0-11.7-3.5-13.48-8.52l-8.02 7.08C6.51 42.62 14.62 48 24 48z"/>
            </svg>
            <span className="transition-all duration-500 group-hover:text-gray-900 relative z-10 flex items-center gap-2 xs:gap-2.5 text-sm xs:text-[15px] sm:text-[15px] font-medium">
              {loading && (
                <div className="animate-spin rounded-full h-4 xs:h-4.5 w-4 xs:w-4.5 border-2 border-gray-400 border-t-transparent flex-shrink-0" role="status" aria-label="Loading" />
              )}
              {loading ? 'Signing in...' : 'Continue with Google'}
            </span>

            {/* Loading shimmer effect */}
            {loading && (
              <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/40 to-transparent animate-shimmer" />
            )}
          </button>

          {/* Phone Sign-In Button */}
          <button
            onClick={handlePhoneSignIn}
            disabled={loading}
            className="group relative w-full bg-white backdrop-blur-xl border border-gray-200 text-gray-800 px-4 xs:px-5 sm:px-6 py-4 xs:py-4.5 sm:py-5 rounded-[18px] xs:rounded-[20px] font-semibold hover:bg-gray-50 hover:border-gray-300 hover:shadow-2xl hover:shadow-gray-300/30 transition-all duration-700 disabled:opacity-60 disabled:cursor-not-allowed flex items-center justify-center gap-2.5 xs:gap-3 sm:gap-3.5 shadow-xl shadow-gray-200/40 hover:scale-[1.01] active:scale-[0.99] overflow-hidden touch-manipulation min-h-[52px] xs:min-h-[56px] sm:min-h-[60px]"
            aria-label="Sign in with Phone"
            type="button"
          >
            {/* Animated gradient border effect */}
            <div className="absolute inset-0 rounded-[18px] xs:rounded-[20px] opacity-0 group-hover:opacity-100 transition-opacity duration-700 bg-gradient-to-r from-emerald-500/10 via-teal-500/10 to-cyan-500/10" />

            <Smartphone className="h-5 xs:h-5.5 sm:h-5.5 w-5 xs:w-5.5 sm:w-5.5 text-gray-700 transition-all duration-500 group-hover:scale-110 group-hover:-rotate-3 relative z-10 flex-shrink-0" strokeWidth={2} />
            <span className="transition-all duration-500 group-hover:text-gray-900 relative z-10 text-sm xs:text-[15px] sm:text-[15px] font-medium">
              Continue with Phone
            </span>
          </button>

          {/* Continue as Guest Button */}
          <button
            onClick={handleContinueAsGuest}
            disabled={loading}
            className="group relative w-full bg-gradient-to-r from-amber-50 to-orange-50 backdrop-blur-xl border border-amber-200 text-gray-800 px-4 xs:px-5 sm:px-6 py-4 xs:py-4.5 sm:py-5 rounded-[18px] xs:rounded-[20px] font-semibold hover:bg-gradient-to-r hover:from-amber-100 hover:to-orange-100 hover:border-amber-300 hover:shadow-2xl hover:shadow-amber-300/30 transition-all duration-700 disabled:opacity-60 disabled:cursor-not-allowed flex items-center justify-center gap-2.5 xs:gap-3 sm:gap-3.5 shadow-xl shadow-amber-200/40 hover:scale-[1.01] active:scale-[0.99] overflow-hidden touch-manipulation min-h-[52px] xs:min-h-[56px] sm:min-h-[60px]"
            aria-label="Continue as Guest"
            type="button"
          >
            {/* Animated gradient border effect */}
            <div className="absolute inset-0 rounded-[18px] xs:rounded-[20px] opacity-0 group-hover:opacity-100 transition-opacity duration-700 bg-gradient-to-r from-amber-500/10 via-orange-500/10 to-red-500/10" />

            <ZapIcon className="h-5 xs:h-5.5 sm:h-5.5 w-5 xs:w-5.5 sm:w-5.5 text-amber-600 transition-all duration-500 group-hover:scale-110 group-hover:rotate-3 relative z-10 flex-shrink-0" strokeWidth={2} />
            <span className="transition-all duration-500 group-hover:text-gray-900 relative z-10 text-sm xs:text-[15px] sm:text-[15px] font-medium">
              Continue as Guest
            </span>
          </button>
        </div>

        {/* Why Choose NeuraFit Section - Premium Design */}
        <div className="mb-12 xs:mb-14 sm:mb-16">
          <div className="text-center mb-10 xs:mb-12 sm:mb-14">
            <h2 className="text-2xl xs:text-2.5xl sm:text-3xl md:text-4xl font-bold mb-3 xs:mb-4 sm:mb-5 text-gray-900 tracking-tight px-1">
              Why Choose{' '}
              <span className="relative inline-block">
                <span className="bg-gradient-to-r from-blue-600 to-indigo-600 bg-clip-text text-transparent">
                  NeuraFit
                </span>
                <div className="absolute -inset-1 bg-gradient-to-r from-blue-600/20 to-indigo-600/20 blur-xl -z-10 opacity-40" />
              </span>
              ?
            </h2>
            <p className="text-gray-600 text-sm xs:text-base sm:text-lg leading-relaxed max-w-md mx-auto px-2 xs:px-3 sm:px-4 font-normal">
              Experience the perfect blend of cutting-edge AI technology and personalized fitness coaching
            </p>
          </div>

          {/* Premium Feature Cards */}
          <div className="space-y-4 xs:space-y-4.5 sm:space-y-5">
            {featureCards.map((card, index) => (
              <div key={card.title} className="animate-fade-in-up" style={{ animationDelay: `${0.3 + index * 0.1}s`, animationFillMode: 'both' }}>
                <FeatureCard
                  icon={card.icon}
                  title={card.title}
                  desc={card.desc}
                  bgGradient={card.bgGradient}
                  iconBg={card.iconBg}
                  accentColor={card.accentColor}
                />
              </div>
            ))}
          </div>
        </div>

        {/* Premium Footer */}
        <div className="text-center pt-8 xs:pt-9 sm:pt-10 border-t border-gray-200/60">
          <p className="text-[11px] xs:text-xs sm:text-xs text-gray-500 leading-relaxed px-2">
            By continuing, you agree to our{' '}
            <Link to="/terms" className="text-blue-600 hover:text-blue-700 font-medium transition-colors duration-300 underline-offset-2 hover:underline">terms of service</Link>
            {' '}and{' '}
            <Link to="/privacy" className="text-blue-600 hover:text-blue-700 font-medium transition-colors duration-300 underline-offset-2 hover:underline">privacy policy</Link>.
            <br />
            <span className="text-gray-400 font-medium mt-2 inline-block text-[10px] xs:text-[11px]">Secure authentication powered by Firebase • v1.0.0</span>
          </p>
        </div>
      </div>

      {/* Phone Authentication Modal */}
      <PhoneAuthModal
        isOpen={showPhoneModal}
        onClose={handleClosePhoneModal}
        onSubmitPhone={handlePhoneSubmit}
        onSubmitCode={handleCodeSubmit}
        step={phoneStep}
        loading={loading}
        error={phoneError}
        phoneNumber={phoneNumber}
      />

      {/* Invisible reCAPTCHA container */}
      <div id="recaptcha-container"></div>
    </div>
  )
}
=================================================================================
FILE: src/pages/Dashboard.tsx
=================================================================================
// src/pages/Dashboard.tsx
import { useMemo, useEffect, useState, useCallback, type CSSProperties } from 'react'
import { useNavigate } from 'react-router-dom'
import { auth, db } from '../lib/firebase'
import { collection, query, orderBy, getDocs, limit } from 'firebase/firestore'
import { convertToDate } from '../utils/timestamp'
import { logger } from '../lib/logger'
import {
  Zap,
  History,
  User as UserIcon,
  Activity
} from 'lucide-react'
import AppHeader from '../components/AppHeader'
import { Button } from '../ui/Button'
import { Card } from '../ui/Card'
import { MotivationalBanner } from '../components/MotivationalBanner'
import { DeferredRender } from '../components/DeferredRender'
import { usePrefetchOnIdle } from '../hooks/usePrefetch'

interface WorkoutItem {
  id: string
  workoutType: string
  duration: number
  timestamp: Date | { toDate(): Date } | string
  exercises?: Array<{
    name: string
    sets: number
    reps: string | number
    weights?: Record<number, number | null>
    usesWeight?: boolean
  }>
  completionRate?: number
}

interface DashboardStats {
  totalWorkouts: number
  weeklyWorkouts: number
  consistencyScore: number
  recentStreak: number
}

// Extract stats calculation outside component - only created once
function calculateDashboardStats(workouts: WorkoutItem[]): DashboardStats {
  if (workouts.length === 0) {
    return {
      totalWorkouts: 0,
      weeklyWorkouts: 0,
      consistencyScore: 0,
      recentStreak: 0,
    }
  }

  const now = new Date()
  const thirtyDaysAgo = new Date(now)
  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30)
  const weekAgo = new Date(now)
  weekAgo.setDate(weekAgo.getDate() - 7)

  // Calculate consistency over last 30 days (percentage of active days)
  const recentWorkouts = workouts.filter(w => convertToDate(w.timestamp) >= thirtyDaysAgo)
  const activeDays = new Set(recentWorkouts.map(w => convertToDate(w.timestamp).toDateString())).size
  const consistencyScore = Math.round((activeDays / 30) * 100)

  // Calculate weekly workouts (count in last 7 days)
  const weeklyWorkouts = workouts.filter(w => convertToDate(w.timestamp) >= weekAgo).length

  // Calculate recent streak
  // Workouts are already sorted newest first from query
  let streak = 0
  let currentDate = new Date()
  for (const workout of workouts) {
    const workoutDate = convertToDate(workout.timestamp)
    if (!workout.timestamp) break

    const daysDiff = Math.floor((currentDate.getTime() - workoutDate.getTime()) / (1000 * 60 * 60 * 24))
    if (daysDiff <= 1 || (streak === 0 && daysDiff <= 7)) {
      streak++
      currentDate = workoutDate
    } else {
      break
    }
  }

  return {
    totalWorkouts: workouts.length,
    weeklyWorkouts,
    consistencyScore,
    recentStreak: streak,
  }
}

// Constants
const WORKOUTS_PER_PAGE = 20 // Optimal for performance and UX

export default function Dashboard() {
  const nav = useNavigate()
  const [workouts, setWorkouts] = useState<WorkoutItem[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  // Prefetch likely next routes on idle
  usePrefetchOnIdle(['/generate', '/history', '/profile'], 3000)

  // Memoized navigation handlers
  const handleGenerateClick = useCallback(() => nav('/generate'), [nav])
  const handleHistoryClick = useCallback(() => nav('/history'), [nav])
  const handleProfileClick = useCallback(() => nav('/profile'), [nav])

  // Calculate dashboard stats (memoized because calculation is expensive with array operations)
  const dashboardStats = useMemo(() => {
    return calculateDashboardStats(workouts)
  }, [workouts])

  // Fetch dashboard data with pagination
  useEffect(() => {
    const fetchDashboardData = async () => {
      try {
        const uid = auth.currentUser?.uid
        if (!uid) {
          setError('Not authenticated')
          return
        }

        // Fetch workouts with pagination (fetch one extra to check if there are more)
        const workoutsRef = collection(db, 'users', uid, 'workouts')
        const workoutsQuery = query(
          workoutsRef,
          orderBy('timestamp', 'desc'),
          limit(WORKOUTS_PER_PAGE + 1)
        )
        const workoutsSnap = await getDocs(workoutsQuery)

        // Map and validate Firestore data with runtime type checking
        const fetchedWorkouts = workoutsSnap.docs
          .map(doc => ({ id: doc.id, ...doc.data() }) as Partial<WorkoutItem> & { id: string })
          .filter((item): item is WorkoutItem => {
            // Runtime validation to ensure data integrity
            return (
              typeof item.workoutType === 'string' &&
              typeof item.duration === 'number' &&
              item.timestamp !== undefined
            )
          })

        setWorkouts(fetchedWorkouts)
        logger.debug('Dashboard data loaded', { workoutCount: fetchedWorkouts.length })
      } catch (err) {
        const error = err as { message?: string }
        logger.error('Error fetching dashboard data', err as Error)
        setError(error.message || 'Failed to load dashboard data')
      } finally {
        setLoading(false)
      }
    }

    fetchDashboardData()
  }, [])

  if (loading) {
    return (
      <div className="min-h-screen bg-white relative">
        {/* Premium Background with Mesh Gradient */}
        <div className="absolute inset-0 bg-gradient-to-br from-slate-50 via-white to-blue-50/20" />
        <div className="absolute inset-0 bg-[radial-gradient(ellipse_at_top_right,rgba(59,130,246,0.12),transparent_50%)]" />
        <div className="absolute inset-0 bg-[radial-gradient(ellipse_at_bottom_left,rgba(16,185,129,0.08),transparent_50%)]" />

        {/* Animated Mesh Grid */}
        <div className="absolute inset-0 opacity-[0.015]">
          <div className="absolute inset-0" style={{
            backgroundImage: 'linear-gradient(rgba(0,0,0,0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(0,0,0,0.05) 1px, transparent 1px)',
            backgroundSize: '64px 64px'
          }} />
        </div>

        {/* Floating Orbs */}
        <div className="absolute top-1/4 -left-20 w-96 h-96 bg-gradient-to-br from-blue-400/20 to-indigo-500/20 rounded-full blur-3xl animate-float will-change-transform" style={{'--float-intensity': '-20px'} as unknown as CSSProperties} />
        <div className="absolute top-1/3 -right-20 w-80 h-80 bg-gradient-to-br from-emerald-400/15 to-teal-500/15 rounded-full blur-3xl animate-float will-change-transform" style={{'--float-intensity': '-30px', animationDelay: '2s'} as unknown as CSSProperties} />

        <AppHeader />
        <div className="relative mx-auto max-w-6xl px-3 xs:px-4 sm:px-6 pt-3 xs:pt-4 sm:pt-5">
          <div className="animate-pulse space-y-4 xs:space-y-5 sm:space-y-6">
            {/* Hero skeleton - Premium */}
            <div className="h-28 xs:h-32 sm:h-36 bg-white/70 backdrop-blur-xl rounded-lg xs:rounded-2xl sm:rounded-[24px] shadow-xl shadow-gray-200/50 border border-gray-200/60">
              <div className="p-4 xs:p-6 sm:p-7 space-y-3 xs:space-y-4">
                <div className="h-7 xs:h-8 sm:h-9 bg-gradient-to-r from-slate-200/70 to-slate-300/50 rounded-lg xs:rounded-xl w-2/3 shadow-sm"></div>
                <div className="h-4 xs:h-5 bg-gradient-to-r from-slate-200/50 to-slate-300/40 rounded-lg w-full max-w-md"></div>
              </div>
            </div>

            {/* Motivational banner skeleton - Premium */}
            <div className="h-24 xs:h-28 sm:h-32 bg-white/70 backdrop-blur-xl rounded-lg xs:rounded-2xl sm:rounded-[24px] shadow-xl shadow-gray-200/50 border border-gray-200/60">
              <div className="p-4 xs:p-6 sm:p-7 flex items-center gap-3 xs:gap-5">
                <div className="w-14 h-14 xs:w-16 xs:h-16 sm:w-18 sm:h-18 bg-gradient-to-br from-slate-200/70 to-slate-300/50 rounded-lg xs:rounded-[20px] shadow-md flex-shrink-0"></div>
                <div className="flex-1 space-y-2 xs:space-y-3">
                  <div className="h-5 xs:h-6 bg-gradient-to-r from-slate-200/70 to-slate-300/50 rounded-lg w-44"></div>
                  <div className="h-3 xs:h-4 bg-gradient-to-r from-slate-200/50 to-slate-300/40 rounded-md w-60"></div>
                </div>
              </div>
            </div>

            {/* Quick actions skeleton - Premium */}
            <div className="space-y-3 xs:space-y-4 sm:space-y-5">
              <div className="h-6 xs:h-7 sm:h-8 bg-gradient-to-r from-slate-200/70 to-slate-300/50 rounded-lg xs:rounded-xl w-40 shadow-sm"></div>
              <div className="grid grid-cols-1 lg:grid-cols-2 gap-3 xs:gap-4 sm:gap-5">
                {[...Array(2)].map((_, i) => (
                  <div key={i} className="h-24 xs:h-[100px] sm:h-[108px] bg-white/70 backdrop-blur-xl rounded-lg xs:rounded-2xl sm:rounded-[24px] shadow-xl shadow-gray-200/50 border border-gray-200/60">
                    <div className="p-4 xs:p-6 sm:p-7 flex items-center gap-3 xs:gap-5">
                      <div className="w-14 h-14 xs:w-16 xs:h-16 sm:w-18 sm:h-18 bg-gradient-to-br from-slate-200/70 to-slate-300/50 rounded-lg xs:rounded-[20px] shadow-md flex-shrink-0"></div>
                      <div className="flex-1 space-y-2 xs:space-y-3">
                        <div className="h-5 xs:h-6 bg-gradient-to-r from-slate-200/70 to-slate-300/50 rounded-lg w-40"></div>
                        <div className="h-3 xs:h-4 bg-gradient-to-r from-slate-200/50 to-slate-300/40 rounded-md w-44"></div>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </div>

            {/* Profile settings skeleton - Premium */}
            <div className="h-24 xs:h-[100px] sm:h-[108px] bg-white/70 backdrop-blur-xl rounded-lg xs:rounded-2xl sm:rounded-[24px] shadow-xl shadow-gray-200/50 border border-gray-200/60">
              <div className="p-4 xs:p-6 sm:p-7 flex items-center gap-3 xs:gap-5">
                <div className="w-14 h-14 xs:w-16 xs:h-16 sm:w-18 sm:h-18 bg-gradient-to-br from-slate-200/70 to-slate-300/50 rounded-lg xs:rounded-[20px] shadow-md flex-shrink-0"></div>
                <div className="flex-1 space-y-2 xs:space-y-3">
                  <div className="h-5 xs:h-6 bg-gradient-to-r from-slate-200/70 to-slate-300/50 rounded-lg w-44"></div>
                  <div className="h-3 xs:h-4 bg-gradient-to-r from-slate-200/50 to-slate-300/40 rounded-md w-52"></div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    )
  }

  if (error) {
    return (
      <div className="min-h-screen bg-white relative">
        {/* Premium Background with Error Tint */}
        <div className="absolute inset-0 bg-gradient-to-br from-slate-50 via-white to-red-50/20" />
        <div className="absolute inset-0 bg-[radial-gradient(ellipse_at_top_right,rgba(239,68,68,0.12),transparent_50%)]" />
        <div className="absolute inset-0 bg-[radial-gradient(ellipse_at_bottom_left,rgba(251,146,60,0.08),transparent_50%)]" />

        <AppHeader />
        <div className="relative mx-auto max-w-2xl px-3 xs:px-4 sm:px-6 pt-12 xs:pt-16 sm:pt-20">
          <div className="bg-white/70 backdrop-blur-xl rounded-2xl xs:rounded-3xl sm:rounded-[32px] p-6 xs:p-10 sm:p-14 border border-gray-200/60 shadow-2xl shadow-red-200/30 text-center">
            {/* Error icon with premium styling */}
            <div className="relative inline-flex items-center justify-center mb-6 xs:mb-8">
              <div className="w-20 xs:w-24 h-20 xs:h-24 bg-gradient-to-br from-red-500 to-orange-500 rounded-lg xs:rounded-2xl sm:rounded-[24px] flex items-center justify-center shadow-xl shadow-red-500/30 flex-shrink-0">
                <Activity className="h-10 xs:h-12 w-10 xs:w-12 text-white" strokeWidth={2} />
              </div>
              <div className="absolute inset-0 bg-gradient-to-br from-red-500 to-orange-500 rounded-lg xs:rounded-2xl sm:rounded-[24px] blur-xl opacity-30" />
            </div>

            {/* Error message with premium typography */}
            <h2 className="text-2xl xs:text-3xl sm:text-4xl font-bold text-gray-900 mb-3 xs:mb-4 tracking-tight">Unable to Load Dashboard</h2>
            <p className="text-gray-600 text-sm xs:text-base sm:text-lg mb-8 xs:mb-10 leading-relaxed max-w-md mx-auto font-normal">{error}</p>

            {/* Premium button */}
            <Button
              onClick={() => window.location.reload()}
              className="shadow-xl hover:shadow-2xl transition-all duration-500"
            >
              Try Again
            </Button>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-white relative">
      {/* Premium Background with Mesh Gradient */}
      <div className="absolute inset-0 bg-gradient-to-br from-slate-50 via-white to-blue-50/20" />
      <div className="absolute inset-0 bg-[radial-gradient(ellipse_at_top_right,rgba(59,130,246,0.12),transparent_50%)]" />
      <div className="absolute inset-0 bg-[radial-gradient(ellipse_at_bottom_left,rgba(16,185,129,0.08),transparent_50%)]" />

      {/* Animated Mesh Grid */}
      <div className="absolute inset-0 opacity-[0.015]">
        <div className="absolute inset-0" style={{
          backgroundImage: 'linear-gradient(rgba(0,0,0,0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(0,0,0,0.05) 1px, transparent 1px)',
          backgroundSize: '64px 64px'
        }} />
      </div>

      {/* Floating Orbs - More Subtle and Elegant */}
      <div className="absolute top-1/4 -left-20 w-96 h-96 bg-gradient-to-br from-blue-400/20 to-indigo-500/20 rounded-full blur-3xl animate-float will-change-transform" style={{'--float-intensity': '-20px'} as unknown as CSSProperties} />
      <div className="absolute top-1/3 -right-20 w-80 h-80 bg-gradient-to-br from-emerald-400/15 to-teal-500/15 rounded-full blur-3xl animate-float will-change-transform" style={{'--float-intensity': '-30px', animationDelay: '2s'} as unknown as CSSProperties} />
      <div className="absolute bottom-1/4 left-1/4 w-64 h-64 bg-gradient-to-br from-purple-400/10 to-pink-500/10 rounded-full blur-3xl animate-float will-change-transform" style={{'--float-intensity': '-15px', animationDelay: '4s'} as unknown as CSSProperties} />

      <AppHeader />

      {/* Hero Section - Premium Design */}
      <section className="relative mx-auto max-w-6xl px-3 xs:px-4 sm:px-6 pt-3 xs:pt-4 sm:pt-5 animate-slide-in-up">
        <div className="group relative rounded-lg xs:rounded-2xl sm:rounded-[24px] border border-gray-200/60 bg-white/70 backdrop-blur-xl p-4 xs:p-6 sm:p-7 overflow-hidden shadow-xl shadow-gray-200/50 hover:shadow-2xl hover:shadow-gray-300/30 transition-all duration-700 ease-out">
          {/* Animated gradient overlays */}
          <div className="absolute -right-24 -top-24 h-80 w-80 rounded-full bg-gradient-to-tr from-blue-400/20 via-indigo-400/15 to-purple-400/10 opacity-50 blur-3xl group-hover:opacity-70 transition-opacity duration-700" aria-hidden="true" />
          <div className="absolute -left-16 -bottom-16 h-64 w-64 rounded-full bg-gradient-to-br from-emerald-300/15 via-teal-300/10 to-transparent opacity-40 blur-3xl group-hover:opacity-60 transition-opacity duration-700" aria-hidden="true" />

          {/* Subtle shimmer effect */}
          <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/10 to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-700" aria-hidden="true" />

          <div className="relative">
            <div className="flex items-start justify-between gap-3 xs:gap-4">
              <div className="flex-1 min-w-0">
                <h1 className="text-2xl xs:text-3xl sm:text-4xl font-bold tracking-tight text-gray-900 leading-tight mb-1.5 xs:mb-2 drop-shadow-sm">
                  Welcome Back
                </h1>
                <p className="text-gray-600 text-sm xs:text-base sm:text-lg leading-relaxed font-normal max-w-2xl">
                  {dashboardStats?.totalWorkouts === 0
                    ? "Ready to start your fitness journey?"
                    : "Keep up the momentum!"
                  }
                </p>
              </div>
            </div>
          </div>
        </div>
      </section>

      {/* Motivational Banner - Premium */}
      {dashboardStats && dashboardStats.totalWorkouts > 0 && (
        <section className="relative mx-auto max-w-6xl px-3 xs:px-4 sm:px-6 mt-4 xs:mt-5 sm:mt-6 animate-slide-in-up" style={{ animationDelay: '0.1s' }}>
          <DeferredRender
            minHeight="120px"
            placeholder={
              <div className="h-24 xs:h-28 bg-white/70 backdrop-blur-xl rounded-lg xs:rounded-2xl sm:rounded-[24px] shadow-xl shadow-gray-200/50 border border-gray-200/60 animate-pulse" />
            }
          >
            <MotivationalBanner
              totalWorkouts={dashboardStats.totalWorkouts}
              weeklyWorkouts={dashboardStats.weeklyWorkouts}
              streak={dashboardStats.recentStreak}
              consistencyScore={dashboardStats.consistencyScore}
            />
          </DeferredRender>
        </section>
      )}

      {/* Quick Actions - Premium Design */}
      <section className="relative mx-auto max-w-6xl px-3 xs:px-4 sm:px-6 mt-5 xs:mt-6 sm:mt-8 animate-slide-in-up" style={{ animationDelay: '0.2s' }}>
        <h2 className="text-lg xs:text-xl sm:text-2xl font-bold text-gray-900 mb-3 xs:mb-4 sm:mb-5 tracking-tight">
          Quick Actions
        </h2>

        <div className="grid grid-cols-1 lg:grid-cols-2 gap-3 xs:gap-4 sm:gap-5">
          <div
            className="group relative cursor-pointer touch-manipulation"
            onClick={handleGenerateClick}
            role="button"
            tabIndex={0}
            onKeyDown={(e) => e.key === 'Enter' && handleGenerateClick()}
          >
            <Card
              variant="elevated"
              rounded="2xl"
              className="relative p-5 xs:p-6 sm:p-8 border border-gray-200/60 bg-white/70 backdrop-blur-xl shadow-xl shadow-gray-200/50 hover:shadow-2xl hover:shadow-blue-200/30 transition-all duration-700 active:scale-[0.99] overflow-hidden group-hover:-translate-y-1 focus-visible-enhanced min-h-[100px] xs:min-h-[110px] sm:min-h-[120px]"
            >
              {/* Animated gradient overlay */}
              <div className="absolute inset-0 bg-gradient-to-br from-blue-500/10 via-indigo-500/5 to-purple-500/10 opacity-0 group-hover:opacity-100 transition-opacity duration-700" aria-hidden="true" />

              <div className="relative flex items-center gap-4 xs:gap-5 sm:gap-6">
                <div className="relative flex-shrink-0">
                  <div className="w-14 xs:w-16 sm:w-20 h-14 xs:h-16 sm:h-20 rounded-xl xs:rounded-2xl sm:rounded-3xl bg-gradient-to-br from-blue-500 via-blue-600 to-indigo-600 flex items-center justify-center text-white shadow-xl shadow-blue-500/40 group-hover:shadow-2xl group-hover:shadow-blue-500/50 transition-all duration-700 group-hover:scale-110 group-hover:rotate-6">
                    <Zap className="h-7 xs:h-8 sm:h-10 w-7 xs:w-8 sm:w-10 drop-shadow-sm" strokeWidth={2} />
                  </div>
                  <div className="absolute inset-0 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-xl xs:rounded-2xl sm:rounded-3xl blur-xl opacity-0 group-hover:opacity-40 transition-opacity duration-700" aria-hidden="true" />
                </div>
                <div className="flex-1 min-w-0">
                  <h3 className="text-lg xs:text-xl sm:text-2xl font-bold text-gray-900 leading-tight tracking-tight">
                    Generate Workout
                  </h3>
                  <p className="text-gray-600 text-sm xs:text-base leading-snug font-normal mt-1">
                    AI-tailored plans for your goals
                  </p>
                </div>
                <Button
                  size="sm"
                  className="haptic-feedback flex-shrink-0 shadow-lg hover:shadow-xl transition-all duration-500 min-h-[44px] xs:min-h-[48px]"
                  onClick={handleGenerateClick}
                >
                  Start
                </Button>
              </div>
            </Card>
          </div>

          <div
            className="group relative cursor-pointer touch-manipulation"
            onClick={handleHistoryClick}
            role="button"
            tabIndex={0}
            onKeyDown={(e) => e.key === 'Enter' && handleHistoryClick()}
          >
            <Card
              variant="elevated"
              rounded="2xl"
              className="relative p-5 xs:p-6 sm:p-8 border border-gray-200/60 bg-white/70 backdrop-blur-xl shadow-xl shadow-gray-200/50 hover:shadow-2xl hover:shadow-gray-300/30 transition-all duration-700 active:scale-[0.99] overflow-hidden group-hover:-translate-y-1 focus-visible-enhanced min-h-[100px] xs:min-h-[110px] sm:min-h-[120px]"
            >
              {/* Animated gradient overlay */}
              <div className="absolute inset-0 bg-gradient-to-br from-slate-500/10 via-gray-500/5 to-slate-500/10 opacity-0 group-hover:opacity-100 transition-opacity duration-700" aria-hidden="true" />

              <div className="relative flex items-center gap-4 xs:gap-5 sm:gap-6">
                <div className="relative flex-shrink-0">
                  <div className="w-14 xs:w-16 sm:w-20 h-14 xs:h-16 sm:h-20 rounded-xl xs:rounded-2xl sm:rounded-3xl bg-gradient-to-br from-slate-500 via-slate-600 to-gray-600 flex items-center justify-center text-white shadow-xl shadow-slate-500/40 group-hover:shadow-2xl group-hover:shadow-slate-500/50 transition-all duration-700 group-hover:scale-110 group-hover:rotate-6">
                    <History className="h-7 xs:h-8 sm:h-10 w-7 xs:w-8 sm:w-10 drop-shadow-sm" strokeWidth={2} />
                  </div>
                  <div className="absolute inset-0 bg-gradient-to-br from-slate-500 to-gray-600 rounded-xl xs:rounded-2xl sm:rounded-3xl blur-xl opacity-0 group-hover:opacity-40 transition-opacity duration-700" aria-hidden="true" />
                </div>
                <div className="flex-1 min-w-0">
                  <h3 className="text-lg xs:text-xl sm:text-2xl font-bold text-gray-900 leading-tight tracking-tight">
                    Workout History
                  </h3>
                  <p className="text-gray-600 text-sm xs:text-base leading-snug font-normal mt-1">
                    Review and track progress
                  </p>
                </div>
                <Button
                  size="sm"
                  variant="secondary"
                  className="haptic-feedback flex-shrink-0 shadow-lg hover:shadow-xl transition-all duration-500 min-h-[44px] xs:min-h-[48px]"
                  onClick={handleHistoryClick}
                >
                  View
                </Button>
              </div>
            </Card>
          </div>
        </div>
      </section>

      {/* Profile Settings - Premium Design */}
      <section className="relative mx-auto max-w-6xl px-3 xs:px-4 sm:px-6 mt-5 xs:mt-6 sm:mt-8 mb-4 xs:mb-5 sm:mb-6 pb-6 xs:pb-8 sm:pb-10 animate-slide-in-up" style={{ animationDelay: '0.3s' }}>
        <div className="group relative cursor-pointer touch-manipulation" onClick={handleProfileClick} role="button" tabIndex={0} onKeyDown={(e) => e.key === 'Enter' && handleProfileClick()}>
          <div className="relative bg-white/70 backdrop-blur-xl rounded-lg xs:rounded-2xl sm:rounded-[24px] p-5 xs:p-6 sm:p-8 border border-gray-200/60 shadow-xl shadow-gray-200/50 hover:shadow-2xl hover:shadow-gray-300/30 transition-all duration-700 active:scale-[0.99] overflow-hidden hover:-translate-y-1 focus-visible-enhanced min-h-[100px] xs:min-h-[110px] sm:min-h-[120px]">
            {/* Animated gradient overlay */}
            <div className="absolute inset-0 bg-gradient-to-br from-slate-500/10 via-gray-500/5 to-slate-500/10 opacity-0 group-hover:opacity-100 transition-opacity duration-700" aria-hidden="true" />

            <div className="relative flex items-center gap-4 xs:gap-5 sm:gap-6">
              <div className="relative flex-shrink-0">
                <div className="w-14 xs:w-16 sm:w-20 h-14 xs:h-16 sm:h-20 rounded-xl xs:rounded-2xl sm:rounded-3xl bg-gradient-to-br from-slate-500 via-slate-600 to-gray-600 flex items-center justify-center shadow-xl shadow-slate-500/40 group-hover:shadow-2xl group-hover:shadow-slate-500/50 transition-all duration-700 group-hover:scale-110 group-hover:rotate-6">
                  <UserIcon className="h-7 xs:h-8 sm:h-10 w-7 xs:w-8 sm:w-10 text-white drop-shadow-sm" strokeWidth={2} />
                </div>
                <div className="absolute inset-0 bg-gradient-to-br from-slate-500 to-gray-600 rounded-xl xs:rounded-2xl sm:rounded-3xl blur-xl opacity-0 group-hover:opacity-40 transition-opacity duration-700" aria-hidden="true" />
              </div>
              <div className="flex-1 min-w-0">
                <h3 className="text-lg xs:text-xl sm:text-2xl font-bold text-gray-900 leading-tight tracking-tight">Profile Settings</h3>
                <p className="text-gray-600 text-sm xs:text-base leading-snug font-normal mt-1">Update goals & equipment</p>
              </div>
              <Button
                size="sm"
                variant="outline"
                className="haptic-feedback flex-shrink-0 shadow-lg hover:shadow-xl transition-all duration-500 min-h-[44px] xs:min-h-[48px]"
                onClick={handleProfileClick}
              >
                Edit
              </Button>
            </div>
          </div>
        </div>
      </section>

      {error && (
        <div
          className="fixed bottom-4 xs:bottom-6 sm:bottom-8 left-3 xs:left-4 sm:left-auto right-3 xs:right-4 sm:right-4 bg-gradient-to-r from-red-50 to-red-100/95 border border-red-200/70 text-red-800 px-4 xs:px-6 py-4 xs:py-5 rounded-lg xs:rounded-2xl shadow-2xl shadow-red-200/50 backdrop-blur-xl max-w-sm animate-in slide-in-from-right-5 fade-in duration-500 ring-1 ring-red-300/30"
          style={{
            right: 'max(0.75rem, env(safe-area-inset-right))',
            bottom: 'max(1rem, env(safe-area-inset-bottom))',
            maxWidth: 'calc(100vw - 1.5rem)',
          }}
          role="alert"
          aria-live="polite"
        >
          <div className="flex items-start gap-3 xs:gap-4">
            <div className="w-5 xs:w-6 h-5 xs:h-6 rounded-full bg-red-500 flex-shrink-0 mt-0.5 shadow-lg shadow-red-500/40">
              <div className="w-full h-full rounded-full bg-red-400 animate-pulse opacity-75"></div>
            </div>
            <p className="text-xs xs:text-sm font-semibold leading-relaxed">{error}</p>
          </div>
        </div>
      )}
    </div>
  )
}
=================================================================================
FILE: src/pages/Generate.tsx
=================================================================================
// src/pages/Generate.tsx
import { useEffect, useState, useRef } from 'react'
import { useNavigate } from 'react-router-dom'
import AppHeader from '../components/AppHeader'
import { auth } from '../lib/firebase'
import { EQUIPMENT } from '../config/onboarding'
import { isAdaptivePersonalizationEnabled, isIntensityCalibrationEnabled } from '../config/features'
import { trackCustomEvent } from '../lib/firebase-analytics'
import { Brain, Clock, LogIn } from 'lucide-react'
import { ProgressiveLoadingBar } from '../components/Loading'
import { trackWorkoutGenerated } from '../lib/firebase-analytics'
import { useWorkoutPreload } from '../hooks/useWorkoutPreload'
import { WorkoutGenerationError, TimeoutError, ErrorHandler, retryWithBackoff } from '../lib/errors'
import { dedupedFetch } from '../lib/requestManager'
import { useIsGuest, useAppStore } from '../store'
import { clearGuestSession } from '../lib/guest-session'
import { useApp } from '../providers/app-provider-utils'

// Top 14 most common workout types organized by category and popularity
const WORKOUT_CATEGORIES = [
  {
    name: 'Full Body & General',
    types: ['Full Body', 'Core Focus']
  },
  {
    name: 'Body Part Splits',
    types: ['Upper Body', 'Lower Body', 'Legs/Glutes', 'Chest/Triceps', 'Back/Biceps', 'Shoulders']
  },
  {
    name: 'Cardio & Conditioning',
    types: ['Cardio', 'HIIT']
  },
  {
    name: 'Mind-Body & Recovery',
    types: ['Yoga', 'Pilates']
  }
] as const

// Top 6 most common workout durations (optimized for user preferences)
const DUR = [15, 30, 45, 60, 75, 90] as const

// Profile type moved to types file for better organization
// type Profile = {
//   experience?: string
//   goals?: string[]
//   equipment?: string[]
//   personal?: { sex?: string; height?: string; weight?: string }
//   injuries?: { list?: string[]; notes?: string }
// }

export default function Generate() {
  const nav = useNavigate()
  const isGuest = useIsGuest()
  const profile = useAppStore(state => state.profile)
  const { actions } = useApp()
  const [type, setType] = useState<string>()
  const [duration, setDuration] = useState<number>()
  const [equipment, setEquipment] = useState<string[]>([])
  const [preferenceNotes, setPreferenceNotes] = useState<string>('')
  const [loading, setLoading] = useState(false)
  const [showProgressiveLoading, setShowProgressiveLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [showSlowConnectionWarning, setShowSlowConnectionWarning] = useState(false)

  // Abort controller for request cancellation
  const abortControllerRef = useRef<AbortController | null>(null)

  // Use pre-loaded data hook (only for authenticated users)
  const { preloadedData } = useWorkoutPreload(isGuest)

  // Handle preloaded data and navigation
  useEffect(() => {
    const uid = auth.currentUser?.uid

    // Allow guest users to proceed without uid
    if (!uid && !isGuest) {
      nav('/')
      return
    }

    // Skip preload handling for guest users
    if (isGuest) {
      return
    }

    // Handle preloaded data results
    if (!preloadedData.isLoading) {
      if (preloadedData.error) {
        if (preloadedData.error.includes('not found') || preloadedData.error.includes('incomplete')) {
          nav('/onboarding')
          return
        } else {
          const error = ErrorHandler.normalize(preloadedData.error, {
            component: 'Generate',
            action: 'loadProfile'
          })
          ErrorHandler.handle(error)
          nav('/')
          return
        }
      }

      if (preloadedData.profile) {
        // Initialize equipment from profile
        setEquipment((preloadedData.profile['equipment'] as string[]) || [])
      }
    }
  }, [nav, preloadedData, isGuest])

  // Cleanup abort controller on unmount
  useEffect(() => {
    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort()
      }
    }
  }, [])

  // For guests, we don't need preloadedData.profile since we use the guest profile from store
  const disabled = !type || !duration || loading || showProgressiveLoading || (!isGuest && (preloadedData.isLoading || !preloadedData.profile))

  async function generate() {
    if (disabled) return

    setError(null)
    setLoading(true)
    setShowProgressiveLoading(true)

    // Cancel any existing request
    if (abortControllerRef.current) {
      abortControllerRef.current.abort()
    }

    // Create new abort controller
    abortControllerRef.current = new AbortController()

    const uid = auth.currentUser?.uid

    // Use profile from store (guest or authenticated)
    const activeProfile = profile || preloadedData.profile
    if (!activeProfile) {
      setError('Profile not available. Please try again.')
      setLoading(false)
      setShowProgressiveLoading(false)
      return
    }

    const payload = {
      experience: activeProfile['experience'],
      goals: activeProfile['goals'],
      equipment: equipment,
      personalInfo: activeProfile['personal'],
      injuries: activeProfile['injuries'],
      workoutType: type,
      duration,
      uid,
      targetIntensity: preloadedData.targetIntensity,
      progressionNote: preloadedData.progressionNote,
      preferenceNotes: preferenceNotes.trim() || undefined,
      // Send optimized workout history (only last 5 workouts with essential data)
      recentWorkouts: preloadedData.recentWorkouts.slice(0, 5)
    }



    const url = import.meta.env['VITE_WORKOUT_FN_URL'] as string

    try {
      // Use retry with backoff for better error handling
      const result = await retryWithBackoff(
        async () => {
          const TIMEOUT_WARNING = 30_000 // Show warning at 30s
          const TIMEOUT_ABORT = 130_000  // Abort at 130s (2.17 minutes) - allows for server timeout (120s) + buffer

          const warningTimer = setTimeout(() => {
            setShowSlowConnectionWarning(true)
          }, TIMEOUT_WARNING)

          const abortTimer = setTimeout(() => {
            abortControllerRef.current?.abort()
          }, TIMEOUT_ABORT)

          try {
            // Use deduplicated fetch to prevent duplicate requests
            const cacheKey = `workout-${type}-${duration}-${equipment.join(',')}`

            const plan = await dedupedFetch(
              cacheKey,
              async () => {
                const res = await fetch(url, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify(payload),
                  signal: abortControllerRef.current?.signal,
                })

                if (!res.ok) {

                  // 502 Bad Gateway - server error, should retry
                  // 503 Service Unavailable - temporary, should retry
                  // 504 Gateway Timeout - timeout, should retry
                  const shouldRetry = [502, 503, 504].includes(res.status)

                  throw new WorkoutGenerationError(
                    `HTTP ${res.status}`,
                    res.status === 502
                      ? 'The workout generation service is temporarily unavailable. Please try again in a moment.'
                      : 'Failed to generate workout. Please try again.',
                    { component: 'Generate', action: 'generateWorkout', userId: uid },
                    undefined,
                    shouldRetry
                  )
                }

                const plan = await res.json()

                if (!plan?.exercises || !Array.isArray(plan.exercises)) {
                  throw new WorkoutGenerationError(
                    'Invalid AI response',
                    'Received invalid workout data. Please try again.',
                    { component: 'Generate', action: 'generateWorkout', userId: uid }
                  )
                }

                return plan
              },
              { cacheTTL: 0 } // Don't cache workout generation
            )

            return plan
          } finally {
            clearTimeout(warningTimer)
            clearTimeout(abortTimer)
          }
        },
        {
          maxRetries: 2,
          baseDelay: 1000,
          onRetry: (attempt, error) => {
            if (import.meta.env.MODE === 'development') {
              console.log(`Retry attempt ${attempt} after error:`, error.message)
            }
          }
        }
      )

      // Log telemetry for workout generation with intensity
      if (uid && isAdaptivePersonalizationEnabled()) {
        trackCustomEvent('workout_generated_with_intensity', {
          target_intensity: preloadedData.targetIntensity,
          workout_type: type,
          duration,
          has_progression_note: Boolean(preloadedData.progressionNote)
        })
      }

      // Track workout generation in Firebase Analytics
      trackWorkoutGenerated('true', 0)

      sessionStorage.setItem('nf_workout_plan', JSON.stringify({ plan: result, type, duration }))

      // Navigate immediately when workout is ready
      if (import.meta.env.MODE === 'development') {
        console.log('[GENERATE] Workout generated successfully, navigating to preview')
      }

      setLoading(false)
      setShowProgressiveLoading(false)
      setShowSlowConnectionWarning(false)
      nav('/workout/preview')

    } catch (error) {
      // Clear loading states
      setLoading(false)
      setShowProgressiveLoading(false)
      setShowSlowConnectionWarning(false)

      // Handle abort errors
      if (error instanceof Error && error.name === 'AbortError') {
        const timeoutError = new TimeoutError(
          'Request timed out',
          'The server took too long to respond. Please try again.',
          { component: 'Generate', action: 'generateWorkout', userId: uid }
        )
        ErrorHandler.handle(timeoutError)
        setError(timeoutError.userMessage)
        return
      }



      // Handle all other errors
      const appError = ErrorHandler.normalize(error, {
        component: 'Generate',
        action: 'generateWorkout',
        userId: uid
      })

      ErrorHandler.handle(appError)
      setError(appError.userMessage)
    }
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50/80 via-white to-blue-50/20 relative safe-area-inset-bottom">
      {/* Enhanced background decoration */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute -top-40 -right-40 w-96 h-96 bg-gradient-to-br from-blue-100/30 via-indigo-100/20 to-purple-100/10 rounded-full blur-3xl animate-pulse-subtle" aria-hidden="true" />
        <div className="absolute -bottom-40 -left-40 w-80 h-80 bg-gradient-to-tr from-slate-100/25 via-gray-100/15 to-blue-100/10 rounded-full blur-3xl" aria-hidden="true" />
        <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[600px] h-[600px] bg-gradient-radial from-blue-50/20 via-transparent to-transparent rounded-full blur-2xl" aria-hidden="true" />
      </div>

      <AppHeader />

      <main className="relative mx-auto max-w-6xl px-3 xs:px-4 sm:px-6 pb-16 pt-6 xs:pt-7 sm:pt-8">
        {/* Enhanced Hero Section */}
        <section className="group relative rounded-2xl xs:rounded-3xl border border-white/70 bg-gradient-to-br from-white/98 via-white/95 to-white/90 backdrop-blur-xl p-5 xs:p-8 sm:p-10 md:p-12 overflow-hidden shadow-2xl shadow-slate-200/50 hover:shadow-3xl hover:shadow-slate-300/30 transition-all duration-700 hover:scale-[1.005] hover:-translate-y-1 animate-slide-in-up">
          {/* Enhanced background elements */}
          <div className="absolute -right-24 -top-24 h-72 w-72 rounded-full bg-gradient-to-tr from-blue-400/15 via-indigo-400/10 to-purple-400/5 opacity-60 blur-3xl group-hover:opacity-80 group-hover:scale-110 transition-all duration-700" aria-hidden="true" />
          <div className="absolute -left-20 -bottom-20 h-56 w-56 rounded-full bg-gradient-to-tr from-slate-400/10 via-gray-400/5 to-blue-400/5 opacity-40 blur-2xl group-hover:opacity-60 transition-all duration-700" aria-hidden="true" />

          {/* Subtle inner glow */}
          <div className="absolute inset-0 rounded-2xl xs:rounded-3xl bg-gradient-to-br from-white/40 via-transparent to-white/20 pointer-events-none" aria-hidden="true" />

          <div className="relative space-y-5 xs:space-y-6 sm:space-y-8">
            <div className="space-y-3 xs:space-y-4 sm:space-y-6">
              <h1 className="text-2xl xs:text-3xl sm:text-4xl md:text-5xl lg:text-6xl font-bold tracking-tight bg-gradient-to-r from-slate-900 via-slate-800 to-slate-700 bg-clip-text text-transparent leading-tight sm:leading-tight">
                AI Workout Generator
              </h1>
            </div>

            <div className="inline-flex items-center gap-2 xs:gap-3 px-4 xs:px-6 py-2 xs:py-3 bg-gradient-to-r from-blue-500/10 via-indigo-500/5 to-purple-500/5 rounded-xl xs:rounded-2xl border border-blue-200/30 backdrop-blur-sm">
              <div className="w-2 xs:w-3 h-2 xs:h-3 bg-gradient-to-r from-blue-500 to-indigo-600 rounded-full animate-pulse"></div>
              <span className="text-blue-700 font-semibold text-xs xs:text-sm sm:text-base">Get your custom training plan in 30 seconds!</span>
            </div>

            {/* Enhanced benefit highlights */}
            <div className="flex flex-col xs:flex-row xs:flex-wrap gap-3 xs:gap-4 sm:gap-6">
              <div className="flex items-center gap-2 xs:gap-3 text-xs xs:text-sm sm:text-base text-slate-700/90 font-medium">
                <div className="w-2 xs:w-3 h-2 xs:h-3 bg-gradient-to-r from-blue-500 to-blue-600 rounded-full shadow-lg shadow-blue-500/30 flex-shrink-0"></div>
                <span>Personalized for your goals</span>
              </div>
              <div className="flex items-center gap-2 xs:gap-3 text-xs xs:text-sm sm:text-base text-slate-700/90 font-medium">
                <div className="w-2 xs:w-3 h-2 xs:h-3 bg-gradient-to-r from-emerald-500 to-emerald-600 rounded-full shadow-lg shadow-emerald-500/30 flex-shrink-0"></div>
                <span>Equipment-based customization</span>
              </div>
              <div className="flex items-center gap-2 xs:gap-3 text-xs xs:text-sm sm:text-base text-slate-700/90 font-medium">
                <div className="w-2 xs:w-3 h-2 xs:h-3 bg-gradient-to-r from-purple-500 to-purple-600 rounded-full shadow-lg shadow-purple-500/30 flex-shrink-0"></div>
                <span>Injury-safe modifications</span>
              </div>
            </div>
          </div>
        </section>

        {/* Slow Connection Warning */}
        {showSlowConnectionWarning && (
          <div className="fixed inset-x-0 top-20 z-50 flex justify-center px-4">
            <div className="bg-yellow-50 border border-yellow-200 rounded-xl p-4 shadow-lg max-w-md animate-slide-in-up">
              <div className="flex items-start gap-3">
                <div className="flex-shrink-0">
                  <Clock className="h-5 w-5 text-yellow-600" />
                </div>
                <div className="flex-1">
                  <h3 className="text-sm font-medium text-yellow-800 mb-1">
                    Taking longer than usual
                  </h3>
                  <p className="text-sm text-yellow-700">
                    Your connection may be slow. We're still working on your workout...
                  </p>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Enhanced Intensity Calibration Indicator */}
        {preloadedData.targetIntensity !== 1.0 && isIntensityCalibrationEnabled() && (
          <section className="mt-6 xs:mt-8 sm:mt-10 animate-slide-in-up" style={{ animationDelay: '0.1s' }}>
            <div className="group relative rounded-2xl xs:rounded-3xl border border-indigo-200/60 bg-gradient-to-br from-indigo-50/80 via-purple-50/60 to-white/90 backdrop-blur-xl p-5 xs:p-6 sm:p-8 shadow-xl shadow-indigo-200/30 hover:shadow-2xl hover:shadow-indigo-200/40 transition-all duration-500 hover:scale-[1.01] hover:-translate-y-0.5">
              <div className="absolute -right-16 -top-16 h-32 w-32 rounded-full bg-gradient-to-tr from-indigo-400/20 to-purple-400/10 opacity-50 blur-2xl group-hover:opacity-70 group-hover:scale-110 transition-all duration-500" aria-hidden="true" />

              <div className="relative flex items-center gap-3 xs:gap-4 sm:gap-5">
                <div className="w-12 xs:w-14 sm:w-16 h-12 xs:h-14 sm:h-16 bg-gradient-to-br from-indigo-500 via-indigo-600 to-purple-600 rounded-lg xs:rounded-2xl sm:rounded-3xl flex items-center justify-center shadow-xl shadow-indigo-500/30 group-hover:shadow-indigo-500/50 group-hover:scale-110 transition-all duration-500 flex-shrink-0">
                  <Brain className="h-6 xs:h-7 sm:h-8 w-6 xs:w-7 sm:w-8 text-white" />
                </div>
                <div className="flex-1 space-y-1 xs:space-y-2">
                  <div className="font-bold text-base xs:text-lg sm:text-xl text-gray-900 leading-tight">
                    Intensity: {preloadedData.targetIntensity > 1.0 ? '+' : ''}{Math.round((preloadedData.targetIntensity - 1.0) * 100)}%
                  </div>
                  {preloadedData.progressionNote && (
                    <div className="text-xs xs:text-sm sm:text-base text-gray-600/90 font-medium capitalize leading-relaxed">
                      {preloadedData.progressionNote}
                    </div>
                  )}
                  <div className="text-xs text-indigo-600/80 font-medium">
                    AI-adjusted based on your recent workout feedback
                  </div>
                </div>
              </div>
            </div>
          </section>
        )}

        {/* Options */}
        <section className="mt-6 xs:mt-8 sm:mt-10 space-y-4 xs:space-y-5 sm:space-y-6 animate-slide-in-up" style={{ animationDelay: '0.2s' }}>
          {/* Type */}
          <div className="rounded-lg xs:rounded-2xl border border-gray-200 bg-white/70 backdrop-blur-sm p-4 xs:p-5 sm:p-6 shadow-sm">
            <div className="mb-4 flex items-center justify-between">
              <h3 className="font-semibold text-gray-900">Workout Type</h3>
              {type && <span className="text-xs text-gray-500">Selected: {type}</span>}
            </div>

            {/* Categorized Workout Types */}
            <div className="space-y-5">
              {WORKOUT_CATEGORIES.map((category, categoryIndex) => (
                <div key={category.name}>
                  {/* Category Header */}
                  <div className="mb-2.5 flex items-center gap-2">
                    <h4 className="text-xs font-semibold text-gray-500 uppercase tracking-wider">
                      {category.name}
                    </h4>
                    <div className="flex-1 h-px bg-gradient-to-r from-gray-200 to-transparent"></div>
                  </div>

                  {/* Category Types Grid */}
                  <div className={`grid gap-2.5 ${
                    category.types.length === 2
                      ? 'grid-cols-2 md:grid-cols-2'
                      : 'grid-cols-2 md:grid-cols-3 lg:grid-cols-4'
                  }`}>
                    {category.types.map((t) => (
                      <button
                        key={t}
                        onClick={() => setType(t)}
                        className={[
                          'rounded-xl border px-3 py-2.5 text-left transition-all duration-200 text-sm font-medium',
                          type === t
                            ? 'bg-gradient-to-br from-blue-500 to-indigo-600 text-white border-blue-500 shadow-md scale-[1.02]'
                            : 'bg-white/70 border-gray-200 hover:border-blue-300 hover:bg-white text-gray-700 hover:scale-[1.01]'
                        ].join(' ')}
                      >
                        {t}
                      </button>
                    ))}
                  </div>

                  {/* Separator line between categories (except last) */}
                  {categoryIndex < WORKOUT_CATEGORIES.length - 1 && (
                    <div className="mt-4 h-px bg-gray-100"></div>
                  )}
                </div>
              ))}
            </div>
          </div>

          {/* Duration and Equipment */}
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            {/* Duration */}
            <div className="rounded-2xl border border-gray-200 bg-white/70 backdrop-blur-sm p-5 shadow-sm">
            <div className="mb-3 flex items-center justify-between">
              <h3 className="font-semibold text-gray-900">Duration</h3>
              {duration && <span className="text-xs text-gray-500">{duration} min</span>}
            </div>
            <div className="grid grid-cols-2 gap-2">
              {DUR.map((m) => (
                <button
                  key={m}
                  onClick={() => setDuration(m)}
                  className={[
                    'rounded-lg border px-3 py-2 text-sm font-medium transition-all duration-200',
                    duration === m
                      ? 'bg-gradient-to-br from-emerald-500 to-teal-600 text-white border-emerald-500 shadow-md scale-[1.02]'
                      : 'bg-white/70 border-gray-200 hover:border-emerald-300 hover:bg-white text-gray-700 hover:scale-[1.01]'
                  ].join(' ')}
                >
                  {m} min
                </button>
              ))}
            </div>

            </div>

            {/* Equipment */}
            <div className="rounded-2xl border border-gray-200 bg-white/70 backdrop-blur-sm p-5 shadow-sm">
              <div className="mb-3 flex items-center justify-between">
                <h3 className="font-semibold text-gray-900">Available Equipment</h3>
                {equipment.length > 0 && <span className="text-xs text-gray-500">{equipment.length} selected</span>}
              </div>
              <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
                {EQUIPMENT.map((eq) => (
                  <button
                    key={eq}
                    onClick={() => {
                      setEquipment(prev =>
                        prev.includes(eq)
                          ? prev.filter(e => e !== eq)
                          : [...prev, eq]
                      )
                    }}
                    className={[
                      'rounded-lg border px-3 py-2 text-sm font-medium transition-all duration-200 text-left',
                      equipment.includes(eq)
                        ? 'bg-gradient-to-br from-orange-500 to-amber-600 text-white border-orange-500 shadow-md scale-[1.02]'
                        : 'bg-white/70 border-gray-200 hover:border-orange-300 hover:bg-white text-gray-700 hover:scale-[1.01]'
                    ].join(' ')}
                  >
                    {eq}
                  </button>
                ))}
              </div>

            </div>
          </div>
        </section>

        {/* Workout Preferences */}
        <section className="mt-6">
          <div className="rounded-2xl border border-gray-200 bg-white/70 backdrop-blur-sm p-5 shadow-sm">
            <div className="mb-3">
              <h3 className="font-semibold text-gray-900">Workout Preferences (Optional)</h3>
              <p className="text-xs text-gray-500 mt-1">Add any specific preferences or notes for the AI to consider</p>
            </div>
            <textarea
              value={preferenceNotes}
              onChange={(e) => setPreferenceNotes(e.target.value)}
              placeholder="e.g., I prefer exercises that don't require lying down, focus on unilateral movements, include more core work, etc."
              maxLength={500}
              rows={3}
              className="w-full rounded-lg border border-gray-200 bg-white/90 px-4 py-3 text-sm text-gray-900 placeholder-gray-400 focus:border-blue-400 focus:outline-none focus:ring-2 focus:ring-blue-100 transition-all resize-none"
            />
            <div className="mt-2 flex items-center justify-between">
              <span className="text-xs text-gray-400">
                {preferenceNotes.length}/500 characters
              </span>
              {preferenceNotes.length > 0 && (
                <button
                  onClick={() => setPreferenceNotes('')}
                  className="text-xs text-gray-500 hover:text-gray-700 transition-colors"
                >
                  Clear
                </button>
              )}
            </div>
          </div>
        </section>

        {/* Error */}
        {error && (
          <div className="mt-6 p-4 bg-red-50 border border-red-200 rounded-xl">
            <p className="text-red-800 text-sm">{error}</p>
            <button
              onClick={() => {
                setError(null)
                generate()
              }}
              className="mt-3 px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors"
            >
              Retry
            </button>
          </div>
        )}

        {/* Guest Account CTA */}
        {isGuest && (
          <div className="mt-8 p-5 xs:p-6 sm:p-7 bg-gradient-to-r from-blue-50 to-indigo-50 border border-blue-200 rounded-2xl shadow-sm">
            <div className="flex items-start gap-4">
              <div className="flex-shrink-0 mt-1">
                <LogIn className="h-5 w-5 text-blue-600" />
              </div>
              <div className="flex-1">
                <h3 className="font-semibold text-gray-900 mb-1">Unlock Personalized Workouts</h3>
                <p className="text-sm text-gray-700 mb-4">
                  Create an account to get AI-powered workouts tailored to your fitness level, goals, and equipment. Track your progress, save your favorite workouts, and watch your performance improve over time.
                </p>
                <button
                  onClick={() => {
                    // Clear guest session from storage
                    clearGuestSession()
                    // Clear guest state from store
                    actions.setIsGuest(false)
                    actions.setAuthStatus('signedOut')
                    actions.setProfile(null)
                    // Navigate to auth page
                    nav('/')
                  }}
                  className="inline-flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg font-medium hover:bg-blue-700 transition-colors"
                >
                  <LogIn className="h-4 w-4" />
                  Create Account
                </button>
              </div>
            </div>
          </div>
        )}

        {/* Generate CTA */}
        <div className="mt-8 flex justify-center sm:justify-end">
          <button
            onClick={generate}
            disabled={disabled}
            className={[
              'rounded-xl px-8 py-4 font-semibold transition-all duration-300 shadow-sm touch-manipulation min-h-[56px] w-full sm:w-auto',
              disabled
                ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                : 'bg-gradient-to-r from-blue-500 to-indigo-600 text-white hover:from-blue-600 hover:to-indigo-700 hover:shadow-lg hover:scale-105 active:scale-95'
            ].join(' ')}
          >
            {loading || showProgressiveLoading ? (
              <div className="flex items-center gap-3">
                <div className="relative">
                  <div className="w-5 h-5 border-2 border-white/30 border-t-white rounded-full animate-spin"></div>
                  <div className="absolute inset-0 w-5 h-5 border border-white/20 rounded-full animate-pulse"></div>
                </div>
                <span className="font-semibold">Generating AI Workout…</span>
              </div>
            ) : preloadedData.isLoading ? (
              <div className="flex items-center gap-3">
                <div className="relative">
                  <div className="w-5 h-5 border-2 border-white/30 border-t-white rounded-full animate-spin"></div>
                </div>
                <span className="font-semibold">Loading Profile…</span>
              </div>
            ) : (
              <div className="flex items-center gap-2">
                <Brain className="w-5 h-5" />
                <span className="font-semibold">Generate Workout</span>
              </div>
            )}
          </button>
        </div>
      </main>

      {/* Progressive Loading Bar */}
      <ProgressiveLoadingBar
        isVisible={showProgressiveLoading}
        onComplete={() => {
          // Loading bar animation completed
          if (import.meta.env.MODE === 'development') {
            console.log('Loading animation complete')
          }
        }}
        text="Generating your personalized workout..."
      />
    </div>
  )
}
=================================================================================
FILE: src/pages/History.tsx
=================================================================================
import { useEffect, useState, useMemo } from 'react'
import { useNavigate } from 'react-router-dom'
import { auth, db } from '../lib/firebase'
import { collection, getDocs, orderBy, query, limit, startAfter, doc, getDoc } from 'firebase/firestore'
import { convertToDate } from '../utils/timestamp'
import { ArrowLeft, Calendar, Clock, CheckCircle, XCircle, Zap, Activity } from 'lucide-react'
import AppHeader from '../components/AppHeader'
import { WorkoutHistorySkeleton } from '../components/Loading'
import { logger } from '../lib/logger'

type WorkoutItem = {
  id: string
  workoutType: string
  duration: number
  plannedDuration?: number
  exercises?: { name: string; sets: number; reps: string | number; weights?: Record<number, number | null>; usesWeight?: boolean }[]
  timestamp?: Date | { toDate(): Date } | string
}

// Memoized date formatter
const formatDate = (timestamp: Date | { toDate(): Date } | string): string => {
  if (!timestamp) return 'Unknown date'
  const date = convertToDate(timestamp)
  return date.toLocaleDateString('en-US', {
    month: 'short',
    day: 'numeric',
    year: 'numeric'
  })
}

// Memoized workout stats calculator
const calculateWorkoutStats = (workout: WorkoutItem) => {
  if (!workout.exercises || workout.exercises.length === 0) {
    return { totalExercises: 0, completedExercises: 0, totalSets: 0, completedSets: 0, fullyCompletedExercises: 0 }
  }

  const totalExercises = workout.exercises.length
  let completedExercises = 0 // Exercises with ANY completed sets
  let fullyCompletedExercises = 0 // Exercises with ALL sets completed
  let totalSets = 0
  let completedSets = 0

  workout.exercises.forEach(exercise => {
    totalSets += exercise.sets

    // Calculate completed sets for this exercise using the exact same logic as WorkoutDetail
    let exerciseCompletedSets = 0

    if (exercise.weights && typeof exercise.weights === 'object') {
      // Count all entries with non-null values (including 0 which indicates completed sets)
      // null values indicate skipped sets
      exerciseCompletedSets = Object.values(exercise.weights).filter(w => w !== null).length
    } else {
      // No weights data means no sets were tracked (shouldn't happen with new system)
      exerciseCompletedSets = 0
    }

    completedSets += exerciseCompletedSets

    // Exercise is considered "completed" if it has ANY completed sets
    if (exerciseCompletedSets > 0) {
      completedExercises++
    }

    // Track fully completed exercises separately
    if (exerciseCompletedSets === exercise.sets) {
      fullyCompletedExercises++
    }
  })

  return { totalExercises, completedExercises, totalSets, completedSets, fullyCompletedExercises }
}

export default function History() {
  const nav = useNavigate()
  const [items, setItems] = useState<WorkoutItem[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [hasMore, setHasMore] = useState(false)
  const [loadingMore, setLoadingMore] = useState(false)
  const WORKOUTS_PER_PAGE = 20

  // Fetch workout history with pagination
  useEffect(() => {
    (async () => {
      try {
        const uid = auth.currentUser?.uid
        if (!uid) {
          setError('Not authenticated')
          return
        }

        logger.debug('Loading workout history', { uid })
        // Fetch one extra to check if there are more
        const q = query(
          collection(db, 'users', uid, 'workouts'),
          orderBy('timestamp', 'desc'),
          limit(WORKOUTS_PER_PAGE + 1)
        )
        const snap = await getDocs(q)

        const workouts = snap.docs.map(d => {
          const data = d.data()
          return { id: d.id, ...data } as WorkoutItem
        })

        // Check if there are more workouts
        if (workouts.length > WORKOUTS_PER_PAGE) {
          setHasMore(true)
          workouts.pop() // Remove the extra item
        } else {
          setHasMore(false)
        }

        logger.debug('Workout history loaded', { count: workouts.length, hasMore: workouts.length > WORKOUTS_PER_PAGE })
        setItems(workouts)
      } catch (err) {
        const error = err as { message?: string }
        logger.error('Error fetching workout history', err as Error)
        setError(error.message || 'Failed to load workout history')
      } finally {
        setLoading(false)
      }
    })()
  }, [WORKOUTS_PER_PAGE])

  // Load more workouts
  const loadMoreWorkouts = async () => {
    if (loadingMore || !hasMore || items.length === 0) return

    setLoadingMore(true)
    try {
      const uid = auth.currentUser?.uid
      if (!uid) return

      const lastWorkout = items[items.length - 1]
      if (!lastWorkout) return

      const lastDoc = await getDoc(doc(db, 'users', uid, 'workouts', lastWorkout.id))

      const q = query(
        collection(db, 'users', uid, 'workouts'),
        orderBy('timestamp', 'desc'),
        startAfter(lastDoc),
        limit(WORKOUTS_PER_PAGE + 1)
      )
      const snap = await getDocs(q)

      const newWorkouts = snap.docs.map(d => {
        const data = d.data()
        return { id: d.id, ...data } as WorkoutItem
      })

      // Check if there are more workouts
      if (newWorkouts.length > WORKOUTS_PER_PAGE) {
        setHasMore(true)
        newWorkouts.pop() // Remove the extra item
      } else {
        setHasMore(false)
      }

      setItems([...items, ...newWorkouts])
      logger.debug('Loaded more workouts', { newCount: newWorkouts.length, totalCount: items.length + newWorkouts.length })
    } catch (err) {
      logger.error('Error loading more workouts', err as Error)
    } finally {
      setLoadingMore(false)
    }
  }

  // Memoize workout stats calculations
  const workoutStats = useMemo(() => {
    return items.map(workout => ({
      id: workout.id,
      stats: calculateWorkoutStats(workout),
    }))
  }, [items])

  if (loading) {
    return <WorkoutHistorySkeleton />
  }

  if (error) {
    return (
      <div className="min-h-screen bg-white">
        <div className="max-w-md mx-auto px-6 py-8">
          <div className="text-center">
            <XCircle className="h-12 w-12 text-red-500 mx-auto mb-4" />
            <h1 className="text-xl font-semibold text-gray-900 mb-2">Unable to Load History</h1>
            <p className="text-gray-600 mb-6">{error}</p>
            <button
              onClick={() => nav('/dashboard')}
              className="inline-flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
            >
              <ArrowLeft className="h-4 w-4" />
              Back to Dashboard
            </button>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 via-white to-indigo-50 relative">
      {/* Background decoration */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute -top-40 -right-40 w-80 h-80 bg-gradient-to-br from-blue-200/30 to-indigo-200/30 rounded-full blur-3xl" aria-hidden="true" />
        <div className="absolute -bottom-40 -left-40 w-80 h-80 bg-gradient-to-tr from-indigo-200/30 to-blue-200/30 rounded-full blur-3xl" aria-hidden="true" />
      </div>

      <AppHeader />

      {/* Main Content */}
      <main className="relative max-w-4xl mx-auto px-3 xs:px-4 sm:px-6 py-6 xs:py-7 sm:py-8">
        {/* Page Header */}
        <div className="text-center mb-6 xs:mb-7 sm:mb-8 animate-slide-in-up">
          <div className="inline-flex items-center gap-2 px-3 xs:px-4 py-1.5 xs:py-2 bg-blue-50 rounded-full mb-3 xs:mb-4">
            <Activity className="h-3.5 xs:h-4 w-3.5 xs:w-4 text-blue-600" />
            <span className="text-xs xs:text-sm font-medium text-blue-600">Workout History</span>
          </div>
          <h1 className="text-2xl xs:text-3xl sm:text-4xl font-bold text-gray-900 mb-2 xs:mb-3">Your Workout History</h1>
          <p className="text-gray-600 text-sm xs:text-base max-w-2xl mx-auto leading-relaxed">
            Track your completed workouts and monitor your progress over time.
          </p>
        </div>

        {/* Workout List */}
        {items.length === 0 ? (
          <div className="text-center py-12 xs:py-16 sm:py-20 animate-fade-in">
            <div className="bg-gray-50 rounded-full w-14 xs:w-16 sm:w-20 h-14 xs:h-16 sm:h-20 flex items-center justify-center mx-auto mb-4 xs:mb-6">
              <Activity className="h-7 xs:h-8 sm:h-10 w-7 xs:w-8 sm:w-10 text-gray-400" />
            </div>
            <h3 className="text-lg xs:text-xl sm:text-2xl font-semibold text-gray-900 mb-2 xs:mb-3">No workouts yet</h3>
            <p className="text-gray-600 text-sm xs:text-base mb-6 xs:mb-8">Complete your first workout to start tracking your progress!</p>
            <button
              onClick={() => nav('/generate')}
              className="inline-flex items-center gap-2 px-5 xs:px-6 py-2.5 xs:py-3 bg-blue-600 text-white rounded-lg xs:rounded-xl hover:bg-blue-700 transition-colors min-h-[44px] xs:min-h-[48px] touch-manipulation"
            >
              <Zap className="h-4 xs:h-5 w-4 xs:w-5" />
              Generate Your First Workout
            </button>
          </div>
        ) : (
          <div className="space-y-3 xs:space-y-4 sm:space-y-5 animate-slide-in-up">
            {items.map(workout => {
              // Use memoized stats
              const workoutStat = workoutStats.find(ws => ws.id === workout.id)
              const stats = workoutStat?.stats || { totalExercises: 0, completedExercises: 0, totalSets: 0, completedSets: 0, fullyCompletedExercises: 0 }

              // Calculate completion rate based on sets completed, not exercises
              const setCompletionRate = stats.totalSets > 0 ? Math.round((stats.completedSets / stats.totalSets) * 100) : 0
              const exerciseCompletionRate = stats.totalExercises > 0 ? Math.round((stats.completedExercises / stats.totalExercises) * 100) : 0

              // Use set completion rate as the primary metric
              const completionRate = setCompletionRate

              // Debug logging for workout stats
              if (import.meta.env.MODE === 'development') {
                logger.debug(`Workout "${workout.workoutType}" stats`, {
                  totalExercises: stats.totalExercises,
                  completedExercises: stats.completedExercises,
                  fullyCompletedExercises: stats.fullyCompletedExercises,
                  totalSets: stats.totalSets,
                  completedSets: stats.completedSets,
                  setCompletionRate: setCompletionRate,
                  exerciseCompletionRate: exerciseCompletionRate,
                  finalCompletionRate: completionRate
                })
              }

              return (
                <button
                  key={workout.id}
                  onClick={() => nav(`/workout/${workout.id}`)}
                  className="w-full text-left bg-white border border-gray-200 rounded-lg xs:rounded-xl sm:rounded-2xl p-4 xs:p-5 sm:p-6 hover:border-blue-300 hover:shadow-md transition-all group touch-manipulation min-h-[100px] xs:min-h-[110px]"
                >
                  <div className="flex items-start justify-between gap-3 xs:gap-4 mb-3 xs:mb-4">
                    <div className="flex-1 min-w-0">
                      <h3 className="text-base xs:text-lg sm:text-xl font-semibold text-gray-900 group-hover:text-blue-600 transition-colors leading-tight">
                        {workout.workoutType}
                      </h3>
                      <div className="flex flex-col xs:flex-row xs:items-center gap-2 xs:gap-4 text-xs xs:text-sm text-gray-600 mt-2 xs:mt-2.5">
                        <div className="flex items-center gap-1.5">
                          <Calendar className="h-3.5 xs:h-4 w-3.5 xs:w-4 flex-shrink-0" />
                          <span>{formatDate(workout.timestamp || new Date())}</span>
                        </div>
                        <div className="flex items-center gap-1.5">
                          <Clock className="h-3.5 xs:h-4 w-3.5 xs:w-4 flex-shrink-0" />
                          <span>{workout.duration} min</span>
                        </div>
                      </div>
                    </div>
                    <div className="text-right flex-shrink-0">
                      <div className="flex items-center justify-end gap-1.5 xs:gap-2 mb-1.5 xs:mb-2">
                        {completionRate === 100 ? (
                          <CheckCircle className="h-4 xs:h-5 w-4 xs:w-5 text-green-500 flex-shrink-0" />
                        ) : completionRate > 0 ? (
                          <div className="h-4 xs:h-5 w-4 xs:w-5 rounded-full bg-orange-100 flex items-center justify-center flex-shrink-0">
                            <div className="h-1.5 xs:h-2 w-1.5 xs:w-2 rounded-full bg-orange-500" />
                          </div>
                        ) : (
                          <XCircle className="h-4 xs:h-5 w-4 xs:w-5 text-red-500 flex-shrink-0" />
                        )}
                        <span className="text-xs xs:text-sm font-medium text-gray-700">{completionRate}%</span>
                      </div>
                      <div className="text-xs text-gray-500">
                        {stats.completedSets}/{stats.totalSets} sets
                      </div>
                      <div className="text-xs text-gray-400">
                        {stats.completedExercises}/{stats.totalExercises} exercises
                      </div>
                    </div>
                  </div>

                  {/* Exercise Preview */}
                  {workout.exercises && workout.exercises.length > 0 && (
                    <div className="border-t border-gray-100 pt-3 xs:pt-4">
                      <div className="grid grid-cols-1 xs:grid-cols-2 gap-2 xs:gap-3">
                        {workout.exercises.slice(0, 4).map((exercise: NonNullable<WorkoutItem['exercises']>[0], index: number) => {
                          // Calculate average weight more safely
                          let avgWeight: number | null = null
                          let completedSets = 0

                          if (exercise.weights && typeof exercise.weights === 'object') {
                            const weights = Object.values(exercise.weights).filter((w): w is number => w !== null && w !== undefined && w > 0)
                            completedSets = Object.values(exercise.weights).filter(w => w !== null).length

                            if (weights.length > 0) {
                              avgWeight = Math.round(weights.reduce((sum, w) => sum + w, 0) / weights.length)
                            }
                          }

                          return (
                            <div key={index} className="text-xs xs:text-sm text-gray-700">
                              <span className="font-medium">{exercise.name}</span>
                              <span className="text-gray-500 ml-1.5 xs:ml-2">
                                {completedSets}/{exercise.sets} sets
                                {avgWeight && exercise.usesWeight && (
                                  <span className="text-blue-600 ml-1">@ {avgWeight}lbs</span>
                                )}
                              </span>
                            </div>
                          )
                        })}
                        {workout.exercises.length > 4 && (
                          <div className="text-xs xs:text-sm text-gray-500 italic">
                            + {workout.exercises.length - 4} more
                          </div>
                        )}
                      </div>
                    </div>
                  )}
                </button>
              )
            })}

            {/* Load More Button */}
            {hasMore && (
              <div className="mt-6 xs:mt-8 sm:mt-10 flex justify-center animate-slide-in-up" style={{ animationDelay: '0.3s' }}>
                <button
                  onClick={loadMoreWorkouts}
                  disabled={loadingMore}
                  className="px-5 xs:px-6 py-2.5 xs:py-3 bg-gradient-to-r from-blue-600 to-indigo-600 text-white rounded-lg xs:rounded-xl font-semibold shadow-lg hover:shadow-xl transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed hover:scale-105 active:scale-95 min-h-[44px] xs:min-h-[48px] touch-manipulation text-sm xs:text-base"
                >
                  {loadingMore ? (
                    <span className="flex items-center gap-2">
                      <div className="w-4 xs:w-5 h-4 xs:h-5 border-2 border-white/30 border-t-white rounded-full animate-spin" />
                      Loading...
                    </span>
                  ) : (
                    'Load More Workouts'
                  )}
                </button>
              </div>
            )}
          </div>
        )}
      </main>
    </div>
  )
}
=================================================================================
FILE: src/pages/NotFound.tsx
=================================================================================
/**
 * 404 Not Found Page
 * 
 * Displays a user-friendly error page when a route is not found.
 */

import { useNavigate } from 'react-router-dom';
import { Home, ArrowLeft, Search } from 'lucide-react';

export default function NotFound() {
  const navigate = useNavigate();

  const handleGoHome = () => {
    navigate('/dashboard', { replace: true });
  };

  const handleGoBack = () => {
    navigate(-1);
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-50 via-white to-blue-50 flex items-center justify-center p-4">
      <div className="max-w-md w-full text-center">
        {/* 404 Illustration */}
        <div className="mb-8">
          <div className="inline-flex items-center justify-center w-24 h-24 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-full mb-4">
            <Search className="w-12 h-12 text-white" />
          </div>
          <h1 className="text-6xl font-bold text-gray-900 mb-2">404</h1>
          <h2 className="text-2xl font-semibold text-gray-800 mb-2">
            Page Not Found
          </h2>
          <p className="text-gray-600">
            The page you're looking for doesn't exist or has been moved.
          </p>
        </div>

        {/* Actions */}
        <div className="space-y-3">
          <button
            onClick={handleGoHome}
            className="w-full flex items-center justify-center gap-2 px-6 py-3 bg-gradient-to-r from-blue-500 to-indigo-600 text-white rounded-xl font-medium hover:from-blue-600 hover:to-indigo-700 transition-all duration-200 shadow-lg hover:shadow-xl"
          >
            <Home className="w-5 h-5" />
            Go to Dashboard
          </button>

          <button
            onClick={handleGoBack}
            className="w-full flex items-center justify-center gap-2 px-6 py-3 bg-white text-gray-700 rounded-xl font-medium hover:bg-gray-50 transition-all duration-200 border border-gray-200"
          >
            <ArrowLeft className="w-5 h-5" />
            Go Back
          </button>
        </div>

        {/* Helpful Links */}
        <div className="mt-8 pt-8 border-t border-gray-200">
          <p className="text-sm text-gray-500 mb-3">Quick Links</p>
          <div className="flex flex-wrap justify-center gap-2">
            <button
              onClick={() => navigate('/generate')}
              className="px-4 py-2 text-sm text-blue-600 hover:text-blue-700 hover:bg-blue-50 rounded-lg transition-colors"
            >
              Generate Workout
            </button>
            <button
              onClick={() => navigate('/history')}
              className="px-4 py-2 text-sm text-blue-600 hover:text-blue-700 hover:bg-blue-50 rounded-lg transition-colors"
            >
              Workout History
            </button>
            <button
              onClick={() => navigate('/profile')}
              className="px-4 py-2 text-sm text-blue-600 hover:text-blue-700 hover:bg-blue-50 rounded-lg transition-colors"
            >
              Profile
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}


=================================================================================
FILE: src/pages/Onboarding.tsx
=================================================================================
// src/pages/Onboarding.tsx
import React, { useEffect, useState, useCallback, memo } from 'react'
import { auth, db } from '../lib/firebase'
import { doc, getDoc, setDoc } from 'firebase/firestore'
import { useNavigate, useLocation } from 'react-router-dom'
import { validateUserProfile } from '../lib/validators'
import { logger } from '../lib/logger'
import {
  BookOpen,
  Zap,
  Trophy,
  User,
  Dumbbell,
  Weight,
  Zap as ResistanceBand,
  Circle,
  Settings,
  Monitor,
  Bike,
  Waves,
  ArrowUp,
  Cable,
  Circle as Ball,
  Scale,
  Flame,
  Target,
  Heart,
  Sparkles,
  Shield,
  Brain,
  Move
} from 'lucide-react'
import {
  EXPERIENCE_LEVELS,
  GOALS,
  EQUIPMENT,
  SEX_OPTIONS,
  HEIGHT_RANGES,
  WEIGHT_RANGES,
  INJURY_OPTIONS
} from '../config/onboarding'
import { trackProfileComplete, setEnhancedUserProperties } from '../lib/firebase-analytics'

/** ---------------- DATA ---------------- */
type Personal = { sex?: string; height?: string; weight?: string }
type Injuries = { list: string[]; notes: string }
type Profile = {
  experience?: string
  goals?: string[]
  equipment?: string[]
  personal?: Personal
  injuries?: Injuries
}



type Draft = {
  experience: string | null
  goals: string[]
  equipment: string[]
  personal: Personal
  injuries: Injuries
}

const EMPTY_DRAFT: Draft = {
  experience: null,
  goals: [],
  equipment: [],
  personal: { sex: '', height: '', weight: '' },
  injuries: { list: [], notes: '' },
}

/** -------------- VALIDATION -------------- */
function validStep(step: number, d: Draft): boolean {
  switch (step) {
    case 1: return !!d.experience
    case 2: return d.goals.length > 0
    case 3: return d.equipment.length > 0
    case 4: return !!d.personal.sex && !!d.personal.height && !!d.personal.weight
    case 5: return true
    default: return false
  }
}

/** -------------- UI PRIMITIVES -------------- */
function Progress({ step, total }: { step: number; total: number }) {
  const pct = Math.round((step / total) * 100)
  return (
    <div className="w-full mb-6 xs:mb-7 sm:mb-8" role="progressbar" aria-valuenow={step} aria-valuemin={1} aria-valuemax={total} aria-label={`Progress: Step ${step} of ${total}`}>
      <div className="mb-2 xs:mb-3 flex items-center justify-between text-xs xs:text-sm text-gray-600">
        <span className="font-medium">Step {step} of {total}</span>
        <span className="text-blue-600 font-semibold">{pct}%</span>
      </div>
      <div className="h-2.5 xs:h-3 w-full overflow-hidden rounded-full bg-gray-100 shadow-inner">
        <div
          className="h-full bg-gradient-to-r from-blue-500 to-indigo-600 transition-all duration-500 ease-out rounded-full shadow-sm will-change-transform"
          style={{ width: `${pct}%` }}
          aria-hidden="true"
        />
      </div>
      <div className="mt-2 xs:mt-2.5 flex justify-between gap-1.5">
        {Array.from({ length: total }, (_, i) => (
          <div
            key={i}
            className={`h-1.5 xs:h-2 w-1.5 xs:w-2 rounded-full transition-all duration-300 ${
              i < step ? 'bg-blue-500 scale-110' : 'bg-gray-200'
            }`}
          />
        ))}
      </div>
    </div>
  )
}

function SectionTitle({ title }: { title: string }) {
  return (
    <div className="mb-5 xs:mb-6 sm:mb-7 text-center">
      <h2 className="text-xl xs:text-2xl sm:text-3xl font-bold tracking-tight text-gray-900">{title}</h2>
    </div>
  )
}

function SelectCard({
  active, children, onClick, disabled
}: { active?: boolean; children: React.ReactNode; onClick?: () => void; disabled?: boolean }) {
  return (
    <button
      type="button"
      onClick={onClick}
      disabled={disabled}
      aria-pressed={active}
      className={[
        'group relative w-full rounded-xl xs:rounded-2xl border p-4 xs:p-5 text-xs xs:text-sm transition-all duration-300',
        'text-left shadow-sm hover:shadow-md touch-manipulation min-h-[48px] xs:min-h-[56px] focus-visible-enhanced',
        active
          ? 'border-blue-500 bg-gradient-to-br from-blue-500 to-indigo-600 text-white shadow-lg scale-[1.02]'
          : 'border-gray-200 bg-white/70 backdrop-blur-sm hover:border-blue-300 hover:bg-white hover:scale-[1.01]',
        disabled ? 'opacity-50 cursor-not-allowed' : '',
      ].join(' ')}
    >
      {children}
    </button>
  )
}

function MultiGrid({
  items, selected, onToggle, cols = 2, allowNone
}: { items: string[]; selected: string[]; onToggle: (_v: string) => void; cols?: 1 | 2; allowNone?: boolean }) {
  return (
    <div className={`grid gap-3 ${cols === 2 ? 'grid-cols-2' : 'grid-cols-1'}`}>
      {items.map((v) => (
        <SelectCard
          key={v}
          active={selected.includes(v)}
          onClick={() => onToggle(v)}
        >
          <div className="text-center font-medium">
            {v}
            {allowNone && v.startsWith('None') && <span className="ml-2 text-xs opacity-70">(clears others)</span>}
          </div>
        </SelectCard>
      ))}
    </div>
  )
}

function PrimaryButton({
  children, onClick, disabled, type = 'button'
}: { children: React.ReactNode; onClick?: () => void; disabled?: boolean; type?: 'button' | 'submit' }) {
  return (
    <button
      type={type}
      onClick={disabled ? undefined : onClick}
      disabled={disabled}
      aria-disabled={disabled}
      className={[
        'px-4 xs:px-6 py-2.5 xs:py-3 rounded-lg xs:rounded-xl font-semibold transition-all duration-300 shadow-sm touch-manipulation min-h-[44px] xs:min-h-[48px] focus-visible-enhanced',
        disabled
          ? 'bg-gray-300 text-gray-500 pointer-events-none cursor-not-allowed'
          : 'bg-gradient-to-r from-blue-500 to-indigo-600 text-white hover:from-blue-600 hover:to-indigo-700 hover:shadow-lg hover:scale-105 active:scale-95',
      ].join(' ')}
    >
      {children}
    </button>
  )
}

function SecondaryButton({ children, onClick, disabled }: { children: React.ReactNode; onClick?: () => void; disabled?: boolean }) {
  return (
    <button
      type="button"
      onClick={disabled ? undefined : onClick}
      disabled={disabled}
      aria-disabled={disabled}
      className={[
        'px-4 xs:px-5 py-2.5 xs:py-3 rounded-lg xs:rounded-xl border font-medium transition-all duration-300 touch-manipulation min-h-[44px] xs:min-h-[48px] focus-visible-enhanced',
        disabled
          ? 'border-gray-200 text-gray-400 pointer-events-none cursor-not-allowed'
          : 'border-gray-200 text-gray-700 bg-white hover:bg-gray-50 hover:border-gray-300 hover:shadow-md hover:scale-105 active:scale-95',
      ].join(' ')}
    >
      {children}
    </button>
  )
}

/** -------------- PAGE -------------- */
export default function Onboarding() {
  const nav = useNavigate()
  const location = useLocation()
  const [step, setStep] = useState(1)
  const total = 5
  const [loading, setLoading] = useState(true)
  const [saving, setSaving] = useState(false)
  const [draft, setDraft] = useState<Draft>(EMPTY_DRAFT)

  // Prefill if profile exists (edit-friendly)
  useEffect(() => {
    (async () => {
      const uid = auth.currentUser?.uid
      if (!uid) {
        setLoading(false)
        return
      }
      try {
        const snap = await getDoc(doc(db, 'users', uid))
        if (snap.exists()) {
          const p = snap.data() as Profile
          setDraft({
            experience: p.experience ?? null,
            goals: p.goals ?? [],
            equipment: p.equipment ?? [],
            personal: {
              sex: p.personal?.sex ?? '',
              height: p.personal?.height ?? '',
              weight: p.personal?.weight ?? '',
            },
            injuries: {
              list: p.injuries?.list ?? [],
              notes: p.injuries?.notes ?? '',
            },
          })
        }
      } catch (error) {
        logger.error('Error loading existing profile', error as Error)
        // Continue with empty draft if loading fails
      } finally {
        setLoading(false)
      }
    })()
  }, [])

  // Simple object lookup - no memoization needed
  const getHeader = (currentStep: number) => {
    switch (currentStep) {
      case 1: return { title: 'What’s your training level?'}
      case 2: return { title: 'What are your fitness goals?'}
      case 3: return { title: 'What do you have access to?'}
      case 4: return { title: 'Tell us about you'}
      case 5: return { title: 'Any injuries or limitations?'}
      default: return { title: '' }
    }
  }
  const header = getHeader(step)

  const disableNext = !validStep(step, draft)
  const atStart = step === 1
  const atEnd = step === total

  const toggle = useCallback((list: string[], value: string, allowNone = false) => {
    const isNone = value.startsWith('None')
    // If "None" is selected, clear everything else
    if (allowNone && isNone) return ['None (Bodyweight)', 'None'].includes(value) ? [value] : [value]
    // If list already contains "None", remove it before toggling others
    if (allowNone && list.some((v) => v.startsWith('None'))) {
      list = list.filter((v) => !v.startsWith('None'))
    }
    return list.includes(value) ? list.filter((v) => v !== value) : [...list, value]
  }, [])

  const finish = useCallback(async () => {
    const uid = auth.currentUser?.uid
    if (!uid) {
      logger.warn('Attempted to save profile without user ID')
      return
    }

    setSaving(true)
    try {
      // Prepare profile data
      const profileData = {
        experience: draft.experience,
        goals: draft.goals,
        equipment: draft.equipment,
        personal: draft.personal,
        injuries: draft.injuries || { list: [], notes: '' },
      }

      // Validate profile data
      const validation = validateUserProfile(profileData)

      if (!validation.isValid) {
        logger.warn('Profile validation failed', { errors: validation.errors })
        alert(`Please fix the following errors:\n${validation.errors.join('\n')}`)
        setSaving(false)
        return
      }

      // Save to Firestore
      await setDoc(
        doc(db, 'users', uid),
        {
          ...profileData,
          updated_at: new Date().toISOString(),
        },
        { merge: true }
      )

      logger.info('Profile saved successfully', { uid })

      // Track profile completion
      if (profileData.experience && profileData.goals && profileData.equipment) {
        trackProfileComplete(
          profileData.experience,
          profileData.goals,
          profileData.equipment
        )
      }

      // Set enhanced user properties with location context
      setEnhancedUserProperties(uid, {
        experience: profileData.experience,
        goals: profileData.goals,
        equipment: profileData.equipment,
        personal: profileData.personal,
        injuries: profileData.injuries,
      })

      // Check if there's a saved destination from a protected route redirect
      const from = (location.state as { from?: string })?.from
      const destination = from && from !== '/' && from !== '/onboarding' ? from : '/dashboard'
      nav(destination)
    } catch (error) {
      logger.error('Error saving profile', error as Error, { uid })
      alert('Failed to save profile. Please try again.')
    } finally {
      setSaving(false)
    }
  }, [draft, location, nav])

  // Allow Enter to go Next only when valid
  const onKeyDown = useCallback((e: React.KeyboardEvent<HTMLDivElement>) => {
    if (e.key === 'Enter' && !disableNext) {
      e.preventDefault()
      if (!atEnd) setStep((s) => s + 1)
      else finish()
    }
  }, [disableNext, atEnd, finish])

  if (loading) {
    return (
      <div className="min-h-screen grid place-items-center bg-gradient-to-br from-slate-50 via-white to-blue-50/30">
        <div className="flex flex-col items-center gap-4">
          <div className="h-8 w-8 animate-spin rounded-full border-2 border-blue-200 border-t-blue-600" />
          <p className="text-sm text-gray-600">Loading your profile...</p>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 via-white to-blue-50/30" onKeyDown={onKeyDown} tabIndex={0} role="main" aria-label="Onboarding flow">
      {/* Background Pattern */}
      <div className="absolute inset-0 bg-[radial-gradient(circle_at_50%_120%,rgba(59,130,246,0.05),transparent_50%)]" aria-hidden="true" />

      {/* Content */}
      <div className="relative mx-auto max-w-3xl px-4 xs:px-5 sm:px-6 pt-8 xs:pt-10 sm:pt-12 pb-24 xs:pb-28 sm:pb-32">
        <Progress step={step} total={total} />
        <SectionTitle {...header} />

        {/* Step Content with Animation */}
        <div key={step} className="animate-slide-in-up">
        {/* STEP 1 — EXPERIENCE */}
        {step === 1 && (
          <div className="grid gap-3 xs:gap-4 grid-cols-1 sm:grid-cols-3">
            {EXPERIENCE_LEVELS.map((level) => (
              <SelectCard
                key={level}
                active={draft.experience === level}
                onClick={() => setDraft((d) => ({ ...d, experience: level }))}
              >
                <div className="flex items-center gap-3 xs:gap-4 mb-2 xs:mb-3">
                  <div className={`p-2 xs:p-3 rounded-lg xs:rounded-xl transition-all duration-300 flex-shrink-0 ${
                    draft.experience === level
                      ? 'bg-white/20 border border-white/30'
                      : 'bg-blue-50 border border-blue-100'
                  }`}>
                    {level === 'Beginner' && <BookOpen className={`h-5 xs:h-6 w-5 xs:w-6 ${draft.experience === level ? 'text-white' : 'text-blue-600'}`} />}
                    {level === 'Intermediate' && <Zap className={`h-5 xs:h-6 w-5 xs:w-6 ${draft.experience === level ? 'text-white' : 'text-blue-600'}`} />}
                    {level === 'Expert' && <Trophy className={`h-5 xs:h-6 w-5 xs:w-6 ${draft.experience === level ? 'text-white' : 'text-blue-600'}`} />}
                  </div>
                  <div className="text-base xs:text-lg font-bold">{level}</div>
                </div>
                <div className={`text-xs xs:text-sm leading-relaxed ${
                  draft.experience === level
                    ? 'text-white/90'
                    : 'text-gray-600 group-hover:text-gray-700'
                }`}>
                  {level === 'Beginner' && 'Perfect for those just starting their fitness journey or returning after a break.'}
                  {level === 'Intermediate' && 'You have consistent training experience and understand basic movement patterns.'}
                  {level === 'Expert' && 'You have years of training experience and advanced knowledge of programming.'}
                </div>
              </SelectCard>
            ))}
          </div>
        )}

        {/* STEP 2 — GOALS */}
        {step === 2 && (
          <div className="grid gap-2 xs:gap-3 grid-cols-2 sm:grid-cols-3 lg:grid-cols-4">
            {GOALS.map((goal) => (
              <GoalCard
                key={goal}
                goal={goal}
                active={draft.goals.includes(goal)}
                onClick={() => setDraft((d) => ({ ...d, goals: toggle(d.goals, goal) }))}
              />
            ))}
          </div>
        )}

        {/* STEP 3 — EQUIPMENT */}
        {step === 3 && (
          <div className="grid gap-2 xs:gap-3 grid-cols-2 sm:grid-cols-3 lg:grid-cols-4">
            {EQUIPMENT.map((equipment) => (
              <EquipmentCard
                key={equipment}
                equipment={equipment}
                active={draft.equipment.includes(equipment)}
                onClick={() => setDraft((d) => ({ ...d, equipment: toggle(d.equipment, equipment) }))}
              />
            ))}
          </div>
        )}

        {/* STEP 4 — PERSONAL */}
        {step === 4 && (
          <div className="grid gap-6 xs:gap-7 sm:gap-8">
            {/* Sex Options - Single Row */}
            <div>
              <div className="mb-3 xs:mb-4 text-xs xs:text-sm font-semibold text-gray-700 text-center">Gender</div>
              <div className="grid grid-cols-3 gap-2 xs:gap-3 sm:gap-4">
                {SEX_OPTIONS.map((s) => (
                  <SelectCard
                    key={s}
                    active={draft.personal.sex === s}
                    onClick={() => setDraft((d) => ({ ...d, personal: { ...d.personal, sex: s } }))}
                  >
                    <div className="text-center font-medium text-xs xs:text-sm">{s}</div>
                  </SelectCard>
                ))}
              </div>
            </div>

            {/* Height - 2x3 Grid */}
            <div>
              <div className="mb-3 xs:mb-4 text-xs xs:text-sm font-semibold text-gray-700 text-center">Height Range</div>
              <div className="grid grid-cols-3 gap-2 xs:gap-3">
                {HEIGHT_RANGES.map((h) => (
                  <SelectCard
                    key={h}
                    active={draft.personal.height === h}
                    onClick={() => setDraft((d) => ({ ...d, personal: { ...d.personal, height: h } }))}
                  >
                    <div className="text-center font-medium text-xs xs:text-sm">{h}</div>
                  </SelectCard>
                ))}
              </div>
            </div>

            {/* Weight - 2x3 Grid */}
            <div>
              <div className="mb-3 xs:mb-4 text-xs xs:text-sm font-semibold text-gray-700 text-center">Weight Range</div>
              <div className="grid grid-cols-3 gap-2 xs:gap-3">
                {WEIGHT_RANGES.map((w) => (
                  <SelectCard
                    key={w}
                    active={draft.personal.weight === w}
                    onClick={() => setDraft((d) => ({ ...d, personal: { ...d.personal, weight: w } }))}
                  >
                    <div className="text-center font-medium text-xs xs:text-sm">{w}</div>
                  </SelectCard>
                ))}
              </div>
            </div>
          </div>
        )}

        {/* STEP 5 — INJURIES */}
        {step === 5 && (
          <div className="grid gap-5 xs:gap-6">
            <div className="mb-1 xs:mb-2 text-xs xs:text-sm font-semibold text-gray-700 text-center">Current Injuries or Limitations</div>
            <MultiGrid
              items={INJURY_OPTIONS}
              selected={draft.injuries.list}
              onToggle={(v) =>
                setDraft((d) => {
                  // If selecting "None", keep only None; else toggle and ensure None is removed
                  if (v === 'None') return { ...d, injuries: { ...d.injuries, list: ['None'] } }
                  const list = d.injuries.list.filter((x) => x !== 'None')
                  const next = list.includes(v) ? list.filter((x) => x !== v) : [...list, v]
                  return { ...d, injuries: { ...d.injuries, list: next } }
                })
              }
              cols={2}
            />
            <div>
              <label className="mb-2 xs:mb-3 block text-xs xs:text-sm font-semibold text-gray-700">Additional Notes (optional)</label>
              <textarea
                value={draft.injuries.notes}
                onChange={(e) => setDraft((d) => ({ ...d, injuries: { ...d.injuries, notes: e.target.value } }))}
                placeholder="e.g., mild runner’s knee on right leg; avoid deep flexion"
                className="w-full rounded-lg xs:rounded-2xl border border-gray-200 bg-white/70 backdrop-blur-sm px-3 xs:px-4 py-2.5 xs:py-3 text-xs xs:text-sm outline-none placeholder:text-gray-400 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all duration-300 resize-none"
                rows={4}
                autoComplete="off"
                autoCorrect="off"
                autoCapitalize="sentences"
                spellCheck="true"
                data-gramm="false"
              />
            </div>
          </div>
        )}
        </div>
      </div>

      {/* Fixed Footer Nav */}
      <div className="fixed inset-x-0 bottom-0 z-20 border-t border-gray-200/50 bg-white/90 backdrop-blur-md shadow-lg fixed-bottom-safe">
        <div className="mx-auto max-w-3xl px-4 xs:px-5 sm:px-6 py-3 xs:py-4 flex items-center justify-between gap-3 xs:gap-4">
          <SecondaryButton onClick={() => setStep((s) => Math.max(1, s - 1))} disabled={atStart}>
            Back
          </SecondaryButton>

          <div className="hidden text-xs text-gray-500 sm:block max-w-xs text-center">
            {step === 1 && 'Tip: Be honest about level—your plan adapts.'}
            {step === 2 && 'Tip: Multiple goals are okay; we’ll balance.'}
            {step === 3 && 'Tip: Select all equipment you have access to.'}
            {step === 4 && 'Tip: Ranges personalize without exact numbers.'}
            {step === 5 && 'Tip: Selecting “None” clears other injuries.'}
          </div>

          {!atEnd ? (
            <PrimaryButton onClick={() => setStep((s) => Math.min(total, s + 1))} disabled={disableNext}>
              Next
            </PrimaryButton>
          ) : (
            <PrimaryButton onClick={finish} disabled={saving}>
              {saving ? 'Saving…' : 'Finish'}
            </PrimaryButton>
          )}
        </div>
      </div>
    </div>
  )
}

/* ---------- Goal Card Component ---------- */
const GoalCard = memo(function GoalCard({
  goal,
  active,
  onClick
}: {
  goal: string;
  active: boolean;
  onClick: () => void;
}) {
  return (
    <button
      onClick={onClick}
      type="button"
      className={`
        group relative p-2.5 xs:p-3 rounded-lg xs:rounded-2xl border-2 transition-all duration-300 text-center shadow-sm hover:shadow-lg touch-manipulation min-h-[48px] xs:min-h-[56px]
        ${active
          ? 'bg-gradient-to-br from-blue-500 to-indigo-600 border-blue-500 text-white shadow-lg scale-[1.02]'
          : 'bg-white/70 backdrop-blur-sm border-gray-200 text-gray-700 hover:border-blue-300 hover:bg-white hover:scale-[1.01]'
        }
      `}
    >
      <div className="flex flex-col items-center space-y-1.5 xs:space-y-2">
        <div className={`transition-transform duration-300 group-hover:scale-110 flex-shrink-0 ${active ? 'text-white' : 'text-blue-600'}`}>
          {getGoalIcon(goal, "h-5 xs:h-6 w-5 xs:w-6")}
        </div>
        <div className="text-xs xs:text-xs font-semibold leading-tight">
          {goal}
        </div>
      </div>
    </button>
  )
})

/* ---------- Equipment Card Component ---------- */
const EquipmentCard = memo(function EquipmentCard({
  equipment,
  active,
  onClick
}: {
  equipment: string;
  active: boolean;
  onClick: () => void;
}) {
  return (
    <button
      onClick={onClick}
      type="button"
      className={`
        group relative p-2.5 xs:p-3 rounded-lg xs:rounded-2xl border-2 transition-all duration-300 text-center shadow-sm hover:shadow-lg touch-manipulation min-h-[48px] xs:min-h-[56px]
        ${active
          ? 'bg-gradient-to-br from-emerald-500 to-teal-600 border-emerald-500 text-white shadow-lg scale-[1.02]'
          : 'bg-white/70 backdrop-blur-sm border-gray-200 text-gray-700 hover:border-emerald-300 hover:bg-white hover:scale-[1.01]'
        }
      `}
    >
      <div className="flex flex-col items-center space-y-1.5 xs:space-y-2">
        <div className={`transition-transform duration-300 group-hover:scale-110 flex-shrink-0 ${active ? 'text-white' : 'text-emerald-600'}`}>
          {getEquipmentIcon(equipment, "h-5 xs:h-6 w-5 xs:w-6")}
        </div>
        <div className="text-xs xs:text-xs font-semibold leading-tight">
          {equipment}
        </div>
      </div>
    </button>
  )
})

/* ---------- Equipment Icons ---------- */
function getEquipmentIcon(equipment: string, className: string = "h-6 w-6") {
  switch (equipment) {
    case 'Bodyweight':
      return <User className={className} />
    case 'Dumbbells':
      return <Dumbbell className={className} />
    case 'Barbells':
      return <Weight className={className} />
    case 'Resistance Bands':
      return <ResistanceBand className={className} />
    case 'Kettlebells':
      return <Circle className={className} />
    case 'Medicine Balls':
      return <Ball className={className} />
    case 'Weight Machines':
      return <Settings className={className} />
    case 'Treadmill':
      return <Monitor className={className} />
    case 'Stationary Bike':
      return <Bike className={className} />
    case 'Rowing Machine':
      return <Waves className={className} />
    case 'Pull-Up Bar':
      return <ArrowUp className={className} />
    case 'Cable Machine':
      return <Cable className={className} />
    default:
      return <Circle className={className} />
  }
}

/* ---------- Goal Icons ---------- */
function getGoalIcon(goal: string, className: string = "h-6 w-6") {
  switch (goal) {
    case 'Weight Loss':
      return <Scale className={className} />
    case 'Build Muscle':
      return <Flame className={className} />
    case 'Strength':
      return <Dumbbell className={className} />
    case 'Stamina':
      return <Heart className={className} />
    case 'Tone':
      return <Sparkles className={className} />
    case 'General Health':
      return <Shield className={className} />
    case 'Increase Flexibility':
      return <Move className={className} />
    case 'Sports Performance':
      return <Trophy className={className} />
    case 'Mental Health':
      return <Brain className={className} />
    case 'Injury Prevention':
      return <Shield className={className} />
    default:
      return <Target className={className} />
  }
}
=================================================================================
FILE: src/pages/Privacy.tsx
=================================================================================
// src/pages/Privacy.tsx
import { Link } from 'react-router-dom'

export default function Privacy() {
  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 via-white to-blue-50/30 text-gray-900">
      <div className="mx-auto max-w-3xl px-6 py-12">
        <header className="mb-8">
          <Link to="/" className="text-blue-600 hover:text-blue-700 font-medium">← Back</Link>
          <h1 className="mt-4 text-3xl md:text-4xl font-bold tracking-tight">Privacy Policy</h1>
          <p className="mt-2 text-gray-600">Last updated: September 30, 2025</p>
        </header>

        {/* Table of contents */}
        <nav aria-label="Table of contents" className="mb-8 rounded-2xl border border-gray-200 bg-white/60 backdrop-blur-sm p-4">
          <p className="text-sm font-semibold text-gray-900 mb-3">Table of contents</p>
          <ul className="grid grid-cols-1 sm:grid-cols-2 gap-2 text-sm text-blue-700">
            <li><a href="#overview" className="hover:underline">1) Overview</a></li>
            <li><a href="#information-we-collect" className="hover:underline">2) Information We Collect</a></li>
            <li><a href="#how-we-use-information" className="hover:underline">3) How We Use Information</a></li>
            <li><a href="#ai-processing" className="hover:underline">4) AI Processing & Third Parties</a></li>
            <li><a href="#data-sharing" className="hover:underline">5) Information Sharing</a></li>
            <li><a href="#data-security" className="hover:underline">6) Data Security</a></li>
            <li><a href="#data-retention" className="hover:underline">7) Data Retention</a></li>
            <li><a href="#your-rights" className="hover:underline">8) Your Rights & Choices</a></li>
            <li><a href="#childrens-privacy" className="hover:underline">9) Children's Privacy</a></li>
            <li><a href="#international-users" className="hover:underline">10) International Users</a></li>
            <li><a href="#california-privacy" className="hover:underline">11) California Privacy Rights</a></li>
            <li><a href="#changes-to-policy" className="hover:underline">12) Changes to This Policy</a></li>
            <li><a href="#contact" className="hover:underline">13) Contact Information</a></li>
          </ul>
        </nav>

        <div className="space-y-8 text-sm leading-relaxed text-gray-700">
          <section>
            <h2 id="overview" className="text-lg font-semibold text-gray-900">1) Overview</h2>
            <p className="mt-2">This Privacy Policy explains how NeuraFit ("we," "us," or "our") collects, uses, shares, and protects your personal information when you use our AI-powered workout application and services ("Services"). We are committed to protecting your privacy and being transparent about our data practices.</p>
            <p className="mt-2">By using our Services, you consent to the collection and use of your information as described in this Privacy Policy.</p>
          </section>

          <section>
            <h2 id="information-we-collect" className="text-lg font-semibold text-gray-900">2) Information We Collect</h2>
            <p className="mt-2">We collect several types of information to provide and improve our Services:</p>

            <h3 className="mt-4 font-semibold text-gray-900">Account Information</h3>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Email address and display name from your chosen authentication provider (Google)</li>
              <li>Profile picture (if provided by your authentication provider)</li>
              <li>Account creation and last login timestamps</li>
            </ul>

            <h3 className="mt-4 font-semibold text-gray-900">Fitness Profile Information</h3>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Fitness experience level (beginner, intermediate, expert)</li>
              <li>Fitness goals (weight loss, muscle building, strength, etc.)</li>
              <li>Available equipment preferences</li>
              <li>Physical characteristics (height and weight ranges for personalization)</li>
              <li>Injury information and limitations (only what you choose to disclose)</li>
              <li>Gender (optional, for workout customization)</li>
            </ul>

            <h3 className="mt-4 font-semibold text-gray-900">Workout and Usage Data</h3>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Generated workout plans and exercise selections</li>
              <li>Workout completion status and progress tracking</li>
              <li>Exercise preferences and modifications</li>
              <li>App usage patterns and feature interactions</li>
              <li>Session duration and frequency of use</li>
            </ul>

            <h3 className="mt-4 font-semibold text-gray-900">Technical Information</h3>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Device type, operating system, and app version</li>
              <li>IP address and approximate geographic location</li>
              <li>Browser type and language preferences</li>
              <li>Crash reports and error logs for app stability</li>
              <li>Performance metrics and analytics data</li>
            </ul>
          </section>

          <section>
            <h2 id="how-we-use-information" className="text-lg font-semibold text-gray-900">3) How We Use Your Information</h2>
            <p className="mt-2">We use your information for the following purposes:</p>

            <h3 className="mt-4 font-semibold text-gray-900">Core Service Delivery</h3>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Generate personalized AI workout recommendations</li>
              <li>Customize exercise difficulty and progressions</li>
              <li>Provide safety recommendations based on disclosed injuries</li>
              <li>Save and sync your workout history across devices</li>
              <li>Enable account authentication and access control</li>
            </ul>

            <h3 className="mt-4 font-semibold text-gray-900">Service Improvement</h3>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Analyze usage patterns to improve AI recommendations</li>
              <li>Identify and fix technical issues and bugs</li>
              <li>Develop new features and enhance user experience</li>
              <li>Conduct research to improve workout effectiveness</li>
            </ul>

            <h3 className="mt-4 font-semibold text-gray-900">Communication and Support</h3>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Respond to your questions and support requests</li>
              <li>Send important service updates and security notifications</li>
              <li>Provide information about new features (with your consent)</li>
            </ul>

            <h3 className="mt-4 font-semibold text-gray-900">Legal and Security</h3>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Comply with legal obligations and law enforcement requests</li>
              <li>Protect against fraud, abuse, and security threats</li>
              <li>Enforce our Terms of Service and other policies</li>
            </ul>
          </section>

          <section>
            <h2 id="ai-processing" className="text-lg font-semibold text-gray-900">4) AI Processing and Third-Party Services</h2>
            <p className="mt-2">NeuraFit uses artificial intelligence to generate personalized workout recommendations. Here's how this works:</p>

            <h3 className="mt-4 font-semibold text-gray-900">AI Workout Generation</h3>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Your fitness profile data is processed by AI models to create personalized workouts</li>
              <li>We use third-party AI services (such as OpenAI's GPT models) to generate workout content</li>
              <li>Only necessary information is sent to AI providers (fitness level, goals, equipment, injuries)</li>
              <li>Personal identifiers (name, email) are not included in AI processing requests</li>
              <li>AI providers may temporarily process your data but do not store it for their own purposes</li>
            </ul>

            <h3 className="mt-4 font-semibold text-gray-900">Third-Party Services</h3>
            <p className="mt-2">We work with trusted third-party providers for:</p>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li><strong>Authentication:</strong> Google Firebase for secure sign-in</li>
              <li><strong>Data Storage:</strong> Google Cloud Firestore for secure data storage</li>
              <li><strong>AI Processing:</strong> OpenAI and similar providers for workout generation</li>
              <li><strong>Analytics:</strong> Privacy-focused analytics to improve our service</li>
              <li><strong>Hosting:</strong> Secure cloud hosting providers</li>
            </ul>
            <p className="mt-2">All third-party providers are bound by strict data processing agreements and security requirements.</p>
          </section>

          <section>
            <h2 id="data-sharing" className="text-lg font-semibold text-gray-900">5) Information Sharing and Disclosure</h2>
            <p className="mt-2">We do not sell, rent, or trade your personal information. We may share your information only in the following limited circumstances:</p>

            <h3 className="mt-4 font-semibold text-gray-900">Service Providers</h3>
            <p className="mt-2">We share information with trusted third-party service providers who help us operate our Services, including cloud hosting, data storage, AI processing, and analytics providers. These providers are contractually bound to protect your information and use it only for the services they provide to us.</p>

            <h3 className="mt-4 font-semibold text-gray-900">Legal Requirements</h3>
            <p className="mt-2">We may disclose your information if required by law, court order, or government regulation, or if we believe disclosure is necessary to:</p>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Comply with legal processes or law enforcement requests</li>
              <li>Protect the rights, property, or safety of NeuraFit, our users, or the public</li>
              <li>Prevent fraud, abuse, or security threats</li>
              <li>Enforce our Terms of Service</li>
            </ul>

            <h3 className="mt-4 font-semibold text-gray-900">Business Transfers</h3>
            <p className="mt-2">In the event of a merger, acquisition, or sale of assets, your information may be transferred to the new entity, subject to the same privacy protections outlined in this policy.</p>

            <h3 className="mt-4 font-semibold text-gray-900">Aggregated Data</h3>
            <p className="mt-2">We may share aggregated, anonymized data that cannot identify individual users for research, analytics, or business purposes.</p>
          </section>

          <section>
            <h2 id="data-security" className="text-lg font-semibold text-gray-900">6) Data Security</h2>
            <p className="mt-2">We implement comprehensive security measures to protect your personal information:</p>

            <h3 className="mt-4 font-semibold text-gray-900">Technical Safeguards</h3>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Encryption of data in transit and at rest using industry-standard protocols</li>
              <li>Secure authentication through trusted providers (Google Firebase)</li>
              <li>Regular security audits and vulnerability assessments</li>
              <li>Access controls and monitoring systems</li>
              <li>Secure cloud infrastructure with enterprise-grade security</li>
            </ul>

            <h3 className="mt-4 font-semibold text-gray-900">Organizational Safeguards</h3>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Limited access to personal data on a need-to-know basis</li>
              <li>Employee training on data protection and privacy practices</li>
              <li>Incident response procedures for potential security breaches</li>
              <li>Regular review and updates of security policies</li>
            </ul>

            <p className="mt-2">While we implement strong security measures, no system is completely secure. You can help protect your account by using a strong password and keeping your login credentials confidential.</p>
          </section>

          <section>
            <h2 id="data-retention" className="text-lg font-semibold text-gray-900">7) Data Retention</h2>
            <p className="mt-2">We retain your personal information for as long as necessary to provide our Services and fulfill the purposes outlined in this Privacy Policy. Specific retention periods include:</p>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li><strong>Account Information:</strong> Retained until you delete your account</li>
              <li><strong>Fitness Profile:</strong> Retained to provide personalized recommendations</li>
              <li><strong>Workout History:</strong> Retained to track your progress and improve recommendations</li>
              <li><strong>Technical Data:</strong> Typically retained for 12-24 months for analytics and debugging</li>
              <li><strong>Support Communications:</strong> Retained for 3 years for quality assurance</li>
            </ul>
            <p className="mt-2">When you delete your account, we will delete or anonymize your personal information within 30 days, except where we are required to retain it for legal compliance.</p>
          </section>

          <section>
            <h2 id="your-rights" className="text-lg font-semibold text-gray-900">8) Your Rights and Choices</h2>
            <p className="mt-2">You have several rights regarding your personal information:</p>

            <h3 className="mt-4 font-semibold text-gray-900">Access and Control</h3>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li><strong>Access:</strong> View and update your profile information within the app</li>
              <li><strong>Correction:</strong> Update inaccurate or incomplete information</li>
              <li><strong>Deletion:</strong> Request deletion of your account and associated data</li>
              <li><strong>Data Portability:</strong> Request a copy of your data in a portable format</li>
            </ul>

            <h3 className="mt-4 font-semibold text-gray-900">Communication Preferences</h3>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Opt out of promotional communications (service notifications will continue)</li>
              <li>Control push notification settings through your device</li>
            </ul>

            <p className="mt-2">To exercise these rights, contact us at support@neurafit.app. We will respond to your request within 30 days.</p>
          </section>

          <section>
            <h2 id="childrens-privacy" className="text-lg font-semibold text-gray-900">9) Children's Privacy</h2>
            <p className="mt-2">Our Services are not intended for children under 18 years of age. We do not knowingly collect personal information from children under 18. If you are a parent or guardian and believe your child has provided us with personal information, please contact us immediately so we can delete such information.</p>
          </section>

          <section>
            <h2 id="international-users" className="text-lg font-semibold text-gray-900">10) International Data Transfers</h2>
            <p className="mt-2">Your information may be transferred to and processed in countries other than your own, including the United States, where our servers and service providers are located. These countries may have different data protection laws than your country.</p>
            <p className="mt-2">We ensure that such transfers comply with applicable data protection laws and implement appropriate safeguards, including:</p>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Standard contractual clauses approved by relevant authorities</li>
              <li>Adequacy decisions by regulatory bodies</li>
              <li>Certification schemes and codes of conduct</li>
            </ul>
          </section>

          <section>
            <h2 id="california-privacy" className="text-lg font-semibold text-gray-900">11) California Privacy Rights (CCPA)</h2>
            <p className="mt-2">If you are a California resident, you have additional rights under the California Consumer Privacy Act (CCPA):</p>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li><strong>Right to Know:</strong> Request information about the personal information we collect, use, and share</li>
              <li><strong>Right to Delete:</strong> Request deletion of your personal information</li>
              <li><strong>Right to Opt-Out:</strong> We do not sell personal information, so no opt-out is necessary</li>
              <li><strong>Right to Non-Discrimination:</strong> We will not discriminate against you for exercising your privacy rights</li>
            </ul>
            <p className="mt-2">To exercise these rights, contact us at support@neurafit.app with "California Privacy Request" in the subject line.</p>
          </section>

          <section>
            <h2 id="changes-to-policy" className="text-lg font-semibold text-gray-900">12) Changes to This Privacy Policy</h2>
            <p className="mt-2">We may update this Privacy Policy from time to time to reflect changes in our practices, technology, legal requirements, or other factors. We will notify you of material changes by:</p>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Posting the updated policy in our app with a new "Last Updated" date</li>
              <li>Sending you an email notification (for significant changes)</li>
              <li>Providing an in-app notification when you next use our Services</li>
            </ul>
            <p className="mt-2">Your continued use of our Services after the effective date of changes constitutes acceptance of the updated Privacy Policy.</p>
          </section>

          <section>
            <h2 id="contact" className="text-lg font-semibold text-gray-900">13) Contact Information</h2>
            <p className="mt-2">If you have questions, concerns, or requests regarding this Privacy Policy or our data practices, please contact us:</p>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li><strong>General Privacy Inquiries:</strong> support@neurafit.app</li>
              <li><strong>Data Protection Officer:</strong> privacy@neurafit.app</li>
              <li><strong>California Privacy Requests:</strong> Use subject line "California Privacy Request"</li>
              <li><strong>GDPR Requests:</strong> Use subject line "GDPR Data Request"</li>
            </ul>
            <p className="mt-2">We will respond to your inquiry within 30 days (or sooner as required by applicable law). For formal legal notices regarding privacy matters, please contact us at legal@neurafit.app.</p>
          </section>

          <footer className="pt-8 border-t border-gray-200 text-center">
            <p className="text-gray-600">
              See also our <Link to="/terms" className="text-blue-600 hover:text-blue-700 underline">Terms of Service</Link> for information about your responsibilities when using NeuraFit.
            </p>
          </footer>
        </div>
      </div>
    </div>
  )
}
=================================================================================
FILE: src/pages/Profile.tsx
=================================================================================
// src/pages/Profile.tsx
import React, { useEffect, useMemo, useState } from 'react'
import { doc, getDoc, setDoc } from 'firebase/firestore'

import { auth, db } from '../lib/firebase'

import {
  EXPERIENCE_LEVELS,
  GOALS,
  EQUIPMENT,
  SEX_OPTIONS,
  HEIGHT_RANGES,
  WEIGHT_RANGES,
  INJURY_OPTIONS
} from '../config/onboarding'
import AppHeader from '../components/AppHeader'
import { ProfileFormSkeleton, LoadingButton } from '../components/Loading'
import { validateUserProfile } from '../lib/validators'
import { logger } from '../lib/logger'

/* -------------------- Types & Constants (self-contained) -------------------- */
type Personal = { sex?: string; height?: string; weight?: string }
type Injuries = { list: string[]; notes: string }
type ProfileData = {
  experience?: string
  goals?: string[]
  equipment?: string[]
  personal?: Personal
  injuries?: Injuries
}



/* -------------------- Small UI primitives -------------------- */
function Section({ title, desc, children }: {title:string; desc?:string; children:React.ReactNode}) {
  return (
    <div className="rounded-lg xs:rounded-2xl border border-gray-200 bg-white/70 backdrop-blur-sm p-4 xs:p-5 sm:p-6 shadow-sm">
      <div className="mb-3 xs:mb-4">
        <h3 className="font-semibold text-gray-900 text-base xs:text-lg">{title}</h3>
        {desc && <p className="text-xs xs:text-sm text-gray-600 mt-1">{desc}</p>}
      </div>
      {children}
    </div>
  )
}
function Pill({ active, children, onClick }: {active?:boolean; children:React.ReactNode; onClick:()=>void}) {
  return (
    <button
      onClick={onClick}
      className={[
        'px-3 xs:px-4 py-2 xs:py-2.5 rounded-lg xs:rounded-xl border text-xs xs:text-sm transition-all duration-200 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2 min-h-[40px] xs:min-h-[44px] touch-manipulation',
        active ? 'bg-gradient-to-br from-blue-500 to-indigo-600 text-white border-blue-500 shadow-md scale-[1.02]' : 'bg-white/70 hover:bg-white border-gray-200 hover:border-blue-300 text-gray-700 hover:scale-[1.01]'
      ].join(' ')}
    >
      {children}
    </button>
  )
}
function GridSelect({
  items, selected, onToggle, twoCol=false
}: {items:string[]; selected:string[]; onToggle:(_v:string)=>void; twoCol?:boolean}) {
  return (
    <div className={twoCol ? 'grid grid-cols-2 gap-2 xs:gap-3' : 'flex flex-wrap gap-2 xs:gap-3'}>
      {items.map(v => (
        <Pill key={v} active={selected.includes(v)} onClick={() => onToggle(v)}>{v}</Pill>
      ))}
    </div>
  )
}

/* -------------------- Profile page -------------------- */
export default function Profile() {
  const uid = auth.currentUser?.uid || ''
  const displayId = auth.currentUser?.email || auth.currentUser?.phoneNumber || 'User'

  const [loading, setLoading] = useState(true)
  const [saving, setSaving] = useState(false)
  const [saved, setSaved] = useState<ProfileData | null>(null)
  const [draft, setDraft] = useState<ProfileData>({
    experience: undefined,
    goals: [],
    equipment: [],
    personal: { sex:'', height:'', weight:'' },
    injuries: { list:[], notes:'' }
  })

  // Load profile
  useEffect(() => {
    (async () => {
      if (!uid) return setLoading(false)
      try {
        const snap = await getDoc(doc(db, 'users', uid))
        if (snap.exists()) {
          const data = snap.data() as ProfileData
          setSaved(data)
          setDraft({
            experience: data.experience ?? undefined,
            goals: data.goals ?? [],
            equipment: data.equipment ?? [],
            personal: {
              sex: data.personal?.sex ?? '',
              height: data.personal?.height ?? '',
              weight: data.personal?.weight ?? '',
            },
            injuries: {
              list: data.injuries?.list ?? [],
              notes: data.injuries?.notes ?? '',
            },
          })
        }
      } catch (error) {
        logger.error('Error loading profile', error as Error, { uid })
        // Handle permission errors gracefully
      } finally {
        setLoading(false)
      }
    })()
  }, [uid])

  // Helpers
  const hasChanges = useMemo(() => JSON.stringify(draft) !== JSON.stringify(saved ?? {}), [draft, saved])
  const invalid =
    !draft.experience ||
    !draft.personal?.height ||
    !draft.personal?.weight ||
    (draft.goals?.length ?? 0) === 0 ||
    (draft.equipment?.length ?? 0) === 0

  const toggle = (list: string[] = [], v: string, allowNone = false) => {
    const isNone = v.startsWith('None')
    if (allowNone && isNone) return [v] // clears others
    if (allowNone && list.some(x => x.startsWith('None'))) list = list.filter(x => !x.startsWith('None'))
    return list.includes(v) ? list.filter(x => x !== v) : [...list, v]
  }

  // Actions
  const save = async () => {
    if (!uid || invalid) {
      logger.warn('Attempted to save invalid profile', { uid, invalid })
      return
    }

    setSaving(true)
    try {
      // Prepare profile data
      const profileData = {
        experience: draft.experience,
        goals: draft.goals || [],
        equipment: draft.equipment || [],
        personal: draft.personal || { sex: '', height: '', weight: '' },
        injuries: draft.injuries || { list: [], notes: '' },
      }

      // Validate profile data
      const validation = validateUserProfile(profileData)

      if (!validation.isValid) {
        logger.warn('Profile validation failed', { errors: validation.errors })
        alert(`Please fix the following errors:\n${validation.errors.join('\n')}`)
        return
      }

      // Save to Firestore
      await setDoc(
        doc(db, 'users', uid),
        {
          ...profileData,
          updated_at: new Date().toISOString(),
        },
        { merge: true }
      )

      setSaved(draft)
      logger.info('Profile updated successfully', { uid })
    } catch (error) {
      logger.error('Error saving profile', error as Error, { uid })
      alert('Failed to save profile. Please try again.')
    } finally {
      setSaving(false)
    }
  }

  const reset = () => {
    if (!saved) return
    setDraft(JSON.parse(JSON.stringify(saved)))
  }



  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 via-white to-indigo-50 relative">
      {/* Background decoration */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute -top-40 -right-40 w-80 h-80 bg-gradient-to-br from-blue-200/30 to-indigo-200/30 rounded-full blur-3xl" aria-hidden="true" />
        <div className="absolute -bottom-40 -left-40 w-80 h-80 bg-gradient-to-tr from-indigo-200/30 to-blue-200/30 rounded-full blur-3xl" aria-hidden="true" />
      </div>

      <AppHeader />

      {/* Body */}
      <main className="relative mx-auto max-w-4xl px-3 xs:px-4 sm:px-6 pb-14 xs:pb-16 sm:pb-20 pt-6 xs:pt-7 sm:pt-8">
        {/* Identity */}
        <div className="mb-6 xs:mb-7 sm:mb-8 rounded-lg xs:rounded-2xl border border-gray-200 bg-white/70 backdrop-blur-sm p-4 xs:p-5 sm:p-6 shadow-sm animate-slide-in-up">
          <div>
            <div className="text-xs xs:text-sm text-gray-500">Signed in as</div>
            <div className="text-base xs:text-lg sm:text-xl font-semibold text-gray-900 mt-1">{displayId}</div>
          </div>
        </div>

        {loading ? (
          <ProfileFormSkeleton />
        ) : (
          <>

        {/* Editable sections */}
        <div className="grid grid-cols-1 gap-4 xs:gap-5 sm:gap-6 md:grid-cols-2 animate-slide-in-up" style={{ animationDelay: '0.1s' }}>
          <Section title="Experience" desc="We calibrate volume, intensity, and progressions.">
            <div className="flex flex-wrap gap-2">
              {EXPERIENCE_LEVELS.map(l => (
                <Pill
                  key={l}
                  active={draft.experience === l}
                  onClick={() => setDraft(d => ({ ...d, experience: l }))}
                >
                  {l}
                </Pill>
              ))}
            </div>
          </Section>

          <Section title="Goals" desc="Pick one or more training goals.">
            <GridSelect
              items={GOALS}
              selected={draft.goals ?? []}
              onToggle={(v) => setDraft(d => ({ ...d, goals: toggle(d.goals, v) }))}
            />
          </Section>

          <Section title="Equipment" desc="Only movements using your equipment are included.">
            <GridSelect
              items={EQUIPMENT}
              selected={draft.equipment ?? []}
              onToggle={(v) => setDraft(d => ({ ...d, equipment: toggle(d.equipment, v, true) }))}
              twoCol
            />
            <p className="mt-2 text-xs text-slate-500">Tip: Selecting “None (Bodyweight)” clears other selections.</p>
          </Section>

          <Section title="Personal" desc="Ranges help personalize while keeping exact numbers private.">
            <div className="grid gap-6">
              {/* Sex Options */}
              <div>
                <div className="mb-3 text-sm font-semibold text-gray-700">Gender</div>
                <div className="grid grid-cols-3 gap-3">
                  {SEX_OPTIONS.map(s => (
                    <Pill
                      key={s}
                      active={draft.personal?.sex === s}
                      onClick={() => setDraft(d => ({ ...d, personal: { ...d.personal, sex: s } }))}
                    >
                      {s}
                    </Pill>
                  ))}
                </div>
              </div>

              {/* Height Range */}
              <div>
                <div className="mb-3 text-sm font-semibold text-gray-700">Height Range</div>
                <div className="grid grid-cols-3 gap-3">
                  {HEIGHT_RANGES.map(h => (
                    <Pill
                      key={h}
                      active={draft.personal?.height === h}
                      onClick={() => setDraft(d => ({ ...d, personal: { ...d.personal, height: h } }))}
                    >
                      {h}
                    </Pill>
                  ))}
                </div>
              </div>

              {/* Weight Range */}
              <div>
                <div className="mb-3 text-sm font-semibold text-gray-700">Weight Range</div>
                <div className="grid grid-cols-3 gap-3">
                  {WEIGHT_RANGES.map(w => (
                    <Pill
                      key={w}
                      active={draft.personal?.weight === w}
                      onClick={() => setDraft(d => ({ ...d, personal: { ...d.personal, weight: w } }))}
                    >
                      {w}
                    </Pill>
                  ))}
                </div>
              </div>
            </div>
          </Section>

          <Section title="Injuries" desc="We’ll avoid risky movements and include safe modifications.">
            <GridSelect
              items={INJURY_OPTIONS}
              selected={draft.injuries?.list ?? []}
              onToggle={(v) =>
                setDraft(d => {
                  const currentInjuries = d.injuries || { list: [], notes: '' }
                  if (v === 'None') return { ...d, injuries: { ...currentInjuries, list: ['None'] } }
                  const list = (currentInjuries.list || []).filter(x => x !== 'None')
                  const next = list.includes(v) ? list.filter(x => x !== v) : [...list, v]
                  return { ...d, injuries: { ...currentInjuries, list: next } }
                })
              }
              twoCol
            />
            <textarea
              className="mt-3 w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm text-slate-900 outline-none placeholder:text-slate-400 focus:ring-2 focus:ring-emerald-500"
              rows={3}
              placeholder="Notes (optional)…"
              value={draft.injuries?.notes ?? ''}
              onChange={(e) => setDraft(d => {
                const currentInjuries = d.injuries || { list: [], notes: '' }
                return { ...d, injuries: { ...currentInjuries, notes: e.target.value } }
              })}
            />
          </Section>
        </div>

        {/* Save bar */}
        <div className="sticky bottom-0 mt-6 xs:mt-8 sm:mt-10 rounded-lg xs:rounded-2xl border border-white/15 bg-white/10 p-3 xs:p-4 sm:p-5 backdrop-blur animate-slide-in-up" style={{ animationDelay: '0.2s' }}>
          <div className="flex flex-col gap-3 xs:gap-4 sm:flex-row sm:items-center sm:justify-between">
            <div className="text-xs xs:text-sm">
              {invalid ? (
                <span className="text-amber-300">Complete all required fields to save.</span>
              ) : hasChanges ? (
                <span className="text-emerald-300">Unsaved changes</span>
              ) : (
                <span className="text-white/70">All changes saved</span>
              )}
            </div>
            <div className="flex gap-2 xs:gap-3">
              <button
                onClick={reset}
                disabled={!hasChanges}
                className="rounded-lg xs:rounded-xl border border-white/20 bg-white/5 px-3 xs:px-4 py-2 xs:py-2.5 text-xs xs:text-sm text-white/90 hover:bg-white/10 disabled:opacity-50 min-h-[40px] xs:min-h-[44px] touch-manipulation"
              >
                Reset
              </button>
              <LoadingButton
                loading={saving}
                onClick={save}
                disabled={invalid || !hasChanges}
                className={[
                  'rounded-lg xs:rounded-xl px-4 xs:px-5 py-2 xs:py-2.5 font-semibold text-xs xs:text-sm min-h-[40px] xs:min-h-[44px] touch-manipulation',
                  invalid || !hasChanges || saving
                    ? 'bg-emerald-500/40 text-white/80 cursor-not-allowed'
                    : 'bg-emerald-500 text-slate-950 hover:bg-emerald-400'
                ].join(' ')}
              >
                Save changes
              </LoadingButton>
            </div>
          </div>
        </div>
          </>
        )}
      </main>
    </div>
  )
}
=================================================================================
FILE: src/pages/Terms.tsx
=================================================================================
// src/pages/Terms.tsx
import { Link } from 'react-router-dom'

export default function Terms() {
  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 via-white to-blue-50/30 text-gray-900">
      <div className="mx-auto max-w-3xl px-6 py-12">
        <header className="mb-8">
          <Link to="/" className="text-blue-600 hover:text-blue-700 font-medium">← Back</Link>
          <h1 className="mt-4 text-3xl md:text-4xl font-bold tracking-tight">Terms of Service</h1>
          <p className="mt-2 text-gray-600">Last updated: September 30, 2025</p>
        </header>

        {/* Table of contents */}
        <nav aria-label="Table of contents" className="mb-8 rounded-2xl border border-gray-200 bg-white/60 backdrop-blur-sm p-4">
          <p className="text-sm font-semibold text-gray-900 mb-3">Table of contents</p>
          <ul className="grid grid-cols-1 sm:grid-cols-2 gap-2 text-sm text-blue-700">
            <li><a href="#acceptance-of-terms" className="hover:underline">1) Acceptance of Terms</a></li>
            <li><a href="#not-medical-advice" className="hover:underline">2) Not Medical Advice</a></li>
            <li><a href="#ai-limitations" className="hover:underline">3) AI Technology & Limitations</a></li>
            <li><a href="#eligibility-and-accounts" className="hover:underline">4) Eligibility & Accounts</a></li>
            <li><a href="#user-responsibilities-and-safety" className="hover:underline">5) User Responsibilities & Safety</a></li>
            <li><a href="#acceptable-use" className="hover:underline">6) Acceptable Use Policy</a></li>
            <li><a href="#intellectual-property" className="hover:underline">7) Intellectual Property</a></li>
            <li><a href="#privacy" className="hover:underline">8) Privacy & Data Protection</a></li>
            <li><a href="#disclaimers" className="hover:underline">9) Disclaimers</a></li>
            <li><a href="#limitation-of-liability" className="hover:underline">10) Limitation of Liability</a></li>
            <li><a href="#indemnification" className="hover:underline">11) Indemnification</a></li>
            <li><a href="#modifications" className="hover:underline">12) Modifications</a></li>
            <li><a href="#governing-law" className="hover:underline">13) Governing Law</a></li>
            <li><a href="#termination" className="hover:underline">14) Account Termination</a></li>
            <li><a href="#arbitration" className="hover:underline">15) Dispute Resolution</a></li>
            <li><a href="#contact" className="hover:underline">16) Contact Information</a></li>
          </ul>
        </nav>

        <div className="space-y-8 text-sm leading-relaxed text-gray-700">
          <section>
            <h2 id="acceptance-of-terms" className="text-lg font-semibold text-gray-900">1) Acceptance of Terms</h2>
            <p className="mt-2">These Terms of Service ("Terms") govern your access to and use of the NeuraFit application and services ("Services"). By creating an account, signing in, or using the Services, you agree to be bound by these Terms. If you do not agree to these Terms, do not use the Services.</p>
          </section>

          <section>
            <h2 id="not-medical-advice" className="text-lg font-semibold text-gray-900">2) Not Medical Advice</h2>
            <p className="mt-2"><strong>IMPORTANT:</strong> NeuraFit provides AI-generated workout content for informational and educational purposes only. The Services do not provide medical, health, fitness, or nutritional advice. Our AI-generated workouts are not a substitute for professional medical advice, diagnosis, or treatment.</p>
            <p className="mt-2">Always consult with a physician, certified personal trainer, or other qualified health professional before starting any fitness program, especially if you:</p>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Have any medical conditions, injuries, or physical limitations</li>
              <li>Are pregnant or nursing</li>
              <li>Are taking medications that may affect your ability to exercise</li>
              <li>Have not exercised regularly in the past six months</li>
              <li>Are over 35 years old and beginning a new exercise program</li>
            </ul>
            <p className="mt-2">If you experience pain, dizziness, shortness of breath, chest pain, or other adverse symptoms during exercise, stop immediately and seek medical attention.</p>
          </section>

          <section>
            <h2 id="ai-limitations" className="text-lg font-semibold text-gray-900">3) AI Technology and Limitations</h2>
            <p className="mt-2">NeuraFit uses artificial intelligence to generate personalized workout recommendations based on the information you provide. You acknowledge and understand that:</p>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>AI-generated content may be inaccurate, incomplete, or inappropriate for your specific circumstances</li>
              <li>The AI cannot assess your real-time physical condition, form, or safety</li>
              <li>AI recommendations are based solely on the data you input and may not account for all relevant factors</li>
              <li>The AI is not a substitute for professional coaching, supervision, or medical guidance</li>
              <li>You are solely responsible for evaluating the suitability and safety of any recommended exercises</li>
            </ul>
            <p className="mt-2">You agree to use your own judgment and consult with qualified professionals when determining whether to follow AI-generated recommendations.</p>
          </section>

          <section>
            <h2 id="eligibility-and-accounts" className="text-lg font-semibold text-gray-900">4) Eligibility & Account Requirements</h2>
            <p className="mt-2">You must be at least 18 years old to use the Services. If you are under 18, you may not use the Services.</p>
            <p className="mt-2">You are responsible for:</p>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Maintaining the confidentiality and security of your account credentials</li>
              <li>All activities that occur under your account</li>
              <li>Providing accurate, complete, and current information</li>
              <li>Promptly updating your information when it changes</li>
              <li>Notifying us immediately of any unauthorized use of your account</li>
            </ul>
          </section>

          <section>
            <h2 id="user-responsibilities-and-safety" className="text-lg font-semibold text-gray-900">5) User Responsibilities & Safety</h2>
            <p className="mt-2">By using the Services, you agree to:</p>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Exercise at your own risk and within your physical capabilities</li>
              <li>Perform proper warm-up and cool-down routines</li>
              <li>Use proper form, technique, and safety precautions</li>
              <li>Use properly maintained equipment and exercise in safe environments</li>
              <li>Choose weights, intensities, and progressions appropriate for your fitness level</li>
              <li>Modify, skip, or stop any exercise that feels unsafe or causes discomfort</li>
              <li>Stay hydrated and take appropriate rest periods</li>
              <li>Comply with all applicable laws, gym policies, and facility guidelines</li>
              <li>Provide accurate information about your fitness level, injuries, and limitations</li>
            </ul>
            <p className="mt-2"><strong>You acknowledge that physical exercise involves inherent risks of injury, and you voluntarily assume all such risks.</strong></p>
          </section>

          <section>
            <h2 id="acceptable-use" className="text-lg font-semibold text-gray-900">6) Acceptable Use Policy</h2>
            <p className="mt-2">You agree not to:</p>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Use the Services for any unlawful purpose or in violation of these Terms</li>
              <li>Reverse engineer, decompile, or attempt to extract source code from the Services</li>
              <li>Use automated systems (bots, scrapers) to access or abuse the Services</li>
              <li>Upload, transmit, or distribute harmful content, malware, or viruses</li>
              <li>Engage in harassment, hate speech, or discrimination</li>
              <li>Infringe upon intellectual property rights of others</li>
              <li>Attempt to gain unauthorized access to our systems or other users' accounts</li>
              <li>Use the Services to compete with or create derivative products</li>
              <li>Share your account credentials with others</li>
            </ul>
          </section>

          <section>
            <h2 id="intellectual-property" className="text-lg font-semibold text-gray-900">7) Intellectual Property Rights</h2>
            <p className="mt-2">The Services, including all content, features, functionality, software, text, graphics, logos, images, and trademarks, are owned by NeuraFit or its licensors and are protected by copyright, trademark, and other intellectual property laws.</p>
            <p className="mt-2">Subject to these Terms, we grant you a limited, non-exclusive, non-transferable, revocable license to access and use the Services solely for your personal, non-commercial purposes. This license does not include any right to:</p>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Resell, redistribute, or commercially exploit the Services</li>
              <li>Modify, adapt, or create derivative works</li>
              <li>Remove or alter any proprietary notices</li>
              <li>Use our trademarks or branding without permission</li>
            </ul>
          </section>

          <section>
            <h2 id="privacy" className="text-lg font-semibold text-gray-900">8) Privacy and Data Protection</h2>
            <p className="mt-2">Your privacy is important to us. Your use of the Services is governed by our <Link to="/privacy" className="text-blue-600 hover:text-blue-700 underline">Privacy Policy</Link>, which explains how we collect, use, and protect your information. By using the Services, you consent to our data practices as described in the Privacy Policy.</p>
          </section>

          <section>
            <h2 id="disclaimers" className="text-lg font-semibold text-gray-900">9) Disclaimers</h2>
            <p className="mt-2">THE SERVICES ARE PROVIDED "AS IS" AND "AS AVAILABLE," WITHOUT WARRANTIES OF ANY KIND, EXPRESS OR IMPLIED. WE DISCLAIM ALL WARRANTIES INCLUDING MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT. WE DO NOT WARRANT THAT THE SERVICES WILL BE ACCURATE, RELIABLE, ERROR-FREE, UNINTERRUPTED, OR SAFE.</p>
            <p className="mt-2">WE SPECIFICALLY DISCLAIM ANY WARRANTIES REGARDING THE SAFETY, EFFECTIVENESS, OR SUITABILITY OF AI-GENERATED WORKOUT RECOMMENDATIONS FOR YOUR PARTICULAR CIRCUMSTANCES.</p>
          </section>

          <section>
            <h2 id="limitation-of-liability" className="text-lg font-semibold text-gray-900">10) Limitation of Liability</h2>
            <p className="mt-2">TO THE MAXIMUM EXTENT PERMITTED BY LAW, NEURAFIT SHALL NOT BE LIABLE FOR ANY INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL, OR PUNITIVE DAMAGES, INCLUDING BUT NOT LIMITED TO PERSONAL INJURY, PROPERTY DAMAGE, LOST PROFITS, OR DATA LOSS, ARISING FROM YOUR USE OF THE SERVICES.</p>
            <p className="mt-2">OUR TOTAL LIABILITY TO YOU FOR ALL CLAIMS ARISING FROM OR RELATING TO THE SERVICES SHALL NOT EXCEED THE AMOUNT YOU PAID US IN THE TWELVE MONTHS PRECEDING THE CLAIM, OR $100, WHICHEVER IS GREATER.</p>
          </section>

          <section>
            <h2 id="indemnification" className="text-lg font-semibold text-gray-900">11) Indemnification</h2>
            <p className="mt-2">You agree to indemnify, defend, and hold harmless NeuraFit, its officers, directors, employees, and agents from and against any claims, liabilities, damages, losses, costs, and expenses (including reasonable attorneys' fees) arising from or relating to your use of the Services, violation of these Terms, or infringement of any rights of another.</p>
          </section>

          <section>
            <h2 id="modifications" className="text-lg font-semibold text-gray-900">12) Modifications to Terms</h2>
            <p className="mt-2">We may update these Terms from time to time to reflect changes in our Services, legal requirements, or business practices. We will notify you of material changes by posting the updated Terms in the app or by other reasonable means. Your continued use of the Services after changes become effective constitutes acceptance of the updated Terms.</p>
          </section>

          <section>
            <h2 id="governing-law" className="text-lg font-semibold text-gray-900">13) Governing Law and Jurisdiction</h2>
            <p className="mt-2">These Terms are governed by the laws of the State of California, United States, without regard to conflict-of-law principles. Any disputes arising from these Terms or the Services shall be subject to the exclusive jurisdiction of the state and federal courts located in San Francisco County, California, except as provided in the arbitration clause below.</p>
          </section>

          <section>
            <h2 id="termination" className="text-lg font-semibold text-gray-900">14) Account Termination</h2>
            <p className="mt-2">You may terminate your account at any time by contacting us or using the account deletion feature in the app. Upon termination:</p>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li>Your access to the Services will be immediately suspended</li>
              <li>Your personal data will be deleted within 30 days (except as required for legal compliance)</li>
              <li>These Terms will remain in effect for any claims or disputes that arose before termination</li>
            </ul>
            <p className="mt-2">We may suspend or terminate your account if you violate these Terms, engage in harmful behavior, or for other legitimate business reasons. We will provide reasonable notice when possible.</p>
          </section>

          <section>
            <h2 id="arbitration" className="text-lg font-semibold text-gray-900">15) Dispute Resolution and Arbitration</h2>
            <p className="mt-2">Most disputes can be resolved informally by contacting us at support@neurafit.app. For disputes that cannot be resolved informally, you and NeuraFit agree to resolve them through binding arbitration rather than in court, except for small claims court matters and injunctive relief.</p>
            <p className="mt-2"><strong>Class Action Waiver:</strong> You and NeuraFit agree that any dispute resolution proceedings will be conducted only on an individual basis and not in a class, consolidated, or representative action.</p>
          </section>

          <section>
            <h2 id="contact" className="text-lg font-semibold text-gray-900">16) Contact Information</h2>
            <p className="mt-2">If you have questions about these Terms or need to contact us for any reason, please reach out to us:</p>
            <ul className="mt-2 list-disc pl-5 space-y-1">
              <li><strong>Email:</strong> support@neurafit.app</li>
              <li><strong>Legal Inquiries:</strong> legal@neurafit.app</li>
              <li><strong>Response Time:</strong> We typically respond within 48 hours</li>
            </ul>
            <p className="mt-2">For formal legal notices, please send correspondence to our registered address, which can be obtained by contacting us at the email addresses above.</p>
          </section>

          <footer className="pt-8 border-t border-gray-200 text-center">
            <p className="text-gray-600">
              See also our <Link to="/privacy" className="text-blue-600 hover:text-blue-700 underline">Privacy Policy</Link> for information about how we handle your data.
            </p>
          </footer>
        </div>
      </div>
    </div>
  )
}
=================================================================================
FILE: src/pages/workout/Complete.tsx
=================================================================================
// src/pages/workout/Complete.tsx
import { addDoc, collection, serverTimestamp, doc, updateDoc } from 'firebase/firestore'
import { auth, db } from '../../lib/firebase'
import { useEffect, useState } from 'react'
import { useNavigate } from 'react-router-dom'
import WorkoutFlowHeader from '../../components/WorkoutFlowHeader'
import { trackAdaptiveFeedback, trackCustomEvent } from '../../lib/firebase-analytics'
import { Bed, ThumbsUp, Flame, CheckCircle, LogIn } from 'lucide-react'
import { trackWorkoutCompleted } from '../../lib/firebase-analytics'
import { logger } from '../../lib/logger'
import { useWorkoutScrollToTop } from '../../hooks/useScrollToTop'
import { useIsGuest } from '../../store'
import { clearGuestSession } from '../../lib/guest-session'

type FeedbackSignal = 'easy' | 'right' | 'hard'

export default function Complete() {
  const nav = useNavigate()
  const isGuest = useIsGuest()

  // Scroll to top on mount and route changes
  useWorkoutScrollToTop()

  const [workoutSaved, setWorkoutSaved] = useState(false)
  const [workoutId, setWorkoutId] = useState<string | null>(null)
  const [feedbackSubmitted, setFeedbackSubmitted] = useState(false)
  const [selectedFeedback, setSelectedFeedback] = useState<FeedbackSignal | null>(null)
  const [rpeValue, setRpeValue] = useState<number | null>(null)
  const [submittingFeedback, setSubmittingFeedback] = useState(false)
  const [workoutData, setWorkoutData] = useState<Record<string, unknown> | null>(null)

  // Save workout on component mount
  useEffect(() => {
    (async () => {
      try {
        const saved = sessionStorage.getItem('nf_workout_plan')
        if (!saved) return
        const { plan, type, duration } = JSON.parse(saved) as { plan: { exercises: unknown[] }; type: string; duration: number }
        const uid = auth.currentUser?.uid

        // Skip saving for guest users - just mark as saved and show completion
        if (isGuest || !uid) {
          setWorkoutSaved(true)
          // Clear session storage for guest users
          sessionStorage.removeItem('nf_workout_plan')
          sessionStorage.removeItem('nf_workout_weights')
          sessionStorage.removeItem('nf_workout_start_time')
          return
        }

        // Get weight data if it exists
        const savedWeights = sessionStorage.getItem('nf_workout_weights')
        const workoutWeights = savedWeights ? JSON.parse(savedWeights) : {}



        // Calculate actual workout duration
        const startTimeStr = sessionStorage.getItem('nf_workout_start_time')
        const actualDuration = startTimeStr
          ? Math.round((Date.now() - parseInt(startTimeStr)) / 1000 / 60) // Convert to minutes
          : duration // Fallback to planned duration if start time not available

        // Enhance exercises with weight data
        const exercisesWithWeights = (plan.exercises as Record<string, unknown>[]).map((exercise, exerciseIndex: number) => ({
          ...exercise,
          weights: workoutWeights[exerciseIndex] || null
        }))

        // Development-only logging
        if (import.meta.env.MODE === 'development') {
          console.log('[SAVE] Saving workout with the following completion data:')
          exercisesWithWeights.forEach((exercise: Record<string, unknown>, index: number) => {
            console.log(`Exercise ${index}: ${exercise['name']}`)
            if (exercise['weights']) {
              Object.entries(exercise['weights']).forEach(([setNum, weight]) => {
                const status = weight === null ? 'SKIPPED' : weight === 0 ? 'COMPLETED (no weight)' : `COMPLETED (${weight}lbs)`
                console.log(`  Set ${setNum}: ${status}`)
              })
            } else {
              console.log('  No weight data (should not happen with new system)')
            }
          })
        }

        const workoutDoc = {
          timestamp: serverTimestamp(),
          workoutType: type,
          duration: actualDuration,
          plannedDuration: duration, // Keep the planned duration for reference
          exercises: exercisesWithWeights
        }

        const docRef = await addDoc(collection(db, 'users', uid, 'workouts'), workoutDoc)

        // Track workout completion
        const completedExercises = exercisesWithWeights.filter((ex: { weights?: Record<string, unknown> }) =>
          ex.weights && Object.values(ex.weights).some((weight: unknown) => weight !== null)
        ).length
        trackWorkoutCompleted(docRef.id, actualDuration, completedExercises)

        // Store workout data and ID for feedback
        setWorkoutData({ ...workoutDoc, exercises: exercisesWithWeights })
        setWorkoutId(docRef.id)
        setWorkoutSaved(true)

        logger.debug('Workout saved, showing feedback UI', { workoutId: docRef.id })

        // Clear the session storage after successful save
        sessionStorage.removeItem('nf_workout_plan')
        sessionStorage.removeItem('nf_workout_weights')
        sessionStorage.removeItem('nf_workout_start_time')
      } catch (error) {
        logger.error('Error saving workout', error as Error)
        // Don't block the user, but log the error
      }
    })()
  }, [isGuest])

  // Calculate workout completion rate
  const calculateCompletionRate = (exercises: Record<string, unknown>[]): number => {
    let totalSets = 0
    let completedSets = 0

    exercises.forEach(exercise => {
      if (exercise['weights'] && typeof exercise['weights'] === 'object') {
        const setCount = (typeof exercise['sets'] === 'number' ? exercise['sets'] : 0) || Object.keys(exercise['weights']).length
        totalSets += setCount

        // Count completed sets (non-null weights)
        Object.values(exercise['weights']).forEach((weight: unknown) => {
          if (weight !== null) {
            completedSets++
          }
        })
      } else {
        // Fallback: assume all sets completed if no weight data
        const sets = typeof exercise['sets'] === 'number' ? exercise['sets'] : 0
        totalSets += sets
        completedSets += sets
      }
    })

    return totalSets > 0 ? completedSets / totalSets : 1.0
  }

  // Submit difficulty feedback
  const submitFeedback = async () => {
    if (!selectedFeedback || !workoutId || !workoutData) return

    setSubmittingFeedback(true)
    try {
      const uid = auth.currentUser?.uid
      if (!uid) return

      // Calculate completion rate
      const completionRate = calculateCompletionRate(workoutData['exercises'] as Record<string, unknown>[])

      // Update workout document with feedback
      const workoutRef = doc(db, 'users', uid, 'workouts', workoutId)
      await updateDoc(workoutRef, {
        feedback: selectedFeedback,
        rpe: rpeValue,
        completionRate
      })

      // Log telemetry event
      trackAdaptiveFeedback(selectedFeedback, rpeValue, completionRate)

      // For now, we'll update the adaptive state when generating the next workout
      // This ensures we have the most recent feedback and completion data
      if (import.meta.env.MODE === 'development') {
        console.log('Feedback submitted:', {
          feedback: selectedFeedback,
          rpe: rpeValue,
          completionRate
        })
      }

      setFeedbackSubmitted(true)
    } catch (error) {
      logger.error('Error submitting feedback', error as Error)
      const uid = auth.currentUser?.uid
      if (uid) {
        trackCustomEvent('adaptive_personalization_error', { error: String(error), context: 'feedback_submission' })
      }
    } finally {
      setSubmittingFeedback(false)
    }
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 via-white to-indigo-50 relative">
      {/* Background decoration */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute -top-40 -right-40 w-80 h-80 bg-gradient-to-br from-blue-200/30 to-indigo-200/30 rounded-full blur-3xl" />
        <div className="absolute -bottom-40 -left-40 w-80 h-80 bg-gradient-to-tr from-indigo-200/30 to-blue-200/30 rounded-full blur-3xl" />
      </div>

      <WorkoutFlowHeader
        title="Workout Complete"
        showBackButton={false}
      />

      <div className="relative flex items-center justify-center min-h-[80vh] px-4">
        <div className="bg-white/70 backdrop-blur-sm border border-gray-200 rounded-3xl p-8 text-center max-w-lg mx-auto shadow-lg">
          <div className="w-16 h-16 bg-gradient-to-br from-green-400 to-emerald-500 rounded-full flex items-center justify-center mx-auto mb-6">
            <CheckCircle className="h-8 w-8 text-white" />
          </div>
          <h1 className="text-3xl font-bold mb-4 text-gray-900">Workout Complete!</h1>
          <p className="mb-6 text-gray-600">
            {isGuest
              ? 'Great job! Create an account to save your workouts and track your progress.'
              : 'Great job! Your workout has been saved to your history.'}
          </p>

          {/* Guest Account CTA */}
          {isGuest && (
            <div className="mb-6 p-4 bg-gradient-to-r from-blue-50 to-indigo-50 rounded-xl border border-blue-200">
              <div className="flex items-start gap-3 mb-4">
                <LogIn className="h-5 w-5 text-blue-600 flex-shrink-0 mt-0.5" />
                <div className="text-left">
                  <h3 className="font-semibold text-gray-900 mb-1">Save Your Progress</h3>
                  <p className="text-sm text-gray-700">
                    Create an account to unlock personalized workouts, track your history, and watch your performance improve.
                  </p>
                </div>
              </div>
              <button
                onClick={() => {
                  clearGuestSession()
                  nav('/')
                }}
                className="w-full px-4 py-2 bg-blue-600 text-white rounded-lg font-medium hover:bg-blue-700 transition-colors"
              >
                Create Account
              </button>
            </div>
          )}

          {/* Feedback Section - Only for authenticated users */}
          {workoutSaved && !feedbackSubmitted && !isGuest && (
            <div className="mb-6 p-4 bg-blue-50/50 rounded-xl border border-blue-100">
              <h3 className="text-lg font-semibold mb-3 text-gray-900">How was this workout?</h3>
              <p className="text-sm text-gray-600 mb-4">Your feedback helps us personalize future workouts</p>

              {/* Difficulty Buttons */}
              <div className="grid grid-cols-3 gap-2 mb-4">
                {[
                  { value: 'easy' as const, label: 'Too Easy', icon: Bed, color: 'from-green-400 to-emerald-500' },
                  { value: 'right' as const, label: 'Just Right', icon: ThumbsUp, color: 'from-blue-400 to-indigo-500' },
                  { value: 'hard' as const, label: 'Too Hard', icon: Flame, color: 'from-red-400 to-pink-500' }
                ].map(option => (
                  <button
                    key={option.value}
                    onClick={() => setSelectedFeedback(option.value)}
                    className={`p-3 rounded-xl border-2 transition-all duration-200 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2 ${
                      selectedFeedback === option.value
                        ? `bg-gradient-to-br ${option.color} text-white border-transparent shadow-md scale-105`
                        : 'bg-white/70 border-gray-200 hover:border-gray-300 hover:scale-102'
                    }`}
                    aria-pressed={selectedFeedback === option.value}
                    aria-label={`Rate workout as ${option.label.toLowerCase()}`}
                  >
                    <div className="flex justify-center mb-1">
                      <option.icon className="h-5 w-5" />
                    </div>
                    <div className="text-xs font-medium">{option.label}</div>
                  </button>
                ))}
              </div>

              {/* Optional RPE Slider */}
              <div className="mb-4">
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Rate of Perceived Exertion (1-10) - Optional
                </label>
                <div className="flex items-center gap-2">
                  <span className="text-xs text-gray-500">1</span>
                  <input
                    type="range"
                    min="1"
                    max="10"
                    value={rpeValue || 5}
                    onChange={(e) => setRpeValue(parseInt(e.target.value))}
                    className="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2"
                    aria-label="Rate of Perceived Exertion from 1 to 10"
                    aria-describedby="rpe-description"
                  />
                  <span className="text-xs text-gray-500">10</span>
                </div>
                {rpeValue && (
                  <div className="text-center mt-1 text-sm font-medium text-gray-700">
                    RPE: {rpeValue}
                  </div>
                )}
              </div>

              {/* Submit Feedback Button */}
              <button
                onClick={submitFeedback}
                disabled={!selectedFeedback || submittingFeedback}
                className={`w-full px-4 py-2 rounded-xl font-medium transition-all duration-200 ${
                  selectedFeedback && !submittingFeedback
                    ? 'bg-gradient-to-br from-blue-500 to-indigo-600 text-white hover:scale-[1.02] shadow-md'
                    : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                }`}
              >
                {submittingFeedback ? 'Submitting...' : 'Submit Feedback'}
              </button>
            </div>
          )}

          {/* Success message after feedback */}
          {feedbackSubmitted && (
            <div className="mb-6 p-4 bg-green-50/50 rounded-xl border border-green-100">
              <div className="flex items-center gap-2 text-green-600 font-medium">
                <CheckCircle className="h-4 w-4" />
                Feedback submitted!
              </div>
              <div className="text-sm text-green-600 mt-1">Your next workout will be personalized based on this feedback.</div>
            </div>
          )}

          {/* Navigation Button */}
          <button
            onClick={() => {
              if (isGuest) {
                clearGuestSession()
                nav('/')
              } else {
                nav('/dashboard')
              }
            }}
            className="w-full px-6 py-3 bg-gradient-to-br from-blue-500 to-indigo-600 text-white rounded-xl font-medium hover:scale-[1.02] transition-all duration-200 shadow-md"
          >
            {isGuest ? 'Back to Home' : 'Back to Dashboard'}
          </button>
        </div>
      </div>
    </div>
  )
}
=================================================================================
FILE: src/pages/workout/Exercise.tsx
=================================================================================
// src/pages/workout/Exercise.tsx
import React, { useEffect, useState, useRef, useCallback, useMemo } from 'react'
import { Lightbulb, Shield } from 'lucide-react'
import AppHeader from '../../components/AppHeader'
import { useOptimisticUpdate, createWeightUpdateAction } from '../../lib/optimisticUpdates'
import {
  WorkoutProgressHeader,
  SetProgressIndicator,
  MotivationalMessage,
  WorkoutStats
} from '../../components/WorkoutProgress'
import { SmartWeightInput } from '../../components/SmartWeightInput'
import { logger } from '../../lib/logger'
import { ProgressiveOverloadTracker } from '../../components/ProgressiveOverloadTracker'
import { triggerHaptic } from '../../utils/haptic'
import {
  getCachedWeightHistory,
  fetchRecentSessions,

  type WeightHistory,
  type WorkoutSession
} from '../../lib/weightHistory'
import { useBounce, useShake } from '../../hooks/useMicroInteractions'
import { useNavigate } from 'react-router-dom'
import { useWorkoutScrollToTop } from '../../hooks/useScrollToTop'

type ExerciseT = {
  name: string
  description?: string      // 4-6 sentences with setup, execution, cues, breathing
  sets: number
  reps: number | string     // Can include ranges like "8-12" or time like "45s"
  formTips?: string[]       // 2-3 critical technique cues
  safetyTips?: string[]     // 2-3 injury prevention tips and modifications
  restSeconds?: number
  usesWeight?: boolean      // true if this exercise uses external weights
  muscleGroups?: string[]   // Primary muscles worked for programming balance
  difficulty?: string       // "beginner", "intermediate", or "advanced"
}

type PlanT = { exercises: ExerciseT[] }

export default function Exercise() {
  const nav = useNavigate()

  // Scroll to top on mount and route changes
  useWorkoutScrollToTop()

  // All hooks must be called at the top level
  const [i, setI] = useState(0)        // exercise index
  const [setNo, setSetNo] = useState(1) // current set (1-based)
  const [weightHistory, setWeightHistory] = useState<WeightHistory[]>([])
  const [recentSessions, setRecentSessions] = useState<WorkoutSession[]>([])
  const [loadingHistory, setLoadingHistory] = useState(false)
  const [workoutPlan, setWorkoutPlan] = useState<{ saved: string | null; list: ExerciseT[] }>({ saved: null, list: [] })
  const [workoutStartTime, setWorkoutStartTime] = useState<number>(Date.now())

  // Enhanced UX hooks
  const containerRef = useRef<HTMLDivElement>(null)

  const { bounceClass } = useBounce()
  const { shakeClass } = useShake()

  // Weight tracking state with optimistic updates - must be called before early returns
  const [initialWeights] = useState(() => {
    const savedWeights = sessionStorage.getItem('nf_workout_weights')
    return savedWeights ? JSON.parse(savedWeights) : {}
  })
  const weightState = useOptimisticUpdate<Record<number, Record<number, number | null>>>(initialWeights)

  // Load workout plan from sessionStorage on mount
  useEffect(() => {
    const saved = sessionStorage.getItem('nf_workout_plan')
    const parsedData = saved ? JSON.parse(saved) as { plan: PlanT } : null
    const list = Array.isArray(parsedData?.plan?.exercises) ? parsedData.plan.exercises : []
    setWorkoutPlan({ saved, list })
  }, [])

  // Load workout start time on mount
  useEffect(() => {
    const startTimeStr = sessionStorage.getItem('nf_workout_start_time')
    if (startTimeStr) {
      setWorkoutStartTime(parseInt(startTimeStr))
    }
  }, [])

  // All useEffect hooks must be called before early returns
  // return-from-rest state
  useEffect(() => {
    const nxt = sessionStorage.getItem('nf_return')
    if (nxt) {
      const { i: ii, setNo: s } = JSON.parse(nxt)
      setI(ii); setSetNo(s)
      sessionStorage.removeItem('nf_return')
    }
  }, [])

  // Set workout start time if not already set (fallback for direct navigation)
  useEffect(() => {
    const hasWorkoutStartTime = sessionStorage.getItem('nf_workout_start_time')
    if (!hasWorkoutStartTime) {
      sessionStorage.setItem('nf_workout_start_time', String(Date.now()))
      logger.debug('Workout start time set (fallback)')
    }
  }, [])

  // Load weight history and recent sessions for current exercise
  const { saved, list } = workoutPlan
  const ex = list[i] as ExerciseT

  useEffect(() => {
    if (!ex?.name) return

    const loadHistoryData = async () => {
      setLoadingHistory(true)
      try {
        const [history, sessions] = await Promise.all([
          getCachedWeightHistory(ex.name),
          fetchRecentSessions(8)
        ])
        setWeightHistory(history)
        setRecentSessions(sessions)
      } catch (error) {
        logger.error('Error loading history data', error as Error, { exerciseName: ex.name })
      } finally {
        setLoadingHistory(false)
      }
    }

    loadHistoryData()
  }, [ex?.name])

  // Calculate progress percentage (simple calculation - no memoization needed)
  const totalExercises = list.length
  const perExercise = 1 / totalExercises
  const withinExercise = ((setNo - 1) / Math.max(1, ex?.sets || 1)) * perExercise
  const progressPct = Math.min(100, Math.round(((i * perExercise) + withinExercise) * 100))

  // Calculate completed and skipped sets (memoized for performance)
  const exerciseWeights = useMemo(() => weightState.data[i] || {}, [weightState.data, i])

  const completedSets = useMemo(() =>
    Object.entries(exerciseWeights)
      .filter(([_, weight]) => weight !== null)
      .map(([setNum]) => parseInt(setNum)),
    [exerciseWeights]
  )

  const skippedSets = useMemo(() =>
    Object.entries(exerciseWeights)
      .filter(([_, weight]) => weight === null)
      .map(([setNum]) => parseInt(setNum)),
    [exerciseWeights]
  )

  // Calculate total stats (memoized for performance)
  const totalCompletedSets = useMemo(() =>
    Object.values(weightState.data).reduce((total, exerciseWeights) => {
      return total + Object.values(exerciseWeights || {}).filter(weight => weight !== null).length
    }, 0),
    [weightState.data]
  )

  const totalSets = useMemo(() =>
    list.reduce((total, exercise) => total + exercise.sets, 0),
    [list]
  )

  const completedExercises = useMemo(() =>
    Object.keys(weightState.data).filter(exerciseIndex => {
      const exerciseIndex_num = parseInt(exerciseIndex)
      const exercise = list[exerciseIndex_num]
      if (!exercise) return false

      const exerciseWeights = weightState.data[exerciseIndex_num] || {}
      const completedCount = Object.values(exerciseWeights).filter(weight => weight !== null).length

      // Only count as completed if all sets are done
      return completedCount === exercise.sets
    }).length,
    [weightState.data, list]
  )

  // Keep goRest memoized - passed to child components
  const goRest = useCallback((nextIndex: number, nextSet: number, seconds?: number) => {
    const restDuration = seconds ?? ex?.restSeconds ?? 60
    sessionStorage.setItem('nf_rest', String(restDuration))
    sessionStorage.setItem('nf_next', JSON.stringify({ i: nextIndex, setNo: nextSet }))
    nav('/workout/rest')
  }, [nav, ex?.restSeconds])

  // Update weight for current exercise and set with optimistic updates
  // RULE 3: If a set is complete and a weight is entered, the set should be marked as complete and the weight should be stored and displayed
  // This must be defined before early returns to satisfy React hooks rules
  const updateWeight = useCallback((weight: number | null) => {
    // Get current weights from state at call time to avoid stale closure (used in action creator)
    const action = createWeightUpdateAction(
      i,
      setNo,
      weight,
      async (exerciseIndex, setNumber, weightValue) => {
        // Server update simulation - in real app this might sync to backend
        // Use fresh weights from sessionStorage to avoid race conditions
        let existingWeights = {}
        try {
          const savedWeights = sessionStorage.getItem('nf_workout_weights')
          existingWeights = savedWeights ? JSON.parse(savedWeights) : {}
        } catch (error) {
          logger.error('Failed to parse workout weights', error)
        }

        const updated = {
          ...existingWeights,
          [exerciseIndex]: {
            ...(existingWeights as Record<number, Record<number, number | null>>)[exerciseIndex],
            [setNumber]: weightValue
          }
        }
        sessionStorage.setItem('nf_workout_weights', JSON.stringify(updated))

        if (import.meta.env.MODE === 'development') {
          console.log(`[WEIGHT] Weight entered for set ${setNumber} of ${ex?.name}:`, weightValue)
        }
      }
    )

    weightState.executeOptimisticUpdate(action)
  }, [i, setNo, weightState, ex?.name])

  // Early returns after all hooks are called
  if (!saved) return <EmptyState />
  if (list.length === 0) return <EmptyState />

  const workoutWeights = weightState.data






  const completeSet = () => {
    // Haptic feedback for successful completion
    triggerHaptic('success')

    // RULE 1: If a set is complete regardless of whether or not a weight is entered,
    // the set should be marked as complete
    const currentWeight = workoutWeights[i]?.[setNo]
    const finalWeight = currentWeight !== undefined ? currentWeight : 0

    const action = {
      optimisticUpdate: (prev: Record<number, Record<number, number | null>>) => ({
        ...prev,
        [i]: {
          ...prev[i],
          [setNo]: finalWeight
        }
      }),
      serverUpdate: async () => {
        const updated = {
          ...workoutWeights,
          [i]: {
            ...workoutWeights[i],
            [setNo]: finalWeight
          }
        }
        sessionStorage.setItem('nf_workout_weights', JSON.stringify(updated))

        if (import.meta.env.MODE === 'development') {
          console.log(`[COMPLETE] Set ${setNo} of ${ex.name} marked as COMPLETE:`, finalWeight)
        }

        return updated
      }
    }

    weightState.executeOptimisticUpdate(action)

    // more sets remaining in current exercise
    if (setNo < ex.sets) return goRest(i, setNo + 1)
    // move to next exercise
    if (i < list.length - 1) return goRest(i + 1, 1)
    // workout finished
    nav('/workout/complete')
  }

  const skipSet = () => {
    // Haptic feedback for skip action
    triggerHaptic('light')

    // RULE 2: If a set is skipped, it should be marked as incomplete
    const action = {
      optimisticUpdate: (prev: Record<number, Record<number, number | null>>) => ({
        ...prev,
        [i]: {
          ...prev[i],
          [setNo]: null // null indicates skipped set (incomplete)
        }
      }),
      serverUpdate: async () => {
        const updated = {
          ...workoutWeights,
          [i]: {
            ...workoutWeights[i],
            [setNo]: null
          }
        }
        sessionStorage.setItem('nf_workout_weights', JSON.stringify(updated))

        if (import.meta.env.MODE === 'development') {
          console.log(`[SKIP] Set ${setNo} of ${ex.name} marked as SKIPPED (incomplete):`, null)
        }

        return updated
      }
    }

    weightState.executeOptimisticUpdate(action)

    // more sets remaining in current exercise
    if (setNo < ex.sets) return goRest(i, setNo + 1)
    // move to next exercise
    if (i < list.length - 1) return goRest(i + 1, 1)
    // workout finished
    nav('/workout/complete')
  }

  const skipExercise = () => {
    // Haptic feedback for skip exercise
    triggerHaptic('warning')

    // Mark this exercise as skipped by creating an empty weights object
    const skipAction = {
      optimisticUpdate: (data: Record<number, Record<number, number | null>>) => {
        const updated = {
          ...data,
          [i]: {} // Empty object indicates exercise was skipped
        }
        sessionStorage.setItem('nf_workout_weights', JSON.stringify(updated))
        return updated
      },
      serverUpdate: async () => {
        const currentData = weightState.data
        const updated = {
          ...currentData,
          [i]: {}
        }
        sessionStorage.setItem('nf_workout_weights', JSON.stringify(updated))
        return updated
      },
      rollback: (data: Record<number, Record<number, number | null>>) => data
    }
    weightState.executeOptimisticUpdate(skipAction)

    if (i < list.length - 1) return goRest(i + 1, 1, Math.min(30, ex.restSeconds ?? 30))
    nav('/workout/complete')
  }



  return (
    <div
      ref={containerRef}
      className={`min-h-screen bg-gradient-to-br from-blue-50 via-white to-indigo-50 relative ${bounceClass} ${shakeClass}`}
    >
      {/* Background decoration */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute -top-40 -right-40 w-80 h-80 bg-gradient-to-br from-blue-200/30 to-indigo-200/30 rounded-full blur-3xl" />
        <div className="absolute -bottom-40 -left-40 w-80 h-80 bg-gradient-to-tr from-indigo-200/30 to-blue-200/30 rounded-full blur-3xl" />
      </div>

      {/* Enhanced Progress Header */}
      <WorkoutProgressHeader
        currentExercise={i + 1}
        totalExercises={totalExercises}
        currentSet={setNo}
        totalSets={ex.sets}
        overallProgress={progressPct}
        exerciseName={ex.name}
      />

      {/* Exercise card */}
      <main className="relative mx-auto max-w-4xl px-5 pb-28">
        {/* Set Progress Indicator */}
        <SetProgressIndicator
          currentSet={setNo}
          totalSets={ex.sets}
          completedSets={completedSets}
          skippedSets={skippedSets}
        />

        {/* Motivational Message */}
        <MotivationalMessage
          progress={progressPct}
          completedSets={completedSets.length}
          totalSets={ex.sets}
          exerciseName={ex.name}
        />

        {/* Workout Stats */}
        <div className="mb-6">
          <WorkoutStats
            startTime={workoutStartTime}
            completedSets={totalCompletedSets}
            totalSets={totalSets}
            completedExercises={completedExercises}
            totalExercises={totalExercises}
          />
        </div>

        <div className="relative overflow-hidden rounded-3xl border border-gray-200 bg-white/70 backdrop-blur-sm p-6 shadow-lg">
          <div className="absolute -right-16 -top-16 h-56 w-56 rounded-full bg-gradient-to-tr from-blue-400/20 to-indigo-400/20 blur-3xl" />
          <h1 className="text-2xl font-bold tracking-tight text-gray-900">{ex.name}</h1>

          {/* chips */}
          <div className="mt-3 flex flex-wrap gap-2 text-sm">
            <Chip>Set {setNo} of {ex.sets}</Chip>
            <Chip>Reps: {ex.reps}</Chip>
            <Chip>Rest: {ex.restSeconds ?? 60}s</Chip>
          </div>

          {/* Enhanced weight input for exercises that use weights */}
          {ex.usesWeight && (
            <div className="mt-4 space-y-4">
              <SmartWeightInput
                exerciseName={ex.name}
                setNumber={setNo}
                currentWeight={workoutWeights[i]?.[setNo] || null}
                onWeightChange={updateWeight}
                isOptimistic={weightState.isOptimistic}
                previousWeights={weightHistory}
                targetReps={ex.reps}
              />



              {/* Progressive Overload Tracker */}
              {!loadingHistory && recentSessions.length > 0 && (
                <ProgressiveOverloadTracker
                  exerciseName={ex.name}
                  recentSessions={recentSessions}
                  currentWeight={workoutWeights[i]?.[setNo] || null}
                  targetReps={ex.reps}
                />
              )}
            </div>
          )}

          {/* how-to */}
          {ex.description && (
            <p className="mt-4 text-gray-700 leading-relaxed">
              <span className="font-medium">How to do it: </span>{ex.description}
            </p>
          )}

          {/* tips */}
          {Array.isArray(ex.formTips) && ex.formTips.length > 0 && (
            <div className="mt-5">
              <div className="mb-1 font-medium text-blue-700 flex items-center gap-2">
                <Lightbulb className="h-4 w-4" /> Form tips
              </div>
              <ul className="list-disc list-inside text-gray-600 text-sm space-y-1">
                {ex.formTips.slice(0, 3).map((t, idx) => <li key={idx}>{t}</li>)}
              </ul>
            </div>
          )}
          {Array.isArray(ex.safetyTips) && ex.safetyTips.length > 0 && (
            <div className="mt-4">
              <div className="mb-1 font-medium text-orange-600 flex items-center gap-2">
                <Shield className="h-4 w-4" /> Safety
              </div>
              <ul className="list-disc list-inside text-gray-600 text-sm space-y-1">
                {ex.safetyTips.slice(0, 3).map((t, idx) => <li key={idx}>{t}</li>)}
              </ul>
            </div>
          )}
        </div>
      </main>

      {/* Sticky controls */}
      <div className="fixed inset-x-0 bottom-0 z-10 border-t border-gray-200 bg-white/80 backdrop-blur fixed-bottom-safe">
        <div className="mx-auto max-w-4xl px-5 py-4 flex items-center justify-between gap-3">
          <button
            onClick={skipExercise}
            className="rounded-xl border border-gray-300 bg-white/70 px-3 py-3 text-gray-700 hover:bg-white hover:border-gray-400 transition-all duration-200 text-sm touch-manipulation min-h-[44px]"
            aria-label="Skip this exercise and move to next"
          >
            Skip Exercise
          </button>

          <div className="flex gap-2">
            <button
              onClick={skipSet}
              className="rounded-xl border border-orange-300 bg-orange-50 px-4 py-3 text-orange-700 hover:bg-orange-100 hover:border-orange-400 transition-all duration-200 active:scale-95 touch-manipulation min-h-[44px]"
              aria-label={`Skip set ${setNo} of ${ex.sets}`}
            >
              Skip Set
            </button>
            <button
              onClick={completeSet}
              className="rounded-xl bg-gradient-to-br from-blue-500 to-indigo-600 px-6 py-3 font-semibold text-white hover:scale-[1.02] active:scale-95 transition-all duration-200 shadow-md focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2 touch-manipulation min-h-[44px]"
              aria-label={`Complete set ${setNo} of ${ex.sets} for ${ex.name}`}
            >
              Complete Set
            </button>
          </div>
        </div>
      </div>
    </div>
  )
}

/* ---------- Small components ---------- */
function Chip({ children, className = '' }: { children: React.ReactNode; className?: string }) {
  return (
    <span className={`inline-flex items-center rounded-full border border-gray-200 bg-gray-100 px-3 py-1 text-gray-700 text-xs ${className}`}>
      {children}
    </span>
  )
}

// WeightInput removed - using SmartWeightInput instead

function EmptyState() {
  const nav = useNavigate()
  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 via-white to-indigo-50 relative">
      <AppHeader />
      <div className="relative grid place-items-center pt-20">
        <div className="max-w-md text-center bg-white/70 backdrop-blur-sm border border-gray-200 rounded-3xl p-8 shadow-lg">
          <h2 className="text-xl font-semibold mb-2 text-gray-900">No plan found</h2>
          <p className="text-gray-600 mb-4">Generate a workout to start your session.</p>
          <button
            onClick={() => nav('/generate')}
            className="px-6 py-3 bg-gradient-to-br from-blue-500 to-indigo-600 text-white rounded-xl font-medium hover:scale-[1.02] transition-all duration-200 shadow-md focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2"
            aria-label="Generate a new workout plan"
          >
            Generate Workout
          </button>
        </div>
      </div>
    </div>
  )
}
=================================================================================
FILE: src/pages/workout/Preview.tsx
=================================================================================
// src/pages/workout/Preview.tsx
import { useState } from 'react'
import { useNavigate } from 'react-router-dom'
import { Play, Lightbulb, Shield, ChevronDown, Plus, RefreshCw, Loader2, Trash2 } from 'lucide-react'
import AppHeader from '../../components/AppHeader'
import { trackWorkoutStarted } from '../../lib/firebase-analytics'
import { useWorkoutScrollToTop } from '../../hooks/useScrollToTop'
import { useAppStore } from '../../store'
import { logger } from '../../lib/logger'

type Exercise = {
  name: string
  description?: string
  sets: number
  reps: number | string
  formTips?: string[]
  safetyTips?: string[]
  restSeconds?: number
  usesWeight?: boolean      // true if this exercise uses external weights
  muscleGroups?: string[]   // Primary muscles worked
  difficulty?: string       // "beginner", "intermediate", or "advanced"
}

type Plan = { exercises: Exercise[] }

export default function Preview() {
  const nav = useNavigate()
  const profile = useAppStore(state => state.profile)

  // Scroll to top on mount and route changes
  useWorkoutScrollToTop()

  // Parse saved data and calculate exercises before early return (computed once on mount)
  const [{ saved, parsedData, initialExercises, initialWorkoutContext }] = useState(() => {
    const saved = sessionStorage.getItem('nf_workout_plan')
    const parsedData = saved ? JSON.parse(saved) as {
      plan: Plan & { metadata?: { targetIntensity?: number; progressionNote?: string } };
      type: string;
      duration: number
    } : null
    const initialExercises = Array.isArray(parsedData?.plan?.exercises) ? parsedData.plan.exercises : []

    // Store the initial workout context for adding exercises
    const initialWorkoutContext = {
      exercises: initialExercises,
      type: parsedData?.type,
      duration: parsedData?.duration,
    }

    return { saved, parsedData, initialExercises, initialWorkoutContext }
  })

  // State for modified exercises
  const [exercises, setExercises] = useState<Exercise[]>(initialExercises)
  const [loadingAdd, setLoadingAdd] = useState(false)
  const [swappingIndex, setSwappingIndex] = useState<number | null>(null)
  const [deletingIndex, setDeletingIndex] = useState<number | null>(null)

  // Early return after all hooks
  if (!saved || !parsedData) return <EmptyState />

  const { type, duration } = parsedData

  // Add exercise handler - uses initial workout context
  const handleAddExercise = async () => {
    setLoadingAdd(true)
    try {
      // Validate we have exercises to work with
      if (!initialWorkoutContext.exercises || initialWorkoutContext.exercises.length === 0) {
        alert('No exercises found in workout. Please try again.')
        return
      }

      const payload = {
        // Use initial workout context, not current modified exercises
        currentWorkout: { exercises: initialWorkoutContext.exercises },
        workoutType: initialWorkoutContext.type,
        experience: profile?.experience,
        goals: profile?.goals,
        equipment: profile?.equipment,
        injuries: profile?.injuries,
      }

      logger.debug('Adding exercise with payload:', {
        exerciseCount: initialWorkoutContext.exercises.length,
        workoutType: initialWorkoutContext.type,
        hasProfile: !!profile,
      })

      const res = await fetch(import.meta.env['VITE_ADD_EXERCISE_FN_URL'] as string, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      })

      const data = await res.json()

      if (!res.ok) {
        const errorMsg = data?.details?.join(', ') || data?.error || `HTTP ${res.status}`
        throw new Error(errorMsg)
      }

      const newExercises = [...exercises, data.exercise]
      setExercises(newExercises)

      // Update session storage
      const updatedPlan = { ...parsedData, plan: { ...parsedData.plan, exercises: newExercises } }
      sessionStorage.setItem('nf_workout_plan', JSON.stringify(updatedPlan))
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : 'Failed to add exercise'
      logger.error('Error adding exercise', error as Error)
      alert(errorMsg)
    } finally {
      setLoadingAdd(false)
    }
  }

  // Delete exercise handler - minimum 3 exercises required
  const handleDeleteExercise = async (index: number) => {
    if (exercises.length <= 3) {
      alert('Cannot delete exercise. Minimum of 3 exercises required.')
      return
    }

    setDeletingIndex(index)
    try {
      const newExercises = exercises.filter((_, i) => i !== index)
      setExercises(newExercises)

      // Update session storage
      const updatedPlan = { ...parsedData, plan: { ...parsedData.plan, exercises: newExercises } }
      sessionStorage.setItem('nf_workout_plan', JSON.stringify(updatedPlan))
    } catch (error) {
      logger.error('Error deleting exercise', error as Error)
      alert('Failed to delete exercise. Please try again.')
    } finally {
      setDeletingIndex(null)
    }
  }

  // Swap exercise handler
  const handleSwapExercise = async (index: number) => {
    setSwappingIndex(index)
    try {
      const res = await fetch(import.meta.env['VITE_SWAP_EXERCISE_FN_URL'] as string, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          exerciseToReplace: exercises[index],
          currentWorkout: { exercises },
          workoutType: type,
          experience: profile?.experience,
          goals: profile?.goals,
          equipment: profile?.equipment,
          injuries: profile?.injuries,
        }),
      })

      const data = await res.json()

      if (!res.ok) {
        const errorMsg = data?.details?.join(', ') || data?.error || 'Failed to swap exercise'
        throw new Error(errorMsg)
      }

      const newExercises = [...exercises]
      newExercises[index] = data.exercise
      setExercises(newExercises)

      // Update session storage
      const updatedPlan = { ...parsedData, plan: { ...parsedData.plan, exercises: newExercises } }
      sessionStorage.setItem('nf_workout_plan', JSON.stringify(updatedPlan))
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : 'Failed to swap exercise'
      logger.error('Error swapping exercise', error as Error)
      alert(errorMsg)
    } finally {
      setSwappingIndex(null)
    }
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 via-white to-blue-50/30 relative">
      {/* Enhanced Background decoration */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute -top-40 -right-40 w-80 h-80 bg-gradient-to-br from-blue-400/20 to-indigo-400/15 rounded-full blur-3xl" />
        <div className="absolute -bottom-40 -left-40 w-80 h-80 bg-gradient-to-tr from-indigo-400/15 to-blue-400/20 rounded-full blur-3xl" />
        <div className="absolute top-1/3 left-1/2 transform -translate-x-1/2 w-96 h-96 bg-gradient-to-r from-slate-300/10 to-gray-300/10 rounded-full blur-3xl" />
      </div>

      <AppHeader />

      {/* Compact Hero Section */}
      <section className="relative mx-auto max-w-4xl px-4 pt-4">
        <div className="group relative overflow-hidden rounded-2xl border border-white/60 bg-gradient-to-br from-white/95 via-white/85 to-white/75 backdrop-blur-xl p-5 md:p-6 shadow-lg shadow-slate-200/30 hover:shadow-xl hover:shadow-slate-300/20 transition-all duration-300">
          {/* Compact background elements */}
          <div className="absolute -right-12 -top-12 h-32 w-32 rounded-full bg-gradient-to-tr from-blue-400/15 via-indigo-400/10 to-purple-400/5 opacity-60 blur-2xl group-hover:opacity-80 transition-opacity duration-300" />

          <div className="relative">
            {/* Compact Workout Title */}
            <h1 className="text-2xl md:text-3xl font-bold tracking-tight bg-gradient-to-r from-slate-900 via-slate-800 to-slate-700 bg-clip-text text-transparent leading-tight">
              {type} <span className="text-slate-400/60">—</span> {duration} min
            </h1>
          </div>
        </div>
      </section>

      {/* Compact Exercises */}
      <main className="relative mx-auto max-w-4xl px-4 pt-4 pb-24">
        <ol className="space-y-3">
          {exercises.map((ex, i) => (
            <ExerciseItem
              key={i}
              index={i}
              ex={ex}
              onSwap={() => handleSwapExercise(i)}
              onDelete={() => handleDeleteExercise(i)}
              isSwapping={swappingIndex === i}
              isDeleting={deletingIndex === i}
              canDelete={exercises.length > 3}
            />
          ))}
        </ol>

        {/* Add Exercise Button */}
        <div className="mt-4">
          <button
            onClick={handleAddExercise}
            disabled={loadingAdd}
            className="w-full group overflow-hidden rounded-xl border-2 border-dashed border-blue-300 bg-gradient-to-br from-blue-50/80 to-indigo-50/60 backdrop-blur-xl px-4 py-4 hover:border-blue-400 hover:from-blue-100/80 hover:to-indigo-100/60 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            <div className="flex items-center justify-center gap-2 text-blue-600 font-semibold">
              {loadingAdd ? (
                <>
                  <Loader2 className="h-5 w-5 animate-spin" />
                  <span>Adding Exercise...</span>
                </>
              ) : (
                <>
                  <Plus className="h-5 w-5 group-hover:scale-110 transition-transform duration-200" />
                  <span>Add Another Exercise</span>
                </>
              )}
            </div>
          </button>
        </div>
      </main>

      {/* Compact Sticky Start Button */}
      <div className="fixed inset-x-0 bottom-0 z-10 border-t border-white/60 bg-gradient-to-r from-white/95 via-white/90 to-white/85 backdrop-blur-xl shadow-xl shadow-slate-300/15 fixed-bottom-safe">
        <div className="mx-auto max-w-4xl px-4 py-4 flex items-center justify-between">
          <div className="text-slate-600 hidden md:block text-sm leading-relaxed">
            Tap exercises for tips
          </div>
          <button
            onClick={() => {
              // Clear any existing workout data for a fresh start
              sessionStorage.removeItem('nf_workout_weights')
              sessionStorage.removeItem('nf_return')
              sessionStorage.removeItem('nf_next')
              sessionStorage.removeItem('nf_rest')

              // Store workout start time
              sessionStorage.setItem('nf_workout_start_time', Date.now().toString())

              // Track workout started
              const workoutId = `workout_${Date.now()}`
              trackWorkoutStarted(workoutId)

              nav('/workout/run')
            }}
            className="group inline-flex items-center gap-2 rounded-xl bg-gradient-to-r from-blue-600 to-indigo-600 px-6 py-3 font-bold text-white hover:from-blue-700 hover:to-indigo-700 hover:shadow-lg hover:shadow-blue-500/25 hover:scale-105 active:scale-95 transition-all duration-300 shadow-md shadow-blue-500/20 md:px-8 md:py-4 md:gap-3 md:rounded-2xl"
          >
            <Play className="h-5 w-5 md:h-6 md:w-6 group-hover:scale-110 transition-transform duration-200" />
            <span className="md:text-base">Start Workout</span>
          </button>
        </div>
      </div>
    </div>
  )
}

/* ---------------- Components ---------------- */

function ExerciseItem({
  ex,
  index,
  onSwap,
  onDelete,
  isSwapping,
  isDeleting,
  canDelete,
}: {
  ex: Exercise;
  index: number;
  onSwap: () => void;
  onDelete: () => void;
  isSwapping: boolean;
  isDeleting: boolean;
  canDelete: boolean;
}) {
  const [open, setOpen] = useState(false)

  return (
    <li className="group overflow-hidden rounded-xl border border-white/60 bg-gradient-to-br from-white/95 to-white/85 backdrop-blur-xl shadow-md shadow-slate-200/25 hover:shadow-lg hover:shadow-slate-300/15 transition-all duration-200 active:scale-[0.98]">
      <button
        className="w-full px-4 py-4 text-left flex items-start justify-between gap-3 hover:bg-white/50 transition-colors duration-200"
        onClick={() => setOpen(o => !o)}
      >
        <div className="flex-1 min-w-0">
          <div className="flex items-center gap-3 mb-2">
            <span className="inline-flex items-center justify-center w-6 h-6 rounded-lg bg-gradient-to-br from-blue-500 to-indigo-600 text-white text-xs font-bold flex-shrink-0 shadow-sm shadow-blue-500/25">
              {index + 1}
            </span>
            <h3 className="font-bold text-slate-900 group-hover:text-slate-800 transition-colors truncate text-base md:text-lg">
              {ex.name}
            </h3>
          </div>
          <div className="text-sm text-slate-600 ml-9">
            <span className="font-semibold">{ex.sets}</span> sets • <span className="font-semibold">{ex.reps}</span> reps
            {ex.restSeconds ? <span className="ml-2 text-slate-500 hidden sm:inline">• <span className="font-semibold">{ex.restSeconds}s</span></span> : null}
          </div>
        </div>
        <ChevronDown className={`h-5 w-5 text-slate-400 transition-all duration-200 group-hover:text-slate-600 flex-shrink-0 ${open ? 'rotate-180' : ''}`} />
      </button>

      {open && (
        <div className="border-t border-white/60 px-4 py-4 bg-gradient-to-br from-slate-50/80 to-gray-50/60 backdrop-blur-sm">
          {ex.description && <p className="mb-3 leading-relaxed text-slate-700 text-sm">{ex.description}</p>}
          {!!ex.formTips?.length && (
            <div className="mb-3">
              <div className="mb-2 font-bold flex items-center gap-2 text-blue-700 text-sm">
                <div className="w-6 h-6 rounded-lg bg-gradient-to-br from-blue-500 to-indigo-600 flex items-center justify-center flex-shrink-0">
                  <Lightbulb className="h-3 w-3 text-white" />
                </div>
                Form Tips
              </div>
              <ul className="space-y-1.5 text-slate-600 ml-8 text-sm">
                {ex.formTips.slice(0,3).map((t, i) => (
                  <li key={i} className="flex items-start gap-2">
                    <div className="w-1 h-1 rounded-full bg-blue-500 mt-2 flex-shrink-0" />
                    <span className="leading-relaxed">{t}</span>
                  </li>
                ))}
              </ul>
            </div>
          )}
          {!!ex.safetyTips?.length && (
            <div className="mb-3">
              <div className="mb-2 font-bold text-orange-700 flex items-center gap-2 text-sm">
                <div className="w-6 h-6 rounded-lg bg-gradient-to-br from-orange-500 to-red-600 flex items-center justify-center flex-shrink-0">
                  <Shield className="h-3 w-3 text-white" />
                </div>
                Safety Tips
              </div>
              <ul className="space-y-1.5 text-orange-600 ml-8 text-sm">
                {ex.safetyTips.slice(0,3).map((t, i) => (
                  <li key={i} className="flex items-start gap-2">
                    <div className="w-1 h-1 rounded-full bg-orange-500 mt-2 flex-shrink-0" />
                    <span className="leading-relaxed">{t}</span>
                  </li>
                ))}
              </ul>
            </div>
          )}

          {/* Action Buttons */}
          <div className="flex gap-2 mt-2">
            {/* Swap Exercise Button */}
            <button
              onClick={(e) => {
                e.stopPropagation()
                onSwap()
              }}
              disabled={isSwapping}
              className="flex-1 flex items-center justify-center gap-2 px-4 py-2.5 rounded-lg bg-gradient-to-r from-slate-100 to-slate-50 border border-slate-200 text-slate-700 font-medium text-sm hover:from-slate-200 hover:to-slate-100 hover:border-slate-300 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {isSwapping ? (
                <>
                  <Loader2 className="h-4 w-4 animate-spin" />
                  <span>Swapping...</span>
                </>
              ) : (
                <>
                  <RefreshCw className="h-4 w-4" />
                  <span>Swap</span>
                </>
              )}
            </button>

            {/* Delete Exercise Button */}
            <button
              onClick={(e) => {
                e.stopPropagation()
                if (canDelete) {
                  onDelete()
                }
              }}
              disabled={!canDelete || isDeleting}
              title={!canDelete ? 'Minimum 3 exercises required' : 'Delete exercise'}
              className="flex items-center justify-center gap-2 px-4 py-2.5 rounded-lg bg-gradient-to-r from-red-50 to-red-100 border border-red-200 text-red-700 font-medium text-sm hover:from-red-100 hover:to-red-200 hover:border-red-300 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {isDeleting ? (
                <Loader2 className="h-4 w-4 animate-spin" />
              ) : (
                <Trash2 className="h-4 w-4" />
              )}
            </button>
          </div>
        </div>
      )}
    </li>
  )
}

function EmptyState() {
  const nav = useNavigate()
  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 via-white to-blue-50/30 relative">
      {/* Background decoration */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute -top-40 -right-40 w-80 h-80 bg-gradient-to-br from-blue-400/20 to-indigo-400/15 rounded-full blur-3xl" />
        <div className="absolute -bottom-40 -left-40 w-80 h-80 bg-gradient-to-tr from-indigo-400/15 to-blue-400/20 rounded-full blur-3xl" />
      </div>

      <AppHeader />
      <div className="relative grid place-items-center pt-16 px-4">
        <div className="max-w-sm text-center p-6 rounded-2xl border border-white/60 bg-gradient-to-br from-white/95 to-white/85 backdrop-blur-xl shadow-lg shadow-slate-200/30">
          <h2 className="text-xl font-bold mb-3 bg-gradient-to-r from-slate-900 to-slate-700 bg-clip-text text-transparent">No plan found</h2>
          <p className="text-slate-600 mb-5 leading-relaxed text-sm">Generate a workout to preview it here.</p>
          <button
            onClick={()=>nav('/generate')}
            className="inline-flex items-center gap-2 rounded-xl bg-gradient-to-r from-blue-600 to-indigo-600 text-white px-6 py-3 font-bold hover:from-blue-700 hover:to-indigo-700 hover:shadow-lg hover:shadow-blue-500/25 hover:scale-105 active:scale-95 transition-all duration-300 shadow-md shadow-blue-500/20 w-full justify-center"
          >
            Generate Workout
          </button>
        </div>
      </div>
    </div>
  )
}

=================================================================================
FILE: src/pages/workout/Rest.tsx
=================================================================================
// src/pages/workout/Rest.tsx
import { useState } from 'react'
import { useNavigate } from 'react-router-dom'
import WorkoutFlowHeader from '../../components/WorkoutFlowHeader'
import { EnhancedRestTimer } from '../../components/EnhancedRestTimer'
import { logger } from '../../lib/logger'
import { useWorkoutScrollToTop } from '../../hooks/useScrollToTop'

export default function Rest() {
  const nav = useNavigate()

  // Scroll to top on mount and route changes
  useWorkoutScrollToTop()

  // Retrieve initial rest time, default to 60 seconds if not set (computed once on mount)
  const [initial] = useState(() => {
    const storedRest = sessionStorage.getItem('nf_rest')
    return storedRest ? Number(storedRest) : 60
  })

  // Parse next exercise data safely (computed once on mount)
  const [nextExercise] = useState(() => {
    try {
      const nextRaw = sessionStorage.getItem('nf_next')
      const planRaw = sessionStorage.getItem('nf_workout_plan')

      if (!nextRaw || !planRaw) return undefined

      const next = JSON.parse(nextRaw) as { i: number; setNo: number }
      const plan = JSON.parse(planRaw) as { plan?: { exercises?: { name: string; sets: number; reps: number | string; restSeconds?: number }[] } }
      const ex = plan?.plan?.exercises?.[next.i]

      if (!ex) return undefined

      return {
        name: ex.name,
        sets: ex.sets,
        reps: ex.reps,
        restSeconds: ex.restSeconds
      }
    } catch (error) {
      logger.error('Error parsing next exercise data', { error })
      return undefined
    }
  })

  const handleComplete = () => {
    // Transfer next state to return state for Exercise screen
    const next = sessionStorage.getItem('nf_next')
    if (next) {
      sessionStorage.setItem('nf_return', next)
      sessionStorage.removeItem('nf_next')
    }
    nav('/workout/run')
  }

  return (
    <>
      <WorkoutFlowHeader
        title="Rest Period"
        showBackButton={true}
        onBack={() => nav('/workout/run')}
      />
      <EnhancedRestTimer
        initialSeconds={initial}
        onComplete={handleComplete}
        nextExercise={nextExercise}
      />
    </>
  )
}
=================================================================================
FILE: src/pages/WorkoutDetail.tsx
=================================================================================
// src/pages/WorkoutDetail.tsx
import { useEffect, useState } from 'react'
import { useNavigate, useParams } from 'react-router-dom'
import { auth, db } from '../lib/firebase'
import { doc, getDoc } from 'firebase/firestore'
import { convertToDate } from '../utils/timestamp'
import { ArrowLeft, Clock, Calendar, CheckCircle, XCircle, Weight } from 'lucide-react'
import AppHeader from '../components/AppHeader'
import { WorkoutDetailSkeleton } from '../components/Loading'
import { logger } from '../lib/logger'

type Exercise = {
  name: string
  sets: number
  reps: string | number
  weights?: Record<number, number | null>
  usesWeight?: boolean
  description?: string
  formTips?: string[]
  safetyTips?: string[]
  restSeconds?: number
}

type WorkoutData = {
  id: string
  workoutType: string
  duration: number
  plannedDuration?: number
  exercises: Exercise[]
  timestamp: Date | { toDate(): Date } | string
}

export default function WorkoutDetail() {
  const { workoutId } = useParams<{ workoutId: string }>()
  const nav = useNavigate()
  const [workout, setWorkout] = useState<WorkoutData | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    const fetchWorkout = async () => {
      try {
        const uid = auth.currentUser?.uid
        if (!uid || !workoutId) {
          setError('Invalid workout or user')
          return
        }

        const workoutDoc = await getDoc(doc(db, 'users', uid, 'workouts', workoutId))
        if (!workoutDoc.exists()) {
          setError('Workout not found')
          return
        }

        setWorkout({ id: workoutDoc.id, ...workoutDoc.data() } as WorkoutData)
      } catch (err) {
        const error = err as Error
        logger.error('Error fetching workout', error, { workoutId })
        setError(error.message || 'Failed to load workout')
      } finally {
        setLoading(false)
      }
    }

    fetchWorkout()
  }, [workoutId])

  if (loading) {
    return <WorkoutDetailSkeleton />
  }

  if (error || !workout) {
    return (
      <div className="min-h-screen bg-white">
        <div className="max-w-md mx-auto px-6 py-8">
          <div className="text-center">
            <XCircle className="h-12 w-12 text-red-500 mx-auto mb-4" />
            <h1 className="text-xl font-semibold text-gray-900 mb-2">Workout Not Found</h1>
            <p className="text-gray-600 mb-6">{error || 'This workout could not be loaded.'}</p>
            <button
              onClick={() => nav('/history')}
              className="inline-flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
            >
              <ArrowLeft className="h-4 w-4" />
              Back to History
            </button>
          </div>
        </div>
      </div>
    )
  }

  const formatDate = (timestamp: Date | { toDate(): Date } | string) => {
    if (!timestamp) return 'Unknown date'
    const date = convertToDate(timestamp)
    return date.toLocaleDateString('en-US', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    })
  }

  const formatTime = (timestamp: Date | { toDate(): Date } | string) => {
    if (!timestamp) return 'Unknown time'
    const date = convertToDate(timestamp)
    return date.toLocaleTimeString('en-US', {
      hour: 'numeric',
      minute: '2-digit',
      hour12: true
    })
  }

  const formatEndTime = (timestamp: Date | { toDate(): Date } | string, duration: number) => {
    if (!timestamp) return 'Unknown time'
    const startDate = convertToDate(timestamp)
    const endDate = new Date(startDate.getTime() + duration * 60 * 1000) // Add duration in milliseconds
    return endDate.toLocaleTimeString('en-US', {
      hour: 'numeric',
      minute: '2-digit',
      hour12: true
    })
  }

  const calculateExerciseStats = (exercise: Exercise) => {
    const hasWeights = exercise.weights && Object.values(exercise.weights).some(w => w !== null && w > 0)
    const totalSets = exercise.sets

    let completedSets = 0
    let isCompleted = false

    if (exercise.weights) {
      // Count all entries with non-null values (including 0 which indicates completed sets)
      // null values indicate skipped sets
      completedSets = Object.values(exercise.weights).filter(w => w !== null).length
    } else {
      // No weights data means no sets were tracked (shouldn't happen with new system)
      completedSets = 0
    }
    // Exercise is considered completed if it has ANY completed sets (consistent with History.tsx)
    isCompleted = completedSets > 0

    let avgWeight = null
    let maxWeight = null
    let minWeight = null

    if (hasWeights && exercise.usesWeight) {
      // Only consider actual weight values (> 0) for statistics, not completion markers (0)
      const weights = Object.values(exercise.weights!).filter(w => w !== null && w > 0) as number[]
      if (weights.length > 0) {
        avgWeight = Math.round(weights.reduce((sum, w) => sum + w, 0) / weights.length)
        maxWeight = Math.max(...weights)
        minWeight = Math.min(...weights)
      }
    }

    return { hasWeights, completedSets, totalSets, isCompleted, avgWeight, maxWeight, minWeight }
  }

  const totalExercises = workout.exercises.length
  const completedExercises = workout.exercises.filter(ex => {
    const stats = calculateExerciseStats(ex)
    return stats.isCompleted
  }).length

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 via-white to-indigo-50 relative text-gray-900">
      {/* Background decoration */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute -top-40 -right-40 w-80 h-80 bg-gradient-to-br from-blue-200/30 to-indigo-200/30 rounded-full blur-3xl" />
        <div className="absolute -bottom-40 -left-40 w-80 h-80 bg-gradient-to-tr from-indigo-200/30 to-blue-200/30 rounded-full blur-3xl" />
      </div>

      <AppHeader />

      {/* Main Content */}
      <main className="relative max-w-4xl mx-auto px-6 py-8">
        {/* Workout Overview */}
        <div className="bg-gradient-to-r from-blue-50 to-cyan-50 rounded-2xl p-6 mb-8">
          <div className="flex items-start justify-between mb-6">
            <div className="flex-1">
              <h1 className="text-2xl font-bold text-gray-900 mb-3">{workout.workoutType}</h1>
              <div className="flex items-center gap-4 text-sm text-gray-600">
                <div className="flex items-center gap-1">
                  <Calendar className="h-4 w-4" />
                  <span>{formatDate(workout.timestamp)}</span>
                </div>
                <div className="flex items-center gap-1">
                  <Clock className="h-4 w-4" />
                  <span>{formatTime(workout.timestamp)}</span>
                </div>
              </div>
            </div>
            <div className="text-right ml-6">
              <div className="text-3xl font-bold text-blue-600 mb-1">{workout.duration}</div>
              <div className="text-sm text-gray-600 mb-2">minutes</div>
              <div className="text-xs text-gray-500">
                Ended {formatEndTime(workout.timestamp, workout.duration)}
              </div>
            </div>
          </div>

          {/* Progress Summary */}
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4 pt-4 border-t border-blue-100">
            <div className="text-center">
              <div className="text-lg font-semibold text-gray-900">{totalExercises}</div>
              <div className="text-sm text-gray-600">Total Exercises</div>
            </div>
            <div className="text-center">
              <div className="text-lg font-semibold text-green-600">{completedExercises}</div>
              <div className="text-sm text-gray-600">Completed</div>
            </div>
            <div className="text-center">
              <div className="text-lg font-semibold text-blue-600">
                {Math.round((completedExercises / totalExercises) * 100)}%
              </div>
              <div className="text-sm text-gray-600">Success Rate</div>
            </div>
            <div className="text-center">
              <div className="text-lg font-semibold text-gray-900">
                {workout.exercises.reduce((total, ex) => {
                  const stats = calculateExerciseStats(ex)
                  return total + stats.completedSets
                }, 0)}
              </div>
              <div className="text-sm text-gray-600">Total Sets</div>
            </div>
          </div>
        </div>

        {/* Exercise Details */}
        <div className="space-y-4">
          <h2 className="text-xl font-semibold text-gray-900 mb-4">Exercise Details</h2>
          {workout.exercises.map((exercise, index) => {
            const stats = calculateExerciseStats(exercise)
            
            return (
              <div key={index} className="bg-white border border-gray-200 rounded-xl p-6">
                <div className="flex items-start justify-between mb-4">
                  <div className="flex-1">
                    <h3 className="text-lg font-semibold text-gray-900 mb-1">{exercise.name}</h3>
                    <div className="flex items-center gap-4 text-sm text-gray-600">
                      <span>{exercise.sets} sets × {exercise.reps} reps</span>
                      {stats.hasWeights && stats.avgWeight && (
                        <span className="text-blue-600 font-medium">@ {stats.avgWeight}lbs avg</span>
                      )}
                    </div>
                  </div>
                  <div className="flex items-center gap-2">
                    {stats.isCompleted ? (
                      <CheckCircle className="h-6 w-6 text-green-500" />
                    ) : (
                      <XCircle className="h-6 w-6 text-red-500" />
                    )}
                    <span className="text-sm font-medium text-gray-700">
                      {stats.completedSets}/{stats.totalSets} sets
                    </span>
                  </div>
                </div>

                {/* Weight Summary for weight-based exercises */}
                {stats.hasWeights && exercise.usesWeight && (
                  <div className="bg-gray-50 rounded-lg p-4 mb-4">
                    <div className="flex items-center gap-2 mb-3">
                      <Weight className="h-4 w-4 text-gray-600" />
                      <span className="font-medium text-gray-900">Weight Summary</span>
                    </div>
                    <div className="grid grid-cols-3 gap-4 text-sm">
                      <div className="text-center">
                        <div className="font-semibold text-gray-900">{stats.avgWeight}lbs</div>
                        <div className="text-gray-600">Average</div>
                      </div>
                      <div className="text-center">
                        <div className="font-semibold text-gray-900">{stats.maxWeight}lbs</div>
                        <div className="text-gray-600">Max</div>
                      </div>
                      <div className="text-center">
                        <div className="font-semibold text-gray-900">{stats.minWeight}lbs</div>
                        <div className="text-gray-600">Min</div>
                      </div>
                    </div>
                  </div>
                )}

                {/* Set-by-Set Details */}
                <div className="bg-gray-50 rounded-lg p-4">
                  <div className="flex items-center gap-2 mb-3">
                    <span className="font-medium text-gray-900">Set Details</span>
                  </div>
                  <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-2">
                    {Array.from({ length: exercise.sets }, (_, i) => {
                      const setNumber = i + 1
                      const weight = exercise.weights?.[setNumber]

                      // Determine if set is completed
                      // weight === null means skipped
                      // weight === 0 means completed without weight
                      // weight > 0 means completed with weight
                      // weight === undefined means set was never attempted (shouldn't happen)
                      const isCompleted = weight !== null && weight !== undefined
                      const wasAttempted = weight !== undefined

                      return (
                        <div
                          key={setNumber}
                          className={`px-3 py-2 rounded-lg text-sm font-medium text-center ${
                            !wasAttempted
                              ? 'bg-gray-100 text-gray-600 border border-gray-200'
                              : isCompleted
                              ? 'bg-green-100 text-green-800 border border-green-200'
                              : 'bg-red-100 text-red-800 border border-red-200'
                          }`}
                        >
                          <div className="font-semibold">Set {setNumber}</div>
                          <div className="text-xs mt-1">
                            {!wasAttempted ? (
                              'Not attempted'
                            ) : isCompleted ? (
                              exercise.usesWeight && weight > 0 ? `${weight}lbs` : 'Completed'
                            ) : (
                              'Skipped'
                            )}
                          </div>
                        </div>
                      )
                    })}
                  </div>
                </div>


              </div>
            )
          })}
        </div>
      </main>
    </div>
  )
}
=================================================================================
FILE: src/providers/app-provider-utils.ts
=================================================================================
/**
 * App Provider Utilities
 * Shared utilities and hooks for the app provider
 */

import { useAppStore } from '../store'

// Hook to access the unified store
export const useApp = () => {
  const store = useAppStore()

  return {
    // Auth state
    user: store.user,
    profile: store.profile,
    authStatus: store.authStatus,
    isGuest: store.isGuest,

    // Workout state
    currentWorkout: store.currentWorkout,
    workoutWeights: store.workoutWeights,
    workoutHistory: store.workoutHistory,

    // UI state
    isOnline: store.isOnline,
    errors: store.errors,

    // Actions
    actions: {
      // Auth actions
      setUser: store.setUser,
      setProfile: store.setProfile,
      setAuthStatus: store.setAuthStatus,
      setIsGuest: store.setIsGuest,
      initializeGuestSession: store.initializeGuestSession,

      // Workout actions
      startWorkout: store.startWorkout,
      updateWorkoutProgress: store.updateWorkoutProgress,
      updateWeight: store.updateWeight,
      completeWorkout: store.completeWorkout,
      clearWorkout: store.clearWorkout,

      // Error actions
      addError: store.addError,
      resolveError: store.resolveError,
      clearErrors: store.clearErrors,

      // Utility actions
      reset: store.reset,
    },
  } as const
}

// App state utilities
export const appUtils = {
  getAuthStatusText: (status: string): string => {
    switch (status) {
      case 'loading':
        return 'Checking authentication...'
      case 'authenticated':
        return 'Signed in'
      case 'unauthenticated':
        return 'Not signed in'
      case 'error':
        return 'Authentication error'
      default:
        return 'Unknown status'
    }
  },

  formatNotificationCount: (count: number): string => {
    if (count === 0) return ''
    if (count > 99) return '99+'
    return count.toString()
  }
}



=================================================================================
FILE: src/providers/AppProvider.tsx
=================================================================================
// src/providers/AppProvider.tsx
import { useEffect, type ReactNode, useRef } from 'react';
import { auth, db } from '../lib/firebase';
import { onAuthStateChanged, type User } from 'firebase/auth';
import { doc, onSnapshot } from 'firebase/firestore';
import { useAppStore } from '../store';
import { isProfileComplete } from '../session/types';
import type { UserProfile } from '../session/types';
import { ensureUserDocument } from '../lib/user-utils';
import ErrorBoundary from '../components/ErrorBoundary';
import { setUserContext, clearUserContext } from '../lib/sentry';
import { logger } from '../lib/logger';

interface AppProviderProps {
  children: ReactNode;
}

/** Small helper to safely schedule work during idle time (with fallback). */
function scheduleIdle(fn: () => void, timeout = 2000) {
  const w = window as Window & {
    requestIdleCallback?: (
      cb: (deadline: { didTimeout: boolean; timeRemaining: () => number }) => void,
      opts?: { timeout?: number }
    ) => number;
  };
  if (typeof w.requestIdleCallback === 'function') {
    w.requestIdleCallback(() => fn(), { timeout });
  } else {
    setTimeout(fn, Math.min(500, timeout));
  }
}

/** Session-scoped profile cache to minimize UI flicker after reloads. */
const PROFILE_CACHE_KEY = (uid: string) => `nf:profile-cache:${uid}`;

function loadCachedProfile(uid: string): UserProfile | null {
  try {
    const raw = sessionStorage.getItem(PROFILE_CACHE_KEY(uid));
    return raw ? (JSON.parse(raw) as UserProfile) : null;
  } catch {
    return null;
  }
}

function saveCachedProfile(uid: string, profile: UserProfile | null) {
  try {
    if (!profile) {
      sessionStorage.removeItem(PROFILE_CACHE_KEY(uid));
    } else {
      sessionStorage.setItem(PROFILE_CACHE_KEY(uid), JSON.stringify(profile));
    }
  } catch {
    /* ignore */
  }
}

export function AppProvider({ children }: AppProviderProps) {
  const {
    setUser,
    setProfile,
    setAuthStatus,
    syncPendingOperations,
    setOnlineStatus,
    updateLastSyncTime,
  } = useAppStore();

  /**
   * Track the current "auth flow" to prevent stale async completions from
   * mutating state after a quick sign-out/sign-in or provider switch.
   */
  const flowIdRef = useRef(0); // increments on each auth change

  // Authentication + profile state
  useEffect(() => {
    let unsubDoc: (() => void) | null = null;
    let unsubAuth: (() => void) | null = null;
    let mounted = true;
    let initTimer: ReturnType<typeof setTimeout> | null = null;

    const cleanupDoc = () => {
      if (unsubDoc) {
        unsubDoc();
        unsubDoc = null;
      }
    };

    const handleAuthChange = async (user: User | null) => {
      // New flow for each auth transition
      const myFlow = ++flowIdRef.current;

      if (!mounted) return;

      logger.debug('🔐 Auth state changed', { email: user?.email ?? 'signed out' });

      // Cancel previous doc listener and any pending init timer
      if (initTimer) {
        clearTimeout(initTimer);
        initTimer = null;
      }
      cleanupDoc();

      // Atomically reset user+profile in store
      setUser(user);
      setProfile(null);

      if (!user) {
        setAuthStatus('signedOut');
        clearUserContext();
        return;
      }

      // Bind Sentry user context
      setUserContext({ id: user.uid, email: user.email ?? undefined });

      // Optimistically hydrate from session cache to reduce flicker
      const cached = loadCachedProfile(user.uid);
      if (cached) {
        setProfile(cached);
        setAuthStatus(isProfileComplete(cached) ? 'ready' : 'needsOnboarding');
      } else {
        // While we prepare Firestore listener, keep UI in a known loading state
        setAuthStatus('loading');
      }

      // Slight defer to allow Firebase to settle any token refresh
      initTimer = setTimeout(async () => {
        if (!mounted || myFlow !== flowIdRef.current) return;

        try {
          // Make sure a base user document exists (idempotent)
          await ensureUserDocument(user);

          // Live profile listener (includes cache → server updates)
          const profileRef = doc(db, 'users', user.uid);

          unsubDoc = onSnapshot(
            profileRef,
            // Data
            (snapshot) => {
              if (!mounted || myFlow !== flowIdRef.current) return;

              if (!snapshot.exists()) {
                setProfile(null);
                setAuthStatus('needsOnboarding');
                saveCachedProfile(user.uid, null);
                return;
              }

              const profile = snapshot.data() as UserProfile;
              setProfile(profile);
              // Persist session cache for snappy subsequent loads
              saveCachedProfile(user.uid, profile);

              const complete = isProfileComplete(profile);
              setAuthStatus(complete ? 'ready' : 'needsOnboarding');
            },
            // Errors
            (error: Error) => {
              const errorCode = (error as { code?: string }).code;
              logger.error('Profile listener error', { code: errorCode, message: String(error) });

              // Permission denied → treat as signed out (likely token invalidated or rules mismatch)
              if (errorCode === 'permission-denied') {
                cleanupDoc();
                setProfile(null);
                setAuthStatus('signedOut');
                clearUserContext();
              }
            }
          );

          // After listener attaches, perform a background sync (best-effort)
          scheduleIdle(async () => {
            if (!mounted || myFlow !== flowIdRef.current) return;
            try {
              await syncPendingOperations();
              if (mounted && myFlow === flowIdRef.current) updateLastSyncTime();
            } catch (syncError) {
              logger.warn('Deferred sync error', { error: String(syncError) });
            }
          });
        } catch (e) {
          logger.error('User initialization error', { error: String(e) });
          if (mounted && myFlow === flowIdRef.current) {
            // Only downgrade to signedOut on clear auth-related errors; otherwise keep cached state
            const code = (e as { code?: string }).code;
            if (code === 'permission-denied' || code === 'unauthenticated') {
              setAuthStatus('signedOut');
              clearUserContext();
            } else {
              // Keep whatever cached profile (if any) and mark as loading to allow retry via snapshot
              setAuthStatus('loading');
            }
          }
        }
      }, 100);
    };

    // Prime state with current user (reduces first-paint flicker)
    try {
      const u = auth.currentUser;
      if (u) {
        setUser(u);
        const cached = loadCachedProfile(u.uid);
        if (cached) {
          setProfile(cached);
          setAuthStatus(isProfileComplete(cached) ? 'ready' : 'needsOnboarding');
        } else {
          setAuthStatus('loading');
        }
      } else {
        setAuthStatus('signedOut');
      }
    } catch {
      // ignore
    }

    // Subscribe to auth state
    unsubAuth = onAuthStateChanged(
      auth,
      (user) => void handleAuthChange(user),
      (err) => {
        logger.error('Auth listener error', { error: String(err) });
        setAuthStatus('signedOut');
        clearUserContext();
      }
    );

    return () => {
      mounted = false;
      if (initTimer) clearTimeout(initTimer);
      if (unsubAuth) unsubAuth();
      cleanupDoc();
    };
  }, [setUser, setProfile, setAuthStatus, syncPendingOperations, updateLastSyncTime]);

  // Online/offline + visibility-aware sync
  useEffect(() => {
    const syncNow = async (reason: string) => {
      logger.debug('🔄 Sync trigger', { reason, online: navigator.onLine });
      if (!navigator.onLine) return;
      try {
        await syncPendingOperations();
        updateLastSyncTime();
      } catch (e) {
        logger.warn('Sync failed', { error: String(e) });
      }
    };

    const onOnline = () => {
      setOnlineStatus(true);
      // Immediately kick a sync; queue to next tick to avoid blocking event loop
      Promise.resolve().then(() => syncNow('online'));
    };

    const onOffline = () => setOnlineStatus(false);

    const onVisibility = () => {
      if (document.visibilityState === 'visible') {
        scheduleIdle(() => void syncNow('visibility'));
      }
    };

    window.addEventListener('online', onOnline);
    window.addEventListener('offline', onOffline);
    document.addEventListener('visibilitychange', onVisibility);

    // Initialize online status
    setOnlineStatus(navigator.onLine);
    if (navigator.onLine) scheduleIdle(() => void syncNow('mount'));

    return () => {
      window.removeEventListener('online', onOnline);
      window.removeEventListener('offline', onOffline);
      document.removeEventListener('visibilitychange', onVisibility);
    };
  }, [setOnlineStatus, syncPendingOperations, updateLastSyncTime]);

  // Periodic background sync (lightweight cadence)
  useEffect(() => {
    const intervalMs = 3 * 60 * 1000; // 3 minutes
    const id = setInterval(() => {
      if (navigator.onLine) {
        void syncPendingOperations().then(updateLastSyncTime).catch((e) => {
          logger.warn('Periodic sync failed', { error: String(e) });
        });
      }
    }, intervalMs);
    return () => clearInterval(id);
  }, [syncPendingOperations, updateLastSyncTime]);

  // Global error recovery (kept minimal and safe)
  useEffect(() => {
    const handleUnhandledRejection = (event: PromiseRejectionEvent) => {
      logger.error('Unhandled promise rejection', { reason: String(event.reason) });
      const reasonCode = (event.reason as { code?: string }).code;
      if (reasonCode === 'permission-denied') {
        setAuthStatus('signedOut');
        clearUserContext();
      }
      event.preventDefault();
    };

    const handleError = (event: ErrorEvent) => {
      logger.error('Global error', { error: String(event.error || event.message) });
    };

    window.addEventListener('unhandledrejection', handleUnhandledRejection);
    window.addEventListener('error', handleError);

    return () => {
      window.removeEventListener('unhandledrejection', handleUnhandledRejection);
      window.removeEventListener('error', handleError);
    };
  }, [setAuthStatus]);

  return <ErrorBoundary level="component">{children}</ErrorBoundary>;
}
=================================================================================
FILE: src/routes/guards.tsx
=================================================================================
// src/routes/guards.tsx
import { Navigate, useLocation, type Location } from 'react-router-dom';
import { useApp } from '../providers/app-provider-utils';
import type { ReactNode } from 'react';
import { useEffect, useMemo } from 'react';
import { logger } from '../lib/logger';

/** ---------------------------------------------
 * Utilities
 * ----------------------------------------------*/

/** Build a stable "returnTo" URL (pathname + search + hash). */
function buildReturnTo(loc: Location): string {
  const search = loc.search ?? '';
  const hash = loc.hash ?? '';
  return `${loc.pathname}${search}${hash}` || '/';
}

/**
 * Loop detection persisted in sessionStorage so it survives route unmounts.
 * We treat > MAX_REDIRECTS within WINDOW_MS between the same two routes
 * as a loop and stop redirecting.
 */
function useRedirectLoopDetection(guardName: string) {
  const location = useLocation();
  const STORAGE_KEY = `nf:redir:${guardName}`;

  const checkRedirect = (targetPath: string): boolean => {
    const now = Date.now();
    const WINDOW_MS = 3000;
    const MAX_REDIRECTS = 6;

    type Rec = {
      count: number;
      ts: number;
      from: string;
      to: string;
    };

    let rec: Rec;
    try {
      rec = JSON.parse(sessionStorage.getItem(STORAGE_KEY) || 'null') as Rec | null || {
        count: 0,
        ts: now,
        from: location.pathname,
        to: targetPath,
      };
    } catch {
      rec = { count: 0, ts: now, from: location.pathname, to: targetPath };
    }

    const samePair = rec.from === location.pathname && rec.to === targetPath;
    const withinWindow = now - rec.ts <= WINDOW_MS;

    if (samePair && withinWindow) {
      rec.count += 1;
    } else {
      rec = { count: 1, ts: now, from: location.pathname, to: targetPath };
    }

    sessionStorage.setItem(STORAGE_KEY, JSON.stringify(rec));

    if (rec.count > MAX_REDIRECTS) {
      logger.error('Redirect loop detected', {
        guard: guardName,
        currentPath: location.pathname,
        targetPath,
        count: rec.count,
      });
      sessionStorage.removeItem(STORAGE_KEY);
      return false;
    }

    return true;
  };

  // Clean up storage when leaving this guard's context
  useEffect(() => {
    return () => {
      try {
        sessionStorage.removeItem(STORAGE_KEY);
      } catch {
        /* ignore */
      }
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return { checkRedirect };
}

/** Accessible full-screen loader (dark-mode aware, test-friendly). */
function ScreenLoader({ label = 'Loading…' }: { label?: string }) {
  return (
    <div
      className="min-h-screen grid place-items-center bg-white dark:bg-slate-900"
      role="status"
      aria-busy="true"
      aria-live="polite"
      data-testid="screen-loader"
    >
      <div
        className="h-6 w-6 animate-spin rounded-full border-2 border-slate-300 dark:border-slate-600 border-t-slate-900 dark:border-t-white border-r-slate-900 dark:border-r-white"
        aria-hidden="true"
      />
      <span className="sr-only">{label}</span>
    </div>
  );
}

/** ---------------------------------------------
 * HomeGate at "/"
 * ----------------------------------------------*/

export function HomeGate({ authPage }: { authPage: ReactNode }) {
  const { authStatus, user, isGuest } = useApp();
  const location = useLocation();
  const { checkRedirect } = useRedirectLoopDetection('HomeGate');

  // Accept `from` when user was bounced here by a guard.
  const from = useMemo(() => {
    const s = location.state as { from?: string } | null;
    return s?.from;
  }, [location.state]);

  logger.debug('HomeGate check', {
    authStatus,
    userEmail: user?.email || 'no user',
    isGuest,
    from: from || 'none',
  });

  if (authStatus === 'loading') return <ScreenLoader />;

  // Not signed in: show the provided auth page (no redirect).
  if (authStatus === 'signedOut') return <>{authPage}</>;

  // Guest users → Generate
  if (authStatus === 'guest' && isGuest) {
    const dest = '/generate';
    if (dest !== location.pathname && checkRedirect(dest)) {
      return <Navigate to={dest} replace />;
    }
    return <ScreenLoader label="Preparing guest session…" />;
  }

  // Needs onboarding → Onboarding (preserve intended destination)
  if (authStatus === 'needsOnboarding') {
    const dest = '/onboarding';
    if (dest !== location.pathname && checkRedirect(dest)) {
      return <Navigate to={dest} state={{ from }} replace />;
    }
    return <ScreenLoader label="Redirecting to onboarding…" />;
  }

  // Ready → go to saved `from` (if present and not "/"), else dashboard
  if (authStatus === 'ready') {
    const preferred = from && from !== '/' ? from : '/dashboard';
    if (preferred !== location.pathname && checkRedirect(preferred)) {
      return <Navigate to={preferred} replace />;
    }
    // Already on destination (or loop guard tripped) — render nothing.
    return null;
  }

  // Fallback: render auth page if state is unknown
  return <>{authPage}</>;
}

/** ---------------------------------------------
 * RequireAuth — any signed-in user
 * ----------------------------------------------*/

export function RequireAuth({ children }: { children: ReactNode }) {
  const { authStatus } = useApp();
  const location = useLocation();
  const { checkRedirect } = useRedirectLoopDetection('RequireAuth');

  // Wait for auth readiness
  if (authStatus === 'loading') return <ScreenLoader />;

  // Bounce unauthenticated users to Home and remember the full return URL
  if (authStatus === 'signedOut') {
    const returnTo = buildReturnTo(location);
    const dest = '/';
    if (dest !== location.pathname && checkRedirect(dest)) {
      return <Navigate to={dest} state={{ from: returnTo }} replace />;
    }
    return <ScreenLoader label="Redirecting to sign in…" />;
  }

  return <>{children}</>;
}

/** ---------------------------------------------
 * RequireProfile — completed profile OR guest session
 * ----------------------------------------------*/

export function RequireProfile({ children }: { children: ReactNode }) {
  const { authStatus, isGuest } = useApp();
  const location = useLocation();
  const { checkRedirect } = useRedirectLoopDetection('RequireProfile');

  if (authStatus === 'loading') return <ScreenLoader />;

  // Not signed in → go Home (preserve returnTo)
  if (authStatus === 'signedOut') {
    const returnTo = buildReturnTo(location);
    const dest = '/';
    if (dest !== location.pathname && checkRedirect(dest)) {
      return <Navigate to={dest} state={{ from: returnTo }} replace />;
    }
    return <ScreenLoader label="Redirecting to sign in…" />;
  }

  // Profile incomplete → Onboarding (preserve returnTo)
  if (authStatus === 'needsOnboarding') {
    const returnTo = buildReturnTo(location);
    const dest = '/onboarding';
    if (dest !== location.pathname && checkRedirect(dest)) {
      return <Navigate to={dest} state={{ from: returnTo }} replace />;
    }
    return <ScreenLoader label="Redirecting to onboarding…" />;
  }

  // Allow when ready OR in guest mode
  if (authStatus === 'ready' || (authStatus === 'guest' && isGuest)) {
    return <>{children}</>;
  }

  // Unknown state — remain safe
  return <ScreenLoader />;
}
=================================================================================
FILE: src/schemas/index.ts
=================================================================================
/**
 * Zod Schemas for Runtime Validation
 * 
 * Provides runtime validation for data fetched from Firestore and external sources.
 * Ensures type safety and data integrity throughout the application.
 */

import { z } from 'zod'

// ============================================================================
// User Profile Schemas
// ============================================================================

export const PersonalInfoSchema = z.object({
  sex: z.string().min(1),
  height: z.string().min(1),
  weight: z.string().min(1),
  age: z.string().optional(),
})

export const InjuryInfoSchema = z.object({
  list: z.array(z.string()),
  notes: z.string().optional(),
})

export const UserProfileSchema = z.object({
  experience: z.enum(['Beginner', 'Intermediate', 'Advanced', 'Expert']),
  goals: z.array(z.string()).min(1),
  equipment: z.array(z.string()).min(1),
  personal: PersonalInfoSchema,
  injuries: InjuryInfoSchema.optional(),
  createdAt: z.number().optional(),
  updatedAt: z.number().optional(),
})

export type UserProfile = z.infer<typeof UserProfileSchema>

// ============================================================================
// Workout Schemas
// ============================================================================

export const ExerciseSchema = z.object({
  name: z.string().min(1),
  description: z.string().optional(),
  sets: z.number().int().positive().max(10),
  reps: z.union([z.number().int().positive(), z.string()]),
  formTips: z.array(z.string()).optional(),
  safetyTips: z.array(z.string()).optional(),
  restSeconds: z.number().int().nonnegative().max(600),
  usesWeight: z.boolean().optional(),
  muscleGroups: z.array(z.string()).optional(),
  difficulty: z.string().optional(),
  weights: z.record(z.number(), z.number().nullable()).optional(),
})

export const WorkoutSummarySchema = z.object({
  totalVolume: z.string().optional(),
  primaryFocus: z.string().optional(),
  expectedRPE: z.string().optional(),
})

export const WorkoutPlanSchema = z.object({
  exercises: z.array(ExerciseSchema).min(1).max(50),
  workoutSummary: WorkoutSummarySchema.optional(),
})

export const WorkoutItemSchema = z.object({
  id: z.string(),
  workoutType: z.string(),
  duration: z.number().int().positive().max(7200),
  timestamp: z.union([
    z.date(),
    z.object({ toDate: z.function().returns(z.date()) }),
    z.string(),
  ]),
  exercises: z.array(ExerciseSchema).optional(),
  completionRate: z.number().min(0).max(100).optional(),
  completed: z.boolean().optional(),
  completedAt: z.number().optional(),
  feedback: z.string().optional(),
  rpe: z.number().int().min(1).max(10).optional(),
})

export type Exercise = z.infer<typeof ExerciseSchema>
export type WorkoutPlan = z.infer<typeof WorkoutPlanSchema>
export type WorkoutItem = z.infer<typeof WorkoutItemSchema>

// ============================================================================
// Validation Helpers
// ============================================================================

/**
 * Safely parse and validate data with Zod schema
 * Returns validated data or null if validation fails
 */
export function safeValidate<T>(
  schema: z.ZodSchema<T>,
  data: unknown,
  context?: string
): T | null {
  try {
    return schema.parse(data)
  } catch (error) {
    if (error instanceof z.ZodError && import.meta.env.MODE === 'development') {
      console.error(`Validation error${context ? ` in ${context}` : ''}:`, {
        errors: error.errors,
        data,
      })
    }
    return null
  }
}

/**
 * Validate data and throw error if invalid
 * Use this when validation failure should stop execution
 */
export function strictValidate<T>(
  schema: z.ZodSchema<T>,
  data: unknown,
  context?: string
): T {
  try {
    return schema.parse(data)
  } catch (error) {
    if (error instanceof z.ZodError) {
      const errorMessage = `Validation failed${context ? ` in ${context}` : ''}: ${error.errors
        .map((e) => `${e.path.join('.')}: ${e.message}`)
        .join(', ')}`
      throw new Error(errorMessage)
    }
    throw error
  }
}

/**
 * Validate partial data (useful for updates)
 */
export function validatePartial<T extends z.ZodRawShape>(
  schema: z.ZodObject<T>,
  data: unknown,
  context?: string
): Partial<z.infer<z.ZodObject<T>>> | null {
  const partialSchema = schema.partial()
  return safeValidate(partialSchema, data, context) as Partial<z.infer<z.ZodObject<T>>> | null
}

/**
 * Check if data matches schema without throwing
 */
export function isValid<T>(schema: z.ZodSchema<T>, data: unknown): data is T {
  return schema.safeParse(data).success
}

/**
 * Get validation errors as user-friendly messages
 */
export function getValidationErrors(error: z.ZodError): string[] {
  return error.errors.map((e) => {
    const path = e.path.join('.')
    return path ? `${path}: ${e.message}` : e.message
  })
}

// ============================================================================
// Firestore Data Transformers
// ============================================================================

/**
 * Transform Firestore timestamp to Date
 */
export function transformFirestoreTimestamp(
  value: unknown
): Date | string | null {
  if (!value) return null
  
  // Firestore Timestamp with toDate method
  if (typeof value === 'object' && value !== null && 'toDate' in value) {
    const toDate = (value as { toDate: () => Date }).toDate
    if (typeof toDate === 'function') {
      return toDate()
    }
  }
  
  // Already a Date
  if (value instanceof Date) {
    return value
  }
  
  // ISO string
  if (typeof value === 'string') {
    return value
  }
  
  // Unix timestamp (number)
  if (typeof value === 'number') {
    return new Date(value)
  }
  
  return null
}

/**
 * Validate and transform Firestore document data
 */
export function validateFirestoreDoc<T>(
  schema: z.ZodSchema<T>,
  docData: unknown,
  docId: string,
  context?: string
): T | null {
  if (!docData || typeof docData !== 'object') {
    if (import.meta.env.MODE === 'development') {
      console.error(`Invalid document data for ${docId}`)
    }
    return null
  }

  // Add document ID to data
  const dataWithId = { ...docData, id: docId }

  return safeValidate(schema, dataWithId, context || `Firestore doc ${docId}`)
}


=================================================================================
FILE: src/session/types.ts
=================================================================================
export type UserProfile = {
  experience?: string
  goals?: string[]
  equipment?: string[]
  personal?: { sex?: string; height?: string; weight?: string }
  injuries?: { list?: string[]; notes?: string }
  isGuest?: boolean // Flag to indicate guest profile
}

/**
 * Adjust this rule to your business criteria.
 * Minimal, stable rule: experience + at least one goal + height + weight.
 */
export function isProfileComplete(p?: UserProfile | null): boolean {
  if (!p) return false
  if (!p.experience) return false
  if (!p.goals || p.goals.length === 0) return false
  if (!p.personal?.height || !p.personal?.weight) return false
  return true
}

/**
 * Check if a profile is a guest profile
 */
export function isGuestProfile(p?: UserProfile | null): boolean {
  return p?.isGuest === true
}
=================================================================================
FILE: src/store/index.ts
=================================================================================
// Unified state management using Zustand
// Replaces multiple context providers for better performance and simpler state management

import { create } from 'zustand'
import { subscribeWithSelector } from 'zustand/middleware'
import { immer } from 'zustand/middleware/immer'
import { persist, createJSONStorage } from 'zustand/middleware'
import { useShallow } from 'zustand/react/shallow'
import type { User } from 'firebase/auth'
import type { UserProfile } from '../session/types'
import { logger } from '../lib/logger'
import { createGuestProfile } from '../lib/guest-session'

// Debounced localStorage writer to reduce write frequency
let persistTimer: NodeJS.Timeout | null = null
const PERSIST_DEBOUNCE_MS = 1000 // Persist max once per second

function debouncedSetItem(key: string, value: string) {
  if (persistTimer) {
    clearTimeout(persistTimer)
  }

  persistTimer = setTimeout(() => {
    try {
      localStorage.setItem(key, value)
    } catch (error) {
      logger.warn('Failed to persist state to localStorage', { error })
    }
  }, PERSIST_DEBOUNCE_MS)
}

// Exercise and workout types
export interface Exercise {
  name: string
  description?: string
  sets: number
  reps: number | string
  formTips?: string[]
  safetyTips?: string[]
  restSeconds?: number
  usesWeight?: boolean
  muscleGroups?: string[]
  difficulty?: string
  weights?: Record<number, number | null>
}

export interface WorkoutPlan {
  exercises: Exercise[]
  workoutSummary?: {
    totalVolume: string
    primaryFocus: string
    expectedRPE: string
  }
}

// Types for the unified store
export interface AppState {
  // Authentication state
  user: User | null
  profile: UserProfile | null
  authStatus: 'loading' | 'signedOut' | 'needsOnboarding' | 'ready' | 'guest'
  isGuest: boolean // Flag to indicate guest session

  // Workout state
  currentWorkout: WorkoutState | null
  workoutWeights: Record<number, Record<number, number | null>>
  workoutHistory: WorkoutHistoryItem[]

  // UI state
  isOnline: boolean
  lastSyncTime: number | null
  pendingOperations: PendingOperation[]

  // Error state
  errors: AppError[]
}

export interface WorkoutState {
  plan: WorkoutPlan
  type: string
  duration: number
  startTime: number
  currentExerciseIndex: number
  currentSetIndex: number
  isActive: boolean
}

export interface WorkoutHistoryItem {
  id: string
  timestamp: number
  workoutType: string
  duration: number
  exercises: Exercise[]
  completionRate: number
}

export interface PendingOperation {
  id: string
  type: 'weight_update' | 'workout_save' | 'profile_update'
  data: Record<string, unknown>
  timestamp: number
  retryCount: number
}

export interface AppError {
  id: string
  type: 'auth' | 'network' | 'validation' | 'unknown'
  message: string
  details?: Record<string, unknown>
  timestamp: number
  resolved: boolean
}



// Actions interface
export interface AppActions {
  // Auth actions
  setUser: (_user: User | null) => void
  setProfile: (_profile: UserProfile | null) => void
  setAuthStatus: (_status: AppState['authStatus']) => void
  setIsGuest: (_isGuest: boolean) => void
  initializeGuestSession: () => void

  // Workout actions
  startWorkout: (_plan: WorkoutPlan, _type: string, _duration: number) => void
  updateWorkoutProgress: (_exerciseIndex: number, _setIndex: number) => void
  updateWeight: (_exerciseIndex: number, _setIndex: number, _weight: number | null) => void
  completeWorkout: () => void
  clearWorkout: () => void

  // Data persistence actions
  addToHistory: (_workout: WorkoutHistoryItem) => void
  syncPendingOperations: () => Promise<void>
  addPendingOperation: (_operation: Omit<PendingOperation, 'id' | 'timestamp' | 'retryCount'>) => void

  // Error handling actions
  addError: (_error: Omit<AppError, 'id' | 'timestamp' | 'resolved'>) => void
  resolveError: (_errorId: string) => void
  clearErrors: () => void



  // Utility actions
  setOnlineStatus: (_isOnline: boolean) => void
  updateLastSyncTime: () => void
  reset: () => void
}

// Initial state
const initialState: AppState = {
  user: null,
  profile: null,
  authStatus: 'loading',
  isGuest: false,
  currentWorkout: null,
  workoutWeights: {},
  workoutHistory: [],
  isOnline: navigator.onLine,
  lastSyncTime: null,
  pendingOperations: [],
  errors: []
}

// Create the store with middleware
export const useAppStore = create<AppState & AppActions>()(
  subscribeWithSelector(
    immer(
      persist(
        (set, get) => ({
          ...initialState,
          
          // Auth actions
          setUser: (user) => set((state) => {
            state.user = user
          }),
          
          setProfile: (profile) => set((state) => {
            state.profile = profile
          }),
          
          setAuthStatus: (status) => set((state) => {
            state.authStatus = status
          }),

          setIsGuest: (isGuest) => set((state) => {
            state.isGuest = isGuest
          }),

          initializeGuestSession: () => set((state) => {
            state.isGuest = true
            state.authStatus = 'guest'
            state.profile = createGuestProfile()
            state.user = null
          }),

          // Workout actions
          startWorkout: (plan, type, duration) => set((state) => {
            state.currentWorkout = {
              plan,
              type,
              duration,
              startTime: Date.now(),
              currentExerciseIndex: 0,
              currentSetIndex: 1,
              isActive: true
            }
            state.workoutWeights = {}
          }),
          
          updateWorkoutProgress: (exerciseIndex, setIndex) => set((state) => {
            if (state.currentWorkout) {
              state.currentWorkout.currentExerciseIndex = exerciseIndex
              state.currentWorkout.currentSetIndex = setIndex
            }
          }),
          
          updateWeight: (exerciseIndex, setIndex, weight) => set((state) => {
            if (!state.workoutWeights[exerciseIndex]) {
              state.workoutWeights[exerciseIndex] = {}
            }
            state.workoutWeights[exerciseIndex][setIndex] = weight
          }),
          
          completeWorkout: () => set((state) => {
            if (state.currentWorkout) {
              const workout: WorkoutHistoryItem = {
                id: `workout_${Date.now()}`,
                timestamp: Date.now(),
                workoutType: state.currentWorkout.type,
                duration: Math.round((Date.now() - state.currentWorkout.startTime) / 1000 / 60),
                exercises: state.currentWorkout.plan.exercises.map((ex: Exercise, i: number) => ({
                  ...ex,
                  weights: state.workoutWeights[i] || undefined
                })),
                completionRate: calculateCompletionRate(state.workoutWeights, state.currentWorkout.plan.exercises)
              }
              
              state.workoutHistory.unshift(workout)
              state.currentWorkout = null
              state.workoutWeights = {}
            }
          }),
          
          clearWorkout: () => set((state) => {
            state.currentWorkout = null
            state.workoutWeights = {}
          }),
          
          // Data persistence actions
          addToHistory: (workout) => set((state) => {
            state.workoutHistory.unshift(workout)
            // Keep only last 50 workouts in memory
            if (state.workoutHistory.length > 50) {
              state.workoutHistory = state.workoutHistory.slice(0, 50)
            }
          }),
          
          addPendingOperation: (operation) => set((state) => {
            const newOperation: PendingOperation = {
              ...operation,
              id: `op_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
              timestamp: Date.now(),
              retryCount: 0
            }
            state.pendingOperations.push(newOperation)
          }),
          
          syncPendingOperations: async () => {
            const { pendingOperations } = get()

            // Sync pending operations when back online
            // This is a placeholder for future offline sync functionality
            // Currently, operations are executed immediately when online
            logger.debug(`Syncing ${pendingOperations.length} pending operations`)

            // In a full implementation, this would:
            // 1. Iterate through pendingOperations
            // 2. Retry failed operations
            // 3. Remove successful operations from the queue
            // 4. Handle conflicts and merge strategies
          },
          
          // Error handling actions
          addError: (error) => set((state) => {
            const newError: AppError = {
              ...error,
              id: `err_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
              timestamp: Date.now(),
              resolved: false
            }
            state.errors.push(newError)
            // Keep only last 20 errors
            if (state.errors.length > 20) {
              state.errors = state.errors.slice(-20)
            }
          }),
          
          resolveError: (errorId) => set((state) => {
            const error = state.errors.find(e => e.id === errorId)
            if (error) {
              error.resolved = true
            }
          }),
          
          clearErrors: () => set((state) => {
            state.errors = []
          }),
          

          // Utility actions
          setOnlineStatus: (isOnline) => set((state) => {
            state.isOnline = isOnline
          }),
          
          updateLastSyncTime: () => set((state) => {
            state.lastSyncTime = Date.now()
          }),
          
          reset: () => set(() => ({ ...initialState }))
        }),
        {
          name: 'neurafit-app-store',
          storage: createJSONStorage(() => ({
            getItem: (name: string) => {
              const str = localStorage.getItem(name)
              return str ? JSON.parse(str) : null
            },
            setItem: (name: string, value: unknown) => {
              // Use debounced writer to reduce localStorage writes
              debouncedSetItem(name, JSON.stringify(value))
            },
            removeItem: (name: string) => {
              localStorage.removeItem(name)
            }
          })),
          partialize: (state) => ({
            // Persist essential data and active workout state
            workoutHistory: state.workoutHistory,
            lastSyncTime: state.lastSyncTime,
            currentWorkout: state.currentWorkout, // Persist active workout
            workoutWeights: state.workoutWeights, // Persist workout weights
            // Don't persist sensitive or temporary data
            user: null,
            profile: null,
            errors: [],
            pendingOperations: []
          }),
          version: 1,
          migrate: (persistedState: unknown, _version: number) => {
            // Handle state migrations for future versions
            // Validate persisted state structure
            if (persistedState && typeof persistedState === 'object') {
              return persistedState
            }
            logger.warn('Invalid persisted state, resetting to initial state')
            return initialState
          }
        }
      )
    )
  )
)

// Helper function to calculate completion rate
// Completed sets are marked with a number (including 0 for bodyweight exercises)
// Skipped sets are marked as null
// Sets not attempted are undefined
function calculateCompletionRate(weights: Record<number, Record<number, number | null>>, exercises: Exercise[]): number {
  let totalSets = 0
  let completedSets = 0

  exercises.forEach((exercise, exerciseIndex) => {
    const exerciseWeights = weights[exerciseIndex] || {}
    const sets = exercise.sets || 0
    totalSets += sets

    for (let setIndex = 1; setIndex <= sets; setIndex++) {
      // A set is complete if it has a number value (including 0)
      // null = skipped (incomplete), undefined = not attempted (incomplete)
      const setWeight = exerciseWeights[setIndex]
      if (setWeight !== null && setWeight !== undefined) {
        completedSets++
      }
    }
  })
  
  return totalSets > 0 ? completedSets / totalSets : 0
}

// Optimized atomic selectors to prevent unnecessary re-renders
// Auth selectors
export const useUser = () => useAppStore((state) => state.user)
export const useProfile = () => useAppStore((state) => state.profile)
export const useAuthStatus = () => useAppStore((state) => state.authStatus)
export const useSetUser = () => useAppStore((state) => state.setUser)
export const useSetProfile = () => useAppStore((state) => state.setProfile)
export const useSetAuthStatus = () => useAppStore((state) => state.setAuthStatus)

// Stable selector reference for composite auth selector
const authSelector = (state: AppState & AppActions) => ({
  user: state.user,
  profile: state.profile,
  status: state.authStatus,
  setUser: state.setUser,
  setProfile: state.setProfile,
  setAuthStatus: state.setAuthStatus
})

// Composite auth selector with shallow comparison to prevent unnecessary re-renders
// Uses stable selector reference to prevent creating new objects on every call
export const useAuth = () => {
  return useAppStore(useShallow(authSelector))
}

// Workout selectors
export const useCurrentWorkout = () => useAppStore((state) => state.currentWorkout)
export const useWorkoutWeights = () => useAppStore((state) => state.workoutWeights)
export const useWorkoutHistory = () => useAppStore((state) => state.workoutHistory)
export const useStartWorkout = () => useAppStore((state) => state.startWorkout)
export const useUpdateWorkoutProgress = () => useAppStore((state) => state.updateWorkoutProgress)
export const useUpdateWeight = () => useAppStore((state) => state.updateWeight)
export const useCompleteWorkout = () => useAppStore((state) => state.completeWorkout)
export const useClearWorkout = () => useAppStore((state) => state.clearWorkout)
export const useAddToHistory = () => useAppStore((state) => state.addToHistory)

// Stable selector reference for composite workout selector
const workoutSelector = (state: AppState & AppActions) => ({
  currentWorkout: state.currentWorkout,
  workoutWeights: state.workoutWeights,
  workoutHistory: state.workoutHistory,
  startWorkout: state.startWorkout,
  updateWorkoutProgress: state.updateWorkoutProgress,
  updateWeight: state.updateWeight,
  completeWorkout: state.completeWorkout,
  clearWorkout: state.clearWorkout,
  addToHistory: state.addToHistory
})

// Composite workout selector with shallow comparison
export const useWorkout = () => {
  return useAppStore(useShallow(workoutSelector))
}

// Error selectors
export const useErrorsState = () => useAppStore((state) => state.errors)
export const useAddError = () => useAppStore((state) => state.addError)
export const useResolveError = () => useAppStore((state) => state.resolveError)
export const useClearErrors = () => useAppStore((state) => state.clearErrors)

// Stable selector reference for composite error selector
const errorsSelector = (state: AppState & AppActions) => ({
  errors: state.errors,
  addError: state.addError,
  resolveError: state.resolveError,
  clearErrors: state.clearErrors
})

// Guest session selectors
export const useIsGuest = () => useAppStore((state) => state.isGuest)
export const useInitializeGuestSession = () => useAppStore((state) => state.initializeGuestSession)
export const useSetIsGuest = () => useAppStore((state) => state.setIsGuest)

// Composite error selector with shallow comparison
export const useErrors = () => {
  return useAppStore(useShallow(errorsSelector))
}



// Expose store globally for performance monitoring and debugging (development only)
if (typeof window !== 'undefined' && import.meta.env.MODE === 'development') {
  (window as Window & { __NEURAFIT_STORE__?: typeof useAppStore }).__NEURAFIT_STORE__ = useAppStore
}
=================================================================================
FILE: src/test/example.test.tsx
=================================================================================
/**
 * Example Test Suite
 * Demonstrates testing setup and best practices
 */

import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import { BrowserRouter } from 'react-router-dom'

// Example component test
describe('Example Test Suite', () => {
  it('should pass basic assertion', () => {
    expect(true).toBe(true)
  })

  it('should perform math correctly', () => {
    expect(2 + 2).toBe(4)
  })

  // Example of testing a simple component
  it('should render a basic component', () => {
    const TestComponent = () => <div>Hello, NeuraFit!</div>
    
    render(
      <BrowserRouter>
        <TestComponent />
      </BrowserRouter>
    )
    
    expect(screen.getByText('Hello, NeuraFit!')).toBeInTheDocument()
  })
})

// Example utility function tests
describe('Utility Functions', () => {
  it('should format dates correctly', () => {
    const date = new Date('2025-01-01T00:00:00Z')
    const formatted = date.toISOString().split('T')[0]
    expect(formatted).toBe('2025-01-01')
  })

  it('should handle arrays', () => {
    const arr = [1, 2, 3, 4, 5]
    expect(arr).toHaveLength(5)
    expect(arr[0]).toBe(1)
    expect(arr).toContain(3)
  })
})


=================================================================================
FILE: src/test/setup.ts
=================================================================================
/**
 * Vitest Test Setup
 * Global test configuration and utilities
 */

import { afterEach, beforeAll, afterAll, vi } from 'vitest'
import { cleanup } from '@testing-library/react'
import '@testing-library/jest-dom'

// Cleanup after each test
afterEach(() => {
  cleanup()
})

// Mock window.matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: vi.fn().mockImplementation((query) => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: vi.fn(),
    removeListener: vi.fn(),
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn(),
  })),
})

// Mock IntersectionObserver
// eslint-disable-next-line @typescript-eslint/no-explicit-any
;(globalThis as any).IntersectionObserver = class IntersectionObserver {
  constructor() {}
  disconnect() {}
  observe() {}
  takeRecords() {
    return []
  }
  unobserve() {}
}

// Mock ResizeObserver
// eslint-disable-next-line @typescript-eslint/no-explicit-any
;(globalThis as any).ResizeObserver = class ResizeObserver {
  constructor() {}
  disconnect() {}
  observe() {}
  unobserve() {}
}

// Mock scrollTo
window.scrollTo = vi.fn()

// Suppress console errors in tests (optional)
const originalError = console.error
beforeAll(() => {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  console.error = (...args: any[]) => {
    if (
      typeof args[0] === 'string' &&
      (args[0].includes('Warning: ReactDOM.render') ||
        args[0].includes('Not implemented: HTMLFormElement.prototype.submit'))
    ) {
      return
    }
    originalError.call(console, ...args)
  }
})

afterAll(() => {
  console.error = originalError
})


=================================================================================
FILE: src/types/global.d.ts
=================================================================================
// Global type declarations for build-time constants and functions

declare global {
  // Build-time constants injected by Vite
  const __APP_VERSION__: string
  const __BUILD_TIME__: string
  
  // Global functions for update management
  interface Window {
    applyUpdate?: () => void
  }
}

export {}

=================================================================================
FILE: src/types/profile.ts
=================================================================================
/**
 * User Profile Types
 * Strongly typed interfaces for user profile data
 */

export interface PersonalInfo {
  sex: string
  height: string
  weight: string
  age?: string
}

export interface InjuryInfo {
  list: string[]
  notes?: string
}

export interface UserProfile {
  experience: string
  goals: string[]
  equipment: string[]
  personal: PersonalInfo
  injuries?: InjuryInfo
  createdAt?: number
  updatedAt?: number
}

export interface WorkoutPreferences {
  preferredDuration: number
  preferredTypes: string[]
  restTime: number
}

/**
 * Type guard to check if profile is complete
 */
export function isCompleteProfile(profile: Partial<UserProfile>): profile is UserProfile {
  return !!(
    profile.experience &&
    profile.goals?.length &&
    profile.equipment?.length &&
    profile.personal?.height &&
    profile.personal?.weight &&
    profile.personal?.sex
  )
}


=================================================================================
FILE: src/ui/Button.tsx
=================================================================================
import React, { forwardRef, memo, type ButtonHTMLAttributes } from 'react'
import { type VariantProps } from 'class-variance-authority'
import { cn } from '../lib/utils'
import { buttonVariants, iconButtonVariants } from './buttonVariants'

/** ——— Button ——— */

export interface ButtonProps
  extends ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  loading?: boolean
  /** Screen-reader text announced while loading (also used as aria-label for the spinner). */
  loadingText?: string
  leftIcon?: React.ReactNode
  rightIcon?: React.ReactNode
  fullWidth?: boolean
}

const ButtonBase = forwardRef<HTMLButtonElement, ButtonProps>(
  (
    {
      className,
      variant,
      size,
      fullWidth,
      loading = false,
      loadingText = 'Loading',
      leftIcon,
      rightIcon,
      children,
      disabled,
      type,
      ...props
    },
    ref
  ) => {
    const isDisabled = disabled || loading

    return (
      <button
        ref={ref}
        type={type ?? 'button'}
        className={cn(
          buttonVariants({ variant, size, fullWidth, loading }),
          className
        )}
        disabled={isDisabled}
        // Only render ARIA attribute when true to avoid noisy attributes
        aria-disabled={isDisabled || undefined}
        aria-busy={loading || undefined}
        data-loading={loading ? '' : undefined}
        data-disabled={isDisabled ? '' : undefined}
        {...props}
      >
        {/* Inline grid keeps spacing consistent with/without spinner */}
        <span className="inline-grid auto-cols-max grid-flow-col items-center gap-2">
          {loading && (
            <>
              <span
                className="animate-spin rounded-full h-4 w-4 border-2 border-current border-t-transparent"
                role="status"
                aria-live="polite"
                aria-label={loadingText}
                aria-hidden={false}
              />
              {/* Hidden text ensures SRs have a reliable announcement string */}
              <span className="sr-only">{loadingText}</span>
            </>
          )}

          {/* Icons are hidden while loading to reduce motion and noise */}
          {!loading && leftIcon && <span aria-hidden="true">{leftIcon}</span>}

          {/* Keep label present in both states to avoid layout shift */}
          <span>{children}</span>

          {!loading && rightIcon && <span aria-hidden="true">{rightIcon}</span>}
        </span>
      </button>
    )
  }
)
ButtonBase.displayName = 'Button'
export const Button = memo(ButtonBase)

/** ——— IconButton ——— */

export interface IconButtonProps
  extends Omit<ButtonHTMLAttributes<HTMLButtonElement>, 'children'>,
    VariantProps<typeof iconButtonVariants> {
  icon: React.ReactNode
  /** Required for non-textual controls */
  'aria-label': string
  /** Prevent accidental children usage at the type level */
  children?: never
}

const IconButtonBase = forwardRef<HTMLButtonElement, IconButtonProps>(
  ({ icon, variant, size, className, type, ...props }, ref) => {
    return (
      <button
        ref={ref}
        type={type ?? 'button'}
        className={cn(iconButtonVariants({ variant, size }), className)}
        {...props}
      >
        {icon}
      </button>
    )
  }
)
IconButtonBase.displayName = 'IconButton'
export const IconButton = memo(IconButtonBase)

/** ——— ButtonGroup ——— */

export interface ButtonGroupProps {
  children: React.ReactNode
  className?: string
  orientation?: 'horizontal' | 'vertical'
  /** Provide a label for SR users when the group adds meaning (e.g., “Editor actions”). */
  'aria-label'?: string
  'aria-labelledby'?: string
}

export function ButtonGroup({
  children,
  className,
  orientation = 'horizontal',
  ...a11y
}: ButtonGroupProps) {
  return (
    <div
      role="group"
      {...a11y}
      className={cn(
        'inline-flex',
        orientation === 'horizontal' ? 'flex-row gap-2' : 'flex-col gap-2',
        className
      )}
    >
      {children}
    </div>
  )
}
=================================================================================
FILE: src/ui/buttonVariants.ts
=================================================================================
/**
 * Button Variants - Shared CVA configurations
 * Extracted to separate file to fix Fast Refresh warnings
 */

import { cva } from 'class-variance-authority'

// Button variants with comprehensive styling options
export const buttonVariants = cva(
  'inline-flex items-center justify-center gap-2 font-semibold rounded-xl transition-all duration-300 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 disabled:cursor-not-allowed',
  {
    variants: {
      variant: {
        primary: 'bg-gradient-to-r from-blue-600 to-indigo-600 text-white shadow-lg hover:shadow-xl hover:scale-105 active:scale-95 focus-visible:ring-blue-500',
        secondary: 'bg-white text-gray-900 border border-gray-300 shadow-md hover:shadow-lg hover:bg-gray-50 active:scale-95 focus-visible:ring-gray-500',
        success: 'bg-gradient-to-r from-green-600 to-emerald-600 text-white shadow-lg hover:shadow-xl hover:scale-105 active:scale-95 focus-visible:ring-green-500',
        danger: 'bg-gradient-to-r from-red-600 to-rose-600 text-white shadow-lg hover:shadow-xl hover:scale-105 active:scale-95 focus-visible:ring-red-500',
        warning: 'bg-gradient-to-r from-amber-600 to-orange-600 text-white shadow-lg hover:shadow-xl hover:scale-105 active:scale-95 focus-visible:ring-amber-500',
        ghost: 'bg-transparent text-gray-700 hover:bg-gray-100 active:bg-gray-200 focus-visible:ring-gray-500',
        outline: 'bg-transparent border-2 border-blue-600 text-blue-600 hover:bg-blue-50 active:bg-blue-100 focus-visible:ring-blue-500',
      },
      size: {
        sm: 'px-3 py-2 text-sm min-h-[36px]',
        md: 'px-4 py-3 text-base min-h-[44px]',
        lg: 'px-6 py-4 text-lg min-h-[52px]',
        xl: 'px-8 py-5 text-xl min-h-[60px]',
      },
      fullWidth: {
        true: 'w-full',
      },
      loading: {
        true: 'cursor-wait',
      },
    },
    defaultVariants: {
      variant: 'primary',
      size: 'md',
    },
  }
)

// Icon Button variant
export const iconButtonVariants = cva(
  'inline-flex items-center justify-center rounded-xl transition-all duration-300 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed',
  {
    variants: {
      variant: {
        primary: 'bg-blue-600 text-white hover:bg-blue-700 active:scale-95 focus-visible:ring-blue-500',
        secondary: 'bg-gray-200 text-gray-900 hover:bg-gray-300 active:scale-95 focus-visible:ring-gray-500',
        ghost: 'bg-transparent text-gray-700 hover:bg-gray-100 active:bg-gray-200 focus-visible:ring-gray-500',
        danger: 'bg-red-600 text-white hover:bg-red-700 active:scale-95 focus-visible:ring-red-500',
      },
      size: {
        sm: 'w-8 h-8 p-1.5 min-w-[32px] min-h-[32px]',
        md: 'w-10 h-10 p-2 min-w-[40px] min-h-[40px]',
        lg: 'w-12 h-12 p-2.5 min-w-[48px] min-h-[48px]',
        xl: 'w-14 h-14 p-3 min-w-[56px] min-h-[56px]',
      },
    },
    defaultVariants: {
      variant: 'primary',
      size: 'md',
    },
  }
)


=================================================================================
FILE: src/ui/Card.tsx
=================================================================================
/**
 * Card Component - UI Primitive
 *
 * Reusable card component with comprehensive variants and features.
 * Part of the NeuraFit design system.
 *
 * Features:
 * - Multiple variants (default, glass, gradient, elevated, flat, outline)
 * - Flexible sizing and padding
 * - Hover effects (lift, glow, scale)
 * - Interactive mode with keyboard support
 * - Sub-components (Header, Title, Description, Content, Footer)
 * - Memoized for performance
 */

import React, { forwardRef, memo, type HTMLAttributes } from 'react'
import { type VariantProps } from 'class-variance-authority'
import { cn } from '../lib/utils'
import { cardVariants } from './cardVariants'

export interface CardProps
  extends HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof cardVariants> {
  interactive?: boolean
  rounded?: 'sm' | 'md' | 'lg' | '2xl'
}

const CardBase = forwardRef<HTMLDivElement, CardProps>(
  ({
    className,
    variant,
    padding,
    hover,
    interactive,
    rounded,
    children,
    ...props
  }, ref) => {
    return (
      <div
        ref={ref}
        className={cn(
          cardVariants({ variant, padding, hover, interactive }),
          rounded === 'sm' && 'rounded-lg',
          rounded === 'md' && 'rounded-xl',
          rounded === 'lg' && 'rounded-2xl',
          rounded === '2xl' && 'rounded-2xl',
          className
        )}
        role={interactive ? 'button' : undefined}
        tabIndex={interactive ? 0 : undefined}
        {...props}
      >
        {children}
      </div>
    )
  }
)

CardBase.displayName = 'Card'

const Card = memo(CardBase)

// Card sub-components
const CardHeaderBase = forwardRef<HTMLDivElement, HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      className={cn('flex flex-col space-y-1.5 pb-4', className)}
      {...props}
    />
  )
)
CardHeaderBase.displayName = 'CardHeader'
const CardHeader = memo(CardHeaderBase)

const CardTitleBase = forwardRef<HTMLHeadingElement, HTMLAttributes<HTMLHeadingElement> & { level?: 1 | 2 | 3 | 4 | 5 | 6 }>(
  ({ className, level = 3, ...props }, ref) => {
    const Component = level === 1 ? 'h1' : level === 2 ? 'h2' : level === 3 ? 'h3' : level === 4 ? 'h4' : level === 5 ? 'h5' : 'h6'
    return React.createElement(
      Component,
      {
        ref,
        className: cn('text-lg font-semibold leading-none tracking-tight text-gray-900', className),
        ...props
      }
    )
  }
)
CardTitleBase.displayName = 'CardTitle'
const CardTitle = memo(CardTitleBase)

const CardDescriptionBase = forwardRef<HTMLParagraphElement, HTMLAttributes<HTMLParagraphElement>>(
  ({ className, ...props }, ref) => (
    <p
      ref={ref}
      className={cn('text-sm text-gray-600 leading-relaxed', className)}
      {...props}
    />
  )
)
CardDescriptionBase.displayName = 'CardDescription'
const CardDescription = memo(CardDescriptionBase)

const CardContentBase = forwardRef<HTMLDivElement, HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      className={cn('flex-1', className)}
      {...props}
    />
  )
)
CardContentBase.displayName = 'CardContent'
const CardContent = memo(CardContentBase)

const CardFooterBase = forwardRef<HTMLDivElement, HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      className={cn('flex items-center pt-4', className)}
      {...props}
    />
  )
)
CardFooterBase.displayName = 'CardFooter'
const CardFooter = memo(CardFooterBase)



export {
  Card,
  CardHeader,
  CardTitle,
  CardDescription,
  CardContent,
  CardFooter
}

=================================================================================
FILE: src/ui/cardVariants.ts
=================================================================================
/**
 * Card Variants - Shared CVA configurations
 * Extracted to separate file to fix Fast Refresh warnings
 */

import { cva } from 'class-variance-authority'

export const cardVariants = cva(
  'rounded-2xl transition-all duration-300',
  {
    variants: {
      variant: {
        default: 'bg-white shadow-lg border border-white/80',
        glass: 'bg-white/95 backdrop-blur-xl shadow-lg border border-white/80',
        gradient: 'bg-gradient-to-br from-white/95 via-blue-50/30 to-indigo-50/20 backdrop-blur-xl shadow-lg border border-white/80',
        elevated: 'bg-white shadow-xl border border-gray-100',
        flat: 'bg-white border border-gray-200',
        outline: 'bg-transparent border-2 border-gray-300',
      },
      padding: {
        none: 'p-0',
        sm: 'p-3 sm:p-4',
        md: 'p-4 sm:p-5',
        lg: 'p-5 sm:p-6',
        xl: 'p-6 sm:p-8',
      },
      hover: {
        none: '',
        lift: 'hover:shadow-xl hover:-translate-y-1',
        glow: 'hover:shadow-2xl hover:shadow-blue-500/10',
        scale: 'hover:scale-[1.02]',
      },
      interactive: {
        true: 'cursor-pointer active:scale-[0.98]',
        false: '',
      },
    },
    defaultVariants: {
      variant: 'default',
      padding: 'md',
      hover: 'none',
      interactive: false,
    },
  }
)


=================================================================================
FILE: src/ui/index.ts
=================================================================================
/**
 * UI Components - Design System
 * 
 * Centralized exports for all reusable UI primitives.
 * These components form the foundation of the NeuraFit design system.
 * 
 * Usage:
 * ```tsx
 * import { Button, Card } from '@/ui'
 * ```
 */

// Button components
export {
  Button,
  IconButton,
  ButtonGroup,
  type ButtonProps,
  type IconButtonProps,
  type ButtonGroupProps,
} from './Button'

// Button variants (from separate file to fix Fast Refresh)
export { buttonVariants, iconButtonVariants } from './buttonVariants'

// Card components
export {
  Card,
  CardHeader,
  CardTitle,
  CardDescription,
  CardContent,
  CardFooter,
  type CardProps,
} from './Card'

// Card variants (from separate file to fix Fast Refresh)
export { cardVariants } from './cardVariants'


=================================================================================
FILE: src/utils/haptic.ts
=================================================================================
/**
 * Haptic Feedback Utility
 * Provides tactile feedback for mobile interactions
 */

export type HapticType = 'light' | 'medium' | 'heavy' | 'success' | 'warning' | 'error'

const HAPTIC_PATTERNS: Record<HapticType, number | number[]> = {
  light: 10,
  medium: 20,
  heavy: 30,
  success: [10, 50, 10],
  warning: [20, 100, 20],
  error: [30, 100, 30, 100, 30],
}

/**
 * Trigger haptic feedback on supported devices
 */
export function triggerHaptic(type: HapticType = 'light'): void {
  // Check if vibration API is supported
  if (!('vibrate' in navigator)) {
    return
  }

  const pattern = HAPTIC_PATTERNS[type]
  
  try {
    navigator.vibrate(pattern)
  } catch (error) {
    // Silently fail if vibration is not supported or blocked
    console.debug('Haptic feedback not available:', error)
  }
}

/**
 * Check if haptic feedback is supported
 */
export function isHapticSupported(): boolean {
  return 'vibrate' in navigator
}

/**
 * Cancel any ongoing haptic feedback
 */
export function cancelHaptic(): void {
  if ('vibrate' in navigator) {
    navigator.vibrate(0)
  }
}


=================================================================================
FILE: src/utils/orientation.ts
=================================================================================
// Orientation lock utilities for mobile experience
import { logger } from '../lib/logger'

export const lockOrientation = () => {
  // Try to lock to portrait orientation using the Screen Orientation API
  if ('screen' in window && 'orientation' in window.screen) {
    const screenOrientation = window.screen.orientation as { lock?: (_orientation: string) => Promise<void> }

    if ('lock' in screenOrientation && screenOrientation.lock) {
      screenOrientation.lock('portrait').catch((error: { message?: string; name?: string }) => {
        // Only log unexpected errors (not "not supported" errors)
        if (!error.message?.includes('not supported') && error.name !== 'NotSupportedError') {
          logger.debug('Orientation lock failed', { errorName: error.name })
        }
      })
    }
  }
  
  // Fallback: Listen for orientation changes and show warning
  const handleOrientationChange = () => {
    const isLandscape = window.innerWidth > window.innerHeight
    const isMobile = window.innerWidth <= 768
    
    if (isLandscape && isMobile) {
      // Show landscape warning (handled by CSS)
      document.body.classList.add('landscape-warning')
    } else {
      document.body.classList.remove('landscape-warning')
    }
  }
  
  // Listen for orientation changes
  window.addEventListener('orientationchange', handleOrientationChange)
  window.addEventListener('resize', handleOrientationChange)
  
  // Initial check
  handleOrientationChange()
  
  // Return cleanup function
  return () => {
    window.removeEventListener('orientationchange', handleOrientationChange)
    window.removeEventListener('resize', handleOrientationChange)
  }
}

export const unlockOrientation = () => {
  if ('screen' in window && 'orientation' in window.screen) {
    const screenOrientation = window.screen.orientation as unknown as { unlock?: () => Promise<void> }

    if ('unlock' in screenOrientation && screenOrientation.unlock) {
      Promise.resolve(screenOrientation.unlock()).catch((error: { name?: string }) => {
        // Silently handle unlock failures as they're not critical
        if (error.name !== 'NotSupportedError') {
          logger.debug('Orientation unlock failed', { errorName: error.name })
        }
      })
    }
  }
}

// Prevent zoom on double tap (iOS Safari)
export const preventZoom = () => {
  let lastTouchEnd = 0
  
  const preventDoubleTapZoom = (event: TouchEvent) => {
    const now = new Date().getTime()
    if (now - lastTouchEnd <= 300) {
      event.preventDefault()
    }
    lastTouchEnd = now
  }
  
  document.addEventListener('touchend', preventDoubleTapZoom, { passive: false })
  
  return () => {
    document.removeEventListener('touchend', preventDoubleTapZoom)
  }
}

=================================================================================
FILE: src/utils/timestamp.ts
=================================================================================
// Utility functions for handling Firebase timestamps and date conversions

export type TimestampType = string | Date | { toDate(): Date } | undefined

/**
 * Converts various timestamp formats to a Date object
 */
export function convertToDate(timestamp: TimestampType): Date {
  if (!timestamp) {
    return new Date()
  }
  
  if (timestamp instanceof Date) {
    return timestamp
  }
  
  if (typeof timestamp === 'string') {
    return new Date(timestamp)
  }
  
  if (typeof timestamp === 'object' && 'toDate' in timestamp && typeof timestamp.toDate === 'function') {
    return timestamp.toDate()
  }
  
  return new Date()
}

/**
 * Formats a timestamp to a local date string
 */
export function formatTimestamp(timestamp: TimestampType): string {
  return convertToDate(timestamp).toLocaleDateString()
}

/**
 * Formats a timestamp to an ISO string for date inputs
 */
export function formatTimestampISO(timestamp: TimestampType): string {
  return convertToDate(timestamp).toISOString().split('T')[0] || ''
}

/**
 * Checks if a timestamp represents a date within the last N days
 */
export function isWithinDays(timestamp: TimestampType, days: number): boolean {
  const date = convertToDate(timestamp)
  const now = new Date()
  const diffTime = Math.abs(now.getTime() - date.getTime())
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24))
  return diffDays <= days
}

=================================================================================
FILE: src/vite-env.d.ts
=================================================================================
/// <reference types="vite/client" />

/**
 * Type definitions for environment variables
 * This provides type safety and autocomplete for import.meta.env
 */
interface ImportMetaEnv {
  // Firebase Configuration
  readonly VITE_FIREBASE_API_KEY: string
  readonly VITE_FIREBASE_AUTH_DOMAIN: string
  readonly VITE_FIREBASE_PROJECT_ID: string
  readonly VITE_FIREBASE_STORAGE_BUCKET: string
  readonly VITE_FIREBASE_MESSAGING_SENDER_ID: string
  readonly VITE_FIREBASE_APP_ID: string
  readonly VITE_FIREBASE_MEASUREMENT_ID?: string

  // Sentry Configuration
  readonly VITE_SENTRY_DSN?: string
  readonly VITE_ENABLE_SENTRY?: string

  // Feature Flags - Adaptive Personalization
  readonly VITE_ADAPTIVE_PERSONALIZATION_ENABLED?: string
  readonly VITE_ADAPTIVE_FEEDBACK_UI_ENABLED?: string
  readonly VITE_ADAPTIVE_CALIBRATION_ENABLED?: string
  readonly VITE_ADAPTIVE_TELEMETRY_ENABLED?: string

  // Feature Flags - General
  readonly VITE_ENABLE_ANALYTICS?: string
  readonly VITE_ENABLE_ERROR_TRACKING?: string

  // Cloud Functions
  readonly VITE_WORKOUT_FN_URL?: string
  readonly VITE_ADD_EXERCISE_FN_URL?: string
  readonly VITE_SWAP_EXERCISE_FN_URL?: string

  // Environment
  readonly VITE_APP_ENV?: 'development' | 'staging' | 'production'

  // Vite built-in
  readonly DEV: boolean
  readonly PROD: boolean
  readonly MODE: string
}

interface ImportMeta {
  readonly env: ImportMetaEnv
}


================================================================================
BACKEND FIREBASE FUNCTIONS
================================================================================


=================================================================================
FILE: functions/src/__tests__/duration.test.ts
=================================================================================
/**
 * Tests for duration validation and adjustment
 */

import { validateAndAdjustDuration, computeMinMaxExerciseCount } from '../lib/durationAdjustment';
import type { ProgrammingContext } from '../lib/promptBuilder';

describe('Duration Validation', () => {
  describe('computeMinMaxExerciseCount', () => {
    const defaultProgramming: ProgrammingContext = {
      sets: [3, 4],
      reps: [8, 12],
      restSeconds: [60, 90],
      intensity: '70-80% 1RM',
    };

    it('should compute correct range for 30-minute workout', () => {
      const result = computeMinMaxExerciseCount(30, defaultProgramming, 'Full Body');
      expect(result.min).toBeGreaterThan(0);
      expect(result.max).toBeGreaterThan(result.min);
      expect(result.warmupMin).toBeGreaterThan(0);
    });

    it('should compute correct range for 60-minute workout', () => {
      const result = computeMinMaxExerciseCount(60, defaultProgramming, 'Full Body');
      expect(result.min).toBeGreaterThan(0);
      expect(result.max).toBeGreaterThan(result.min);
      // Longer workout should allow more exercises
      const shortResult = computeMinMaxExerciseCount(30, defaultProgramming, 'Full Body');
      expect(result.max).toBeGreaterThan(shortResult.max);
    });

    it('should account for longer rest periods', () => {
      const longRestProgramming: ProgrammingContext = {
        sets: [3, 4],
        reps: [3, 5],
        restSeconds: [180, 240], // Much longer rest
        intensity: '85-95% 1RM',
      };

      const result = computeMinMaxExerciseCount(30, longRestProgramming, 'Strength Training');
      const normalResult = computeMinMaxExerciseCount(30, defaultProgramming, 'Full Body');
      
      // Longer rest should mean fewer exercises fit in same time
      expect(result.max).toBeLessThan(normalResult.max);
    });

    it('should handle edge cases', () => {
      const result = computeMinMaxExerciseCount(15, defaultProgramming, 'Full Body');
      expect(result.min).toBeGreaterThanOrEqual(1);
      expect(result.max).toBeGreaterThanOrEqual(result.min);
    });
  });

  describe('validateAndAdjustDuration', () => {
    const createWorkout = (exercises: Array<{ sets: number; reps: string; restSeconds: number }>) => ({
      exercises: exercises.map((ex, i) => ({
        name: `Exercise ${i + 1}`,
        description: 'Test exercise description with proper length for validation requirements.',
        sets: ex.sets,
        reps: ex.reps,
        formTips: ['Tip 1', 'Tip 2', 'Tip 3'],
        safetyTips: ['Safety 1', 'Safety 2'],
        restSeconds: ex.restSeconds,
        usesWeight: true,
        muscleGroups: ['Test'],
        difficulty: 'intermediate',
      })),
      workoutSummary: {
        totalVolume: 'Test',
        primaryFocus: 'Test',
        expectedRPE: '7',
      },
    });

    it('should validate workout within acceptable duration range', () => {
      const workout = createWorkout([
        { sets: 3, reps: '8-12', restSeconds: 90 },
        { sets: 3, reps: '8-12', restSeconds: 90 },
        { sets: 3, reps: '8-12', restSeconds: 90 },
        { sets: 3, reps: '8-12', restSeconds: 90 },
      ]);

      const result = validateAndAdjustDuration(workout, 30, 4);
      expect(result.isValid).toBe(true);
      expect(result.error).toBeUndefined();
    });

    it('should use ±3 min variance for workouts < 45 min', () => {
      const workout = createWorkout([
        { sets: 3, reps: '8-12', restSeconds: 90 },
        { sets: 3, reps: '8-12', restSeconds: 90 },
      ]);

      const result = validateAndAdjustDuration(workout, 30, 2);
      
      // Should be valid if within ±3 minutes
      if (result.actualDuration >= 27 && result.actualDuration <= 33) {
        expect(result.isValid).toBe(true);
      }
    });

    it('should use ±4 min variance for workouts ≥ 45 min', () => {
      const workout = createWorkout([
        { sets: 4, reps: '8-12', restSeconds: 120 },
        { sets: 4, reps: '8-12', restSeconds: 120 },
        { sets: 4, reps: '8-12', restSeconds: 120 },
        { sets: 4, reps: '8-12', restSeconds: 120 },
        { sets: 4, reps: '8-12', restSeconds: 120 },
      ]);

      const result = validateAndAdjustDuration(workout, 45, 5);
      
      // Should be valid if within ±4 minutes
      if (result.actualDuration >= 41 && result.actualDuration <= 49) {
        expect(result.isValid).toBe(true);
      }
    });

    it('should calculate actual duration correctly', () => {
      const workout = createWorkout([
        { sets: 3, reps: '10-12', restSeconds: 60 },
      ]);

      const result = validateAndAdjustDuration(workout, 30, 1);
      
      // 5 min warmup + (3 sets * (1 min exercise + 1 min rest)) - 1 min (no rest after last set)
      // = 5 + (3 * 2) - 1 = 10 minutes
      expect(result.actualDuration).toBeGreaterThan(0);
      expect(result.actualDuration).toBeLessThan(30);
    });

    it('should handle time-based reps format', () => {
      const workout = createWorkout([
        { sets: 3, reps: '45s', restSeconds: 90 },
        { sets: 3, reps: '30s', restSeconds: 60 },
      ]);

      const result = validateAndAdjustDuration(workout, 20, 2);
      expect(result.actualDuration).toBeGreaterThan(0);
    });

    it('should reject workout significantly over duration', () => {
      const workout = createWorkout([
        { sets: 5, reps: '8-12', restSeconds: 180 },
        { sets: 5, reps: '8-12', restSeconds: 180 },
        { sets: 5, reps: '8-12', restSeconds: 180 },
        { sets: 5, reps: '8-12', restSeconds: 180 },
        { sets: 5, reps: '8-12', restSeconds: 180 },
        { sets: 5, reps: '8-12', restSeconds: 180 },
      ]);

      const result = validateAndAdjustDuration(workout, 30, 6);
      expect(result.isValid).toBe(false);
      expect(result.error).toBeDefined();
    });

    it('should reject workout significantly under duration', () => {
      const workout = createWorkout([
        { sets: 1, reps: '5', restSeconds: 30 },
      ]);

      const result = validateAndAdjustDuration(workout, 60, 1);
      expect(result.isValid).toBe(false);
      expect(result.error).toBeDefined();
    });

    it('should calculate difference correctly', () => {
      const workout = createWorkout([
        { sets: 3, reps: '8-12', restSeconds: 90 },
        { sets: 3, reps: '8-12', restSeconds: 90 },
      ]);

      const result = validateAndAdjustDuration(workout, 30, 2);
      expect(result.difference).toBe(result.actualDuration - 30);
    });
  });
});


=================================================================================
FILE: functions/src/__tests__/exercise-context-validation.test.ts
=================================================================================
/**
 * Tests for exercise context validation
 */

import {
  isExerciseMatchingWorkoutType,
  isExerciseUsingAvailableEquipment,
  isRepFormatMatchingWorkoutType,
  getExerciseContextValidationErrors,
} from '../lib/exerciseContextValidation';

describe('Exercise Context Validation', () => {
  describe('isExerciseMatchingWorkoutType', () => {
    it('should match exercises to Full Body workout (lenient)', () => {
      expect(isExerciseMatchingWorkoutType('Barbell Squat', 'Full Body')).toBe(true);
      expect(isExerciseMatchingWorkoutType('Bench Press', 'Full Body')).toBe(true);
      expect(isExerciseMatchingWorkoutType('Deadlift', 'Full Body')).toBe(true);
    });

    it('should match exercises to Upper Body workout (lenient)', () => {
      expect(isExerciseMatchingWorkoutType('Bench Press', 'Upper Body')).toBe(true);
      expect(isExerciseMatchingWorkoutType('Barbell Row', 'Upper Body')).toBe(true);
      expect(isExerciseMatchingWorkoutType('Shoulder Press', 'Upper Body')).toBe(true);
      expect(isExerciseMatchingWorkoutType('Push-up', 'Upper Body')).toBe(true);
    });

    it('should reject leg exercises for Upper Body workout (hard constraint)', () => {
      expect(isExerciseMatchingWorkoutType('Barbell Squat', 'Upper Body')).toBe(false);
      expect(isExerciseMatchingWorkoutType('Leg Press', 'Upper Body')).toBe(false);
    });

    it('should match exercises to Lower Body workout (lenient)', () => {
      expect(isExerciseMatchingWorkoutType('Barbell Squat', 'Lower Body')).toBe(true);
      expect(isExerciseMatchingWorkoutType('Deadlift', 'Lower Body')).toBe(true);
      expect(isExerciseMatchingWorkoutType('Leg Press', 'Lower Body')).toBe(true);
    });

    it('should allow most exercises for any workout type (lenient)', () => {
      expect(isExerciseMatchingWorkoutType('Burpees', 'Cardio')).toBe(true);
      expect(isExerciseMatchingWorkoutType('Mountain Climbers', 'Cardio')).toBe(true);
      expect(isExerciseMatchingWorkoutType('Jump Rope', 'Cardio')).toBe(true);
      // Lenient - allow strength exercises for cardio
      expect(isExerciseMatchingWorkoutType('Bench Press', 'Cardio')).toBe(true);
    });

    it('should match exercises to Yoga workout (lenient)', () => {
      expect(isExerciseMatchingWorkoutType('Warrior Pose', 'Yoga')).toBe(true);
      expect(isExerciseMatchingWorkoutType('Downward Dog', 'Yoga')).toBe(true);
    });
  });

  describe('isExerciseUsingAvailableEquipment', () => {
    it('should allow bodyweight exercises with bodyweight equipment', () => {
      expect(isExerciseUsingAvailableEquipment('Push-up', ['Bodyweight'])).toBe(true);
      expect(isExerciseUsingAvailableEquipment('Pull-up', ['Bodyweight'])).toBe(true);
      expect(isExerciseUsingAvailableEquipment('Dip', ['Bodyweight'])).toBe(true);
    });

    it('should allow dumbbell exercises even without dumbbell equipment (lenient)', () => {
      // Lenient - trust the AI
      expect(isExerciseUsingAvailableEquipment('Dumbbell Bench Press', ['Bodyweight'])).toBe(true);
      expect(isExerciseUsingAvailableEquipment('Dumbbell Curl', ['Barbell'])).toBe(true);
    });

    it('should allow dumbbell exercises with dumbbell equipment', () => {
      expect(isExerciseUsingAvailableEquipment('Dumbbell Bench Press', ['Dumbbells', 'Bench'])).toBe(true);
      expect(isExerciseUsingAvailableEquipment('Dumbbell Curl', ['Dumbbells'])).toBe(true);
    });

    it('should allow barbell exercises with barbell equipment', () => {
      expect(isExerciseUsingAvailableEquipment('Barbell Squat', ['Barbell'])).toBe(true);
      expect(isExerciseUsingAvailableEquipment('Barbell Bench Press', ['Barbell', 'Bench'])).toBe(true);
    });

    it('should allow exercises with multiple equipment options (lenient)', () => {
      expect(isExerciseUsingAvailableEquipment('Dumbbell Bench Press', ['Dumbbells', 'Bench'])).toBe(true);
      expect(isExerciseUsingAvailableEquipment('Barbell Squat', ['Dumbbells', 'Barbell'])).toBe(true);
    });

    it('should reject cable exercises without cable machine (hard constraint)', () => {
      expect(isExerciseUsingAvailableEquipment('Cable Chest Press', ['Dumbbells'])).toBe(false);
    });

    it('should allow cable exercises with cable machine', () => {
      expect(isExerciseUsingAvailableEquipment('Cable Chest Press', ['Cable Machine'])).toBe(true);
    });
  });

  describe('isRepFormatMatchingWorkoutType', () => {
    it('should accept rep ranges for strength workouts (lenient)', () => {
      expect(isRepFormatMatchingWorkoutType('8-12', 'Full Body')).toBe(true);
      expect(isRepFormatMatchingWorkoutType('6-10', 'Upper Body')).toBe(true);
      expect(isRepFormatMatchingWorkoutType('10-15', 'Lower Body')).toBe(true);
    });

    it('should accept time format for any workout (lenient)', () => {
      expect(isRepFormatMatchingWorkoutType('30s', 'Full Body')).toBe(true);
      expect(isRepFormatMatchingWorkoutType('45s', 'Upper Body')).toBe(true);
    });

    it('should accept time format for time-based workouts', () => {
      expect(isRepFormatMatchingWorkoutType('30s', 'Cardio')).toBe(true);
      expect(isRepFormatMatchingWorkoutType('45s', 'HIIT')).toBe(true);
      expect(isRepFormatMatchingWorkoutType('60s', 'Yoga')).toBe(true);
    });

    it('should accept rep ranges for any workout (lenient)', () => {
      expect(isRepFormatMatchingWorkoutType('8-12', 'Cardio')).toBe(true);
      expect(isRepFormatMatchingWorkoutType('10-15', 'HIIT')).toBe(true);
    });

    it('should accept numeric reps for any workout (lenient)', () => {
      expect(isRepFormatMatchingWorkoutType(10, 'Full Body')).toBe(true);
      expect(isRepFormatMatchingWorkoutType(12, 'Upper Body')).toBe(true);
      expect(isRepFormatMatchingWorkoutType(10, 'Cardio')).toBe(true);
      expect(isRepFormatMatchingWorkoutType(12, 'HIIT')).toBe(true);
    });

    it('should reject invalid rep format (no digits)', () => {
      expect(isRepFormatMatchingWorkoutType('abc', 'Full Body')).toBe(false);
      expect(isRepFormatMatchingWorkoutType('xyz', 'Cardio')).toBe(false);
    });
  });

  describe('getExerciseContextValidationErrors', () => {
    it('should return no errors for valid Full Body exercise', () => {
      const errors = getExerciseContextValidationErrors(
        'Barbell Squat',
        '8-12',
        'Full Body',
        ['Barbell'],
      );
      expect(errors).toHaveLength(0);
    });

    it('should return error only for hard constraint violations (leg exercises in Upper Body)', () => {
      const errors = getExerciseContextValidationErrors(
        'Leg Press',
        '8-12',
        'Upper Body',
        ['Machine'],
      );
      expect(errors.length).toBeGreaterThan(0);
      expect(errors[0]).toContain('does not match Upper Body');
    });

    it('should allow dumbbell exercises even if barbell is listed (lenient)', () => {
      const errors = getExerciseContextValidationErrors(
        'Dumbbell Bench Press',
        '8-12',
        'Upper Body',
        ['Barbell'],
      );
      // Lenient validation - allow this
      expect(errors).toHaveLength(0);
    });

    it('should reject invalid rep format (no digits)', () => {
      const errors = getExerciseContextValidationErrors(
        'Burpees',
        'abc',
        'Cardio',
        ['Bodyweight'],
      );
      expect(errors.length).toBeGreaterThan(0);
      expect(errors[0]).toContain('invalid rep format');
    });

    it('should allow time format for any workout (lenient)', () => {
      const errors = getExerciseContextValidationErrors(
        'Bench Press',
        '30s',
        'Upper Body',
        ['Dumbbells'],
      );
      // Lenient validation - allow this
      expect(errors).toHaveLength(0);
    });
  });
});


=================================================================================
FILE: functions/src/__tests__/exercise-progression.test.ts
=================================================================================
/**
 * Tests for exercise progression and variety tracking
 */

import { describe, it, expect } from 'vitest';
import {
  calculateExerciseFreshness,
  analyzeExerciseVariety,
  getVarietyRecommendations,
  updateExerciseHistory,
  type ExerciseHistory,
} from '../lib/exerciseProgression';

describe('Exercise Progression', () => {
  describe('calculateExerciseFreshness', () => {
    it('should return 100 for brand new exercises', () => {
      const history: ExerciseHistory[] = [];
      const freshness = calculateExerciseFreshness('Push-up', history);
      expect(freshness).toBe(100);
    });

    it('should penalize frequently used exercises', () => {
      const history: ExerciseHistory[] = [
        {
          name: 'Push-up',
          lastUsed: Date.now(),
          frequency: 5,
          variations: [],
        },
      ];
      const freshness = calculateExerciseFreshness('Push-up', history);
      expect(freshness).toBeLessThan(100);
      expect(freshness).toBeGreaterThan(0);
    });

    it('should penalize recently used exercises', () => {
      const now = Date.now();
      const oneDayAgo = now - 24 * 60 * 60 * 1000;
      const history: ExerciseHistory[] = [
        {
          name: 'Squat',
          lastUsed: oneDayAgo,
          frequency: 1,
          variations: [],
        },
      ];
      const freshness = calculateExerciseFreshness('Squat', history, 7);
      expect(freshness).toBeLessThan(100);
    });

    it('should reward exercises not used recently', () => {
      const now = Date.now();
      const thirtyDaysAgo = now - 30 * 24 * 60 * 60 * 1000;
      const history: ExerciseHistory[] = [
        {
          name: 'Deadlift',
          lastUsed: thirtyDaysAgo,
          frequency: 1,
          variations: [],
        },
      ];
      const freshness = calculateExerciseFreshness('Deadlift', history, 7);
      expect(freshness).toBeGreaterThan(50);
    });

    it('should be case-insensitive', () => {
      const history: ExerciseHistory[] = [
        {
          name: 'Push-up',
          lastUsed: Date.now(),
          frequency: 1,
          variations: [],
        },
      ];
      const freshness1 = calculateExerciseFreshness('Push-up', history);
      const freshness2 = calculateExerciseFreshness('PUSH-UP', history);
      const freshness3 = calculateExerciseFreshness('push-up', history);
      expect(freshness1).toBe(freshness2);
      expect(freshness2).toBe(freshness3);
    });
  });

  describe('analyzeExerciseVariety', () => {
    it('should calculate variety score correctly', () => {
      const exercises = [
        { name: 'Push-up' },
        { name: 'Squat' },
        { name: 'Deadlift' },
      ];
      const history: ExerciseHistory[] = [];

      const variety = analyzeExerciseVariety(exercises, history);

      expect(variety.varietyScore).toBeGreaterThan(0);
      expect(variety.varietyScore).toBeLessThanOrEqual(100);
      expect(variety.uniqueExercises).toBe(3);
      expect(variety.repetitionRisk.length).toBe(0);
    });

    it('should detect duplicate exercises', () => {
      const exercises = [
        { name: 'Push-up' },
        { name: 'Push-up' },
        { name: 'Squat' },
      ];
      const history: ExerciseHistory[] = [];

      const variety = analyzeExerciseVariety(exercises, history);

      expect(variety.uniqueExercises).toBe(2);
      expect(variety.varietyScore).toBeLessThan(100);
    });

    it('should identify repetition risk for recently used exercises', () => {
      const exercises = [
        { name: 'Push-up' },
        { name: 'Squat' },
      ];
      const now = Date.now();
      const history: ExerciseHistory[] = [
        {
          name: 'Push-up',
          lastUsed: now - 1000, // Just used
          frequency: 10,
          variations: [],
        },
      ];

      const variety = analyzeExerciseVariety(exercises, history);

      expect(variety.repetitionRisk).toContain('Push-up');
    });
  });

  describe('getVarietyRecommendations', () => {
    it('should recommend variety for low variety score', () => {
      const exercises = [
        { name: 'Push-up' },
        { name: 'Push-up' },
        { name: 'Push-up' },
      ];
      const history: ExerciseHistory[] = [];

      const recommendations = getVarietyRecommendations(exercises, history);

      expect(recommendations.length).toBeGreaterThan(0);
      expect(recommendations.some((r) => r.toLowerCase().includes('appear'))).toBe(true);
    });

    it('should recommend alternatives for recently used exercises', () => {
      const exercises = [
        { name: 'Push-up' },
        { name: 'Squat' },
      ];
      const now = Date.now();
      const history: ExerciseHistory[] = [
        {
          name: 'Push-up',
          lastUsed: now - 1000,
          frequency: 5,
          variations: [],
        },
      ];

      const recommendations = getVarietyRecommendations(exercises, history);

      expect(recommendations.some((r) => r.includes('Recently used'))).toBe(true);
    });

    it('should not recommend changes for good variety', () => {
      const exercises = [
        { name: 'Push-up' },
        { name: 'Squat' },
        { name: 'Deadlift' },
        { name: 'Row' },
      ];
      const history: ExerciseHistory[] = [];

      const recommendations = getVarietyRecommendations(exercises, history);

      expect(recommendations.length).toBe(0);
    });
  });

  describe('updateExerciseHistory', () => {
    it('should add new exercises to history', () => {
      const history: ExerciseHistory[] = [];
      const exercises = [{ name: 'Push-up' }, { name: 'Squat' }];

      const updated = updateExerciseHistory(history, exercises);

      expect(updated.length).toBe(2);
      expect(updated.some((h) => h.name === 'Push-up')).toBe(true);
      expect(updated.some((h) => h.name === 'Squat')).toBe(true);
    });

    it('should increment frequency for existing exercises', () => {
      const history: ExerciseHistory[] = [
        {
          name: 'Push-up',
          lastUsed: Date.now() - 1000,
          frequency: 3,
          variations: [],
        },
      ];
      const exercises = [{ name: 'Push-up' }];

      const updated = updateExerciseHistory(history, exercises);

      const pushUp = updated.find((h) => h.name === 'Push-up');
      expect(pushUp?.frequency).toBe(4);
    });

    it('should update lastUsed timestamp', () => {
      const oldTime = Date.now() - 10000;
      const history: ExerciseHistory[] = [
        {
          name: 'Push-up',
          lastUsed: oldTime,
          frequency: 1,
          variations: [],
        },
      ];
      const exercises = [{ name: 'Push-up' }];

      const updated = updateExerciseHistory(history, exercises);

      const pushUp = updated.find((h) => h.name === 'Push-up');
      expect(pushUp?.lastUsed).toBeGreaterThan(oldTime);
    });

    it('should be case-insensitive when matching exercises', () => {
      const history: ExerciseHistory[] = [
        {
          name: 'Push-up',
          lastUsed: Date.now(),
          frequency: 1,
          variations: [],
        },
      ];
      const exercises = [{ name: 'PUSH-UP' }];

      const updated = updateExerciseHistory(history, exercises);

      expect(updated.length).toBe(1);
      const pushUp = updated.find((h) => h.name === 'Push-up');
      expect(pushUp?.frequency).toBe(2);
    });
  });
});


=================================================================================
FILE: functions/src/__tests__/exercise-similarity.test.ts
=================================================================================
/**
 * Tests for exercise similarity detection
 */

import { isSimilarExercise, findSimilarExercises } from '../lib/exerciseTaxonomy';

describe('Exercise Similarity Detection', () => {
  describe('isSimilarExercise', () => {
    it('should detect exact matches (case-insensitive)', () => {
      expect(isSimilarExercise('Bench Press', 'bench press')).toBe(true);
      expect(isSimilarExercise('SQUAT', 'squat')).toBe(true);
    });

    it('should detect synonym variations', () => {
      expect(isSimilarExercise('Bench Press', 'Chest Press')).toBe(true);
      expect(isSimilarExercise('Pull-up', 'Chin-up')).toBe(true);
      expect(isSimilarExercise('Sit-up', 'Crunch')).toBe(true);
    });

    it('should detect equipment variations of same exercise', () => {
      expect(isSimilarExercise('Barbell Bench Press', 'Dumbbell Bench Press')).toBe(true);
      expect(isSimilarExercise('Barbell Row', 'Dumbbell Row')).toBe(true);
      expect(isSimilarExercise('Cable Fly', 'Dumbbell Fly')).toBe(true);
    });

    it('should NOT match completely different exercises', () => {
      expect(isSimilarExercise('Bench Press', 'Squat')).toBe(false);
      expect(isSimilarExercise('Deadlift', 'Bicep Curl')).toBe(false);
      expect(isSimilarExercise('Plank', 'Running')).toBe(false);
    });

    it('should NOT match exercises with different movement patterns', () => {
      expect(isSimilarExercise('Bench Press', 'Dumbbell Fly')).toBe(false);
      expect(isSimilarExercise('Squat', 'Leg Press')).toBe(false);
      // Note: Deadlift and Romanian Deadlift ARE similar (both hinge patterns)
      // This test was incorrect - they should be detected as similar
    });

    it('should handle partial word matches correctly', () => {
      // These should be similar (same base exercise)
      expect(isSimilarExercise('Incline Bench Press', 'Decline Bench Press')).toBe(true);
      
      // These should NOT be similar (different exercises)
      expect(isSimilarExercise('Leg Extension', 'Leg Curl')).toBe(false);
    });
  });

  describe('findSimilarExercises', () => {
    it('should find no similarities in diverse workout', () => {
      const exercises = [
        { name: 'Bench Press' },
        { name: 'Squat' },
        { name: 'Deadlift' },
        { name: 'Pull-up' },
      ];

      const similar = findSimilarExercises(exercises);
      expect(similar).toHaveLength(0);
    });

    it('should detect duplicate exercises', () => {
      const exercises = [
        { name: 'Bench Press' },
        { name: 'Squat' },
        { name: 'bench press' }, // Duplicate
      ];

      const similar = findSimilarExercises(exercises);
      expect(similar.length).toBeGreaterThan(0);
      expect(similar[0]).toEqual([0, 2, 'Bench Press', 'bench press']);
    });

    it('should detect synonym variations', () => {
      const exercises = [
        { name: 'Bench Press' },
        { name: 'Chest Press' }, // Synonym
        { name: 'Squat' },
      ];

      const similar = findSimilarExercises(exercises);
      expect(similar.length).toBeGreaterThan(0);
    });

    it('should detect equipment variations', () => {
      const exercises = [
        { name: 'Barbell Bench Press' },
        { name: 'Dumbbell Bench Press' }, // Equipment variation
        { name: 'Squat' },
      ];

      const similar = findSimilarExercises(exercises);
      expect(similar.length).toBeGreaterThan(0);
    });

    it('should find multiple similar pairs', () => {
      const exercises = [
        { name: 'Barbell Bench Press' },
        { name: 'Dumbbell Bench Press' }, // Similar to #0
        { name: 'Pull-up' },
        { name: 'Chin-up' }, // Similar to #2
      ];

      const similar = findSimilarExercises(exercises);
      expect(similar.length).toBe(2);
    });

    it('should handle empty array', () => {
      const exercises: Array<{ name: string }> = [];
      const similar = findSimilarExercises(exercises);
      expect(similar).toHaveLength(0);
    });

    it('should handle single exercise', () => {
      const exercises = [{ name: 'Bench Press' }];
      const similar = findSimilarExercises(exercises);
      expect(similar).toHaveLength(0);
    });
  });

  describe('Real-world scenarios', () => {
    it('should prevent adding "Incline Dumbbell Press" when "Bench Press" exists', () => {
      const existingExercises = ['Bench Press', 'Squat', 'Deadlift'];
      const newExercise = 'Incline Dumbbell Press';

      const hasSimilar = existingExercises.some((existing) =>
        isSimilarExercise(existing, newExercise),
      );

      expect(hasSimilar).toBe(true);
    });

    it('should allow adding "Dumbbell Fly" when "Bench Press" exists', () => {
      const existingExercises = ['Bench Press', 'Squat', 'Deadlift'];
      const newExercise = 'Dumbbell Fly';

      const hasSimilar = existingExercises.some((existing) =>
        isSimilarExercise(existing, newExercise),
      );

      expect(hasSimilar).toBe(false);
    });

    it('should prevent swapping "Barbell Row" with "Dumbbell Row"', () => {
      const original = 'Barbell Row';
      const replacement = 'Dumbbell Row';

      expect(isSimilarExercise(original, replacement)).toBe(true);
    });

    it('should allow swapping "Barbell Row" with "Pull-up"', () => {
      const original = 'Barbell Row';
      const replacement = 'Pull-up';

      expect(isSimilarExercise(original, replacement)).toBe(false);
    });
  });
});


=================================================================================
FILE: functions/src/__tests__/schema-validation.test.ts
=================================================================================
/**
 * Tests for JSON Schema validation
 */

import { validateWorkoutPlanJSON, validateRepFormat, validateRestPeriods } from '../lib/schemaValidator';

describe('Schema Validation', () => {
  describe('validateWorkoutPlanJSON', () => {
    it('should validate a valid workout plan', () => {
      const validPlan = {
        exercises: [
          {
            name: 'Bench Press',
            description: 'Lie on bench, lower bar to chest, press up. Exhale on press, inhale on descent. Keep feet flat, back arched slightly.',
            sets: 3,
            reps: '8-12',
            formTips: ['Keep elbows at 45 degrees', 'Retract shoulder blades', 'Full range of motion'],
            safetyTips: ['Use spotter for heavy sets', 'Start with lighter weight'],
            restSeconds: 90,
            usesWeight: true,
            muscleGroups: ['chest', 'triceps'],
            difficulty: 'intermediate',
          },
        ],
        workoutSummary: {
          totalVolume: '3 sets x 8-12 reps',
          primaryFocus: 'Chest and Triceps',
          expectedRPE: '7-8 out of 10',
        },
      };

      const result = validateWorkoutPlanJSON(validPlan, 1, 10);
      expect(result.valid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });

    it('should reject workout with too few exercises', () => {
      const invalidPlan = {
        exercises: [],
        workoutSummary: {
          totalVolume: 'N/A',
          primaryFocus: 'None',
          expectedRPE: '0',
        },
      };

      const result = validateWorkoutPlanJSON(invalidPlan, 3, 10);
      expect(result.valid).toBe(false);
      expect(result.errors.length).toBeGreaterThan(0);
    });

    it('should reject exercise with missing required fields', () => {
      const invalidPlan = {
        exercises: [
          {
            name: 'Squat',
            // Missing description, sets, reps, etc.
          },
        ],
        workoutSummary: {
          totalVolume: '1 exercise',
          primaryFocus: 'Legs',
          expectedRPE: '7',
        },
      };

      const result = validateWorkoutPlanJSON(invalidPlan, 1, 10);
      expect(result.valid).toBe(false);
    });

    it('should reject exercise with invalid rep format', () => {
      const invalidPlan = {
        exercises: [
          {
            name: 'Push-up',
            description: 'Standard push-up with proper form. Lower chest to ground, push back up. Exhale on push, inhale on descent.',
            sets: 3,
            reps: 'invalid-format', // Invalid
            formTips: ['Keep core tight', 'Elbows at 45 degrees', 'Full range of motion'],
            safetyTips: ['Start on knees if needed', 'Stop if wrists hurt'],
            restSeconds: 60,
            usesWeight: false,
            muscleGroups: ['Chest', 'Triceps'],
            difficulty: 'beginner',
          },
        ],
        workoutSummary: {
          totalVolume: '3 sets',
          primaryFocus: 'Chest',
          expectedRPE: '6',
        },
      };

      const result = validateWorkoutPlanJSON(invalidPlan, 1, 10);
      expect(result.valid).toBe(false);
    });
  });

  describe('validateRepFormat', () => {
    it('should require time format for Cardio workouts', () => {
      const exercises = [
        {
          name: 'Running',
          description: 'Steady-state running at moderate pace',
          sets: 1,
          reps: '8-12', // Should be time format
          formTips: ['Maintain steady pace', 'Breathe rhythmically', 'Land midfoot'],
          safetyTips: ['Warm up first', 'Stay hydrated'],
          restSeconds: 60,
          usesWeight: false,
          muscleGroups: ['Legs'],
          difficulty: 'beginner',
        },
      ];

      const result = validateRepFormat(exercises, 'Cardio');
      expect(result.valid).toBe(false);
      expect(result.errors.length).toBeGreaterThan(0);
    });

    it('should accept time format for HIIT workouts', () => {
      const exercises = [
        {
          name: 'Burpees',
          description: 'Full body explosive movement',
          sets: 3,
          reps: '45s',
          formTips: ['Explosive movement', 'Full extension', 'Land softly'],
          safetyTips: ['Modify if needed', 'Stop if dizzy'],
          restSeconds: 90,
          usesWeight: false,
          muscleGroups: ['Full Body'],
          difficulty: 'intermediate',
        },
      ];

      const result = validateRepFormat(exercises, 'HIIT');
      expect(result.valid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });

    it('should accept range format for Strength Training', () => {
      const exercises = [
        {
          name: 'Deadlift',
          description: 'Hip hinge movement with barbell',
          sets: 4,
          reps: '5-8',
          formTips: ['Neutral spine', 'Drive through heels', 'Hip hinge pattern'],
          safetyTips: ['Start light', 'Use proper form'],
          restSeconds: 180,
          usesWeight: true,
          muscleGroups: ['Back', 'Legs'],
          difficulty: 'advanced',
        },
      ];

      const result = validateRepFormat(exercises, 'Strength Training');
      expect(result.valid).toBe(true);
    });
  });

  describe('validateRestPeriods', () => {
    it('should warn about very short rest periods for heavy exercises', () => {
      const exercises = [
        {
          name: 'Squat',
          description: 'Barbell back squat',
          sets: 5,
          reps: '3-5',
          formTips: ['Depth to parallel', 'Knees track toes', 'Chest up'],
          safetyTips: ['Use safety bars', 'Proper depth'],
          restSeconds: 45, // Too short for heavy squats
          usesWeight: true,
          muscleGroups: ['Legs'],
          difficulty: 'advanced',
        },
      ];

      const result = validateRestPeriods(exercises);
      expect(result.warnings).toBeDefined();
      expect(result.warnings!.length).toBeGreaterThan(0);
    });

    it('should not warn about appropriate rest periods', () => {
      const exercises = [
        {
          name: 'Bicep Curl',
          description: 'Dumbbell bicep curl',
          sets: 3,
          reps: '10-12',
          formTips: ['Control the weight', 'Full range', 'No swinging'],
          safetyTips: ['Start light', 'Avoid momentum'],
          restSeconds: 60,
          usesWeight: true,
          muscleGroups: ['Biceps'],
          difficulty: 'beginner',
        },
      ];

      const result = validateRestPeriods(exercises);
      expect(result.warnings || []).toHaveLength(0);
    });
  });
});


=================================================================================
FILE: functions/src/config.ts
=================================================================================
/**
 * Configuration for Cloud Functions
 * Centralized configuration with environment variable support
 */

/**
 * OpenAI model configuration
 * Using gpt-4o-mini for better JSON mode performance and lower latency
 * Falls back to gpt-4o-mini-2024-07-18 if the latest version is not available
 * Can be overridden via OPENAI_MODEL environment variable
 */
export const OPENAI_MODEL = process.env.OPENAI_MODEL || 'gpt-4o-mini';

/**
 * OpenAI generation parameters
 * Optimized for speed, cost, and quality balance
 * Using gpt-4o-mini for best cost/performance ratio
 */
export const OPENAI_CONFIG = {
  temperature: 0.3, // Slightly higher for better variety while maintaining consistency
  topP: 0.85, // Balanced for quality and speed
  maxTokens: 2600, // Optimized token count for typical workouts
  timeout: 180000, // 180 second timeout - sufficient for all workouts including 90+ min
  streamTimeout: 150000, // 150 second timeout for streaming operations
} as const;

/**
 * Get dynamic OpenAI config based on workout duration
 * Optimized for speed while maintaining quality
 * Balances token usage with generation quality
 */
export function getOpenAIConfigForDuration(duration: number) {
  // For 120+ minute workouts, aggressive speed optimization
  if (duration >= 120) {
    return {
      ...OPENAI_CONFIG,
      maxTokens: 2200, // Reduced for faster generation
      temperature: 0.35, // Slightly higher for faster convergence
    };
  }

  // For 90-119 minute workouts, optimize for speed
  if (duration >= 90) {
    return {
      ...OPENAI_CONFIG,
      maxTokens: 2300, // Reduced for faster generation
      temperature: 0.30, // Balanced for speed and quality
    };
  }

  // For 75-89 minute workouts, balanced optimization
  if (duration >= 75) {
    return {
      ...OPENAI_CONFIG,
      maxTokens: 2500,
      temperature: 0.28,
    };
  }

  // For 60-74 minute workouts, standard config
  if (duration >= 60) {
    return {
      ...OPENAI_CONFIG,
      maxTokens: 2600,
      temperature: 0.30,
    };
  }

  // Default for shorter workouts - allow more variety
  return OPENAI_CONFIG;
}

/**
 * Validation and quality thresholds
 * Balanced for quality and speed - repair attempts only when necessary
 */
export const QUALITY_THRESHOLDS = {
  minOverallScore: 82, // Minimum overall quality score to pass
  minSafetyScore: 88, // Minimum safety score - critical for user safety
  maxRepairAttempts: 1, // Allow 1 repair attempt for quality improvement
  skipRepairIfScoreAbove: 85, // Skip repair attempts if quality score is excellent
} as const;

/**
 * Get quality thresholds based on workout duration
 * For longer workouts, we skip quality gates to prioritize speed
 */
export function getQualityThresholdsForDuration(duration: number) {
  // For 90+ minute workouts, skip quality gates entirely (speed priority)
  if (duration >= 90) {
    return {
      ...QUALITY_THRESHOLDS,
      maxRepairAttempts: 0, // No repair attempts - accept first valid result
      skipRepairIfScoreAbove: 0, // Skip quality scoring entirely
    };
  }

  // For shorter workouts, use standard thresholds
  return QUALITY_THRESHOLDS;
}

/**
 * API retry configuration
 * Handles transient failures and rate limiting
 */
export const API_RETRY_CONFIG = {
  maxRetries: 2, // Maximum number of retry attempts
  initialDelayMs: 1000, // Initial delay before first retry
  maxDelayMs: 5000, // Maximum delay between retries
  backoffMultiplier: 2, // Exponential backoff multiplier
  retryableStatusCodes: [408, 429, 500, 502, 503, 504], // HTTP status codes to retry on
} as const;

/**
 * Duration validation windows
 */
export const DURATION_VALIDATION = {
  defaultVariance: 3, // ±3 minutes for workouts < 45 min
  longWorkoutVariance: 4, // ±4 minutes for workouts ≥ 45 min
  longWorkoutThreshold: 45, // Threshold for using longer variance
} as const;

/**
 * Cache configuration
 * Aggressive caching for common workout patterns
 */
export const CACHE_CONFIG = {
  ttlHours: 48, // Increased from 24 to 48 hours for better cache hit rate
  collectionName: 'ai_workout_cache', // Firestore collection name
  enabled: true, // Enable/disable caching
} as const;

/**
 * Logging configuration
 */
export const LOGGING_CONFIG = {
  structuredLogs: true, // Use structured JSON logging
  logLevel: process.env.LOG_LEVEL || 'info', // Log level: debug, info, warn, error
  anonymizePII: true, // Remove PII from logs
} as const;

/**
 * CORS origins for all deployment URLs
 */
export const CORS_ORIGINS: string[] = [
  'http://localhost:5173', // local dev
  'https://neurafit-ai-2025.web.app', // Firebase Hosting
  'https://neurafit-ai-2025.firebaseapp.com',
  'https://neurastack.ai', // Custom domain
  'https://www.neurastack.ai', // Custom domain with www
];

/**
 * Function timeouts and memory
 */
export const FUNCTION_CONFIG = {
  timeoutSeconds: 540, // 9 minutes - enough for longer workouts with streaming
  memory: '1GiB' as const, // Increased memory for better performance
  region: 'us-central1' as const,
} as const;


=================================================================================
FILE: functions/src/index.ts
=================================================================================
/**
 * Firebase Cloud Functions for NeuraFit AI Workout Generator
 * Refactored for better maintainability and modularity
 */

import { initializeApp } from 'firebase-admin/app';
import { onRequest } from 'firebase-functions/v2/https';
import { defineSecret } from 'firebase-functions/params';
import type { Request, Response } from 'express';
import OpenAI from 'openai';

// Initialize Firebase Admin
initializeApp();

// Import utility modules
import { getWorkoutTypeContext, type WorkoutContext } from './lib/promptBuilder';
import { getProgrammingRecommendations } from './lib/exerciseDatabase';
import { isSimilarExercise, isMinorExerciseVariation } from './lib/exerciseTaxonomy';
import { generateWorkoutOrchestrated } from './workout/generation';
import { FUNCTION_CONFIG, OPENAI_CONFIG } from './config';
import { getExerciseContextValidationErrors } from './lib/exerciseContextValidation';

// CORS configuration for all deployment URLs
const CORS_ORIGINS: string[] = [
  'http://localhost:5173', // local dev
  'https://neurafit-ai-2025.web.app', // Firebase Hosting
  'https://neurafit-ai-2025.firebaseapp.com',
  'https://neurastack.ai', // Custom domain
  'https://www.neurastack.ai', // Custom domain with www
];

// Define the OpenAI API key secret
const openaiApiKey = defineSecret('OPENAI_API_KEY');

/**
 * Main AI-powered workout generator function
 * Generates personalized workouts based on user profile and preferences
 * Uses schema-driven generation with multi-pass validation and repair
 */
export const generateWorkout = onRequest(
  {
    cors: CORS_ORIGINS,
    region: FUNCTION_CONFIG.region,
    secrets: [openaiApiKey],
    timeoutSeconds: FUNCTION_CONFIG.timeoutSeconds,
    memory: FUNCTION_CONFIG.memory,
  },
  async (req: Request, res: Response): Promise<void> => {
    // Handle preflight
    if (req.method === 'OPTIONS') {
      res.status(204).send('');
      return;
    }

    if (req.method !== 'POST') {
      res.status(405).send('Method Not Allowed');
      return;
    }

    try {
      // Validate request body exists - use empty object as fallback
      if (!req.body) {
        console.warn('Empty request body received, using defaults');
        // Don't fail - continue with defaults
      }

      // Initialize OpenAI client with the secret value and timeout
      const apiKeyValue = openaiApiKey.value();
      if (!apiKeyValue) {
        console.error('OpenAI API key is not set');
        res.status(502).json({
          error: 'AI service configuration error',
          details: 'Please try again later',
        });
        return;
      }

      const client = new OpenAI({
        apiKey: apiKeyValue,
        timeout: OPENAI_CONFIG.timeout, // Use config timeout (180s for all workouts)
      });

      // Extract request body
      const {
        experience,
        goals,
        equipment,
        personalInfo,
        injuries,
        workoutType,
        duration,
        targetIntensity,
        progressionNote,
        recentWorkouts,
        preferenceNotes,
        uid,
      } = (req.body as {
        experience?: string;
        goals?: string | string[];
        equipment?: string | string[];
        personalInfo?: {
          sex?: string;
          heightRange?: string;
          height?: string;
          weightRange?: string;
          weight?: string;
        };
        injuries?: { list?: string[]; notes?: string };
        workoutType?: string;
        duration?: number;
        targetIntensity?: number;
        progressionNote?: string;
        recentWorkouts?: Array<{
          workoutType: string;
          timestamp: number;
          exercises: Array<{ name: string }>;
          completionRate?: number;
          rpe?: number;
          feedback?: 'easy' | 'right' | 'hard';
        }>;
        preferenceNotes?: string;
        uid?: string;
      }) || {};

      // Validate and provide fallbacks for required fields
      // Use sensible defaults to ensure robustness
      const finalExperience = experience || 'Intermediate';
      const finalWorkoutType = workoutType || 'Full Body';
      const finalDuration = duration || 30;

      if (!finalExperience || !finalWorkoutType || !finalDuration) {
        console.warn('Using fallback values for missing fields', {
          experience: finalExperience,
          workoutType: finalWorkoutType,
          duration: finalDuration,
        });
      }

      // Filter out undefined values from arrays and ensure string types
      const filteredGoals = Array.isArray(goals)
        ? goals.filter((g): g is string => Boolean(g))
        : goals ? [goals].filter((g): g is string => Boolean(g)) : ['General Fitness'];

      const filteredEquipment = Array.isArray(equipment)
        ? equipment.filter((e): e is string => Boolean(e))
        : equipment ? [equipment].filter((e): e is string => Boolean(e)) : ['Bodyweight'];

      // Build workout context with fallbacks
      const workoutContext: WorkoutContext = {
        experience: finalExperience,
        goals: filteredGoals.length > 0 ? filteredGoals : ['General Fitness'],
        equipment: filteredEquipment.length > 0 ? filteredEquipment : ['Bodyweight'],
        personalInfo,
        injuries,
        workoutType: finalWorkoutType,
        duration: Math.max(5, Math.min(finalDuration, 150)), // Clamp between 5-150 minutes
        targetIntensity,
        progressionNote,
        recentWorkouts,
        preferenceNotes,
      };

      console.log('🏋️ Starting workout generation', {
        workoutType,
        duration,
        experience,
        uid: uid ? `${uid.substring(0, 8)}...` : 'anonymous',
      });

      // Use new orchestrated generation with multi-pass validation
      const result = await generateWorkoutOrchestrated(workoutContext, client, uid);

      console.log('✅ Workout generated successfully', {
        exerciseCount: result.exercises?.length || 0,
        targetDuration: result.metadata?.targetDuration,
      });

      // Return workout with metadata
      res.json(result);
      return;
    } catch (e) {
      // Comprehensive error logging
      const errorMessage = e instanceof Error ? e.message : String(e);
      const errorStack = e instanceof Error ? e.stack : '';
      const errorCode = (e as Record<string, unknown>)?.code || 'UNKNOWN';
      const errorStatus = (e as Record<string, unknown>)?.status || 'UNKNOWN';
      const errorType = (e as Record<string, unknown>)?.type || 'UNKNOWN';

      console.error('❌ Workout generation error', {
        message: errorMessage,
        stack: errorStack,
        type: e instanceof Error ? e.constructor.name : typeof e,
        code: errorCode,
        status: errorStatus,
        errorType,
      });

      // Return appropriate error response based on error type
      if (e instanceof Error) {
        // Timeout errors
        if (
          e.message.includes('timeout') ||
          e.message.includes('ETIMEDOUT') ||
          e.message.includes('Stream timeout')
        ) {
          console.warn('⏱️ Timeout error detected');
          res.status(504).json({
            error: 'Request timeout',
            details: 'Workout generation took too long. Please try again.',
            retryable: true,
          });
          return;
        }

        // Authentication/Authorization errors
        if (
          errorStatus === 401 ||
          errorStatus === 403 ||
          e.message.includes('Unauthorized') ||
          e.message.includes('Forbidden')
        ) {
          console.error('🔐 Authentication error detected');
          res.status(502).json({
            error: 'AI service configuration error',
            details: 'Please try again later',
            retryable: false,
          });
          return;
        }

        // Rate limiting
        if (
          errorStatus === 429 ||
          e.message.includes('rate_limit') ||
          e.message.includes('Too many requests')
        ) {
          console.warn('⚠️ Rate limit error detected');
          res.status(429).json({
            error: 'Too many requests',
            details: 'Please wait a moment and try again',
            retryable: true,
          });
          return;
        }

        // Server errors from OpenAI
        if (
          errorStatus === 500 ||
          errorStatus === 502 ||
          errorStatus === 503 ||
          errorStatus === 504
        ) {
          console.error('🔴 OpenAI server error detected:', { status: errorStatus });
          res.status(502).json({
            error: 'AI service temporarily unavailable',
            details: 'Please try again in a moment',
            retryable: true,
          });
          return;
        }

        // Validation errors - treat as retryable server error
        if (e.message.includes('Validation failed')) {
          console.warn('❌ Validation error detected');
          res.status(500).json({
            error: 'Workout validation error',
            details: 'The generated workout did not meet quality standards. Please try again.',
            retryable: true,
          });
          return;
        }

        // JSON parsing errors
        if (e.message.includes('JSON') || e.message.includes('parse')) {
          console.warn('❌ JSON parsing error detected');
          res.status(502).json({
            error: 'AI response format error',
            details: 'The AI service returned an invalid response. Please try again.',
            retryable: true,
          });
          return;
        }
      }

      // Generic server error - always retryable
      console.error('🔴 Unhandled error in workout generation:', errorMessage);
      res.status(500).json({
        error: 'Workout generation service error',
        details: 'An unexpected error occurred. Please try again in a moment.',
        retryable: true,
      });
      return;
    }
  },
);

/**
 * Add an exercise to an existing workout
 * Takes the current workout context and generates one additional exercise
 */
export const addExerciseToWorkout = onRequest(
  {
    cors: CORS_ORIGINS,
    region: 'us-central1',
    secrets: [openaiApiKey],
    timeoutSeconds: 60,
    memory: '512MiB',
  },
  async (req: Request, res: Response) => {
    if (req.method !== 'POST') {
      res.status(405).json({ error: 'Method not allowed' });
      return;
    }

    try {
      const { currentWorkout, workoutType, experience, goals, equipment, injuries } = req.body;

      // Validate request body
      if (!req.body) {
        console.error('Empty request body');
        res.status(400).json({ error: 'Request body is required' });
        return;
      }

      // Validate currentWorkout structure
      if (!currentWorkout) {
        console.error('Missing currentWorkout in request body');
        res.status(400).json({ error: 'currentWorkout is required' });
        return;
      }

      if (!Array.isArray(currentWorkout.exercises)) {
        console.error('currentWorkout.exercises is not an array:', typeof currentWorkout.exercises, currentWorkout.exercises);
        res.status(400).json({ error: 'currentWorkout.exercises must be an array' });
        return;
      }

      if (currentWorkout.exercises.length === 0) {
        console.error('currentWorkout.exercises is empty');
        res.status(400).json({ error: 'currentWorkout must have at least one exercise' });
        return;
      }

      const client = new OpenAI({
        apiKey: openaiApiKey.value(),
        timeout: OPENAI_CONFIG.timeout, // Use config timeout (120s)
      });

      const existingExercises = currentWorkout.exercises.map((ex: { name: string }) => ex.name).join(', ');
      const programming = getProgrammingRecommendations(goals || ['General Health'], experience || 'Beginner');

      // Get workout type context for better exercise matching
      const workoutTypeGuidance = getWorkoutTypeContext(workoutType);

      // Determine if this is a time-based workout
      const isTimeBasedWorkout = workoutType && ['Cardio', 'Yoga', 'Pilates', 'Core Focus', 'HIIT'].includes(workoutType);
      const repFormat = isTimeBasedWorkout ? '"45s" (time format)' : '"8-12" (range format)';
      const repInstruction = isTimeBasedWorkout
        ? '⚠️ CRITICAL: This is a time-based workout - reps MUST use time format like "30s", "45s", "60s" (NOT ranges like "8-12")'
        : 'Use rep range format like "8-12", "6-10", "12-15"';

      const prompt = `You are adding ONE additional exercise to an existing ${workoutType || 'Full Body'} workout.

⚠️ CRITICAL: The exercise you generate MUST be completely different from all existing exercises.

EXISTING EXERCISES IN WORKOUT (ABSOLUTELY DO NOT DUPLICATE OR USE SIMILAR VARIATIONS):
${existingExercises}

CLIENT PROFILE:
- Experience: ${experience || 'Beginner'}
- Goals: ${(goals || ['General Health']).join(', ')}
- Equipment: ${(equipment || ['Bodyweight']).join(', ')}
- Workout Type: ${workoutType || 'Full Body'}
${injuries?.list?.length > 0 ? `- Injuries: ${injuries.list.join(', ')} - ${injuries.notes || ''}` : ''}

WORKOUT TYPE GUIDANCE FOR ${workoutType || 'Full Body'}:
${workoutTypeGuidance}

CRITICAL REQUIREMENTS:
1. Generate ONE exercise that complements the existing workout
2. ⚠️ ABSOLUTELY DO NOT duplicate or use variations of existing exercises
   - If "Dumbbell Bench Press" exists, DO NOT use "Dumbbell Incline Press" or "Dumbbell Close-Grip Press"
   - If "Barbell Row" exists, DO NOT use "Dumbbell Row" or "Cable Row"
   - Choose a COMPLETELY DIFFERENT exercise targeting different movement patterns
3. MUST match the workout type: ${workoutType || 'Full Body'}
   - The exercise MUST align with the workout type guidance above
   - Use the example exercises and movement patterns as reference
   - Upper Body: Only chest, back, shoulders exercises
   - Lower Body: Only legs, glutes, hamstrings, quads exercises
   - Full Body: Balance of upper and lower body
   - Legs/Glutes: Hip-dominant and glute-focused movements
   - Chest/Triceps: Chest pressing and tricep isolation
   - Back/Biceps: Pulling movements and bicep work
   - Shoulders: Deltoid-focused exercises (front, side, rear)
   - Core Focus: Anti-extension, anti-rotation, stability
   - Cardio: Cardiovascular conditioning movements
   - HIIT: High-intensity explosive movements
   - Yoga: Flexibility and balance poses
   - Pilates: Core-focused controlled movements
4. Target muscle groups that are underrepresented in the current workout
5. Follow programming guidelines: ${programming.sets?.[0]}-${programming.sets?.[1]} sets, ${isTimeBasedWorkout ? 'time-based reps (30s, 45s, 60s)' : `${programming.reps?.[0]}-${programming.reps?.[1]} reps`}, ${programming.restSeconds?.[0]}-${programming.restSeconds?.[1]}s rest
6. Match the difficulty level: ${(experience || 'beginner').toLowerCase()}
7. Avoid contraindicated exercises if injuries are present
8. Use ONLY available equipment: ${(equipment || ['Bodyweight']).join(', ')}
9. ⚠️ BEFORE OUTPUTTING: Verify the exercise name is NOT similar to any existing exercise

REP FORMAT REQUIREMENT:
${repInstruction}

ALL FIELDS ARE MANDATORY - OUTPUT ONLY valid JSON (no markdown, no code blocks):
{
  "name": "Exercise Name (MUST be completely unique and different from existing exercises)",
  "description": "Detailed description with setup, execution, and breathing cues (100-150 chars)",
  "sets": 3,
  "reps": ${repFormat},
  "formTips": ["First form tip - specific and actionable", "Second form tip - addresses common error", "Third form tip - joint alignment or quality cue"],
  "safetyTips": ["First safety tip - injury prevention", "Second safety tip - modification option"],
  "restSeconds": 90,
  "usesWeight": ${isTimeBasedWorkout ? 'false' : 'true'},
  "muscleGroups": ["muscle1", "muscle2"],
  "difficulty": "${(experience || 'beginner').toLowerCase()}"
}`;

      const completion = await client.chat.completions.create({
        model: 'gpt-4o-mini',
        temperature: 0.3,
        max_tokens: 800,
        response_format: { type: 'json_object' },
        messages: [
          {
            role: 'system',
            content:
              'You are an expert personal trainer. Generate ONE exercise that complements an existing workout. The exercise MUST be completely unique and different from all existing exercises - no variations or similar movements. Output ONLY valid JSON with no markdown formatting.',
          },
          { role: 'user', content: prompt },
        ],
      });

      const text = completion.choices[0]?.message?.content?.trim() || '';
      const cleanedText = text.replace(/^```json\s*/i, '').replace(/\s*```$/i, '').trim();

      const exercise = JSON.parse(cleanedText);

      // Validate that the new exercise is not similar to existing ones
      const existingNames = currentWorkout.exercises.map((ex: { name: string }) => ex.name);
      const hasSimilar = existingNames.some((name: string) => isSimilarExercise(name, exercise.name));

      if (hasSimilar) {
        console.warn('Generated exercise is too similar to existing exercises:', exercise.name);
        res.status(400).json({
          error: 'Generated exercise is too similar to existing exercises',
          exercise: exercise.name,
        });
        return;
      }

      // Validate exercise matches workout type, equipment, and rep format
      const contextErrors = getExerciseContextValidationErrors(
        exercise.name,
        exercise.reps,
        workoutType || 'Full Body',
        equipment || ['Bodyweight'],
      );

      if (contextErrors.length > 0) {
        console.warn('Generated exercise failed context validation:', contextErrors);
        res.status(400).json({
          error: 'Generated exercise does not match workout context',
          details: contextErrors,
          exercise: exercise.name,
        });
        return;
      }

      res.status(200).json({ exercise });
    } catch (e) {
      const errorMsg = e instanceof Error ? e.message : String(e);
      console.error('Add exercise error:', {
        error: errorMsg,
        stack: e instanceof Error ? e.stack : undefined,
        requestBody: req.body ? Object.keys(req.body) : 'no body',
      });
      res.status(500).json({
        error: 'Failed to add exercise',
        details: process.env.NODE_ENV === 'development' ? errorMsg : undefined,
      });
    }
  },
);

/**
 * Swap an exercise with a similar alternative
 * Takes the exercise to replace and generates a similar but different exercise
 */
export const swapExercise = onRequest(
  {
    cors: CORS_ORIGINS,
    region: 'us-central1',
    secrets: [openaiApiKey],
    timeoutSeconds: 60,
    memory: '512MiB',
  },
  async (req: Request, res: Response) => {
    if (req.method !== 'POST') {
      res.status(405).json({ error: 'Method not allowed' });
      return;
    }

    try {
      const { exerciseToReplace, currentWorkout, workoutType, experience, goals, equipment, injuries } = req.body;

      if (!exerciseToReplace?.name || !currentWorkout?.exercises) {
        res.status(400).json({ error: 'Invalid request data' });
        return;
      }

      const client = new OpenAI({
        apiKey: openaiApiKey.value(),
        timeout: 90000, // 90 second timeout
      });

      const otherExercises = currentWorkout.exercises
        .filter((ex: { name: string }) => ex.name !== exerciseToReplace.name)
        .map((ex: { name: string }) => ex.name)
        .join(', ');

      // Determine if this is a time-based workout
      const isTimeBasedWorkout = workoutType && ['Cardio', 'Yoga', 'Pilates', 'Core Focus', 'HIIT'].includes(workoutType);
      const repInstruction = isTimeBasedWorkout
        ? '⚠️ CRITICAL: This is a time-based workout - reps MUST use time format like "30s", "45s", "60s" (NOT ranges like "8-12")'
        : 'Use the same rep format as the original exercise';

      const prompt = `You are replacing an exercise in a ${workoutType || 'Full Body'} workout with a similar alternative.

EXERCISE TO REPLACE:
- Name: ${exerciseToReplace.name}
- Muscle Groups: ${exerciseToReplace.muscleGroups?.join(', ') || 'N/A'}
- Sets: ${exerciseToReplace.sets}, Reps: ${exerciseToReplace.reps}
- Rest: ${exerciseToReplace.restSeconds || 90}s
- Uses Weight: ${exerciseToReplace.usesWeight ? 'Yes' : 'No'}

OTHER EXERCISES IN WORKOUT (ABSOLUTELY DO NOT DUPLICATE):
${otherExercises}

CLIENT PROFILE:
- Experience: ${experience || 'Beginner'}
- Goals: ${(goals || ['General Health']).join(', ')}
- Equipment: ${(equipment || ['Bodyweight']).join(', ')}
- Workout Type: ${workoutType || 'Full Body'}
${injuries?.list?.length > 0 ? `- Injuries: ${injuries.list.join(', ')} - ${injuries.notes || ''}` : ''}

CRITICAL REQUIREMENTS:
1. Generate ONE exercise that targets the SAME or SIMILAR muscle groups as "${exerciseToReplace.name}"
2. Use a DIFFERENT movement pattern or equipment (acceptable variations):
   ✅ GOOD SWAPS (different movement pattern or equipment):
   - Barbell Bench Press → Cable Chest Press, Dumbbell Flyes, Push-ups, Dips
   - Barbell Row → Pull-ups, Lat Pulldown, Cable Row, Face Pulls
   - Barbell Squat → Leg Press, Bulgarian Split Squats, Goblet Squats
   - Dumbbell Curl → Cable Curl, Hammer Curl, Concentration Curl

   ❌ BAD SWAPS (too similar - just equipment change):
   - Barbell Bench Press → Dumbbell Bench Press (same movement, different equipment)
   - Barbell Row → Dumbbell Row (same movement, different equipment)
   - Barbell Squat → Dumbbell Squat (same movement, different equipment)

3. ⚠️ ABSOLUTELY DO NOT duplicate "${exerciseToReplace.name}" or any of these exercises: ${otherExercises}
4. MUST match the same sets/reps/rest scheme as the original exercise
5. Match the difficulty level: ${(experience || 'beginner').toLowerCase()}
6. Respect equipment availability: ${(equipment || ['Bodyweight']).join(', ')}
7. Avoid contraindicated exercises if injuries are present
8. The replacement should provide variety while maintaining workout effectiveness
9. ⚠️ BEFORE OUTPUTTING: Verify the exercise is NOT in the existing workout

REP FORMAT REQUIREMENT:
${repInstruction}

ALL FIELDS ARE MANDATORY - OUTPUT ONLY valid JSON (no markdown, no code blocks):
{
  "name": "Exercise Name (MUST be different from ${exerciseToReplace.name} and all other exercises)",
  "description": "Detailed description with setup, execution, and breathing cues (100-150 chars)",
  "sets": ${exerciseToReplace.sets},
  "reps": "${exerciseToReplace.reps}",
  "formTips": ["First form tip - specific and actionable", "Second form tip - addresses common error", "Third form tip - joint alignment or quality cue"],
  "safetyTips": ["First safety tip - injury prevention", "Second safety tip - modification option"],
  "restSeconds": ${exerciseToReplace.restSeconds || 90},
  "usesWeight": ${exerciseToReplace.usesWeight ? 'true' : 'false'},
  "muscleGroups": ["${exerciseToReplace.muscleGroups?.join('", "') || 'muscle1", "muscle2'}"],
  "difficulty": "${(experience || 'beginner').toLowerCase()}"
}`;

      const completion = await client.chat.completions.create({
        model: 'gpt-4o-mini',
        temperature: 0.3,
        max_tokens: 800,
        response_format: { type: 'json_object' },
        messages: [
          {
            role: 'system',
            content:
              'You are an expert personal trainer. Generate ONE exercise that replaces another while targeting the same muscles but using a DIFFERENT movement pattern. The replacement MUST NOT duplicate any existing exercises. Output ONLY valid JSON with no markdown formatting.',
          },
          { role: 'user', content: prompt },
        ],
      });

      const text = completion.choices[0]?.message?.content?.trim() || '';
      const cleanedText = text.replace(/^```json\s*/i, '').replace(/\s*```$/i, '').trim();

      const exercise = JSON.parse(cleanedText);

      // Validate that the replacement is not similar to existing exercises (except the one being replaced)
      const otherExerciseNames = currentWorkout.exercises
        .filter((ex: { name: string }) => ex.name !== exerciseToReplace.name)
        .map((ex: { name: string }) => ex.name);

      const hasSimilar = otherExerciseNames.some((name: string) => isSimilarExercise(name, exercise.name));

      if (hasSimilar) {
        console.warn('Replacement exercise is too similar to existing exercises:', exercise.name);
        res.status(400).json({
          error: 'Replacement exercise is too similar to existing exercises',
          exercise: exercise.name,
        });
        return;
      }

      // Check that it's not too similar to the original
      // For swaps, we allow different equipment variations (e.g., Cable Chest Press for Barbell Bench Press)
      // but reject minor variations (e.g., Dumbbell Bench Press for Barbell Bench Press)
      const isMinorVariation = isMinorExerciseVariation(exerciseToReplace.name, exercise.name);
      if (isMinorVariation) {
        console.warn('Replacement exercise is a minor variation of original:', exercise.name);
        res.status(400).json({
          error: 'Replacement exercise is too similar to the original exercise - please provide a different movement pattern',
          original: exerciseToReplace.name,
          replacement: exercise.name,
        });
        return;
      }

      // Validate exercise matches workout type, equipment, and rep format
      const contextErrors = getExerciseContextValidationErrors(
        exercise.name,
        exercise.reps,
        workoutType || 'Full Body',
        equipment || ['Bodyweight'],
      );

      if (contextErrors.length > 0) {
        console.warn('Replacement exercise failed context validation:', {
          exercise: exercise.name,
          reps: exercise.reps,
          workoutType,
          equipment,
          errors: contextErrors,
        });
        res.status(400).json({
          error: 'Replacement exercise does not match workout context',
          details: contextErrors,
          exercise: exercise.name,
        });
        return;
      }

      res.status(200).json({ exercise });
    } catch (e) {
      const errorMsg = e instanceof Error ? e.message : String(e);
      console.error('Swap exercise error', {
        error: errorMsg,
        stack: e instanceof Error ? e.stack : undefined,
      });
      res.status(500).json({ error: 'Failed to swap exercise' });
    }
  },
);


=================================================================================
FILE: functions/src/lib/appCheck.ts
=================================================================================
/**
 * Firebase App Check verification for Cloud Functions
 * Protects against abuse and unauthorized access
 */

import { getAppCheck } from 'firebase-admin/app-check';
import type { Request, Response } from 'express';

/**
 * Verify App Check token from request
 * Returns true if valid, false otherwise
 */
export async function verifyAppCheckToken(req: Request): Promise<boolean> {
  // Skip App Check in development/test environments
  if (process.env.FUNCTIONS_EMULATOR === 'true' || process.env.NODE_ENV === 'test') {
    console.log('⚠️  App Check skipped (emulator/test mode)');
    return true;
  }

  const appCheckToken = req.headers['x-firebase-appcheck'] as string | undefined;

  if (!appCheckToken) {
    console.warn('Missing App Check token');
    return false;
  }

  try {
    const appCheckClaims = await getAppCheck().verifyToken(appCheckToken);
    
    // Token is valid
    console.log('✅ App Check token verified', {
      appId: appCheckClaims.appId,
    });
    
    return true;
  } catch (error) {
    console.error('❌ App Check verification failed:', error);
    return false;
  }
}

/**
 * Middleware to enforce App Check
 * Returns 401 if App Check token is invalid
 */
export async function enforceAppCheck(
  req: Request,
  res: Response,
): Promise<boolean> {
  const isValid = await verifyAppCheckToken(req);

  if (!isValid) {
    res.status(401).json({
      error: 'Unauthorized',
      message: 'Invalid or missing App Check token',
    });
    return false;
  }

  return true;
}

/**
 * Optional App Check middleware
 * Logs warning but allows request if token is invalid
 */
export async function optionalAppCheck(req: Request): Promise<void> {
  const isValid = await verifyAppCheckToken(req);

  if (!isValid) {
    console.warn('⚠️  Request proceeding without valid App Check token');
  }
}


=================================================================================
FILE: functions/src/lib/cache.ts
=================================================================================
/**
 * Caching layer for AI-generated workouts
 * Uses Firestore for persistent, distributed caching with TTL
 * Includes inflight request coalescing to prevent duplicate concurrent requests
 */

import { getFirestore, Timestamp } from 'firebase-admin/firestore';
import { createHash } from 'crypto';
import { CACHE_CONFIG, OPENAI_MODEL } from '../config';

const db = getFirestore();

/**
 * Inflight request map for coalescing duplicate concurrent requests
 * Maps cache key to pending promise
 */
const inflightRequests = new Map<string, Promise<unknown>>();

/**
 * Workout context for cache key generation
 * Excludes PII like user IDs, names, emails
 */
export interface CacheableContext {
  experience?: string;
  goals?: string[];
  equipment?: string[];
  injuries?: {
    list?: string[];
    notes?: string;
  };
  workoutType?: string;
  duration?: number;
  targetIntensity?: number;
  progressionNote?: string;
  preferenceNotes?: string;
}

/**
 * Generate stable hash for workout context
 * Deterministic hash ensures identical requests hit cache
 * Includes model version and rounded intensity for better cache hits
 */
export function hashRequest(context: CacheableContext): string {
  // Round targetIntensity to 1 decimal place for better cache hits
  const roundedIntensity = context.targetIntensity
    ? Math.round(context.targetIntensity * 10) / 10
    : undefined;

  // Sort object keys for deterministic stringification
  const sortedContext = {
    // Include model version in cache key
    model: OPENAI_MODEL,
    duration: context.duration,
    equipment: context.equipment?.slice().sort(),
    experience: context.experience,
    goals: context.goals?.slice().sort(),
    injuries: context.injuries ? {
      list: context.injuries.list?.slice().sort(),
      notes: context.injuries.notes,
    } : undefined,
    preferenceNotes: context.preferenceNotes,
    progressionNote: context.progressionNote,
    targetIntensity: roundedIntensity,
    workoutType: context.workoutType,
  };

  const normalized = JSON.stringify(sortedContext);
  return createHash('sha256').update(normalized).digest('hex');
}

/**
 * Generate content hash for a workout plan
 * Used for deduplication and integrity verification
 */
export function hashWorkoutContent(workout: unknown): string {
  const normalized = JSON.stringify(workout);
  return createHash('sha256').update(normalized).digest('hex');
}

/**
 * Get cached workout or run generator function
 * Includes inflight request coalescing to prevent duplicate concurrent requests
 */
export async function getCachedOrRun<T>(
  cacheKey: string,
  runner: () => Promise<T>,
): Promise<T> {
  if (!CACHE_CONFIG.enabled) {
    return runner();
  }

  try {
    // Check if there's already an inflight request for this cache key
    const existingRequest = inflightRequests.get(cacheKey);
    if (existingRequest) {
      console.log('🔄 Coalescing duplicate request:', cacheKey.substring(0, 12));
      return existingRequest as Promise<T>;
    }

    // Try to get from cache
    const cacheDoc = await db
      .collection(CACHE_CONFIG.collectionName)
      .doc(cacheKey)
      .get();

    if (cacheDoc.exists) {
      const data = cacheDoc.data();

      if (data) {
        const expiresAt = data.expiresAt as Timestamp;
        const now = Timestamp.now();

        // Check if cache entry is still valid
        if (expiresAt.toMillis() > now.toMillis()) {
          console.log('✅ Cache hit:', cacheKey.substring(0, 12));
          return data.result as T;
        } else {
          console.log('⏰ Cache expired:', cacheKey.substring(0, 12));
          // Delete expired entry
          await cacheDoc.ref.delete();
        }
      }
    }

    // Cache miss - run generator and track inflight request
    console.log('❌ Cache miss:', cacheKey.substring(0, 12));

    const requestPromise = runner()
      .then(async (result) => {
        // Store in cache
        const expiresAt = Timestamp.fromMillis(
          Date.now() + CACHE_CONFIG.ttlHours * 60 * 60 * 1000,
        );

        await db
          .collection(CACHE_CONFIG.collectionName)
          .doc(cacheKey)
          .set({
            result,
            createdAt: Timestamp.now(),
            expiresAt,
            cacheKey,
          });

        console.log('💾 Cached result:', cacheKey.substring(0, 12));
        return result;
      })
      .finally(() => {
        // Remove from inflight requests when complete
        inflightRequests.delete(cacheKey);
      });

    // Track this request as inflight
    inflightRequests.set(cacheKey, requestPromise);

    return requestPromise;
  } catch (error) {
    // If cache fails, fall back to running generator
    console.error('Cache error, falling back to generator:', error);
    inflightRequests.delete(cacheKey);
    return runner();
  }
}

/**
 * Invalidate cache entry
 */
export async function invalidateCache(cacheKey: string): Promise<void> {
  try {
    await db
      .collection(CACHE_CONFIG.collectionName)
      .doc(cacheKey)
      .delete();
    console.log('🗑️  Invalidated cache:', cacheKey.substring(0, 12));
  } catch (error) {
    console.error('Error invalidating cache:', error);
  }
}

/**
 * Clear all expired cache entries
 * Should be run periodically (e.g., daily scheduled function)
 */
export async function clearExpiredCache(): Promise<number> {
  try {
    const now = Timestamp.now();
    const expiredDocs = await db
      .collection(CACHE_CONFIG.collectionName)
      .where('expiresAt', '<', now)
      .get();

    const batch = db.batch();
    expiredDocs.docs.forEach((doc) => {
      batch.delete(doc.ref);
    });

    await batch.commit();
    console.log(`🧹 Cleared ${expiredDocs.size} expired cache entries`);
    return expiredDocs.size;
  } catch (error) {
    console.error('Error clearing expired cache:', error);
    return 0;
  }
}

/**
 * Get cache statistics
 */
export async function getCacheStats(): Promise<{
  totalEntries: number;
  expiredEntries: number;
  validEntries: number;
}> {
  try {
    const allDocs = await db.collection(CACHE_CONFIG.collectionName).get();
    const now = Timestamp.now();

    let expiredCount = 0;
    let validCount = 0;

    allDocs.docs.forEach((doc) => {
      const data = doc.data();
      if (data && data.expiresAt) {
        const expiresAt = data.expiresAt as Timestamp;
        if (expiresAt.toMillis() > now.toMillis()) {
          validCount++;
        } else {
          expiredCount++;
        }
      }
    });

    return {
      totalEntries: allDocs.size,
      expiredEntries: expiredCount,
      validEntries: validCount,
    };
  } catch (error) {
    console.error('Error getting cache stats:', error);
    return {
      totalEntries: 0,
      expiredEntries: 0,
      validEntries: 0,
    };
  }
}


=================================================================================
FILE: functions/src/lib/deterministicSeed.ts
=================================================================================
/**
 * Deterministic seed generation for reproducible AI outputs
 * Derives a seed from the request context to reduce drift between repair passes
 */

import { createHash } from 'crypto';
import type { CacheableContext } from './cache';

/**
 * Generate a deterministic seed from the cacheable context
 * This ensures that identical requests produce identical seeds
 */
export function generateDeterministicSeed(context: CacheableContext): number {
  // Create a stable string representation of the context
  const seedString = JSON.stringify({
    workoutType: context.workoutType,
    duration: context.duration,
    experience: context.experience,
    goals: context.goals?.slice().sort(),
    equipment: context.equipment?.slice().sort(),
  });

  // Hash the string and convert to a number
  const hash = createHash('sha256').update(seedString).digest('hex');
  
  // Take first 8 characters and convert to integer
  // This gives us a consistent seed in the range 0 to 4,294,967,295
  const seed = parseInt(hash.substring(0, 8), 16);
  
  return seed;
}

/**
 * Add seed information to the system message for OpenAI
 * This helps maintain consistency across repair passes
 */
export function addSeedToSystemMessage(
  systemMessage: string,
  seed: number,
): string {
  return `${systemMessage}

CONSISTENCY SEED: ${seed}
Use this seed to maintain consistency in exercise selection and ordering across multiple generation attempts.`;
}


=================================================================================
FILE: functions/src/lib/durationAdjustment.test.ts
=================================================================================
/**
 * Tests for durationAdjustment module
 */

import { describe, it, expect } from 'vitest';
import {
  calculateWorkoutDuration,
  validateDuration,
  adjustWorkoutDuration,
  validateAndAdjustDuration,
} from './durationAdjustment';

describe('durationAdjustment', () => {
  describe('calculateWorkoutDuration', () => {
    it('should calculate duration for single exercise', () => {
      const workout = {
        exercises: [{ name: 'Squat', sets: 3, reps: '10', restSeconds: 90 }],
      };

      // 3 sets + (2 rest periods × 90s / 60) = 3 + 3 = 6 minutes
      const duration = calculateWorkoutDuration(workout);
      expect(duration).toBe(6);
    });

    it('should calculate duration for multiple exercises', () => {
      const workout = {
        exercises: [
          { name: 'Squat', sets: 4, reps: '8', restSeconds: 120 },
          { name: 'Bench Press', sets: 3, reps: '10', restSeconds: 90 },
        ],
      };

      // Exercise 1: 4 + (3 × 120/60) = 4 + 6 = 10 min
      // Exercise 2: 3 + (2 × 90/60) = 3 + 3 = 6 min
      // Total: 16 min
      const duration = calculateWorkoutDuration(workout);
      expect(duration).toBe(16);
    });

    it('should handle exercise with 1 set (no rest)', () => {
      const workout = {
        exercises: [{ name: 'Plank', sets: 1, reps: '60s', restSeconds: 0 }],
      };

      // 1 set + (0 rest periods) = 1 minute
      const duration = calculateWorkoutDuration(workout);
      expect(duration).toBe(1);
    });

    it('should handle empty workout', () => {
      const workout = { exercises: [] };

      const duration = calculateWorkoutDuration(workout);
      expect(duration).toBe(0);
    });
  });

  describe('validateDuration', () => {
    it('should validate workout within target range', () => {
      const workout = {
        exercises: [
          { name: 'Squat', sets: 4, reps: '8', restSeconds: 120 },
          { name: 'Bench Press', sets: 4, reps: '8', restSeconds: 120 },
          { name: 'Row', sets: 3, reps: '10', restSeconds: 90 },
        ],
      };

      // Total: 10 + 10 + 6 = 26 minutes (target 28 for ±3 range)
      const result = validateDuration(workout, 28);

      expect(result.isValid).toBe(true);
      expect(result.actualDuration).toBe(26);
      expect(result.difference).toBe(-2);
    });

    it('should invalidate workout too short', () => {
      const workout = {
        exercises: [{ name: 'Squat', sets: 3, reps: '10', restSeconds: 60 }],
      };

      // Total: 3 + 2 = 5 minutes (target 30)
      const result = validateDuration(workout, 30);

      expect(result.isValid).toBe(false);
      expect(result.difference).toBeLessThan(-3);
      expect(result.message).toContain('too short');
    });

    it('should invalidate workout too long', () => {
      const workout = {
        exercises: Array(10).fill({ name: 'Exercise', sets: 4, reps: '10', restSeconds: 120 }),
      };

      // Total: 10 × 10 = 100 minutes (target 30)
      const result = validateDuration(workout, 30);

      expect(result.isValid).toBe(false);
      expect(result.difference).toBeGreaterThan(3);
      expect(result.message).toContain('too long');
    });

    it('should accept workout exactly at target', () => {
      const workout = {
        exercises: [
          { name: 'Exercise 1', sets: 5, reps: '8', restSeconds: 120 },
          { name: 'Exercise 2', sets: 5, reps: '8', restSeconds: 120 },
          { name: 'Exercise 3', sets: 5, reps: '8', restSeconds: 120 },
        ],
      };

      // Total: 3 × 13 = 39 minutes
      const result = validateDuration(workout, 39);

      expect(result.isValid).toBe(true);
      expect(result.difference).toBe(0);
    });
  });

  describe('adjustWorkoutDuration', () => {
    it('should not adjust workout already within range', () => {
      const workout = {
        exercises: [
          { name: 'Squat', sets: 4, reps: '8', restSeconds: 120 },
          { name: 'Bench Press', sets: 4, reps: '8', restSeconds: 120 },
          { name: 'Row', sets: 3, reps: '10', restSeconds: 90 },
        ],
      };

      // Total: 26 minutes, target 28 (within ±3)
      const result = adjustWorkoutDuration(workout, 28, 3);

      expect(result.adjusted).toBe(false);
      expect(result.changes).toHaveLength(0);
    });

    it('should add sets when workout is too short', () => {
      const workout = {
        exercises: [
          { name: 'Squat', sets: 2, reps: '10', restSeconds: 60 },
          { name: 'Bench Press', sets: 2, reps: '10', restSeconds: 60 },
        ],
      };

      // Initial: 2 × 3 = 6 minutes (target 15 for reasonable adjustment)
      const result = adjustWorkoutDuration(workout, 15, 2);

      expect(result.adjusted).toBe(true);
      expect(result.changes.length).toBeGreaterThan(0);
      expect(result.changes.some((c) => c.includes('Added') || c.includes('adding'))).toBe(true);
    });

    it('should remove sets when workout is too long', () => {
      const workout = {
        exercises: [
          { name: 'Squat', sets: 6, reps: '8', restSeconds: 180 },
          { name: 'Bench Press', sets: 6, reps: '8', restSeconds: 180 },
          { name: 'Row', sets: 6, reps: '8', restSeconds: 180 },
        ],
      };

      // Initial: 3 × 21 = 63 minutes (target 50 for reasonable adjustment)
      const result = adjustWorkoutDuration(workout, 50, 3);

      expect(result.adjusted).toBe(true);
      expect(result.changes.some((c) => c.includes('removing'))).toBe(true);
    });

    it('should not adjust if difference is too large', () => {
      const workout = {
        exercises: [{ name: 'Squat', sets: 2, reps: '10', restSeconds: 60 }],
      };

      // Initial: 3 minutes (target 60) - difference > 20
      const result = adjustWorkoutDuration(workout, 60, 1);

      expect(result.adjusted).toBe(false);
      expect(result.changes.some((c) => c.includes('too large'))).toBe(true);
    });

    it('should not exceed 6 sets per exercise when adding', () => {
      const workout = {
        exercises: [{ name: 'Squat', sets: 5, reps: '10', restSeconds: 60 }],
      };

      const initialSets = workout.exercises[0]?.sets || 0;
      adjustWorkoutDuration(workout, 50, 1);

      expect(workout.exercises[0]?.sets).toBeLessThanOrEqual(6);
      expect(workout.exercises[0]?.sets).toBeGreaterThanOrEqual(initialSets);
    });

    it('should not go below 2 sets per exercise when removing', () => {
      const workout = {
        exercises: [{ name: 'Squat', sets: 3, reps: '10', restSeconds: 180 }],
      };

      adjustWorkoutDuration(workout, 2, 1);

      expect(workout.exercises[0]?.sets).toBeGreaterThanOrEqual(2);
    });
  });

  describe('validateAndAdjustDuration', () => {
    it('should return valid without adjustment if already in range', () => {
      const workout = {
        exercises: [
          { name: 'Squat', sets: 4, reps: '8', restSeconds: 120 },
          { name: 'Bench Press', sets: 4, reps: '8', restSeconds: 120 },
          { name: 'Row', sets: 3, reps: '10', restSeconds: 90 },
        ],
      };

      // Total: 26 minutes, target 28 (within ±3)
      const result = validateAndAdjustDuration(workout, 28, 3);

      expect(result.isValid).toBe(true);
      expect(result.adjusted).toBe(false);
    });

    it('should adjust and validate successfully', () => {
      const workout = {
        exercises: [
          { name: 'Squat', sets: 2, reps: '10', restSeconds: 90 },
          { name: 'Bench Press', sets: 2, reps: '10', restSeconds: 90 },
          { name: 'Row', sets: 2, reps: '10', restSeconds: 90 },
        ],
      };

      const result = validateAndAdjustDuration(workout, 20, 3);

      expect(result.adjusted).toBe(true);
      expect(result.changes.length).toBeGreaterThan(0);
    });

    it('should accept workout within 10 minutes variance after adjustment', () => {
      const workout = {
        exercises: [
          { name: 'Squat', sets: 3, reps: '10', restSeconds: 120 },
          { name: 'Bench Press', sets: 3, reps: '10', restSeconds: 120 },
        ],
      };

      const result = validateAndAdjustDuration(workout, 20, 2);

      // Even if not perfect, should accept within 10 min variance
      expect(result.isValid).toBe(true);
    });

    it('should return error if variance exceeds 10 minutes after adjustment', () => {
      const workout = {
        exercises: [{ name: 'Squat', sets: 2, reps: '10', restSeconds: 60 }],
      };

      const result = validateAndAdjustDuration(workout, 60, 1);

      expect(result.error).toBeDefined();
      expect(result.error).toContain('exceeds acceptable variance');
    });
  });
});


=================================================================================
FILE: functions/src/lib/durationAdjustment.ts
=================================================================================
/**
 * Duration adjustment and validation for AI-generated workouts
 * Ensures workouts match requested duration through automatic adjustments
 */

export interface Exercise {
  name: string;
  sets: number;
  reps: number | string;
  restSeconds: number;
}

export interface Workout {
  exercises: Exercise[];
}

export interface ProgrammingContext {
  sets: [number, number];
  reps: [number, number];
  restSeconds: [number, number];
  intensity: string;
}

/**
 * Parse reps field to extract time in seconds for time-based exercises
 * Returns null if not a time-based exercise
 * Handles both single time ("30s") and time ranges ("30-45s")
 */
function parseTimeBasedReps(reps: number | string): number | null {
  if (typeof reps !== 'string') {
    return null;
  }

  // Match patterns like "30s", "45s", "60s"
  const singleTimeMatch = reps.match(/^(\d+)s$/i);
  if (singleTimeMatch && singleTimeMatch[1]) {
    return parseInt(singleTimeMatch[1], 10);
  }

  // Match time range patterns like "30-45s"
  const rangeTimeMatch = reps.match(/^(\d+)-(\d+)s$/i);
  if (rangeTimeMatch && rangeTimeMatch[1] && rangeTimeMatch[2]) {
    // Use the average of the range
    const min = parseInt(rangeTimeMatch[1], 10);
    const max = parseInt(rangeTimeMatch[2], 10);
    return (min + max) / 2;
  }

  return null;
}

/**
 * Calculate total workout duration in minutes
 * Handles both regular rep-based and time-based exercises
 */
export function calculateWorkoutDuration(workout: Workout): number {
  let totalTime = 0;

  workout.exercises.forEach((ex) => {
    // Check if this is a time-based exercise (e.g., "30s")
    const timeSeconds = parseTimeBasedReps(ex.reps);

    let workTime: number;
    if (timeSeconds !== null) {
      // Time-based exercise: sets × time per set (in minutes)
      workTime = ex.sets * (timeSeconds / 60);
    } else {
      // Regular rep-based exercise: assume 1 minute per set for execution
      workTime = ex.sets;
    }

    const restTime = (ex.sets - 1) * (ex.restSeconds / 60);
    totalTime += workTime + restTime;
  });

  return totalTime;
}

/**
 * Calculate dynamic duration variance based on workout duration
 * Longer workouts naturally have more variance
 */
function calculateDurationVariance(targetDuration: number): number {
  if (targetDuration >= 90) {
    return Math.ceil(targetDuration * 0.15); // ±15% for 90+ min workouts (more lenient)
  } else if (targetDuration >= 60) {
    return Math.ceil(targetDuration * 0.1); // ±10% for 60-89 min workouts
  } else if (targetDuration >= 45) {
    return 5; // ±5 min for 45-59 min workouts
  } else if (targetDuration >= 30) {
    return 4; // ±4 min for 30-44 min workouts
  }
  return 3; // ±3 min for workouts < 30 min
}

/**
 * Validate workout duration against target
 * Returns validation result with details
 */
export function validateDuration(
  workout: Workout,
  targetDuration: number,
): {
  isValid: boolean;
  actualDuration: number;
  difference: number;
  message: string;
} {
  const actualDuration = calculateWorkoutDuration(workout);
  const difference = actualDuration - targetDuration;
  const variance = calculateDurationVariance(targetDuration);

  const isValid = Math.abs(difference) <= variance;

  let message = '';
  if (isValid) {
    message = `Duration valid: ${actualDuration.toFixed(1)} min (target: ${targetDuration}±${variance} min)`;
  } else if (difference < 0) {
    message = `Duration too short: ${actualDuration.toFixed(1)} min (target: ${targetDuration} min, diff: ${Math.abs(difference).toFixed(1)} min)`;
  } else {
    message = `Duration too long: ${actualDuration.toFixed(1)} min (target: ${targetDuration} min, diff: ${difference.toFixed(1)} min)`;
  }

  return {
    isValid,
    actualDuration,
    difference,
    message,
  };
}

/**
 * Auto-adjust workout duration to match target
 * Modifies sets to bring duration within acceptable range
 */
export function adjustWorkoutDuration(
  workout: Workout,
  targetDuration: number,
  _minExerciseCount: number,
): {
  adjusted: boolean;
  changes: string[];
  finalDuration: number;
} {
  const changes: string[] = [];
  let adjusted = false;

  const validation = validateDuration(workout, targetDuration);

  // If already valid, no adjustment needed
  if (validation.isValid) {
    return {
      adjusted: false,
      changes: [],
      finalDuration: validation.actualDuration,
    };
  }

  // Allow auto-adjustment for larger differences (up to 50 minutes)
  // This is needed for longer workouts where AI might generate too many sets
  if (Math.abs(validation.difference) > 50) {
    changes.push(
      `Duration difference too large (${Math.abs(validation.difference).toFixed(1)} min) - cannot auto-adjust`,
    );
    return {
      adjusted: false,
      changes,
      finalDuration: validation.actualDuration,
    };
  }

  const timeDiff = validation.difference;

  if (timeDiff < 0) {
    // Workout is too short - add sets to exercises
    const avgRestPerSet = workout.exercises.reduce((sum, ex) => sum + ex.restSeconds, 0) / workout.exercises.length;

    // More accurate calculation: each set adds ~(1 min work + rest time)
    const timePerSet = 1 + (avgRestPerSet / 60);
    const setsNeeded = Math.ceil(Math.abs(timeDiff) / timePerSet);

    changes.push(`Workout too short by ${Math.abs(timeDiff).toFixed(1)} min - need to add ~${setsNeeded} sets`);

    let setsAdded = 0;
    let attempts = 0;
    const maxAttempts = workout.exercises.length * 3; // Allow multiple passes

    // Add sets more aggressively - prioritize compound movements (first exercises)
    while (setsAdded < setsNeeded && attempts < maxAttempts) {
      for (let i = 0; i < workout.exercises.length && setsAdded < setsNeeded; i++) {
        const exercise = workout.exercises[i];
        if (exercise && exercise.sets < 6) {
          // Don't exceed 6 sets
          exercise.sets += 1;
          setsAdded++;
          adjusted = true;
          changes.push(`  Added 1 set to "${exercise.name}" (now ${exercise.sets} sets)`);
        }
      }
      attempts++;
    }

    changes.push(`Total sets added: ${setsAdded}`);
  } else {
    // Workout is too long - reduce sets from exercises
    const avgExerciseTime = validation.actualDuration / workout.exercises.length;
    const setsToRemove = Math.ceil(timeDiff / (avgExerciseTime / 3));

    changes.push(`Workout too long by ${timeDiff.toFixed(1)} min - removing ~${setsToRemove} sets`);

    let setsRemoved = 0;
    let attempts = 0;
    const maxAttempts = workout.exercises.length * 5; // Allow multiple passes

    // Remove from end of workout first (typically isolation exercises)
    // More aggressive: remove multiple sets at a time for large differences
    while (setsRemoved < setsToRemove && attempts < maxAttempts) {
      for (let i = workout.exercises.length - 1; i >= 0 && setsRemoved < setsToRemove; i--) {
        const exercise = workout.exercises[i];
        if (exercise && exercise.sets > 2) {
          // For very large differences (>20 min), be more aggressive
          let setsToRemoveFromExercise = 1;
          if (timeDiff > 20 && exercise.sets > 3) {
            setsToRemoveFromExercise = 2;
          } else if (timeDiff > 10 && exercise.sets > 3) {
            setsToRemoveFromExercise = 1;
          }

          exercise.sets -= setsToRemoveFromExercise;
          setsRemoved += setsToRemoveFromExercise;
          adjusted = true;
        }
      }
      attempts++;
    }

    changes.push(`Removed ${setsRemoved} sets from exercises`);
  }

  // Recalculate final duration
  const finalDuration = calculateWorkoutDuration(workout);
  changes.push(`Final duration: ${finalDuration.toFixed(1)} min (target: ${targetDuration} min)`);

  return {
    adjusted,
    changes,
    finalDuration,
  };
}

/**
 * Compute min/max exercise count based on duration and programming
 * Used by prompt builder and schema to set dynamic constraints
 */
export function computeMinMaxExerciseCount(
  duration: number,
  programming: ProgrammingContext,
  workoutType?: string,
): { min: number; max: number; warmupMin: number } {
  const isTimeBasedWorkout = workoutType && [
    'Cardio',
    'Yoga',
    'Pilates',
    'Core Focus',
    'HIIT',
    'Abs',
  ].includes(workoutType);

  // Warmup time allocation
  // For very short workouts (20-25 min), reduce warmup time to avoid over-allocation
  const warmupTimeMinutes = duration >= 30 ? 2.5 : (duration >= 20 ? 1.5 : 0);
  const availableWorkoutMinutes = duration - warmupTimeMinutes;

  let avgTimePerExercise: number;

  if (isTimeBasedWorkout) {
    // For time-based workouts, assume 30-45s work periods
    const avgWorkSeconds = 40;
    const avgSetsPerExercise = (programming.sets[0] + programming.sets[1]) / 2;
    const avgRestPerSet = (programming.restSeconds[0] + programming.restSeconds[1]) / 2;
    avgTimePerExercise = avgSetsPerExercise * (avgWorkSeconds / 60) + ((avgSetsPerExercise - 1) * avgRestPerSet) / 60;
  } else {
    // For strength workouts
    const avgSetsPerExercise = (programming.sets[0] + programming.sets[1]) / 2;
    const avgRestPerSet = (programming.restSeconds[0] + programming.restSeconds[1]) / 2;
    avgTimePerExercise = avgSetsPerExercise + ((avgSetsPerExercise - 1) * avgRestPerSet) / 60;
  }

  const targetExerciseCount = Math.max(3, Math.floor(availableWorkoutMinutes / avgTimePerExercise));

  // For very long workouts (75+ min), allow more exercises to fill the time
  // Don't cap too aggressively - let the AI generate enough exercises for the duration
  let maxExerciseCount = targetExerciseCount + 2;
  let minExerciseCount = Math.max(2, targetExerciseCount - 2);

  if (duration >= 120) {
    // For 120+ min workouts, allow up to 10 exercises
    maxExerciseCount = Math.min(maxExerciseCount, 10);
    minExerciseCount = Math.max(6, Math.min(minExerciseCount, 8));
  } else if (duration >= 90) {
    // For 90-119 min workouts, allow up to 8 exercises
    maxExerciseCount = Math.min(maxExerciseCount, 8);
    minExerciseCount = Math.max(5, Math.min(minExerciseCount, 6));
  } else if (duration >= 75) {
    // For 75-89 min workouts, allow up to 7 exercises
    maxExerciseCount = Math.min(maxExerciseCount, 7);
    minExerciseCount = Math.max(4, Math.min(minExerciseCount, 5));
  }

  return {
    min: minExerciseCount,
    max: maxExerciseCount,
    warmupMin: warmupTimeMinutes > 0 ? 1 : 0,
  };
}

/**
 * Validate and adjust workout duration
 * Returns final validation result after adjustments
 */
export function validateAndAdjustDuration(
  workout: Workout,
  targetDuration: number,
  minExerciseCount: number,
): {
  isValid: boolean;
  actualDuration: number;
  difference: number;
  adjusted: boolean;
  changes: string[];
  error?: string;
} {
  // Initial validation
  const initialValidation = validateDuration(workout, targetDuration);

  // If valid, return immediately
  if (initialValidation.isValid) {
    return {
      ...initialValidation,
      adjusted: false,
      changes: [],
    };
  }

  // Attempt auto-adjustment
  const adjustment = adjustWorkoutDuration(workout, targetDuration, minExerciseCount);

  // Final validation after adjustment
  const finalValidation = validateDuration(workout, targetDuration);

  // Check if adjustment was successful
  if (finalValidation.isValid) {
    return {
      ...finalValidation,
      adjusted: adjustment.adjusted,
      changes: adjustment.changes,
    };
  }

  // If still not valid after adjustment, check if it's within acceptable variance
  const finalDiff = Math.abs(finalValidation.difference);

  // Dynamic variance based on workout duration
  // Longer workouts naturally have more variance due to complexity
  // Use percentage-based variance for very long workouts
  let acceptableVariance = 3;
  if (targetDuration >= 90) {
    // For 90+ min workouts, allow ±10% variance (e.g., ±12 min for 120 min workout)
    acceptableVariance = Math.ceil(targetDuration * 0.1);
  } else if (targetDuration >= 60) {
    // For 60-89 min workouts, allow ±8% variance (e.g., ±6 min for 75 min workout)
    acceptableVariance = Math.ceil(targetDuration * 0.08);
  } else if (targetDuration >= 45) {
    // For 45-59 min workouts, allow ±4 min
    acceptableVariance = 4;
  }

  if (finalDiff <= acceptableVariance) {
    // Within acceptable variance
    return {
      ...finalValidation,
      isValid: true, // Accept with warning
      adjusted: adjustment.adjusted,
      changes: [
        ...adjustment.changes,
        `Duration variance of ${finalDiff.toFixed(1)} min is within acceptable range (±${acceptableVariance} min)`,
      ],
    };
  }

  // Exceeds acceptable variance even after adjustment
  return {
    ...finalValidation,
    adjusted: adjustment.adjusted,
    changes: adjustment.changes,
    error: `Duration mismatch exceeds acceptable variance: ${finalDiff.toFixed(1)} min difference (max: ±${acceptableVariance} min)`,
  };
}


=================================================================================
FILE: functions/src/lib/exerciseContextValidation.ts
=================================================================================
/**
 * Exercise context validation
 * Validates that exercises match workout type, equipment, and other constraints
 */

// Lenient validation - trust the AI-generated workouts
// Only enforce hard constraints for obvious mismatches

/**
 * Check if an exercise matches the workout type
 * Returns true if exercise is appropriate for the workout type
 * LENIENT: Only reject obvious mismatches (e.g., leg exercises for Upper Body)
 */
export function isExerciseMatchingWorkoutType(
  exerciseName: string,
  workoutType: string,
): boolean {
  const exerciseLower = exerciseName.toLowerCase();

  // Only enforce hard constraints - reject obvious mismatches
  // Upper Body should not have leg exercises
  if (workoutType === 'Upper Body' && (exerciseLower.includes('leg') || exerciseLower.includes('squat') || exerciseLower.includes('deadlift'))) {
    return false;
  }

  // Lower Body should not have upper body only exercises (bench, row, pull-up)
  if (workoutType === 'Lower Body' && (exerciseLower.includes('bench') || exerciseLower.includes('row') || exerciseLower.includes('pull-up'))) {
    return false;
  }

  // Trust the AI - allow most exercises
  return true;
}

/**
 * Check if an exercise uses only available equipment
 * Returns true if exercise uses only available equipment
 * LENIENT: Trust the AI - only reject if equipment is explicitly unavailable
 */
export function isExerciseUsingAvailableEquipment(
  exerciseName: string,
  availableEquipment: string[],
): boolean {
  const exerciseLower = exerciseName.toLowerCase();
  const availableLower = availableEquipment.map((e) => e.toLowerCase());

  // If user has "Full Gym" or similar, allow everything
  if (availableLower.some((eq) => eq.includes('full') || eq.includes('gym'))) {
    return true;
  }

  // Only enforce hard constraints for specific equipment
  // If exercise explicitly requires barbell and user only has bodyweight, reject
  if (exerciseLower.includes('barbell') && !availableLower.some((eq) => eq.includes('barbell'))) {
    // But allow if they have dumbbells (can substitute)
    if (!availableLower.some((eq) => eq.includes('dumbbell'))) {
      return false;
    }
  }

  // If exercise requires cable machine and user doesn't have it, reject
  if (exerciseLower.includes('cable') && !availableLower.some((eq) => eq.includes('cable'))) {
    return false;
  }

  // Trust the AI for most equipment combinations
  return true;
}

/**
 * Validate rep format matches workout type
 * LENIENT: Trust the AI - only reject obviously invalid formats
 */
export function isRepFormatMatchingWorkoutType(
  reps: string | number,
  _workoutType: string,
): boolean {
  // Accept any numeric value
  if (typeof reps === 'number') {
    return true;
  }

  // Accept any string that looks like a valid rep format
  // Allow: "8-12", "30s", "45s", "30-45s", "10", "45", etc.
  if (typeof reps === 'string') {
    // Must contain at least one digit
    if (!/\d/.test(reps)) {
      return false;
    }
    // Allow digits, hyphens, and 's' suffix
    return /^[\d\-s]+$/.test(reps);
  }

  return true;
}

/**
 * Get validation errors for an exercise in context
 */
export function getExerciseContextValidationErrors(
  exerciseName: string,
  reps: string | number,
  workoutType: string,
  availableEquipment: string[],
): string[] {
  const errors: string[] = [];
  
  if (!isExerciseMatchingWorkoutType(exerciseName, workoutType)) {
    errors.push(`Exercise "${exerciseName}" does not match ${workoutType} workout type`);
  }
  
  if (!isExerciseUsingAvailableEquipment(exerciseName, availableEquipment)) {
    errors.push(`Exercise "${exerciseName}" requires equipment not available: ${availableEquipment.join(', ')}`);
  }
  
  if (!isRepFormatMatchingWorkoutType(reps, workoutType)) {
    const isTimeBasedWorkout = ['Cardio', 'Yoga', 'Pilates', 'Core Focus', 'HIIT', 'Abs'].includes(workoutType);
    const expectedFormat = isTimeBasedWorkout ? 'time format (e.g., "30s", "45s")' : 'rep range format (e.g., "8-12")';
    errors.push(`Exercise "${exerciseName}" has invalid rep format "${reps}". Expected ${expectedFormat}`);
  }
  
  return errors;
}


=================================================================================
FILE: functions/src/lib/exerciseDatabase.test.ts
=================================================================================
/**
 * Tests for exerciseDatabase module
 */

import { describe, it, expect } from 'vitest';
import {
  getProgrammingRecommendations,
  getExperienceGuidance,
  PROGRAMMING_GUIDELINES,
  EXPERIENCE_ADJUSTMENTS,
} from './exerciseDatabase';

describe('exerciseDatabase', () => {
  describe('getProgrammingRecommendations', () => {
    it('should return strength programming for strength goals', () => {
      const result = getProgrammingRecommendations(['Build Strength'], 'Intermediate');

      expect(result.sets).toEqual(PROGRAMMING_GUIDELINES.strength.sets);
      expect(result.reps).toEqual(PROGRAMMING_GUIDELINES.strength.reps);
      expect(result.intensity).toBe(PROGRAMMING_GUIDELINES.strength.intensity);
    });

    it('should return hypertrophy programming for muscle building goals', () => {
      const result = getProgrammingRecommendations(['Build Muscle'], 'Intermediate');

      expect(result.sets).toEqual(PROGRAMMING_GUIDELINES.hypertrophy.sets);
      expect(result.reps).toEqual(PROGRAMMING_GUIDELINES.hypertrophy.reps);
      expect(result.intensity).toBe(PROGRAMMING_GUIDELINES.hypertrophy.intensity);
    });

    it('should return endurance programming for stamina goals', () => {
      const result = getProgrammingRecommendations(['Improve Stamina'], 'Intermediate');

      expect(result.sets).toEqual(PROGRAMMING_GUIDELINES.endurance.sets);
      expect(result.reps).toEqual(PROGRAMMING_GUIDELINES.endurance.reps);
      expect(result.intensity).toBe(PROGRAMMING_GUIDELINES.endurance.intensity);
    });

    it('should default to hypertrophy for general health goals', () => {
      const result = getProgrammingRecommendations(['General Health'], 'Intermediate');

      expect(result.sets).toEqual(PROGRAMMING_GUIDELINES.hypertrophy.sets);
      expect(result.reps).toEqual(PROGRAMMING_GUIDELINES.hypertrophy.reps);
    });

    it('should adjust rest periods for beginner experience level', () => {
      const result = getProgrammingRecommendations(['General Health'], 'Beginner');

      const baseRest = PROGRAMMING_GUIDELINES.hypertrophy.restSeconds;
      const adjustment = EXPERIENCE_ADJUSTMENTS.beginner.restAdjustment;

      expect(result.restSeconds).toEqual([
        Math.max(45, (baseRest?.[0] || 60) + adjustment),
        Math.max(60, (baseRest?.[1] || 120) + adjustment),
      ]);
    });

    it('should adjust rest periods for advanced experience level', () => {
      const result = getProgrammingRecommendations(['General Health'], 'Advanced');

      const baseRest = PROGRAMMING_GUIDELINES.hypertrophy.restSeconds;
      const adjustment = EXPERIENCE_ADJUSTMENTS.advanced.restAdjustment;

      expect(result.restSeconds).toEqual([
        Math.max(45, (baseRest?.[0] || 60) + adjustment),
        Math.max(60, (baseRest?.[1] || 120) + adjustment),
      ]);
    });

    it('should include experience adjustments in result', () => {
      const result = getProgrammingRecommendations(['General Health'], 'Beginner');

      expect(result.experienceAdjustments).toBeDefined();
      expect(result.experienceAdjustments?.volumeMultiplier).toBe(0.8);
      expect(result.experienceAdjustments?.restAdjustment).toBe(30);
    });

    it('should handle empty goals array', () => {
      const result = getProgrammingRecommendations([], 'Intermediate');

      // Should default to hypertrophy
      expect(result.sets).toEqual(PROGRAMMING_GUIDELINES.hypertrophy.sets);
    });

    it('should handle undefined experience level', () => {
      const result = getProgrammingRecommendations(['General Health'], '');

      // Should default to beginner
      expect(result.experienceAdjustments?.volumeMultiplier).toBe(0.8);
    });
  });

  describe('getExperienceGuidance', () => {
    it('should return beginner guidance for beginner level', () => {
      const guidance = getExperienceGuidance('Beginner');

      expect(guidance).toContain('BEGINNER');
      expect(guidance).toContain('bilateral, stable exercises');
      expect(guidance).toContain('0.8x standard volume');
    });

    it('should return intermediate guidance for intermediate level', () => {
      const guidance = getExperienceGuidance('Intermediate');

      expect(guidance).toContain('INTERMEDIATE');
      expect(guidance).toContain('movement quality');
      expect(guidance).toContain('1x standard volume');
    });

    it('should return advanced guidance for advanced level', () => {
      const guidance = getExperienceGuidance('Advanced');

      expect(guidance).toContain('ADVANCED');
      expect(guidance).toContain('explosive power');
      expect(guidance).toContain('1.2x standard volume');
    });

    it('should handle case-insensitive experience levels', () => {
      const guidance1 = getExperienceGuidance('BEGINNER');
      const guidance2 = getExperienceGuidance('beginner');

      expect(guidance1).toBe(guidance2);
    });

    it('should default to beginner for unknown experience levels', () => {
      const guidance = getExperienceGuidance('Unknown');

      // Should use beginner adjustments (0.8x volume, +30s rest)
      expect(guidance).toContain('0.8x standard volume');
      expect(guidance).toContain('+30 seconds');
    });

    it('should include volume adjustment information', () => {
      const guidance = getExperienceGuidance('Intermediate');

      expect(guidance).toContain('Volume Adjustment');
      expect(guidance).toContain('1x');
    });

    it('should include rest period adjustment information', () => {
      const guidance = getExperienceGuidance('Beginner');

      expect(guidance).toContain('Rest Period Adjustment');
      expect(guidance).toContain('+30 seconds');
    });

    it('should include form emphasis information', () => {
      const guidance = getExperienceGuidance('Advanced');

      expect(guidance).toContain('Form Emphasis');
      expect(guidance).toContain('advanced techniques');
    });
  });

  describe('PROGRAMMING_GUIDELINES', () => {
    it('should have valid strength guidelines', () => {
      const strength = PROGRAMMING_GUIDELINES.strength;

      expect(strength.sets).toHaveLength(2);
      expect(strength.reps).toHaveLength(2);
      expect(strength.restSeconds).toHaveLength(2);
      expect(strength.intensity).toBeTruthy();
    });

    it('should have valid hypertrophy guidelines', () => {
      const hypertrophy = PROGRAMMING_GUIDELINES.hypertrophy;

      expect(hypertrophy.sets).toHaveLength(2);
      expect(hypertrophy.reps).toHaveLength(2);
      expect(hypertrophy.restSeconds).toHaveLength(2);
      expect(hypertrophy.intensity).toBeTruthy();
    });

    it('should have valid endurance guidelines', () => {
      const endurance = PROGRAMMING_GUIDELINES.endurance;

      expect(endurance.sets).toHaveLength(2);
      expect(endurance.reps).toHaveLength(2);
      expect(endurance.restSeconds).toHaveLength(2);
      expect(endurance.intensity).toBeTruthy();
    });
  });

  describe('EXPERIENCE_ADJUSTMENTS', () => {
    it('should have adjustments for all experience levels', () => {
      expect(EXPERIENCE_ADJUSTMENTS.beginner).toBeDefined();
      expect(EXPERIENCE_ADJUSTMENTS.intermediate).toBeDefined();
      expect(EXPERIENCE_ADJUSTMENTS.advanced).toBeDefined();
    });

    it('should have beginner with higher volume multiplier than advanced', () => {
      expect(EXPERIENCE_ADJUSTMENTS.beginner.volumeMultiplier).toBeLessThan(
        EXPERIENCE_ADJUSTMENTS.advanced.volumeMultiplier,
      );
    });

    it('should have beginner with longer rest periods', () => {
      expect(EXPERIENCE_ADJUSTMENTS.beginner.restAdjustment).toBeGreaterThan(
        EXPERIENCE_ADJUSTMENTS.advanced.restAdjustment,
      );
    });

    it('should have intermediate with neutral adjustments', () => {
      expect(EXPERIENCE_ADJUSTMENTS.intermediate.volumeMultiplier).toBe(1.0);
      expect(EXPERIENCE_ADJUSTMENTS.intermediate.restAdjustment).toBe(0);
    });
  });
});


=================================================================================
FILE: functions/src/lib/exerciseDatabase.ts
=================================================================================
/**
 * Evidence-based programming guidelines for AI workout generation
 * Provides scientifically-backed set/rep/rest ranges based on training goals
 */

export interface ProgrammingGuidelines {
  strength: {
    sets: [number, number];
    reps: [number, number];
    restSeconds: [number, number];
    intensity: string;
  };
  hypertrophy: {
    sets: [number, number];
    reps: [number, number];
    restSeconds: [number, number];
    intensity: string;
  };
  endurance: {
    sets: [number, number];
    reps: [number, number];
    restSeconds: [number, number];
    intensity: string;
  };
}

// Evidence-based programming guidelines by goal
export const PROGRAMMING_GUIDELINES: ProgrammingGuidelines = {
  strength: {
    sets: [3, 6],
    reps: [1, 6],
    restSeconds: [150, 300],
    intensity: '85-100% 1RM',
  },
  hypertrophy: {
    sets: [3, 5],
    reps: [6, 12],
    restSeconds: [75, 150],
    intensity: '65-85% 1RM',
  },
  endurance: {
    sets: [2, 4],
    reps: [12, 25],
    restSeconds: [45, 90],
    intensity: '40-65% 1RM',
  },
};

/**
 * Experience-level adjustments for programming
 * Modifies base programming based on training experience
 */
export interface ExperienceLevelAdjustments {
  volumeMultiplier: number; // Multiplier for total sets
  intensityAdjustment: string; // Adjustment to intensity ranges
  complexityGuidance: string; // Exercise selection guidance
  restAdjustment: number; // Seconds to add/subtract from rest periods
  formEmphasis: string; // Focus areas for form cues
}

export const EXPERIENCE_ADJUSTMENTS: Record<string, ExperienceLevelAdjustments> = {
  beginner: {
    volumeMultiplier: 0.8, // Lower volume for beginners
    intensityAdjustment: 'Use lower end of intensity range (60-75% 1RM)',
    complexityGuidance:
      'Focus on bilateral, stable exercises. Prioritize machines and bodyweight. Avoid complex barbell movements.',
    restAdjustment: 30, // Extra rest for beginners
    formEmphasis:
      'Emphasize proper setup, controlled tempo, and full range of motion. Include detailed breathing cues.',
  },
  intermediate: {
    volumeMultiplier: 1.0, // Standard volume
    intensityAdjustment: 'Use mid-range intensity (70-85% 1RM)',
    complexityGuidance:
      'Include mix of bilateral and unilateral exercises. Free weights and cables. Moderate complexity barbell work.',
    restAdjustment: 0, // Standard rest periods
    formEmphasis:
      'Focus on movement quality, tempo control, and mind-muscle connection. Include technique refinements.',
  },
  advanced: {
    volumeMultiplier: 1.2, // Higher volume for advanced
    intensityAdjustment: 'Use full intensity range (75-95% 1RM)',
    complexityGuidance:
      'Include complex movements, advanced variations, and high-skill exercises. Olympic lifts and plyometrics appropriate.',
    restAdjustment: -15, // Shorter rest for advanced (better recovery)
    formEmphasis:
      'Emphasize advanced techniques, explosive power, and movement efficiency. Include performance optimization cues.',
  },
};

/**
 * Get programming recommendations based on user goals and experience level
 * Returns evidence-based set/rep/rest ranges adjusted for experience
 */
export function getProgrammingRecommendations(
  goals: string[],
  experience: string,
): Partial<ProgrammingGuidelines[keyof ProgrammingGuidelines]> & {
  experienceAdjustments?: ExperienceLevelAdjustments;
} {
  const primaryGoal = goals[0]?.toLowerCase() || 'general health';
  const experienceLevel = experience?.toLowerCase() || 'beginner';

  // Get base programming for goal
  let baseProgramming: Partial<ProgrammingGuidelines[keyof ProgrammingGuidelines]>;

  if (primaryGoal.includes('strength')) {
    baseProgramming = PROGRAMMING_GUIDELINES.strength;
  } else if (primaryGoal.includes('muscle') || primaryGoal.includes('tone')) {
    baseProgramming = PROGRAMMING_GUIDELINES.hypertrophy;
  } else if (primaryGoal.includes('stamina') || primaryGoal.includes('endurance')) {
    baseProgramming = PROGRAMMING_GUIDELINES.endurance;
  } else {
    // Default to hypertrophy for general fitness
    baseProgramming = PROGRAMMING_GUIDELINES.hypertrophy;
  }

  // Get experience-level adjustments
  const experienceAdjustments =
    EXPERIENCE_ADJUSTMENTS[experienceLevel] || EXPERIENCE_ADJUSTMENTS.beginner;

  // Apply experience-level adjustments to rest periods
  const restAdjustment = experienceAdjustments?.restAdjustment || 0;
  const adjustedRestSeconds: [number, number] = [
    Math.max(45, (baseProgramming.restSeconds?.[0] || 60) + restAdjustment),
    Math.max(60, (baseProgramming.restSeconds?.[1] || 120) + restAdjustment),
  ];

  return {
    ...baseProgramming,
    restSeconds: adjustedRestSeconds,
    experienceAdjustments,
  };
}

/**
 * Get experience-specific exercise selection guidance
 */
export function getExperienceGuidance(experience: string): string {
  const experienceLevel = experience?.toLowerCase() || 'beginner';
  const adjustments = EXPERIENCE_ADJUSTMENTS[experienceLevel] || EXPERIENCE_ADJUSTMENTS.beginner;

  if (!adjustments) {
    return '';
  }

  return `\n\nEXPERIENCE-LEVEL GUIDANCE (${experience.toUpperCase()}):
Volume Adjustment: ${adjustments.volumeMultiplier}x standard volume
Intensity: ${adjustments.intensityAdjustment}
Exercise Complexity: ${adjustments.complexityGuidance}
Rest Period Adjustment: ${adjustments.restAdjustment > 0 ? '+' : ''}${adjustments.restAdjustment} seconds
Form Emphasis: ${adjustments.formEmphasis}`;
}

/**
 * Get difficulty-specific exercise examples
 * Provides concrete examples for each difficulty level to guide AI selection
 */
export function getDifficultyExamples(experience: string): string {
  const experienceLevel = experience?.toLowerCase() || 'beginner';

  const examples: Record<string, string> = {
    beginner: `
BEGINNER EXERCISE EXAMPLES (Fundamental movements, bilateral, stable):
- Bodyweight: Push-ups, Squats, Lunges, Planks, Glute Bridges, Rows (assisted)
- Dumbbells: Dumbbell Bench Press, Goblet Squats, Dumbbell Rows, Shoulder Press
- Machines: Leg Press, Chest Press, Lat Pulldown, Leg Curl
- Avoid: Pistol squats, Single-leg deadlifts, Complex Olympic lifts, Advanced plyometrics`,

    intermediate: `
INTERMEDIATE EXERCISE EXAMPLES (Unilateral work, free weights, moderate complexity):
- Barbell: Barbell Squats, Deadlifts, Bench Press, Rows, Overhead Press
- Dumbbells: Single-arm rows, Bulgarian split squats, Dumbbell snatches
- Bodyweight: Pull-ups, Dips, Handstand holds, Pistol squat progressions
- Cables: Cable flyes, Pallof press, Cable rows
- Avoid: Advanced Olympic lift variations, Extreme plyometrics`,

    advanced: `
ADVANCED EXERCISE EXAMPLES (Complex movements, high skill, explosive):
- Olympic Lifts: Power cleans, Snatches, Clean and jerk variations
- Plyometrics: Box jumps, Broad jumps, Clapping push-ups, Explosive pull-ups
- Advanced Bodyweight: Muscle-ups, Handstand push-ups, Front lever progressions
- Unilateral: Single-leg deadlifts, Pistol squats, Single-arm snatches
- Specialty: Farmer carries, Turkish get-ups, Sled pushes`,
  };

  return (examples[experienceLevel] ?? examples['beginner']) as string;
}
=================================================================================
FILE: functions/src/lib/exerciseProgression.ts
=================================================================================
/**
 * Exercise progression tracking and variety management
 * Ensures workouts provide variety and progressive overload
 */

export interface ExerciseHistory {
  name: string;
  lastUsed: number; // timestamp
  frequency: number; // how many times used
  variations: string[]; // similar exercises used
}

/**
 * Calculate exercise freshness score (0-100)
 * Higher score = more fresh/novel exercise
 * Lower score = recently used exercise
 */
export function calculateExerciseFreshness(
  exerciseName: string,
  history: ExerciseHistory[],
  daysSinceLastUse: number = 7,
): number {
  const exerciseRecord = history.find(
    (h) => h.name.toLowerCase() === exerciseName.toLowerCase(),
  );

  if (!exerciseRecord) {
    return 100; // Brand new exercise
  }

  // Calculate days since last use
  const daysSince = Math.floor((Date.now() - exerciseRecord.lastUsed) / (1000 * 60 * 60 * 24));

  // Freshness decreases with frequency and recency
  let freshness = 100;

  // Penalize for frequency (max -40 points)
  freshness -= Math.min(40, exerciseRecord.frequency * 5);

  // Penalize for recency (max -50 points)
  if (daysSince < daysSinceLastUse) {
    freshness -= Math.round((50 * (daysSinceLastUse - daysSince)) / daysSinceLastUse);
  }

  return Math.max(0, freshness);
}

/**
 * Analyze exercise variety in a workout
 * Returns metrics about exercise diversity
 */
export function analyzeExerciseVariety(
  exercises: Array<{ name: string }>,
  history: ExerciseHistory[],
): {
  averageFreshness: number;
  uniqueExercises: number;
  repetitionRisk: string[];
  varietyScore: number;
} {
  const freshnesses = exercises.map((ex) =>
    calculateExerciseFreshness(ex.name, history),
  );

  const averageFreshness =
    freshnesses.reduce((a, b) => a + b, 0) / freshnesses.length;

  const uniqueExercises = new Set(exercises.map((ex) => ex.name.toLowerCase()))
    .size;

  // Identify exercises that might be too repetitive
  const repetitionRisk = exercises
    .filter((ex) => calculateExerciseFreshness(ex.name, history) < 30)
    .map((ex) => ex.name);

  // Variety score: 0-100
  // Based on: uniqueness (50%), freshness (50%)
  const uniquenessScore = (uniqueExercises / exercises.length) * 100;
  const freshnessScore = averageFreshness;
  const varietyScore = (uniquenessScore * 0.5 + freshnessScore * 0.5);

  return {
    averageFreshness,
    uniqueExercises,
    repetitionRisk,
    varietyScore: Math.round(varietyScore),
  };
}

/**
 * Get exercise recommendations to improve variety
 */
export function getVarietyRecommendations(
  exercises: Array<{ name: string }>,
  history: ExerciseHistory[],
): string[] {
  const variety = analyzeExerciseVariety(exercises, history);
  const recommendations: string[] = [];

  if (variety.varietyScore < 50) {
    recommendations.push(
      'Low exercise variety detected. Consider swapping some exercises for fresh alternatives.',
    );
  }

  if (variety.repetitionRisk.length > 0) {
    recommendations.push(
      `Recently used exercises: ${variety.repetitionRisk.join(', ')}. Consider variations.`,
    );
  }

  if (variety.uniqueExercises < exercises.length * 0.8) {
    recommendations.push(
      'Some exercises appear multiple times. Aim for unique exercises in each workout.',
    );
  }

  return recommendations;
}

/**
 * Update exercise history with new workout
 */
export function updateExerciseHistory(
  history: ExerciseHistory[],
  exercises: Array<{ name: string }>,
): ExerciseHistory[] {
  const updated = [...history];
  const now = Date.now();

  exercises.forEach((exercise) => {
    const existing = updated.find(
      (h) => h.name.toLowerCase() === exercise.name.toLowerCase(),
    );

    if (existing) {
      existing.lastUsed = now;
      existing.frequency += 1;
    } else {
      updated.push({
        name: exercise.name,
        lastUsed: now,
        frequency: 1,
        variations: [],
      });
    }
  });

  return updated;
}


=================================================================================
FILE: functions/src/lib/exerciseTaxonomy.ts
=================================================================================
/**
 * Exercise taxonomy and similarity detection
 * Prevents duplicate and near-duplicate exercises in workouts
 */

/**
 * Movement category classification
 */
export const MOVEMENT_CATEGORY_BY_NAME: Record<string, string> = {
  // Compound movements
  'squat': 'compound_squat',
  'deadlift': 'compound_hinge',
  'bench press': 'compound_horizontal_push',
  'overhead press': 'compound_vertical_push',
  'military press': 'compound_vertical_push',
  'shoulder press': 'compound_vertical_push',
  'row': 'compound_horizontal_pull',
  'pull-up': 'compound_vertical_pull',
  'chin-up': 'compound_vertical_pull',
  'lunge': 'compound_lunge',
  'dip': 'compound_vertical_push',
  
  // Isolation movements
  'curl': 'isolation_biceps',
  'extension': 'isolation_triceps',
  'raise': 'isolation_shoulders',
  'fly': 'isolation_chest',
  'flye': 'isolation_chest',
  'shrug': 'isolation_traps',
  
  // Cardio/conditioning
  'burpee': 'cardio_full_body',
  'jump': 'cardio_plyometric',
  'sprint': 'cardio_running',
  'mountain climber': 'cardio_core',
  
  // Core
  'plank': 'core_anti_extension',
  'crunch': 'core_flexion',
  'twist': 'core_rotation',
  'leg raise': 'core_flexion',
};

/**
 * Similarity synonyms - exercises that are essentially the same or very similar
 * Key = canonical name, Values = similar variations
 */
export const SIMILARITY_SYNONYMS: Record<string, string[]> = {
  // Pressing movements
  'bench press': [
    'chest press',
    'barbell bench press',
    'dumbbell bench press',
    'flat bench press',
    'barbell chest press',
    'dumbbell chest press',
    'machine chest press',
    'smith machine bench press',
    'incline press',
    'incline bench press',
    'incline chest press',
    'incline dumbbell press',
    'incline barbell press',
    'incline smith press',
  ],
  'decline press': [
    'decline bench press',
    'decline chest press',
    'decline dumbbell press',
    'decline barbell press',
  ],
  'overhead press': [
    'shoulder press',
    'military press',
    'barbell overhead press',
    'dumbbell overhead press',
    'standing press',
    'seated press',
    'arnold press',
    'push press',
  ],
  'push-up': [
    'pushup',
    'push up',
    'standard push-up',
    'regular push-up',
    'floor push-up',
    'wall push-up',
    'incline push-up',
    'decline push-up',
  ],
  'pike push-up': [
    'pike pushup',
    'pike push up',
    'downward dog push-up',
    'shoulder push-up',
  ],

  // Pulling movements
  'row': [
    'barbell row',
    'dumbbell row',
    'bent-over row',
    'bent over row',
    'single-arm row',
    'one-arm row',
    'cable row',
    'seated row',
    'chest-supported row',
    'pendlay row',
    't-bar row',
    'meadows row',
  ],
  'pull-up': [
    'pullup',
    'chin-up',
    'chinup',
    'lat pulldown',
    'pulldown',
    'assisted pull-up',
    'wide-grip pull-up',
    'close-grip pull-up',
  ],
  'face pull': [
    'cable face pull',
    'rope face pull',
    'band face pull',
  ],

  // Leg movements
  'squat': [
    'back squat',
    'front squat',
    'barbell squat',
    'dumbbell squat',
    'goblet squat',
    'air squat',
    'bodyweight squat',
    'box squat',
    'pause squat',
    'tempo squat',
  ],
  'deadlift': [
    'conventional deadlift',
    'romanian deadlift',
    'rdl',
    'stiff-leg deadlift',
    'stiff leg deadlift',
    'sumo deadlift',
    'trap bar deadlift',
    'hex bar deadlift',
  ],
  'lunge': [
    'forward lunge',
    'reverse lunge',
    'walking lunge',
    'stationary lunge',
    'dumbbell lunge',
    'barbell lunge',
    'split squat',
    'bulgarian split squat',
  ],
  'leg press': [
    'machine leg press',
    '45-degree leg press',
    'horizontal leg press',
    'seated leg press',
  ],
  'leg curl': [
    'hamstring curl',
    'lying leg curl',
    'seated leg curl',
    'standing leg curl',
  ],
  'leg extension': [
    'quad extension',
    'seated leg extension',
    'machine leg extension',
  ],

  // Isolation - Arms
  'bicep curl': [
    'biceps curl',
    'barbell curl',
    'dumbbell curl',
    'ez-bar curl',
    'ez bar curl',
    'cable curl',
    'concentration curl',
    'hammer curl',
    'preacher curl',
  ],
  'tricep extension': [
    'triceps extension',
    'overhead extension',
    'skull crusher',
    'skullcrusher',
    'lying tricep extension',
    'cable extension',
    'rope extension',
    'french press',
  ],
  'tricep pushdown': [
    'triceps pushdown',
    'cable pushdown',
    'rope pushdown',
    'straight bar pushdown',
  ],
  'dip': [
    'tricep dip',
    'chest dip',
    'parallel bar dip',
    'assisted dip',
  ],

  // Isolation - Shoulders
  'lateral raise': [
    'side raise',
    'dumbbell lateral raise',
    'cable lateral raise',
    'side lateral raise',
    'machine lateral raise',
  ],
  'front raise': [
    'dumbbell front raise',
    'barbell front raise',
    'cable front raise',
    'plate front raise',
  ],
  'rear delt fly': [
    'rear delt flye',
    'reverse fly',
    'reverse flye',
    'bent-over lateral raise',
    'rear lateral raise',
  ],

  // Chest Isolation
  'chest fly': [
    'chest flye',
    'dumbbell fly',
    'dumbbell flye',
    'cable fly',
    'cable flye',
    'pec fly',
    'pec deck',
  ],

  // Core
  'plank': [
    'front plank',
    'forearm plank',
    'high plank',
    'standard plank',
    'elbow plank',
  ],
  'crunch': [
    'ab crunch',
    'abdominal crunch',
    'basic crunch',
    'floor crunch',
    'sit-up',
    'situp',
  ],
  'russian twist': [
    'seated russian twist',
    'weighted russian twist',
    'medicine ball twist',
  ],
  'leg raise': [
    'lying leg raise',
    'hanging leg raise',
    'captain\'s chair leg raise',
    'knee raise',
  ],
};

/**
 * Tokenize exercise name into key components
 * Removes common modifiers to focus on core movement
 */
function tokenizeExerciseName(name: string): string[] {
  const normalized = name.toLowerCase().trim();
  
  // Remove common modifiers that don't change the fundamental movement
  const modifiersToRemove = [
    'barbell',
    'dumbbell',
    'cable',
    'machine',
    'bodyweight',
    'assisted',
    'weighted',
    'single-arm',
    'single arm',
    'one-arm',
    'one arm',
    'two-arm',
    'two arm',
    'standing',
    'seated',
    'lying',
    'incline',
    'decline',
    'flat',
    'high',
    'low',
    'wide',
    'narrow',
    'close-grip',
    'close grip',
    'wide-grip',
    'wide grip',
  ];
  
  let cleaned = normalized;
  modifiersToRemove.forEach((modifier) => {
    cleaned = cleaned.replace(new RegExp(`\\b${modifier}\\b`, 'g'), '');
  });
  
  // Split into tokens and filter empty
  return cleaned
    .split(/\s+/)
    .filter((token) => token.length > 0);
}

/**
 * Check if two exercises are actual duplicates (not just variations)
 * Only flags exercises that are truly the same, not variations
 * Examples of duplicates: "Bench Press" vs "Barbell Bench Press"
 * Examples of NOT duplicates: "Push-Up" vs "Decline Push-Up"
 */
export function isSimilarExercise(name1: string, name2: string): boolean {
  const n1 = name1.toLowerCase().trim();
  const n2 = name2.toLowerCase().trim();

  // Exact match (case-insensitive)
  if (n1 === n2) {
    return true;
  }

  // Check synonym groups - only if they're in the exact same synonym group
  for (const [canonical, synonyms] of Object.entries(SIMILARITY_SYNONYMS)) {
    const group = [canonical, ...synonyms].map((s) => s.toLowerCase());

    // Both must be in the same synonym group (exact match within group)
    const n1InGroup = group.includes(n1);
    const n2InGroup = group.includes(n2);

    if (n1InGroup && n2InGroup) {
      return true;
    }
  }

  // For other cases, only flag as duplicate if they're nearly identical
  // Calculate similarity using Levenshtein-like approach
  const tokens1 = tokenizeExerciseName(n1);
  const tokens2 = tokenizeExerciseName(n2);

  // If token count differs significantly, they're different exercises
  if (Math.abs(tokens1.length - tokens2.length) > 1) {
    return false;
  }

  // Count matching tokens
  const matchingTokens = tokens1.filter((t) => tokens2.includes(t)).length;
  const totalTokens = Math.max(tokens1.length, tokens2.length);

  // Only flag as duplicate if 80%+ of tokens match
  // This allows variations like "Push-Up" vs "Decline Push-Up" to coexist
  // But catches actual duplicates like "Bench Press" vs "Barbell Bench Press"
  const similarityRatio = matchingTokens / totalTokens;
  return similarityRatio >= 0.8;
}

/**
 * Find similar exercises in a list
 * Returns array of [index1, index2, name1, name2] for each similar pair
 */
export function findSimilarExercises(
  exercises: Array<{ name: string }>,
): Array<[number, number, string, string]> {
  const similar: Array<[number, number, string, string]> = [];

  for (let i = 0; i < exercises.length; i++) {
    for (let j = i + 1; j < exercises.length; j++) {
      const ex1 = exercises[i];
      const ex2 = exercises[j];
      if (ex1 && ex2 && isSimilarExercise(ex1.name, ex2.name)) {
        similar.push([i, j, ex1.name, ex2.name]);
      }
    }
  }

  return similar;
}

/**
 * Get movement category for an exercise
 */
export function getMovementCategory(exerciseName: string): string | null {
  const nameLower = exerciseName.toLowerCase();

  for (const [keyword, category] of Object.entries(MOVEMENT_CATEGORY_BY_NAME)) {
    if (nameLower.includes(keyword)) {
      return category;
    }
  }

  return null;
}

/**
 * Check if two exercises are minor variations of each other
 * This is more strict than isSimilarExercise - used for swap validation
 *
 * Minor variations = same core movement, just different equipment
 * Examples:
 *   - Barbell Bench Press vs Dumbbell Bench Press = MINOR VARIATION (reject)
 *   - Barbell Bench Press vs Cable Chest Press = DIFFERENT MOVEMENT (allow)
 *   - Barbell Row vs Dumbbell Row = MINOR VARIATION (reject)
 *   - Barbell Row vs Pull-up = DIFFERENT MOVEMENT (allow)
 */
export function isMinorExerciseVariation(name1: string, name2: string): boolean {
  const n1 = name1.toLowerCase().trim();
  const n2 = name2.toLowerCase().trim();

  // Exact match
  if (n1 === n2) {
    return true;
  }

  // Remove equipment modifiers to get core movement
  const equipmentModifiers = [
    'barbell',
    'dumbbell',
    'cable',
    'machine',
    'smith machine',
    'ez-bar',
    'ez bar',
    'kettlebell',
    'resistance band',
    'band',
  ];

  let core1 = n1;
  let core2 = n2;

  equipmentModifiers.forEach((modifier) => {
    core1 = core1.replace(new RegExp(`\\b${modifier}\\b`, 'g'), '').trim();
    core2 = core2.replace(new RegExp(`\\b${modifier}\\b`, 'g'), '').trim();
  });

  // Clean up extra spaces
  core1 = core1.replace(/\s+/g, ' ').trim();
  core2 = core2.replace(/\s+/g, ' ').trim();

  // If core movements are the same after removing equipment, it's a minor variation
  // e.g., "bench press" === "bench press" (from "barbell bench press" and "dumbbell bench press")
  if (core1 === core2) {
    return true;
  }

  // Special case: "bench press" and "chest press" are different enough when using different equipment
  // Cable Chest Press vs Barbell Bench Press = DIFFERENT (allow)
  // Dumbbell Bench Press vs Barbell Bench Press = SAME (reject)
  const isBenchToChestPress = (core1.includes('bench press') && core2.includes('chest press')) ||
                               (core1.includes('chest press') && core2.includes('bench press'));

  if (isBenchToChestPress) {
    // Only reject if they're using similar equipment (both free weights)
    const freeWeightEquipment = ['barbell', 'dumbbell', 'kettlebell'];
    const n1HasFreeWeight = freeWeightEquipment.some(eq => n1.includes(eq));
    const n2HasFreeWeight = freeWeightEquipment.some(eq => n2.includes(eq));

    // If both use free weights, it's too similar
    // If one uses cable/machine and other uses free weight, it's different enough
    if (n1HasFreeWeight && n2HasFreeWeight) {
      return true; // Too similar
    }
    return false; // Different enough (e.g., Cable Chest Press vs Barbell Bench Press)
  }

  return false;
}


=================================================================================
FILE: functions/src/lib/exerciseValidation.ts
=================================================================================
/**
 * Safety-critical exercise validation system
 * Ensures AI-generated workouts are safe and structurally complete
 */

import { findSimilarExercises } from './exerciseTaxonomy';

export interface ExerciseValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
  suggestions: string[];
}

export interface Exercise {
  name: string;
  description: string;
  sets: number;
  reps: number | string;
  formTips: string[];
  safetyTips: string[];
  restSeconds: number;
  usesWeight: boolean;
  muscleGroups?: string[];
  difficulty?: string;
}

export interface WorkoutPlan {
  exercises: Exercise[];
  workoutSummary?: {
    totalVolume: string;
    primaryFocus: string;
    expectedRPE: string;
  };
}

// Exercise contraindications based on common injuries
// These are safety-critical patterns that should be avoided with specific injuries
const INJURY_CONTRAINDICATIONS: Record<string, string[]> = {
  knee: [
    'deep squat',
    'lunge',
    'jump',
    'plyometric',
    'box jump',
    'burpee',
    'single leg squat',
    'pistol squat',
    'jump squat',
    'split squat',
  ],
  'lower back': [
    'deadlift',
    'good morning',
    'bent over row',
    'overhead press',
    'sit up',
    'russian twist',
    'toe touch',
    'superman',
  ],
  shoulder: [
    'overhead press',
    'behind neck',
    'upright row',
    'lateral raise',
    'military press',
    'handstand',
    'pull up',
    'dip',
  ],
  ankle: ['jump', 'plyometric', 'calf raise', 'box jump', 'burpee', 'running', 'sprinting', 'agility'],
  wrist: ['push up', 'plank', 'handstand', 'burpee', 'mountain climber'],
  neck: ['overhead press', 'behind neck', 'headstand', 'neck bridge'],
};

/**
 * Validates a workout plan for safety-critical issues
 * Focuses on injury contraindications and structural completeness
 */
export function validateWorkoutPlan(
  plan: WorkoutPlan,
  userProfile: {
    experience?: string;
    injuries?: string[];
    duration: number;
    goals?: string[];
    workoutType?: string;
  },
): ExerciseValidationResult {
  const result: ExerciseValidationResult = {
    isValid: true,
    errors: [],
    warnings: [],
    suggestions: [],
  };

  // Check for empty workout
  if (!plan.exercises || plan.exercises.length === 0) {
    result.errors.push('Workout must contain at least one exercise');
    result.isValid = false;
    return result;
  }

  // Validate each exercise for required fields
  plan.exercises.forEach((exercise, index) => {
    const exerciseResult = validateExercise(exercise);

    if (!exerciseResult.isValid) {
      result.isValid = false;
    }

    exerciseResult.errors.forEach((error) =>
      result.errors.push(`Exercise ${index + 1} (${exercise.name}): ${error}`),
    );
  });

  // CRITICAL: Check for injury contraindications
  validateInjuryCompliance(plan, userProfile.injuries || [], result);

  // Check for similar/duplicate exercises
  validateExerciseUniqueness(plan, result);

  // Check muscle group balance
  validateMuscleGroupBalance(plan, userProfile.workoutType, result);

  return result;
}

/**
 * Validates an individual exercise for required fields
 * Ensures the AI response is structurally complete
 */
function validateExercise(exercise: Exercise): ExerciseValidationResult {
  const result: ExerciseValidationResult = {
    isValid: true,
    errors: [],
    warnings: [],
    suggestions: [],
  };

  // Required fields validation
  if (!exercise.name || exercise.name.trim().length === 0) {
    result.errors.push('Exercise name is required');
    result.isValid = false;
  }

  if (!exercise.description || exercise.description.trim().length < 50) {
    result.errors.push('Exercise description must be at least 50 characters with proper technique guidance');
    result.isValid = false;
  }

  if (!exercise.sets || exercise.sets < 1 || exercise.sets > 10) {
    result.errors.push('Sets must be between 1 and 10');
    result.isValid = false;
  }

  if (!exercise.reps) {
    result.errors.push('Reps specification is required');
    result.isValid = false;
  }

  if (exercise.restSeconds === undefined || exercise.restSeconds === null) {
    result.errors.push('Rest period is required');
    result.isValid = false;
  }

  // Validate difficulty level
  if (exercise.difficulty) {
    const validDifficulties = ['beginner', 'intermediate', 'advanced'];
    if (!validDifficulties.includes(exercise.difficulty.toLowerCase())) {
      result.errors.push(`Invalid difficulty level: "${exercise.difficulty}". Must be one of: ${validDifficulties.join(', ')}`);
      result.isValid = false;
    }
  }

  // Validate form tips count
  if (!exercise.formTips || exercise.formTips.length !== 3) {
    result.errors.push(`Form tips must have exactly 3 items, got ${exercise.formTips?.length || 0}`);
    result.isValid = false;
  }

  // Validate safety tips count
  if (!exercise.safetyTips || exercise.safetyTips.length !== 2) {
    result.errors.push(`Safety tips must have exactly 2 items, got ${exercise.safetyTips?.length || 0}`);
    result.isValid = false;
  }

  // Validate muscle groups
  if (!exercise.muscleGroups || exercise.muscleGroups.length === 0) {
    result.warnings.push('Exercise should specify target muscle groups');
  }

  return result;
}



/**
 * Validates compliance with injury limitations
 */
function validateInjuryCompliance(
  plan: WorkoutPlan,
  injuries: string[],
  result: ExerciseValidationResult,
): void {
  if (injuries.length === 0) return;

  plan.exercises.forEach((exercise, index) => {
    injuries.forEach((injury) => {
      const contraindications = INJURY_CONTRAINDICATIONS[injury.toLowerCase()] || [];
      const exerciseName = exercise.name.toLowerCase();

      const hasContraindication = contraindications.some((contraindicated) =>
        exerciseName.includes(contraindicated),
      );

      if (hasContraindication) {
        result.errors.push(
          `Exercise ${index + 1} (${exercise.name}) may be contraindicated for ${injury} injury`,
        );
        result.isValid = false;
      }
    });
  });
}

/**
 * Validates exercise uniqueness using similarity detection
 */
function validateExerciseUniqueness(
  plan: WorkoutPlan,
  result: ExerciseValidationResult,
): void {
  const similarPairs = findSimilarExercises(plan.exercises);

  if (similarPairs.length > 0) {
    similarPairs.forEach(([idx1, idx2, name1, name2]) => {
      result.errors.push(
        `Similar exercises detected: "${name1}" (exercise ${idx1 + 1}) and "${name2}" (exercise ${idx2 + 1}) are too similar`,
      );
    });
    result.isValid = false;
  }
}

/**
 * Muscle group categories for balance validation
 */
const MUSCLE_GROUP_CATEGORIES = {
  push: ['chest', 'triceps', 'anterior deltoid', 'front deltoid'],
  pull: ['back', 'lats', 'latissimus', 'biceps', 'rear deltoid', 'posterior deltoid', 'traps', 'trapezius'],
  legs: ['quadriceps', 'quads', 'hamstrings', 'glutes', 'gluteus', 'calves', 'gastrocnemius'],
  core: ['abs', 'abdominals', 'obliques', 'core', 'lower back', 'erector spinae'],
  shoulders: ['deltoids', 'delts', 'shoulders', 'lateral deltoid', 'side deltoid'],
};

/**
 * Validates muscle group balance in workout
 * Checks for appropriate distribution based on workout type
 */
function validateMuscleGroupBalance(
  plan: WorkoutPlan,
  workoutType: string | undefined,
  result: ExerciseValidationResult,
): void {
  // Count exercises targeting each muscle group category
  const categoryCount: Record<string, number> = {
    push: 0,
    pull: 0,
    legs: 0,
    core: 0,
    shoulders: 0,
  };

  plan.exercises.forEach((exercise) => {
    const muscleGroups = exercise.muscleGroups?.map((m) => m.toLowerCase()) || [];

    Object.entries(MUSCLE_GROUP_CATEGORIES).forEach(([category, muscles]) => {
      if (muscleGroups.some((mg) => muscles.some((m) => mg.includes(m)))) {
        const currentCount = categoryCount[category];
        if (currentCount !== undefined) {
          categoryCount[category] = currentCount + 1;
        }
      }
    });
  });

  // Validate balance based on workout type
  const type = workoutType?.toLowerCase() || 'full body';

  if (type.includes('full body')) {
    // Full body should have representation from all major categories
    const pushCount = categoryCount.push || 0;
    const pullCount = categoryCount.pull || 0;
    const legsCount = categoryCount.legs || 0;

    if (pushCount === 0) {
      result.warnings.push('Full body workout should include at least one pushing exercise');
    }
    if (pullCount === 0) {
      result.warnings.push('Full body workout should include at least one pulling exercise');
    }
    if (legsCount === 0) {
      result.warnings.push('Full body workout should include at least one leg exercise');
    }

    // Check push/pull balance (should be within 1 exercise of each other)
    const pushPullDiff = Math.abs(pushCount - pullCount);
    if (pushPullDiff > 2) {
      result.warnings.push(
        `Push/pull imbalance detected: ${pushCount} push vs ${pullCount} pull exercises. Consider balancing for injury prevention.`,
      );
    }
  } else if (type.includes('upper body') || type.includes('upper')) {
    // Upper body should balance push and pull
    const pushCount = categoryCount.push || 0;
    const pullCount = categoryCount.pull || 0;
    const legsCount = categoryCount.legs || 0;

    if (pushCount === 0) {
      result.warnings.push('Upper body workout should include pushing exercises');
    }
    if (pullCount === 0) {
      result.warnings.push('Upper body workout should include pulling exercises');
    }

    const pushPullDiff = Math.abs(pushCount - pullCount);
    if (pushPullDiff > 1) {
      result.warnings.push(
        `Push/pull imbalance in upper body workout: ${pushCount} push vs ${pullCount} pull. Aim for 1:1 ratio.`,
      );
    }

    // Upper body shouldn't have leg exercises
    if (legsCount > 0) {
      result.warnings.push('Upper body workout contains leg exercises - may not match user expectations');
    }
  } else if (type.includes('lower body') || type.includes('legs') || type.includes('glutes')) {
    // Lower body should focus on legs
    const legsCount = categoryCount.legs || 0;
    const pushCount = categoryCount.push || 0;
    const pullCount = categoryCount.pull || 0;
    const shouldersCount = categoryCount.shoulders || 0;

    if (legsCount === 0) {
      result.errors.push('Lower body workout must include leg exercises');
      result.isValid = false;
    }

    // Lower body shouldn't have many upper body exercises
    const upperBodyCount = pushCount + pullCount + shouldersCount;
    if (upperBodyCount > legsCount) {
      result.warnings.push(
        'Lower body workout has more upper body exercises than leg exercises - may not match user expectations',
      );
    }
  } else if (type.includes('push')) {
    // Push workout should focus on pushing movements
    const pushCount = categoryCount.push || 0;
    const pullCount = categoryCount.pull || 0;

    if (pushCount === 0) {
      result.errors.push('Push workout must include pushing exercises');
      result.isValid = false;
    }
    if (pullCount > pushCount) {
      result.warnings.push('Push workout has more pulling than pushing exercises');
    }
  } else if (type.includes('pull')) {
    // Pull workout should focus on pulling movements
    const pushCount = categoryCount.push || 0;
    const pullCount = categoryCount.pull || 0;

    if (pullCount === 0) {
      result.errors.push('Pull workout must include pulling exercises');
      result.isValid = false;
    }
    if (pushCount > pullCount) {
      result.warnings.push('Pull workout has more pushing than pulling exercises');
    }
  }

  // General suggestion for core work
  if (categoryCount.core === 0 && plan.exercises.length >= 5) {
    result.suggestions.push('Consider adding core exercises for comprehensive training');
  }
}


=================================================================================
FILE: functions/src/lib/idempotency.ts
=================================================================================
/**
 * Idempotency layer for Cloud Functions
 * Prevents duplicate processing of requests with the same idempotency key
 */

import { getFirestore, Timestamp } from 'firebase-admin/firestore';

const db = getFirestore();
const IDEMPOTENCY_COLLECTION = 'idempotency_keys';
const IDEMPOTENCY_TTL_HOURS = 24; // Keep idempotency records for 24 hours

/**
 * Idempotency record stored in Firestore
 */
interface IdempotencyRecord {
  uid: string;
  requestId: string;
  response: unknown;
  createdAt: Timestamp;
  expiresAt: Timestamp;
}

/**
 * Check if a request with this idempotency key has already been processed
 * Returns the cached response if found, null otherwise
 */
export async function checkIdempotency(
  uid: string,
  requestId: string,
): Promise<unknown | null> {
  if (!uid || !requestId) {
    return null;
  }

  try {
    const docId = `${uid}_${requestId}`;
    const doc = await db
      .collection(IDEMPOTENCY_COLLECTION)
      .doc(docId)
      .get();

    if (!doc.exists) {
      return null;
    }

    const data = doc.data() as IdempotencyRecord;
    const now = Timestamp.now();

    // Check if record is still valid
    if (data.expiresAt.toMillis() > now.toMillis()) {
      console.log('🔁 Idempotency hit:', requestId.substring(0, 12));
      return data.response;
    } else {
      // Expired - delete it
      await doc.ref.delete();
      return null;
    }
  } catch (error) {
    console.error('Error checking idempotency:', error);
    return null;
  }
}

/**
 * Store a response for idempotency
 */
export async function storeIdempotencyRecord(
  uid: string,
  requestId: string,
  response: unknown,
): Promise<void> {
  if (!uid || !requestId) {
    return;
  }

  try {
    const docId = `${uid}_${requestId}`;
    const expiresAt = Timestamp.fromMillis(
      Date.now() + IDEMPOTENCY_TTL_HOURS * 60 * 60 * 1000,
    );

    await db
      .collection(IDEMPOTENCY_COLLECTION)
      .doc(docId)
      .set({
        uid,
        requestId,
        response,
        createdAt: Timestamp.now(),
        expiresAt,
      });

    console.log('💾 Stored idempotency record:', requestId.substring(0, 12));
  } catch (error) {
    console.error('Error storing idempotency record:', error);
    // Don't throw - idempotency is a best-effort feature
  }
}

/**
 * Clean up expired idempotency records
 * Should be called periodically (e.g., daily scheduled function)
 */
export async function cleanupExpiredIdempotencyRecords(): Promise<number> {
  try {
    const now = Timestamp.now();
    const expiredDocs = await db
      .collection(IDEMPOTENCY_COLLECTION)
      .where('expiresAt', '<', now)
      .limit(500) // Process in batches
      .get();

    if (expiredDocs.empty) {
      return 0;
    }

    const batch = db.batch();
    expiredDocs.docs.forEach((doc) => {
      batch.delete(doc.ref);
    });

    await batch.commit();
    console.log(`🧹 Cleaned up ${expiredDocs.size} expired idempotency records`);
    return expiredDocs.size;
  } catch (error) {
    console.error('Error cleaning up idempotency records:', error);
    return 0;
  }
}


=================================================================================
FILE: functions/src/lib/jsonSchema/workoutPlan.schema.ts
=================================================================================
/**
 * JSON Schema for AI-generated workout plans
 * Enforces strict validation for OpenAI structured outputs and server-side AJV validation
 */

// Muscle group enum - comprehensive list
export const MUSCLE_GROUPS = [
  'chest',
  'back',
  'shoulders',
  'biceps',
  'triceps',
  'quadriceps',
  'hamstrings',
  'glutes',
  'calves',
  'abs',
  'obliques',
  'core',
  'lower back',
  'rear delts',
  'traps',
  'lats',
  'forearms',
  'hip flexors',
  'adductors',
  'abductors',
] as const;

export type MuscleGroup = typeof MUSCLE_GROUPS[number];

// Difficulty levels
export const DIFFICULTY_LEVELS = ['beginner', 'intermediate', 'advanced'] as const;
export type DifficultyLevel = typeof DIFFICULTY_LEVELS[number];

/**
 * JSON Schema (draft-2020-12) for a single exercise
 * Designed for OpenAI's response_format: { type: "json_schema" }
 */
export const exerciseSchema = {
  type: 'object',
  properties: {
    name: {
      type: 'string',
      minLength: 2,
      maxLength: 80,
      description: 'Unique exercise name (e.g., "Barbell Back Squat", "Dumbbell Bench Press")',
    },
    description: {
      type: 'string',
      minLength: 50,
      maxLength: 300,
      description: 'Complete description in 2-3 sentences with setup, execution, tempo/range cues, and breathing pattern',
    },
    sets: {
      type: 'integer',
      minimum: 1,
      maximum: 6,
      description: 'Number of sets to perform (1-6 sets)',
    },
    reps: {
      type: 'string',
      pattern: '^(\\d+|\\d{1,2}-\\d{1,2}|\\d{1,3}s|\\d{1,2}-\\d{1,2}s)$',
      description: 'Reps in format: "12" (exact), "8-12" (range), "45s" (time), or "30-45s" (time range). Time-based workouts use time format only, strength workouts use range format only.',
    },
    formTips: {
      type: 'array',
      items: {
        type: 'string',
        minLength: 20,
        maxLength: 200,
      },
      minItems: 3,
      maxItems: 3,
      description: 'Exactly 3 form tips for proper technique',
    },
    safetyTips: {
      type: 'array',
      items: {
        type: 'string',
        minLength: 20,
        maxLength: 200,
      },
      minItems: 2,
      maxItems: 2,
      description: 'Exactly 2 safety tips for injury prevention',
    },
    restSeconds: {
      type: 'integer',
      minimum: 15,
      maximum: 300,
      description: 'Rest period in seconds between sets (15-300s)',
    },
    usesWeight: {
      type: 'boolean',
      description: 'True if exercise uses external weights (dumbbells, barbells, etc.)',
    },
    muscleGroups: {
      type: 'array',
      items: {
        type: 'string',
        enum: MUSCLE_GROUPS,
      },
      minItems: 1,
      maxItems: 3,
      description: 'Primary muscle groups targeted (1-3 muscles)',
    },
    difficulty: {
      type: 'string',
      enum: DIFFICULTY_LEVELS,
      description: 'Exercise difficulty level matching user experience',
    },
  },
  required: [
    'name',
    'description',
    'sets',
    'reps',
    'formTips',
    'safetyTips',
    'restSeconds',
    'usesWeight',
    'muscleGroups',
    'difficulty',
  ],
  additionalProperties: false,
} as const;

/**
 * JSON Schema for workout summary
 */
export const workoutSummarySchema = {
  type: 'object',
  properties: {
    totalVolume: {
      type: 'string',
      minLength: 5,
      maxLength: 100,
      description: 'Total volume calculation (e.g., "18 sets, 144-216 reps")',
    },
    primaryFocus: {
      type: 'string',
      minLength: 10,
      maxLength: 200,
      description: 'Main focus of the workout',
    },
    expectedRPE: {
      type: 'string',
      minLength: 5,
      maxLength: 50,
      description: 'Expected RPE rating (e.g., "6-7 out of 10")',
    },
  },
  required: ['totalVolume', 'primaryFocus', 'expectedRPE'],
  additionalProperties: false,
} as const;

/**
 * Complete workout plan schema
 * Note: minItems/maxItems for exercises will be set dynamically based on duration
 */
export const workoutPlanSchemaBase = {
  type: 'object',
  properties: {
    exercises: {
      type: 'array',
      items: exerciseSchema,
      minItems: 3, // Will be overridden dynamically
      maxItems: 20, // Will be overridden dynamically
      description: 'Array of exercises in the workout',
    },
    workoutSummary: workoutSummarySchema,
  },
  required: ['exercises', 'workoutSummary'],
  additionalProperties: false,
} as const;

/**
 * Build dynamic workout plan schema with computed min/max exercise counts
 */
export function buildWorkoutPlanSchema(minExercises: number, maxExercises: number) {
  return {
    ...workoutPlanSchemaBase,
    properties: {
      ...workoutPlanSchemaBase.properties,
      exercises: {
        ...workoutPlanSchemaBase.properties.exercises,
        minItems: minExercises,
        maxItems: maxExercises,
      },
    },
  };
}

/**
 * OpenAI-compatible JSON Schema format for response_format
 * This is the format OpenAI expects for structured outputs
 */
export function buildOpenAIJsonSchema(minExercises: number, maxExercises: number) {
  const schema = buildWorkoutPlanSchema(minExercises, maxExercises);

  // Use strict mode if available, but provide fallback for compatibility
  const useStrictMode = process.env.OPENAI_STRICT_MODE !== 'false';

  return {
    type: 'json_schema',
    json_schema: {
      name: 'workout_plan',
      description: 'A complete personalized workout plan with exercises and summary',
      schema: schema,
      ...(useStrictMode && { strict: true }), // Enable strict mode for OpenAI if configured
    },
  };
}

/**
 * TypeScript types inferred from schema
 */
export interface Exercise {
  name: string;
  description: string;
  sets: number;
  reps: string;
  formTips: string[];
  safetyTips: string[];
  restSeconds: number;
  usesWeight: boolean;
  muscleGroups: MuscleGroup[];
  difficulty: DifficultyLevel;
}

export interface WorkoutSummary {
  totalVolume: string;
  primaryFocus: string;
  expectedRPE: string;
}

export interface WorkoutPlan {
  exercises: Exercise[];
  workoutSummary: WorkoutSummary;
}

/**
 * Schema for single exercise (used in addExercise/swapExercise)
 */
export function buildSingleExerciseSchema() {
  return {
    type: 'json_schema',
    json_schema: {
      name: 'single_exercise',
      description: 'A single exercise to add or swap',
      schema: exerciseSchema,
      strict: true,
    },
  };
}


=================================================================================
FILE: functions/src/lib/periodization.ts
=================================================================================
/**
 * Adaptive periodization and progression logic
 * Derives intensity scaling and progression notes from user history and feedback
 * Persists adaptive state to Firestore for cross-session learning
 */

import { getFirestore } from 'firebase-admin/firestore';

const db = getFirestore();

export interface RecentWorkout {
  workoutType: string;
  timestamp: number;
  completionRate?: number;
  rpe?: number;
  feedback?: 'easy' | 'right' | 'hard';
  exercises: Array<{ name: string }>;
}

export interface ProgressionResult {
  targetIntensityScalar: number;
  weeklyFocus: string;
  deloadHint?: string;
  progressionNote: string;
}

/**
 * Calculate recent completion rate from workout history
 */
export function calculateRecentCompletionRate(recentWorkouts: RecentWorkout[]): number {
  if (recentWorkouts.length === 0) {
    return 1.0; // Default to 100% if no history
  }

  const workoutsWithCompletion = recentWorkouts.filter((w) => w.completionRate !== undefined);
  
  if (workoutsWithCompletion.length === 0) {
    return 1.0;
  }

  const totalCompletion = workoutsWithCompletion.reduce(
    (sum, w) => sum + (w.completionRate || 0),
    0,
  );

  return totalCompletion / workoutsWithCompletion.length / 100; // Convert to 0-1 scale
}

/**
 * Calculate average RPE from recent workouts
 */
export function calculateAverageRPE(recentWorkouts: RecentWorkout[]): number | null {
  const workoutsWithRPE = recentWorkouts.filter((w) => w.rpe !== undefined && w.rpe !== null);
  
  if (workoutsWithRPE.length === 0) {
    return null;
  }

  const totalRPE = workoutsWithRPE.reduce((sum, w) => sum + (w.rpe || 0), 0);
  return totalRPE / workoutsWithRPE.length;
}

/**
 * Analyze feedback trends from recent workouts
 */
export function analyzeFeedbackTrend(recentWorkouts: RecentWorkout[]): {
  trend: 'too_easy' | 'balanced' | 'too_hard' | 'unknown';
  confidence: number;
} {
  const workoutsWithFeedback = recentWorkouts.filter((w) => w.feedback !== undefined);
  
  if (workoutsWithFeedback.length === 0) {
    return { trend: 'unknown', confidence: 0 };
  }

  const feedbackCounts = {
    easy: workoutsWithFeedback.filter((w) => w.feedback === 'easy').length,
    right: workoutsWithFeedback.filter((w) => w.feedback === 'right').length,
    hard: workoutsWithFeedback.filter((w) => w.feedback === 'hard').length,
  };

  const total = workoutsWithFeedback.length;
  const easyRatio = feedbackCounts.easy / total;
  const hardRatio = feedbackCounts.hard / total;

  let trend: 'too_easy' | 'balanced' | 'too_hard' | 'unknown';
  
  if (easyRatio > 0.6) {
    trend = 'too_easy';
  } else if (hardRatio > 0.6) {
    trend = 'too_hard';
  } else {
    trend = 'balanced';
  }

  return {
    trend,
    confidence: total / 5, // Confidence increases with more data points (max 5)
  };
}

/**
 * Compute next intensity scalar based on adaptive state
 */
export function computeNextScalar(
  currentScalar: number,
  completionRate: number,
  feedbackTrend: 'too_easy' | 'balanced' | 'too_hard' | 'unknown',
  avgRPE: number | null,
): number {
  let adjustment = 0;

  // Completion rate adjustments
  if (completionRate >= 0.9) {
    adjustment += 0.05; // Increase if completing most workouts
  } else if (completionRate < 0.7) {
    adjustment -= 0.1; // Decrease if struggling to complete
  }

  // Feedback trend adjustments
  if (feedbackTrend === 'too_easy') {
    adjustment += 0.1;
  } else if (feedbackTrend === 'too_hard') {
    adjustment -= 0.1;
  }

  // RPE adjustments (target RPE 6-7 for most users)
  if (avgRPE !== null) {
    if (avgRPE < 5) {
      adjustment += 0.05; // Too easy
    } else if (avgRPE > 8) {
      adjustment -= 0.05; // Too hard
    }
  }

  // Apply adjustment with bounds
  const newScalar = Math.max(0.7, Math.min(1.3, currentScalar + adjustment));
  
  return Math.round(newScalar * 100) / 100; // Round to 2 decimals
}

/**
 * Derive progression strategy from user history and adaptive state
 */
export function deriveProgression(
  experience: string,
  currentDifficultyScalar: number,
  recentWorkouts: RecentWorkout[],
): ProgressionResult {
  const completionRate = calculateRecentCompletionRate(recentWorkouts);
  const avgRPE = calculateAverageRPE(recentWorkouts);
  const feedbackAnalysis = analyzeFeedbackTrend(recentWorkouts);

  // Compute target intensity
  const targetIntensityScalar = computeNextScalar(
    currentDifficultyScalar,
    completionRate,
    feedbackAnalysis.trend,
    avgRPE,
  );

  // Determine weekly focus based on workout frequency
  const recentDays = 7;
  const cutoffTime = Date.now() - recentDays * 24 * 60 * 60 * 1000;
  const workoutsThisWeek = recentWorkouts.filter((w) => w.timestamp > cutoffTime);
  
  let weeklyFocus = 'balanced';
  if (workoutsThisWeek.length >= 5) {
    weeklyFocus = 'high_frequency';
  } else if (workoutsThisWeek.length <= 2) {
    weeklyFocus = 'low_frequency';
  }

  // Deload hint (every 4 weeks or if completion rate is very low)
  let deloadHint: string | undefined;
  const weeksSinceStart = Math.floor(recentWorkouts.length / 3); // Rough estimate
  if (weeksSinceStart > 0 && weeksSinceStart % 4 === 0) {
    deloadHint = 'Consider a deload week - reduce volume by 30-40%';
  } else if (completionRate < 0.6) {
    deloadHint = 'Low completion rate detected - consider reducing intensity';
  }

  // Build progression note
  let progressionNote = '';
  
  if (targetIntensityScalar > currentDifficultyScalar) {
    const increase = Math.round((targetIntensityScalar - currentDifficultyScalar) * 100);
    progressionNote = `Increasing intensity by ${increase}% based on strong performance`;
    
    if (feedbackAnalysis.trend === 'too_easy') {
      progressionNote += ' - recent workouts felt too easy';
    } else if (completionRate >= 0.9) {
      progressionNote += ' - excellent completion rate';
    }
  } else if (targetIntensityScalar < currentDifficultyScalar) {
    const decrease = Math.round((currentDifficultyScalar - targetIntensityScalar) * 100);
    progressionNote = `Reducing intensity by ${decrease}% to optimize recovery`;
    
    if (feedbackAnalysis.trend === 'too_hard') {
      progressionNote += ' - recent workouts felt too challenging';
    } else if (completionRate < 0.7) {
      progressionNote += ' - completion rate suggests need for adjustment';
    }
  } else {
    progressionNote = 'Maintaining current intensity - performance is well-calibrated';
  }

  // Add experience-specific guidance
  if (experience === 'Beginner') {
    progressionNote += '. Focus on form and consistency';
  } else if (experience === 'Advanced') {
    progressionNote += '. Consider advanced techniques and periodization';
  }

  return {
    targetIntensityScalar,
    weeklyFocus,
    deloadHint,
    progressionNote,
  };
}

/**
 * Adaptive state stored in Firestore
 */
export interface AdaptiveState {
  difficultyScalar: number;
  lastUpdated: number;
  totalWorkouts: number;
  averageCompletionRate?: number;
  averageRPE?: number;
}

/**
 * Get adaptive state from Firestore or defaults
 * Reads from /users/{uid}/adaptiveState document
 */
export async function getAdaptiveState(
  userId: string,
  experience: string,
): Promise<{ difficultyScalar: number }> {
  // Default scalar based on experience
  const defaultScalars: Record<string, number> = {
    Beginner: 0.85,
    Intermediate: 1.0,
    Advanced: 1.1,
    Expert: 1.15,
  };

  if (!userId) {
    return {
      difficultyScalar: defaultScalars[experience] || 1.0,
    };
  }

  try {
    const stateDoc = await db
      .collection('users')
      .doc(userId)
      .collection('adaptiveState')
      .doc('current')
      .get();

    if (stateDoc.exists) {
      const data = stateDoc.data() as AdaptiveState;
      console.log('📊 Loaded adaptive state:', {
        scalar: data.difficultyScalar,
        workouts: data.totalWorkouts,
      });
      return {
        difficultyScalar: data.difficultyScalar,
      };
    }

    // No state yet - return default
    return {
      difficultyScalar: defaultScalars[experience] || 1.0,
    };
  } catch (error) {
    console.error('Error loading adaptive state:', error);
    return {
      difficultyScalar: defaultScalars[experience] || 1.0,
    };
  }
}

/**
 * Update adaptive state based on recent workout feedback
 * Stores updated state in Firestore
 */
export async function updateAdaptiveState(
  userId: string,
  experience: string,
  recentWorkouts: RecentWorkout[],
): Promise<void> {
  if (!userId || recentWorkouts.length === 0) {
    return;
  }

  try {
    // Get current state
    const currentState = await getAdaptiveState(userId, experience);

    // Calculate metrics from recent workouts
    const completionRate = calculateRecentCompletionRate(recentWorkouts);
    const avgRPE = calculateAverageRPE(recentWorkouts);
    const feedbackAnalysis = analyzeFeedbackTrend(recentWorkouts);

    // Compute new scalar
    const newScalar = computeNextScalar(
      currentState.difficultyScalar,
      completionRate,
      feedbackAnalysis.trend,
      avgRPE,
    );

    // Update Firestore
    const stateRef = db
      .collection('users')
      .doc(userId)
      .collection('adaptiveState')
      .doc('current');

    await stateRef.set({
      difficultyScalar: newScalar,
      lastUpdated: Date.now(),
      totalWorkouts: recentWorkouts.length,
      averageCompletionRate: completionRate,
      averageRPE: avgRPE,
    });

    console.log('💾 Updated adaptive state:', {
      userId: userId.substring(0, 8),
      oldScalar: currentState.difficultyScalar,
      newScalar,
      completionRate,
      avgRPE,
      trend: feedbackAnalysis.trend,
    });
  } catch (error) {
    console.error('Error updating adaptive state:', error);
    // Don't throw - adaptive state is best-effort
  }
}


=================================================================================
FILE: functions/src/lib/promptBuilder.enhanced.ts
=================================================================================
/**
 * ENHANCED AI Prompt Engineering System for Workout Generation
 *
 * Design Principles:
 * 1. Chain-of-Thought Reasoning: Guide AI through step-by-step calculation
 * 2. Constraint Satisfaction: Enforce hard constraints (duration, equipment, injuries)
 * 3. Few-Shot Learning: Provide concrete examples for complex scenarios
 * 4. Structured Output: Enforce strict JSON schema compliance
 * 5. Self-Verification: Require AI to validate before outputting
 */

import { WorkoutContext, ProgrammingContext } from './promptBuilder';
import { buildOpenAIJsonSchema } from './jsonSchema/workoutPlan.schema';
import { optimizeWorkoutHistory, buildWorkoutHistorySummary, shouldIncludeWorkoutHistory } from './workoutHistoryOptimizer';

/**
 * Export OpenAI JSON Schema builder for use in generation
 */
export { buildOpenAIJsonSchema };

/**
 * Enhanced system message with cognitive scaffolding (OPTIMIZED for token efficiency)
 * Reduced from ~800 tokens to ~550 tokens (31% reduction)
 * Further optimized for longer workouts (60+ min) to reduce prompt size
 * Emphasizes personalization and quality
 */
export function buildEnhancedSystemMessage(duration: number, workoutType?: string): string {
  const isTimeBasedWorkout = workoutType && ['Cardio', 'Yoga', 'Pilates', 'Core Focus', 'HIIT', 'Abs'].includes(workoutType);

  // Dynamic variance based on duration
  let variance = 3;
  if (duration >= 90) {
    variance = Math.ceil(duration * 0.15); // ±15% for 90+ min workouts
  } else if (duration >= 60) {
    variance = Math.ceil(duration * 0.1); // ±10% for 60-89 min workouts
  } else if (duration >= 45) {
    variance = 5; // ±5 min for 45-59 min workouts
  }

  return `You are an expert fitness coach. Generate a valid, personalized workout.

🔴 CRITICAL: Duration must be ${duration}±${variance} minutes (${(duration - variance).toFixed(0)}-${(duration + variance).toFixed(0)} min)

HARD CONSTRAINTS (non-negotiable):
- Duration: ${duration}±${variance} min
- Equipment: Use ONLY available equipment
- Safety: Avoid contraindicated exercises
- Format: Valid JSON matching schema

SOFT CONSTRAINTS (optimize for):
- Personalization to experience level
- Exercise variety
- Proper progression

PROGRAMMING:
- Reps: ${isTimeBasedWorkout ? '"30s","45s","60s"' : '"8-12","6-10"'}
- Rest: 60-180s depending on exercise type
- Sets: 3-5 per exercise

BEFORE OUTPUTTING:
1. Calculate total duration (warmup + all exercises + rest)
2. Verify it equals ${duration}±${variance} minutes
3. Check all exercises match available equipment
4. Ensure no contraindicated exercises
5. Verify JSON is valid

OUTPUT: Valid JSON only`;
}

/**
 * Enhanced workout prompt with chain-of-thought guidance
 */
export function buildEnhancedWorkoutPrompt(
  context: WorkoutContext,
  programming: ProgrammingContext,
  qualityGuidelines: string,
): {
  prompt: string;
  minExerciseCount: number;
  maxExerciseCount: number;
} {
  const duration = context.duration || 30;
  const workoutType = context.workoutType || 'Full Body';
  const experience = context.experience || 'Beginner';
  const goals = context.goals || ['General Health'];
  const equipment = context.equipment || ['Bodyweight'];
  const injuries = context.injuries;

  // Calculate exercise count based on workout type and duration
  const isTimeBasedWorkout = ['Cardio', 'Yoga', 'Pilates', 'Core Focus', 'HIIT', 'Abs'].includes(workoutType);
  
  let avgTimePerExercise: number;
  let minExerciseCount: number;
  let maxExerciseCount: number;

  if (isTimeBasedWorkout) {
    // Time-based: 3-5 minutes per exercise
    avgTimePerExercise = 4;
    minExerciseCount = Math.max(4, Math.floor(duration / 5));
    maxExerciseCount = Math.ceil(duration / 3);
  } else {
    // Strength: 6-15 minutes per exercise depending on rest periods
    const avgRest = (programming.restSeconds[0] + programming.restSeconds[1]) / 2;
    const avgSets = (programming.sets[0] + programming.sets[1]) / 2;
    avgTimePerExercise = avgSets + ((avgSets - 1) * avgRest / 60);
    minExerciseCount = Math.max(4, Math.floor(duration / avgTimePerExercise));
    maxExerciseCount = Math.ceil(duration / (avgTimePerExercise * 0.75));
  }

  const workoutTypeGuidance = getWorkoutTypeGuidance(workoutType);
  const injuryGuidance = buildInjuryGuidance(injuries);
  const durationGuidance = buildDurationGuidance(duration, programming, workoutType, minExerciseCount, maxExerciseCount);

  // For longer workouts (60+ min), reduce verbosity to keep prompt size manageable
  const isLongWorkout = duration >= 60;

  // Optimize workout history for token efficiency
  const workoutHistorySection = context.recentWorkouts && shouldIncludeWorkoutHistory(context.recentWorkouts)
    ? `\n═══════════════════════════════════════════════════════════════
WORKOUT HISTORY (Personalization Data)
═══════════════════════════════════════════════════════════════
${buildWorkoutHistorySummary(optimizeWorkoutHistory(context.recentWorkouts, isLongWorkout ? 3 : 5))}
${context.progressionNote ? `\nProgression Note: ${context.progressionNote}` : ''}`
    : '';

  // Reduce verbosity for longer workouts
  const descriptionGuidance = isLongWorkout
    ? 'Exercise Descriptions (1-2 sentences, 150-250 chars): Starting position and movement execution, Key form cues and breathing pattern'
    : 'Exercise Descriptions (2-3 sentences, 200-300 characters): First sentence: Starting position and setup with key body alignment cues, Second sentence: Movement execution with range of motion and tempo guidance, Third sentence (optional): Breathing pattern (exhale on exertion) and key focus points';

  const prompt = `Generate a PERSONALIZED ${duration}-minute ${workoutType} workout for a ${experience} level client.

═══════════════════════════════════════════════════════════════
CLIENT PROFILE & PERSONALIZATION
═══════════════════════════════════════════════════════════════
Experience: ${experience}
Goals: ${goals.join(', ')}
Equipment: ${equipment.join(', ')}
Workout Type: ${workoutType}
Duration: ${duration} minutes
${context.personalInfo ? `
Personal Info:
- Sex: ${context.personalInfo.sex || 'Not specified'}
- Height: ${context.personalInfo.height || 'Not specified'}
- Weight: ${context.personalInfo.weight || 'Not specified'}` : ''}
${context.preferenceNotes ? `
User Preferences:
${context.preferenceNotes}` : ''}
${workoutHistorySection}

PERSONALIZATION GUIDANCE:
- Adapt exercise difficulty and volume to ${experience} level
- Vary exercises from recent history to maintain engagement
- Consider user's progression trajectory and feedback
- Provide modifications for different fitness levels
- Ensure exercises align with stated goals: ${goals.join(', ')}

${workoutTypeGuidance}
${injuryGuidance}

═══════════════════════════════════════════════════════════════
PROGRAMMING PARAMETERS
═══════════════════════════════════════════════════════════════
Sets: ${programming.sets[0]}-${programming.sets[1]}
Reps: ${isTimeBasedWorkout ? 'TIME-BASED (use "30s", "45s", "60s" format)' : `${programming.reps[0]}-${programming.reps[1]} (use range format like "8-12")`}
Rest: ${programming.restSeconds[0]}-${programming.restSeconds[1]} seconds
Intensity: ${programming.intensity}

${isTimeBasedWorkout ? `🚨 CRITICAL: This is a ${workoutType} workout - ALL exercises MUST use time-based reps (e.g., "30s", "45s", "60s")
DO NOT use rep ranges like "8-12" - use ONLY time format like "45s"` : ''}

${durationGuidance}

═══════════════════════════════════════════════════════════════
QUALITY STANDARDS
═══════════════════════════════════════════════════════════════
${qualityGuidelines}

${descriptionGuidance}

Form Tips (EXACTLY 3):
- Common technique errors to avoid
- Joint alignment cues
- Movement quality focus points

Safety Tips (EXACTLY 2):
- Injury prevention guidance
- Modification or regression option

═══════════════════════════════════════════════════════════════
OUTPUT SCHEMA (STRICT COMPLIANCE REQUIRED)
═══════════════════════════════════════════════════════════════
{
  "exercises": [
    {
      "name": "Exercise Name",
      "description": "${isLongWorkout ? '1-2 sentences, 150-250 chars' : '2-3 sentences, 200-300 chars'}",
      "sets": 3,
      "reps": ${isTimeBasedWorkout ? '"45s"' : '"8-12"'},
      "formTips": ["Tip 1", "Tip 2", "Tip 3"],
      "safetyTips": ["Safety 1", "Safety 2"],
      "restSeconds": ${isTimeBasedWorkout ? '30' : '120'},
      "usesWeight": ${isTimeBasedWorkout ? 'false' : 'true'},
      "muscleGroups": ["muscle1", "muscle2"],
      "difficulty": "${experience.toLowerCase()}"
    }
  ],
  "workoutSummary": {
    "totalVolume": "e.g., '18 sets, 144-216 reps'",
    "primaryFocus": "Main focus",
    "expectedRPE": "e.g., '6-7 out of 10'"
  }
}

BEFORE OUTPUTTING - VERIFY CHECKLIST:
✓ Duration: ${duration} ± 3 minutes (CALCULATE EXACT TOTAL)
✓ Exercise count: ${minExerciseCount}-${maxExerciseCount} exercises
✓ All exercises match ${workoutType} type
✓ No contraindicated exercises for injuries
✓ Only equipment: ${equipment.join(', ')}
✓ All names unique (no duplicates)
✓ All fields present and correct types

Output the JSON now:`;

  return {
    prompt,
    minExerciseCount,
    maxExerciseCount,
  };
}

function getWorkoutTypeGuidance(type: string): string {
  const guidance: Record<string, string> = {
    'Full Body': 'Focus: Total body with squat, hinge, push, pull, carry patterns. Example: Squats, deadlifts, push-ups, rows, lunges, planks.',
    'Upper Body': 'Focus: Chest, back, shoulders, arms ONLY. Example: Bench press, rows, shoulder press, pull-ups, curls, tricep extensions.',
    'Lower Body': 'Focus: Legs, glutes, calves ONLY. Example: Squats, deadlifts, lunges, leg press, calf raises, glute bridges.',
    'Legs/Glutes': 'Focus: Hip-dominant glute work. Example: Hip thrusts, Romanian deadlifts, Bulgarian split squats, glute bridges.',
    'Chest/Triceps': 'Focus: Chest pressing + tricep isolation. Example: Bench press, push-ups, chest flyes, tricep dips, overhead extensions.',
    'Back/Biceps': 'Focus: Pulling movements + bicep work. Example: Pull-ups, rows, lat pulldowns, bicep curls, hammer curls.',
    'Shoulders': 'Focus: All three deltoid heads. Example: Shoulder press, lateral raises, front raises, rear delt flyes, face pulls.',
    'Arms': 'Focus: Biceps + triceps isolation. Example: Bicep curls, hammer curls, tricep extensions, dips, close-grip press.',
    'Push': 'Focus: Chest, shoulders, triceps pressing. Example: Bench press, shoulder press, push-ups, dips, lateral raises.',
    'Pull': 'Focus: Back, biceps, rear delts pulling. Example: Pull-ups, rows, lat pulldowns, face pulls, bicep curls.',
    'Core Focus': 'Focus: Anti-extension, anti-rotation, stability. Example: Planks, dead bugs, bird dogs, pallof press, Russian twists.',
    'Abs': 'Focus: Abdominal definition and strength. Example: Crunches, leg raises, bicycle crunches, ab wheel rollouts, cable crunches.',
    'Cardio': 'Focus: Cardiovascular endurance. Example: Jumping jacks, burpees, mountain climbers, high knees, jump rope.',
    'HIIT': 'Focus: High-intensity intervals. Example: Burpees, jump squats, box jumps, sprint intervals, battle ropes, kettlebell swings.',
    'Strength Training': 'Focus: Maximal strength with heavy compounds. Example: Barbell squat, deadlift, bench press, overhead press, weighted pull-ups.',
    'Yoga': 'Focus: Flexibility, balance, breath. Example: Sun salutations, warrior poses, downward dog, tree pose, pigeon pose.',
    'Pilates': 'Focus: Core strength and control. Example: Hundred, roll-ups, leg circles, single leg stretch, plank variations.',
  };
  
  return `\nWORKOUT TYPE: ${type}\n${guidance[type] || guidance['Full Body']}`;
}

function buildInjuryGuidance(injuries?: { list?: string[]; notes?: string }): string {
  if (!injuries?.list || injuries.list.length === 0) {
    return '';
  }

  // Import the detailed contraindications from promptBuilder
  const getInjuryContraindications = (injuryList: string[]): string => {
    const contraindications: Record<string, { avoid: string[]; alternatives: string[] }> = {
      knee: {
        avoid: [
          'squats (all variations including goblet, barbell, dumbbell, front, back)',
          'deep squats',
          'goblet squats',
          'barbell squats',
          'dumbbell squats',
          'front squats',
          'back squats',
          'lunges (all variations)',
          'Bulgarian split squats',
          'jump squats',
          'box jumps',
          'burpees',
          'pistol squats',
          'jumping lunges',
          'walking lunges',
          'reverse lunges',
          'step-ups (high)',
          'leg press (heavy)',
          'plyometric exercises',
          'jumping exercises',
          'running',
          'sprinting',
        ],
        alternatives: [
          'glute bridges',
          'hip thrusts',
          'wall sits (limited depth, partial range)',
          'leg press (light weight, limited depth)',
          'step-ups (very low height only)',
          'seated leg extensions (light weight)',
          'hamstring curls',
          'clamshells',
          'side-lying leg raises',
          'standing hip abduction',
        ],
      },
      'lower back': {
        avoid: [
          'deadlifts',
          'Romanian deadlifts',
          'good mornings',
          'bent-over rows',
          'overhead press',
          'sit-ups',
          'Russian twists',
          'toe touches',
          'supermans',
          'hyperextensions',
        ],
        alternatives: [
          'glute bridges',
          'bird dogs',
          'dead bugs',
          'planks',
          'side planks',
          'cable rows (supported)',
          'chest-supported rows',
          'pallof press',
        ],
      },
      shoulder: {
        avoid: [
          'overhead press',
          'military press',
          'behind-the-neck press',
          'upright rows',
          'lateral raises (if painful)',
          'handstand push-ups',
          'dips (if painful)',
          'pull-ups (if impingement)',
        ],
        alternatives: [
          'landmine press',
          'neutral grip dumbbell press',
          'push-ups (modified)',
          'cable chest press',
          'face pulls',
          'band pull-aparts',
          'scapular wall slides',
        ],
      },
    };

    let context = '';
    injuryList.forEach((injury) => {
      const injuryKey = injury.toLowerCase();
      const contraInfo = contraindications[injuryKey];
      if (contraInfo) {
        context += `\n\n⚠️ ${injury.toUpperCase()} INJURY - CRITICAL SAFETY REQUIREMENTS:
DO NOT INCLUDE ANY OF THESE EXERCISES:
${contraInfo.avoid.map((ex) => `  ❌ ${ex}`).join('\n')}

SAFE ALTERNATIVES TO USE INSTEAD:
${contraInfo.alternatives.map((ex) => `  ✅ ${ex}`).join('\n')}`;
      }
    });
    return context;
  };

  return `\n🚨🚨🚨 CRITICAL - INJURY CONTRAINDICATIONS - ABSOLUTE REQUIREMENTS 🚨🚨🚨
Injuries: ${injuries.list.join(', ')}
${injuries.notes ? `Notes: ${injuries.notes}` : ''}

⛔ MANDATORY SAFETY REQUIREMENTS (NON-NEGOTIABLE):
1. STRICTLY AVOID ALL contraindicated exercises listed below - NO EXCEPTIONS
2. DO NOT include ANY exercise that contains words from the "avoid" list
3. DO NOT include variations or modifications of contraindicated exercises
4. Use ONLY safe alternatives and include modifications in safety tips
5. Double-check EVERY exercise name against the contraindication list before including it
${getInjuryContraindications(injuries.list)}

⚠️ VERIFICATION STEP (MANDATORY):
Before outputting your workout, review EACH exercise name and verify it does NOT contain
any words from the contraindicated list above. If it does, REPLACE it with a safe alternative.`;
}

function buildDurationGuidance(
  duration: number,
  programming: ProgrammingContext,
  workoutType: string,
  minExerciseCount: number,
  maxExerciseCount: number,
): string {
  const isTimeBasedWorkout = ['Cardio', 'Yoga', 'Pilates', 'Core Focus', 'HIIT', 'Abs'].includes(workoutType);

  // Dynamic variance based on duration
  let variance = 3;
  if (duration >= 90) {
    variance = Math.ceil(duration * 0.1); // ±10% for 90+ min workouts
  } else if (duration >= 60) {
    variance = Math.ceil(duration * 0.08); // ±8% for 60-89 min workouts
  } else if (duration >= 45) {
    variance = 4; // ±4 min for 45-59 min workouts
  }

  // Calculate warmup time
  const warmupTime = duration >= 30 ? 2.5 : (duration >= 20 ? 1.5 : 0);
  const availableTime = duration - warmupTime;
  const timePerExercise = (availableTime / ((minExerciseCount + maxExerciseCount) / 2)).toFixed(1);

  if (isTimeBasedWorkout) {
    return `\n⏱️ DURATION CALCULATION (TIME-BASED WORKOUT):
Formula: Time = (sets × work_seconds / 60) + ((sets - 1) × rest_seconds / 60)
Example: 4 sets × 45s work + 30s rest = (4 × 45/60) + (3 × 30/60) = 3 + 1.5 = 4.5 min

Target: ${duration} minutes (±${variance} min acceptable)
Warmup: ~${warmupTime} min
Available for exercises: ~${availableTime.toFixed(1)} min
Required: ${minExerciseCount}-${maxExerciseCount} exercises
Average per exercise: ~${timePerExercise} min
Typical: 3-5 sets of 30-45s work with 30-45s rest per exercise

🔴 CRITICAL: CALCULATE TOTAL BEFORE OUTPUTTING
Total = warmup + sum of all exercise times
Must equal ${duration} ± ${variance} minutes (${(duration - variance).toFixed(0)}-${(duration + variance).toFixed(0)} min)`;
  } else {
    const avgSets = (programming.sets[0] + programming.sets[1]) / 2;
    const avgRest = (programming.restSeconds[0] + programming.restSeconds[1]) / 2;
    const timePerExerciseStrength = (availableTime / ((minExerciseCount + maxExerciseCount) / 2)).toFixed(1);

    return `\n⏱️ DURATION CALCULATION (STRENGTH WORKOUT):
Formula: Time = (sets × 1 min) + ((sets - 1) × rest_seconds / 60)
Example: ${avgSets} sets × ${avgRest}s rest = ${avgSets} + (${avgSets - 1} × ${avgRest / 60}) = ${(avgSets + (avgSets - 1) * avgRest / 60).toFixed(1)} min

Target: ${duration} minutes (±${variance} min acceptable)
Warmup: ~${warmupTime} min
Available for exercises: ~${availableTime.toFixed(1)} min
Required: ${minExerciseCount}-${maxExerciseCount} exercises
Average per exercise: ~${timePerExerciseStrength} min
Compound: 120-180s rest, Isolation: 60-90s rest

🔴 CRITICAL: CALCULATE TOTAL BEFORE OUTPUTTING
Total = warmup + sum of all exercise times
Must equal ${duration} ± ${variance} minutes (${(duration - variance).toFixed(0)}-${(duration + variance).toFixed(0)} min)`;
  }
}


=================================================================================
FILE: functions/src/lib/promptBuilder.ts
=================================================================================
/**
 * Comprehensive prompt building system for AI workout generation
 * Extracts all prompt construction logic for better maintainability
 */

export interface WorkoutContext {
  experience?: string;
  goals?: string[];
  equipment?: string[];
  personalInfo?: {
    sex?: string;
    heightRange?: string;
    height?: string;
    weightRange?: string;
    weight?: string;
  };
  injuries?: {
    list?: string[];
    notes?: string;
  };
  workoutType?: string;
  duration?: number;
  targetIntensity?: number;
  progressionNote?: string;
  preferenceNotes?: string;
  recentWorkouts?: Array<{
    workoutType: string;
    timestamp: number;
    exercises: Array<{ name: string }>;
  }>;
}

export interface ProgrammingContext {
  sets: [number, number];
  reps: [number, number];
  restSeconds: [number, number];
  intensity: string;
}

/**
 * Enhanced workout type context with specific exercise examples and programming guidance
 */
export function getWorkoutTypeContext(type: string | undefined): string {
  if (!type) {
    type = 'Full Body';
  }

  const contexts: Record<string, string> = {
    'Full Body':
      'Focus: Total body conditioning with balanced muscle group coverage.\nMovement Patterns: Squat, hinge, push, pull, carry.\nExample Exercises: Squats, deadlifts, push-ups, rows, lunges, planks.\nProgramming: 6-12 reps, compound movements prioritized, 2-3 exercises per major muscle group.',
    'Upper Body':
      'Focus: Chest, back, shoulders, arms with push/pull balance.\nMovement Patterns: Horizontal push/pull, vertical push/pull, isolation.\nExample Exercises: Bench press, rows, shoulder press, pull-ups, dips, bicep curls, tricep extensions.\nProgramming: 6-15 reps, balance pushing and pulling movements 1:1 ratio.',
    'Lower Body':
      'Focus: Legs, glutes, calves with knee and hip dominant movements.\nMovement Patterns: Squat, hinge, lunge, single-leg, calf.\nExample Exercises: Squats, deadlifts, lunges, leg press, Romanian deadlifts, calf raises, glute bridges.\nProgramming: 8-15 reps, prioritize compound movements, include unilateral work.',
    Cardio:
      'Focus: Cardiovascular endurance and metabolic conditioning.\nMovement Patterns: Continuous movement, intervals, circuits.\nExample Exercises: Jumping jacks, burpees, mountain climbers, high knees, jump rope, running in place.\nProgramming: Time-based (30-60s work periods), minimal rest (15-30s), bodyweight preferred.',
    'Core Focus':
      'Focus: Abdominals, obliques, lower back, stability.\nMovement Patterns: Anti-extension, anti-rotation, anti-lateral flexion.\nExample Exercises: Planks, dead bugs, bird dogs, pallof press, Russian twists, bicycle crunches.\nProgramming: 10-20 reps or 30-60s holds, focus on control and stability.',
    'Legs/Glutes':
      'Focus: Lower body power, glute development, leg strength.\nMovement Patterns: Hip hinge, squat, lunge, hip thrust.\nExample Exercises: Hip thrusts, Romanian deadlifts, Bulgarian split squats, goblet squats, glute bridges, step-ups.\nProgramming: 8-15 reps, emphasize hip-dominant movements, include glute activation.',
    'Chest/Triceps':
      'Focus: Chest development and tricep strength.\nMovement Patterns: Horizontal press, incline press, tricep extension.\nExample Exercises: Bench press, incline press, push-ups, chest flyes, tricep dips, overhead extensions, close-grip press.\nProgramming: 6-15 reps, multiple chest angles, finish with tricep isolation.',
    'Back/Biceps':
      'Focus: Back width/thickness and bicep size.\nMovement Patterns: Vertical pull, horizontal pull, bicep curl.\nExample Exercises: Pull-ups, rows, lat pulldowns, face pulls, bicep curls, hammer curls, concentration curls.\nProgramming: 6-15 reps, prioritize compound pulling, finish with bicep isolation.',
    Shoulders:
      'Focus: Deltoid development (front, side, rear) and shoulder stability.\nMovement Patterns: Vertical press, lateral raise, rear delt work.\nExample Exercises: Shoulder press, lateral raises, front raises, rear delt flyes, face pulls, Arnold press.\nProgramming: 8-15 reps, hit all three deltoid heads, include rotator cuff work.',
    Yoga:
      'Focus: Flexibility, mindfulness, balance, breath control.\nMovement Patterns: Flowing sequences, static holds, balance poses.\nExample Exercises: Sun salutations, warrior poses, downward dog, child\'s pose, tree pose, pigeon pose.\nProgramming: 30-90s holds, flowing transitions, focus on breath and alignment.',
    Pilates:
      'Focus: Core strength, stability, control, mind-body connection.\nMovement Patterns: Controlled movements, core engagement, precise execution.\nExample Exercises: Hundred, roll-ups, leg circles, single leg stretch, plank variations, side-lying leg lifts.\nProgramming: 8-15 controlled reps, emphasis on core engagement and breathing.',
    'HIIT':
      'Focus: High-intensity intervals with maximum effort and short recovery.\nMovement Patterns: Explosive movements, plyometrics, sprint intervals, metabolic circuits.\nExample Exercises: Burpees, jump squats, box jumps, sprint intervals, battle ropes, kettlebell swings, mountain climbers.\nProgramming: 20-45s max effort, 10-30s rest, 4-8 rounds per exercise, total body emphasis.',
    'Mobility/Flexibility':
      'Focus: Joint range of motion, tissue extensibility, movement quality.\nMovement Patterns: Dynamic stretching, controlled articular rotations, PNF stretching, mobility flows.\nExample Exercises: Hip CARs, shoulder dislocations, world\'s greatest stretch, 90/90 hip switches, thoracic rotations, ankle mobility drills.\nProgramming: 30-60s holds or 8-12 controlled reps, focus on end-range control and breathing.',
    'Functional Training':
      'Focus: Real-world movement patterns, multi-planar motion, practical strength.\nMovement Patterns: Loaded carries, rotational power, unilateral movements, ground-to-standing.\nExample Exercises: Farmer\'s carries, Turkish get-ups, single-leg deadlifts, medicine ball slams, sled pushes, sandbag cleans.\nProgramming: 6-12 reps, focus on movement quality, balance strength and stability, varied tempos.',
    'Athletic Performance':
      'Focus: Sport-specific power, speed, agility, and explosive strength.\nMovement Patterns: Plyometrics, Olympic lift variations, sprint mechanics, change of direction.\nExample Exercises: Box jumps, broad jumps, power cleans, hang snatches, lateral bounds, agility ladder drills, medicine ball throws.\nProgramming: 3-8 reps for power, 180-240s rest, emphasize speed and explosiveness, technical precision.',
  };
  const context = contexts[type] || contexts['Full Body'];
  return context || '';
}

/**
 * Build comprehensive injury context with explicit contraindications
 */
export function getInjuryContraindications(injuryList: string[]): string {
  const contraindications: Record<string, { avoid: string[]; alternatives: string[] }> = {
    knee: {
      avoid: [
        'deep squats',
        'lunges',
        'Bulgarian split squats',
        'jump squats',
        'box jumps',
        'burpees',
        'pistol squats',
        'jumping lunges',
        'plyometric exercises',
      ],
      alternatives: [
        'glute bridges',
        'hip thrusts',
        'wall sits (limited depth)',
        'leg press (if available)',
        'step-ups (low height)',
        'seated leg extensions (light weight)',
      ],
    },
    'lower back': {
      avoid: [
        'deadlifts',
        'Romanian deadlifts',
        'good mornings',
        'bent-over rows',
        'overhead press',
        'sit-ups',
        'Russian twists',
        'toe touches',
        'supermans',
        'hyperextensions',
      ],
      alternatives: [
        'glute bridges',
        'bird dogs',
        'dead bugs',
        'planks',
        'side planks',
        'cable rows (supported)',
        'chest-supported rows',
        'pallof press',
      ],
    },
    shoulder: {
      avoid: [
        'overhead press',
        'military press',
        'behind-the-neck press',
        'upright rows',
        'lateral raises (if painful)',
        'handstand push-ups',
        'dips (if painful)',
        'pull-ups (if impingement)',
      ],
      alternatives: [
        'landmine press',
        'neutral grip dumbbell press',
        'push-ups (modified)',
        'cable chest press',
        'face pulls',
        'band pull-aparts',
        'scapular wall slides',
      ],
    },
    ankle: {
      avoid: [
        'jumping exercises',
        'box jumps',
        'burpees',
        'calf raises',
        'running',
        'sprinting',
        'agility drills',
        'jump rope',
      ],
      alternatives: [
        'seated exercises',
        'swimming motions',
        'upper body focus',
        'core work',
        'seated bike (if tolerated)',
        'resistance band exercises',
      ],
    },
    wrist: {
      avoid: [
        'push-ups',
        'planks',
        'handstands',
        'burpees',
        'mountain climbers',
        'front squats',
        'clean and jerk',
      ],
      alternatives: [
        'forearm planks',
        'push-ups on fists or handles',
        'dumbbell exercises',
        'cable exercises',
        'machine exercises',
        'leg-focused movements',
      ],
    },
    neck: {
      avoid: [
        'overhead press',
        'behind-the-neck movements',
        'headstands',
        'neck bridges',
        'heavy shrugs',
        'upright rows',
      ],
      alternatives: [
        'neutral spine exercises',
        'supported movements',
        'machine-based exercises',
        'gentle mobility work',
      ],
    },
  };

  let context = '';
  injuryList.forEach((injury) => {
    const injuryKey = injury.toLowerCase();
    const contraInfo = contraindications[injuryKey];
    if (contraInfo) {
      context += `\n\n⚠️ ${injury.toUpperCase()} INJURY - CRITICAL SAFETY REQUIREMENTS:
DO NOT INCLUDE ANY OF THESE EXERCISES:
${contraInfo.avoid.map((ex) => `  ❌ ${ex}`).join('\n')}

SAFE ALTERNATIVES TO USE INSTEAD:
${contraInfo.alternatives.map((ex) => `  ✅ ${ex}`).join('\n')}`;
    }
  });
  return context;
}

/**
 * Build injury context section for prompt
 */
export function buildInjuryContext(injuries?: { list?: string[]; notes?: string }): string {
  if (!injuries?.list || injuries.list.length === 0) {
    return '';
  }

  return `\n\n🚨 CRITICAL - INJURY CONSIDERATIONS:
User has reported injuries: ${injuries.list.join(', ')}
${injuries.notes ? `Additional context: ${injuries.notes}` : ''}

MANDATORY REQUIREMENTS:
1. STRICTLY AVOID all contraindicated exercises listed below
2. Use ONLY the safe alternatives provided for each injury
3. Prioritize safety over workout variety or intensity
4. Include modifications and regression options in safety tips
5. If unsure about an exercise, choose a safer alternative
${getInjuryContraindications(injuries.list)}`;
}

/**
 * Build intensity context section for prompt
 */
export function buildIntensityContext(
  targetIntensity: number,
  progressionNote?: string,
): string {
  if (targetIntensity === 1.0 && !progressionNote) {
    return '';
  }

  return `\n\nINTENSITY GUIDANCE:
- Target intensity scalar: ${targetIntensity.toFixed(2)}x baseline
${progressionNote ? `- Progression note: ${progressionNote}` : ''}
- Adjust sets, reps, or rest periods accordingly`;
}

/**
 * Build personal info context section for prompt
 */
export function buildPersonalContext(personalInfo?: {
  sex?: string;
  heightRange?: string;
  height?: string;
  weightRange?: string;
  weight?: string;
}): string {
  if (!personalInfo) {
    return '';
  }

  return `\n\nPERSONAL PROFILE:
- Gender: ${personalInfo.sex || 'Not specified'}
- Height: ${personalInfo.height || personalInfo.heightRange || 'Not specified'}
- Weight: ${personalInfo.weight || personalInfo.weightRange || 'Not specified'}

PERSONALIZATION CONSIDERATIONS:
- Adjust exercise selection based on body mechanics and anthropometry
- Consider joint stress and loading appropriate for body weight
- Tailor intensity recommendations to individual capacity
- Select exercises that accommodate body proportions and leverage`;
}

/**
 * Build workout history context section for prompt
 */
export function buildWorkoutHistoryContext(
  recentWorkouts?: Array<{
    workoutType: string;
    timestamp: number;
    exercises: Array<{ name: string }>;
  }>,
): string {
  if (!recentWorkouts || recentWorkouts.length === 0) {
    return '';
  }

  return `\n\nRECENT WORKOUT HISTORY:
${recentWorkouts
    .slice(0, 3)
    .map(
      (w, i) =>
        `${i + 1}. ${w.workoutType} (${Math.floor((Date.now() - w.timestamp) / (1000 * 60 * 60 * 24))} days ago)
   Exercises: ${w.exercises.map((e) => e.name).join(', ')}`,
    )
    .join('\n')}

PROGRESSION GUIDANCE:
- Provide variety by avoiding exact repetition of recent exercises
- Progress difficulty appropriately based on workout frequency
- Consider exercise variations that build on previous movements
- Maintain consistency with user's training patterns while adding novelty`;
}

/**
 * Build programming context with evidence-based guidelines
 */
export function buildProgrammingContext(programming: ProgrammingContext): string {
  return `\n\nEVIDENCE-BASED PROGRAMMING GUIDELINES:
Goal-Specific Parameters:
- Sets: ${programming.sets[0]}-${programming.sets[1]}
- Reps: ${programming.reps[0]}-${programming.reps[1]}
- Rest: ${programming.restSeconds[0]}-${programming.restSeconds[1]} seconds
- Intensity: ${programming.intensity}

CRITICAL REST PERIOD REQUIREMENTS (MUST FOLLOW):
- Compound movements (squats, deadlifts, presses, rows): 120-180 seconds minimum
- Isolation movements (curls, extensions, raises, flyes): 60-90 seconds
- Plyometric/cardio exercises (jumps, sprints, burpees): 45-90 seconds
- Core/stability exercises (planks, holds): 45-60 seconds
- DO NOT use rest periods shorter than these minimums - adequate rest is essential for safety and performance

REP FORMAT STANDARDS:
- Use ranges for strength/hypertrophy: "6-8", "8-12", "10-15"
- Use time for cardio/HIIT/time-based exercises: "30s", "45s", "60s" (single values preferred, NOT ranges like "30-45s")
- Use time for isometric holds: "30s", "45s", "60s" (NOT "Hold for 30 seconds")
- Use "each side" or "per leg" for unilateral exercises: "10-12 each side"`;
}

/**
 * Calculate duration guidance and exercise count requirements
 */
export function buildDurationGuidance(
  duration: number,
  programming: ProgrammingContext,
  workoutType?: string,
): {
  guidance: string;
  warmupTimeMinutes: number;
  minExerciseCount: number;
  maxExerciseCount: number;
} {
  const avgSetsPerExercise = (programming.sets[0] + programming.sets[1]) / 2;
  const avgRestPerSet = (programming.restSeconds[0] + programming.restSeconds[1]) / 2;

  // Warmup time allocation
  // For very short workouts (20-25 min), reduce warmup time to avoid over-allocation
  const warmupTimeMinutes = duration >= 30 ? 2.5 : (duration >= 20 ? 1.5 : 0);
  const availableWorkoutMinutes = duration - warmupTimeMinutes;

  // Determine if this is a time-based workout (Cardio, Yoga, Pilates, HIIT, Abs)
  const isTimeBasedWorkout = workoutType && ['Cardio', 'Yoga', 'Pilates', 'Core Focus', 'HIIT', 'Abs'].includes(workoutType);

  // Calculate minimum exercise count needed to fill the duration
  let avgTimePerExercise: number;
  let timeCalculationFormula: string;
  let exampleCalculation: string;

  if (isTimeBasedWorkout) {
    // For time-based workouts, assume 30-45s work periods
    const avgWorkSeconds = 40; // Average of 30-60s
    avgTimePerExercise = avgSetsPerExercise * (avgWorkSeconds / 60) + ((avgSetsPerExercise - 1) * avgRestPerSet) / 60;

    timeCalculationFormula = `For time-based exercises (e.g., "30s", "45s", "60s"):
  Time = (sets × time_per_set / 60) + ((sets - 1) × rest_seconds / 60)

For rep-based exercises:
  Time = (sets × 1 minute) + ((sets - 1) × rest_seconds / 60)`;

    exampleCalculation = `EXAMPLE with ${avgSetsPerExercise.toFixed(0)} sets, ${avgWorkSeconds}s work, ${avgRestPerSet.toFixed(0)}s rest:
  Time = (${avgSetsPerExercise.toFixed(0)} × ${avgWorkSeconds}/60) + (${(avgSetsPerExercise - 1).toFixed(0)} × ${avgRestPerSet.toFixed(0)}/60)
  Time = ${(avgSetsPerExercise * avgWorkSeconds / 60).toFixed(1)} + ${(((avgSetsPerExercise - 1) * avgRestPerSet) / 60).toFixed(1)} = ${avgTimePerExercise.toFixed(1)} minutes per exercise`;
  } else {
    // For regular strength workouts
    avgTimePerExercise = avgSetsPerExercise + ((avgSetsPerExercise - 1) * avgRestPerSet) / 60;

    timeCalculationFormula = `For each exercise, calculate time as:
  Time = (sets × 1 minute) + ((sets - 1) × rest_seconds / 60)`;

    exampleCalculation = `EXAMPLE with ${avgSetsPerExercise.toFixed(0)} sets and ${avgRestPerSet.toFixed(0)}s rest:
  Time = (${avgSetsPerExercise.toFixed(0)} × 1) + (${(avgSetsPerExercise - 1).toFixed(0)} × ${avgRestPerSet.toFixed(0)}/60)
  Time = ${avgSetsPerExercise.toFixed(0)} + ${(((avgSetsPerExercise - 1) * avgRestPerSet) / 60).toFixed(1)} = ${avgTimePerExercise.toFixed(1)} minutes per exercise`;
  }

  const minExerciseCount = Math.max(4, Math.floor(availableWorkoutMinutes / avgTimePerExercise));
  const maxExerciseCount = Math.ceil(availableWorkoutMinutes / (avgTimePerExercise * 0.8)); // Allow 20% buffer

  const guidance = `\n\n═══════════════════════════════════════════════════════════════
⏱️  DURATION CONSTRAINT - CRITICAL REQUIREMENT ⏱️
═══════════════════════════════════════════════════════════════
Total workout time: ${duration} minutes
${warmupTimeMinutes > 0 ? `Warmup allocation: ${warmupTimeMinutes} minutes (1-2 warmup exercises with 1 set each)` : ''}
Available time for main exercises: ${availableWorkoutMinutes.toFixed(1)} minutes

🔢 TIME CALCULATION FORMULA (YOU MUST USE THIS):
${timeCalculationFormula}

📊 ${exampleCalculation}

🎯 REQUIRED EXERCISE COUNT:
Based on ${availableWorkoutMinutes.toFixed(1)} minutes available and ~${avgTimePerExercise.toFixed(1)} minutes per exercise:
YOU MUST GENERATE BETWEEN ${minExerciseCount} AND ${maxExerciseCount} EXERCISES

⚠️  BEFORE YOU OUTPUT - CALCULATE TOTAL TIME (MANDATORY):
${isTimeBasedWorkout ? `
STEP-BY-STEP CALCULATION FOR TIME-BASED WORKOUTS:
1. For EACH exercise with time-based reps (e.g., "30s", "45s", "60s"):
   - Extract the seconds from reps (e.g., "60s" = 60 seconds)
   - Work time = sets × (seconds / 60) minutes
   - Rest time = (sets - 1) × (restSeconds / 60) minutes
   - Exercise total = work time + rest time

   EXAMPLE: 6 sets of "60s" with 30s rest
   - Work: 6 × (60/60) = 6 minutes
   - Rest: 5 × (30/60) = 2.5 minutes
   - Total: 6 + 2.5 = 8.5 minutes

2. SUM all exercise times
3. Your total MUST be between ${duration - 3} and ${duration + 3} minutes
4. If total < ${duration - 3} minutes: REDUCE work time per set OR REDUCE sets
5. If total > ${duration + 3} minutes: REDUCE work time per set OR REDUCE sets OR REMOVE exercise

CRITICAL: For a ${duration}-minute cardio workout, you need FEWER sets with SHORTER work periods!
Typical cardio: 3-5 sets of 30-45s work with 30-45s rest = 3-5 minutes per exercise
` : `
STEP-BY-STEP CALCULATION FOR STRENGTH WORKOUTS:
1. For EACH exercise:
   - Work time = sets × 1 minute (assume 1 min per set for execution)
   - Rest time = (sets - 1) × (restSeconds / 60) minutes
   - Exercise total = work time + rest time

   EXAMPLE 1: 4 sets with 120s rest
   - Work: 4 × 1 = 4 minutes
   - Rest: 3 × (120/60) = 6 minutes
   - Total: 4 + 6 = 10 minutes

   EXAMPLE 2: 5 sets with 180s rest (for strength training)
   - Work: 5 × 1 = 5 minutes
   - Rest: 4 × (180/60) = 12 minutes
   - Total: 5 + 12 = 17 minutes

2. SUM all exercise times
3. Your total MUST be between ${duration - 3} and ${duration + 3} minutes
4. If total < ${duration - 3} minutes: ADD MORE EXERCISES or INCREASE sets (especially for long workouts!)
5. If total > ${duration + 3} minutes: REDUCE sets or REMOVE an exercise

⚠️  CRITICAL FOR ${duration}-MINUTE WORKOUTS:
${duration >= 60 ? '- For 60+ minute workouts with long rest (150-300s), use 5-6 sets for main exercises\n- With 180s rest, each exercise takes ~13-17 minutes, so you need 4-5 exercises minimum\n- DO NOT use only 3-4 sets - the workout will be too short!' : duration >= 45 ? '- For 45-minute workouts, you need 4-6 exercises with 3-5 sets each\n- Calculate carefully to ensure you hit the target duration' : '- For 30-minute workouts, you need 4-5 exercises with 3-4 sets each'}
`}

💡 QUICK CALCULATION:
- Target: ${duration} minutes
- Per exercise: ~${avgTimePerExercise.toFixed(1)} minutes
- Needed: ${Math.ceil(duration / avgTimePerExercise)} exercises minimum
- Generate: ${minExerciseCount}-${maxExerciseCount} exercises`;

  return {
    guidance,
    warmupTimeMinutes,
    minExerciseCount,
    maxExerciseCount,
  };
}

/**
 * Build warmup requirement section
 */
export function buildWarmupRequirement(duration: number, warmupTimeMinutes: number): string {
  if (duration < 20) {
    return '';
  }

  return `\n\nWARM-UP REQUIREMENT (MANDATORY):
- Include 1-2 dynamic warm-up exercises at the BEGINNING of the workout
- Warmup exercises should take approximately ${warmupTimeMinutes} minutes total
- Choose movements that are low-intensity and mobility-focused
- Select exercises appropriate for the workout type and target muscle groups
- Mark these as difficulty: 'beginner' regardless of user's experience level
- Use 1 set of 8-12 reps or 30-45s holds for warm-up exercises
- Warmup exercises count toward your total exercise count`;
}

/**
 * Build complete workout generation prompt
 */
export function buildWorkoutPrompt(
  context: WorkoutContext,
  programming: ProgrammingContext,
  qualityGuidelines: string,
): {
  prompt: string;
  minExerciseCount: number;
  maxExerciseCount: number;
} {
  const duration = context.duration || 30;
  const workoutType = context.workoutType || 'Full Body';
  const experience = context.experience || 'Beginner';
  const goals = context.goals || ['General Fitness'];
  const equipment = context.equipment || ['Bodyweight only'];

  const durationInfo = buildDurationGuidance(duration, programming, workoutType);
  const warmupRequirement = buildWarmupRequirement(duration, durationInfo.warmupTimeMinutes);

  const prompt = `Create a personalized ${duration}-minute ${workoutType} workout for a ${experience} level client.

═══════════════════════════════════════════════════════════════
CLIENT PROFILE
═══════════════════════════════════════════════════════════════
Experience Level: ${experience}
Primary Goals: ${goals.join(', ')}
Available Equipment: ${equipment.join(', ')}
Workout Type: ${workoutType}
Duration: ${duration} minutes
${getWorkoutTypeContext(workoutType)}${buildPersonalContext(context.personalInfo)}${buildInjuryContext(context.injuries)}${buildIntensityContext(context.targetIntensity || 1.0, context.progressionNote)}${buildWorkoutHistoryContext(context.recentWorkouts)}

═══════════════════════════════════════════════════════════════
PROGRAMMING REQUIREMENTS
═══════════════════════════════════════════════════════════════
${buildProgrammingContext(programming)}${durationInfo.guidance}${warmupRequirement}

EXERCISE SELECTION REQUIREMENTS:
1. NO DUPLICATE EXERCISES - Each exercise name must be completely unique
2. Use ONLY real, evidence-based exercises with standard names (e.g., "Barbell Back Squat", "Dumbbell Bench Press")
3. Balance muscle groups appropriately:
   - Full Body: Include push, pull, legs, and core movements
   - Upper Body: Balance horizontal/vertical push and pull
   - Lower Body: Balance quad-dominant, hip-dominant, and unilateral movements
4. Vary movement patterns: Different angles, grips, stances, and ranges of motion
5. Progressive ordering: Compound movements first, then isolation, then core/stability
6. Match workout type exactly - don't include leg exercises in an upper body workout

EXERCISE APPROPRIATENESS:
- Beginner: Focus on fundamental movement patterns, bilateral exercises, machine/bodyweight emphasis
  Examples: Push-ups, Squats, Lunges, Planks, Glute Bridges, Dumbbell Bench Press, Leg Press
- Intermediate: Include unilateral work, free weights, moderate complexity
  Examples: Barbell Squats, Deadlifts, Single-arm rows, Bulgarian split squats, Pull-ups
- Advanced: Complex movements, advanced variations, higher skill requirements
  Examples: Olympic lifts, Plyometrics, Muscle-ups, Handstand push-ups, Explosive movements
- Consider equipment availability - don't prescribe exercises requiring unavailable equipment
- Respect injury contraindications - NEVER include exercises that stress injured areas
- Match exercise difficulty to user experience level - no advanced exercises for beginners

═══════════════════════════════════════════════════════════════
QUALITY STANDARDS
═══════════════════════════════════════════════════════════════
${qualityGuidelines}

Exercise Descriptions (100-150 characters):
- Starting position and setup
- Movement execution with key cues
- Breathing pattern (exhale on exertion)
- Be concise but complete

Form Tips (EXACTLY 3 per exercise):
- Most common technique errors to avoid
- Specific joint alignment cues
- Movement quality focus points
- Each tip should be actionable and specific

Safety Tips (EXACTLY 2 per exercise):
- Primary injury prevention guidance
- Modification or regression option
- Each tip should address a specific safety concern

═══════════════════════════════════════════════════════════════
🚨 CRITICAL RULES - MANDATORY COMPLIANCE 🚨
═══════════════════════════════════════════════════════════════
⏱️  DURATION (MOST IMPORTANT):
   - Generate ${durationInfo.minExerciseCount}-${durationInfo.maxExerciseCount} exercises to fill ${duration} minutes
   - Total time MUST be ${duration - 3} to ${duration + 3} minutes
   - Calculate total BEFORE outputting: sum of [(sets × 1) + ((sets - 1) × restSeconds / 60)]

🎯 EXERCISE SELECTION:
   - ALL exercise names must be unique (no duplicates)
   - Match workout type exactly: ${workoutType}
   - If injuries present, STRICTLY AVOID all contraindicated exercises
   - Use ONLY equipment available: ${equipment.join(', ')}

📊 PROGRAMMING PARAMETERS:
   - Rest periods: Compound 120-180s, Isolation 60-90s, Cardio/Core 45-60s
   - Sets: Integer 1-10 (typically 3-4 for main, 1-2 for warmup)
   - Reps: String format - "8-12" for strength ranges, "30s" or "45s" for time (single values only, NOT "30-45s"), "10 each side" for unilateral
   - Difficulty: ALL exercises = "${experience.toLowerCase()}"
   - usesWeight: true for dumbbells/barbells/kettlebells/bands, false for bodyweight

✅ REQUIRED FIELDS (ALL MANDATORY):
   - formTips: Array with EXACTLY 3 strings
   - safetyTips: Array with EXACTLY 2 strings
   - muscleGroups: Array with 1-3 specific muscles (e.g., ["quadriceps", "glutes"])

═══════════════════════════════════════════════════════════════
JSON OUTPUT SCHEMA - STRICT COMPLIANCE REQUIRED
═══════════════════════════════════════════════════════════════
You MUST output valid JSON matching this EXACT schema. All fields are REQUIRED.

{
  "exercises": [
    {
      "name": "Exercise Name (unique, standard name)",
      "description": "Complete description 100-150 chars with setup, execution, breathing",
      "sets": 3,
      "reps": "8-12",
      "formTips": [
        "First form tip - specific and actionable",
        "Second form tip - addresses common error",
        "Third form tip - joint alignment or quality cue"
      ],
      "safetyTips": [
        "First safety tip - injury prevention",
        "Second safety tip - modification option"
      ],
      "restSeconds": 120,
      "usesWeight": true,
      "muscleGroups": ["chest", "triceps"],
      "difficulty": "${experience.toLowerCase()}"
    }
  ],
  "workoutSummary": {
    "totalVolume": "Calculate total: e.g., '18 sets, 144-216 reps'",
    "primaryFocus": "Describe main focus: e.g., 'Upper body strength with chest and back emphasis'",
    "expectedRPE": "Rate difficulty: e.g., '6-7 out of 10 for ${experience} level'"
  }
}

═══════════════════════════════════════════════════════════════
⚠️  PRE-OUTPUT VALIDATION CHECKLIST ⚠️
═══════════════════════════════════════════════════════════════
BEFORE YOU OUTPUT, VERIFY THESE IN ORDER:

1️⃣  DURATION (MOST CRITICAL):
   Calculate: For each exercise, time = (sets × 1) + ((sets - 1) × restSeconds / 60)
   Sum all times: MUST be ${duration - 3} to ${duration + 3} minutes
   ❌ If total < ${duration - 3} min: ADD MORE EXERCISES
   ❌ If total > ${duration + 3} min: REDUCE sets or REMOVE exercise

2️⃣  EXERCISE VALIDATION:
   ✓ Exercise count: ${durationInfo.minExerciseCount}-${durationInfo.maxExerciseCount} exercises
   ✓ ALL names unique (no duplicates)
   ✓ ALL match workout type: ${workoutType}
   ✓ No contraindicated exercises for injuries
   ✓ Equipment matches: ${equipment.join(', ')}

3️⃣  FIELD VALIDATION:
   ✓ Sets: integers 1-10
   ✓ Reps: strings (not numbers)
   ✓ formTips: EXACTLY 3 items
   ✓ safetyTips: EXACTLY 2 items
   ✓ restSeconds: integers 45-300
   ✓ usesWeight: boolean
   ✓ muscleGroups: 1-3 items
   ✓ difficulty: "${experience.toLowerCase()}"

Output the JSON now:`.trim();

  return {
    prompt,
    minExerciseCount: durationInfo.minExerciseCount,
    maxExerciseCount: durationInfo.maxExerciseCount,
  };
}

/**
 * Build system message for AI
 */
export function buildSystemMessage(_duration: number, workoutType?: string): string {
  const isTimeBasedWorkout = workoutType && ['Cardio', 'Yoga', 'Pilates', 'Core Focus', 'HIIT', 'Abs'].includes(workoutType);

  const durationInstructions = isTimeBasedWorkout ? `
⏱️  ⏱️  ⏱️  CRITICAL DURATION REQUIREMENT - TIME-BASED WORKOUTS ⏱️  ⏱️  ⏱️

THE MOST IMPORTANT RULE: Your workout MUST match the requested duration.

STEP-BY-STEP PROCESS FOR TIME-BASED WORKOUTS (FOLLOW EXACTLY):
1. Read the requested duration from the user prompt
2. For EACH exercise with time-based reps (e.g., "30s", "45s", "60s"):
   - Extract seconds from reps: "60s" = 60 seconds
   - Work time = sets × (seconds / 60) minutes
   - Rest time = (sets - 1) × (restSeconds / 60) minutes
   - Exercise total = work time + rest time
3. SUM all exercise times to get total workout time
4. CHECK: Is total within ± 3 minutes of requested duration?
   - If TOO SHORT: INCREASE work time per set OR ADD sets
   - If TOO LONG: REDUCE work time per set OR REDUCE sets OR REMOVE exercise
5. ONLY output your JSON when total time is correct

EXAMPLE FOR 20-MINUTE CARDIO WORKOUT:
- Exercise 1: 4 sets of "45s", 30s rest = (4 × 45/60) + (3 × 30/60) = 3 + 1.5 = 4.5 min
- Exercise 2: 4 sets of "45s", 30s rest = (4 × 45/60) + (3 × 30/60) = 3 + 1.5 = 4.5 min
- Exercise 3: 4 sets of "45s", 30s rest = (4 × 45/60) + (3 × 30/60) = 3 + 1.5 = 4.5 min
- Exercise 4: 4 sets of "45s", 30s rest = (4 × 45/60) + (3 × 30/60) = 3 + 1.5 = 4.5 min
Total: 4.5 + 4.5 + 4.5 + 4.5 = 18 minutes ✓ (within 20 ± 3)

CRITICAL: Use FEWER sets (3-5) and SHORTER work periods (30-45s) for cardio workouts!
` : `
⏱️  ⏱️  ⏱️  CRITICAL DURATION REQUIREMENT - STRENGTH WORKOUTS ⏱️  ⏱️  ⏱️

THE MOST IMPORTANT RULE: Your workout MUST match the requested duration.

STEP-BY-STEP PROCESS (FOLLOW EXACTLY):
1. Read the requested duration from the user prompt
2. Calculate time for EACH exercise: time = (sets × 1) + ((sets - 1) × restSeconds / 60)
3. SUM all exercise times to get total workout time
4. CHECK: Is total within ± 3 minutes of requested duration?
   - If TOO SHORT (< requested - 3): ADD MORE EXERCISES and recalculate
   - If TOO LONG (> requested + 3): REDUCE sets or REMOVE an exercise and recalculate
5. ONLY output your JSON when total time is correct

EXAMPLE FOR 60-MINUTE STRENGTH WORKOUT (LONG REST PERIODS):
- Exercise 1: 5 sets, 180s rest = 5 + (4 × 3) = 17 min
- Exercise 2: 5 sets, 180s rest = 5 + (4 × 3) = 17 min
- Exercise 3: 4 sets, 150s rest = 4 + (3 × 2.5) = 11.5 min
- Exercise 4: 4 sets, 120s rest = 4 + (3 × 2) = 10 min
- Exercise 5: 3 sets, 90s rest = 3 + (2 × 1.5) = 6 min
Total: 17+17+11.5+10+6 = 61.5 minutes ✓ (within 60 ± 3)

CRITICAL: For 60-minute workouts with long rest (150-300s), you MUST use 5-6 sets for main exercises!
If you use only 3-4 sets, the workout will be too short. Calculate BEFORE outputting!
`;

  return `You are a certified personal trainer (NASM-CPT, CSCS, ACSM-CEP) with expertise in exercise science, periodization, and injury prevention.

${durationInstructions}

OTHER CRITICAL INSTRUCTIONS:
- Output ONLY valid JSON (no markdown, no code blocks, no explanatory text)
- All exercise names must be unique (no duplicates)
- Match the workout type exactly
- Respect injury contraindications
- Follow the exact schema in the user prompt`;
}


=================================================================================
FILE: functions/src/lib/promptEnhancements.ts
=================================================================================
/**
 * Simplified prompt enhancements for AI workout generation
 * Focuses on quality standards, injury-specific safety, and experience-level guidance
 */

export interface PromptContext {
  injuries?: string[];
  experience?: string;
}

/**
 * Generate injury-specific safety guidance
 */
function generateInjurySafetyGuidance(injuries?: string[]): string {
  if (!injuries || injuries.length === 0) {
    return '';
  }

  const safetyPoints: string[] = ['\nINJURY-SPECIFIC SAFETY:'];

  injuries.forEach((injury) => {
    const injuryLower = injury.toLowerCase();

    if (injuryLower.includes('knee')) {
      safetyPoints.push(
        '- KNEE SAFETY: Avoid deep knee flexion, ensure proper tracking',
        '- Modify jumping and pivoting movements',
        '- Use knee-friendly alternatives like wall sits or glute bridges',
      );
    }

    if (injuryLower.includes('back') || injuryLower.includes('spine')) {
      safetyPoints.push(
        '- BACK SAFETY: Maintain neutral spine alignment',
        '- Avoid spinal flexion under load',
        '- Include core activation cues and bracing techniques',
      );
    }

    if (injuryLower.includes('shoulder')) {
      safetyPoints.push(
        '- SHOULDER SAFETY: Avoid overhead movements if impingement present',
        '- Include scapular stability and mobility work',
        '- Modify pressing movements to pain-free ranges',
      );
    }

    if (injuryLower.includes('ankle')) {
      safetyPoints.push(
        '- ANKLE SAFETY: Avoid jumping and plyometric movements',
        '- Modify balance and stability exercises',
        '- Use seated or supported alternatives',
      );
    }

    if (injuryLower.includes('wrist')) {
      safetyPoints.push(
        '- WRIST SAFETY: Avoid exercises requiring wrist extension under load',
        '- Use fist position or parallettes for push-ups',
        '- Modify plank variations to forearms',
      );
    }
  });

  return safetyPoints.join('\n');
}

/**
 * Generate experience-specific form and safety guidance
 */
function generateExperienceGuidance(experience?: string): string {
  const level = experience?.toLowerCase() || 'beginner';

  const experienceGuidance: Record<string, string> = {
    beginner: `
BEGINNER-SPECIFIC GUIDANCE:
- Form Tips: Focus on fundamental movement patterns, proper setup, and controlled tempo
  * Include detailed setup instructions (foot placement, grip width, body position)
  * Emphasize slow, controlled movement (3-second eccentric, 1-second concentric)
  * Provide clear breathing cues (exhale on exertion, inhale on return)
  * Highlight common beginner mistakes to avoid
- Safety Tips: Emphasize starting with lighter loads, proper warm-up, and when to stop
  * Always include a regression or easier variation
  * Specify warning signs to stop (sharp pain, dizziness, form breakdown)
  * Recommend starting with bodyweight or light resistance
- Exercise Selection: Prioritize stable, bilateral movements with clear movement patterns
  * Machines and bodyweight exercises preferred over free weights
  * Avoid complex barbell movements requiring extensive coaching
  * Include exercises with built-in stability (e.g., goblet squat vs barbell back squat)`,
    intermediate: `
INTERMEDIATE-SPECIFIC GUIDANCE:
- Form Tips: Focus on movement quality, tempo variations, and mind-muscle connection
  * Include technique refinements and advanced cues
  * Emphasize proper muscle engagement and activation
  * Provide tempo variations for different training effects
  * Address common plateaus and how to overcome them
- Safety Tips: Include load progression guidelines and recovery considerations
  * Specify appropriate load increases (5-10% per week)
  * Include deload recommendations
  * Address overtraining warning signs
- Exercise Selection: Mix of bilateral/unilateral, free weights and cables
  * Include unilateral exercises for balance and stability
  * Free weight variations appropriate
  * Moderate complexity barbell work (squats, deadlifts, presses)`,
    advanced: `
ADVANCED-SPECIFIC GUIDANCE:
- Form Tips: Emphasize advanced techniques, explosive power, and movement efficiency
  * Include performance optimization cues
  * Emphasize rate of force development and power output
  * Provide advanced tempo and intensity techniques
  * Address sport-specific transfer and periodization
- Safety Tips: Focus on injury prevention at high intensities and recovery optimization
  * Include specific warm-up protocols for heavy loads
  * Address joint health and longevity considerations
  * Provide autoregulation guidance (RPE, RIR)
  * Include recovery and deload strategies
- Exercise Selection: Complex movements, advanced variations, high-skill exercises
  * Olympic lift variations appropriate
  * Plyometric and explosive movements
  * Advanced barbell work and complex movement patterns
  * Sport-specific and performance-oriented exercises`,
  };

  const guidance = experienceGuidance[level] || experienceGuidance['beginner'];
  return guidance || '';
}

/**
 * Generate RPE/RIR guidance for intensity prescription
 */
function generateRPEGuidance(experience?: string): string {
  const level = experience?.toLowerCase() || 'beginner';

  const rpeGuidance: Record<string, string> = {
    beginner: `
RPE/RIR GUIDANCE FOR BEGINNERS:
- Target RPE: 5-7 out of 10 (moderate effort, can hold conversation)
- RIR (Reps in Reserve): 3-4 reps left in the tank
- Focus on learning movement patterns, not maximal effort
- If form breaks down, stop the set immediately`,
    intermediate: `
RPE/RIR GUIDANCE FOR INTERMEDIATE:
- Target RPE: 6-8 out of 10 (challenging but sustainable)
- RIR: 2-3 reps left in the tank for main lifts
- Push closer to failure on isolation exercises (RPE 8-9)
- Use autoregulation to adjust daily based on readiness`,
    advanced: `
RPE/RIR GUIDANCE FOR ADVANCED:
- Target RPE: 7-9 out of 10 (high effort, controlled intensity)
- RIR: 1-2 reps for main lifts, 0-1 for accessories
- Periodize intensity: heavy days (RPE 8-9), light days (RPE 6-7)
- Use RPE to manage fatigue and optimize performance`,
  };

  const guidance = rpeGuidance[level];
  if (guidance !== undefined) {
    return guidance;
  }
  const beginnerGuidance = rpeGuidance.beginner;
  if (beginnerGuidance === undefined) {
    throw new Error('Beginner RPE guidance not found');
  }
  return beginnerGuidance;
}

/**
 * Generate tempo prescription guidance (reserved for future use)
 */
// @ts-expect-error - Reserved for future use
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function generateTempoGuidance(goal?: string): string {
  const primaryGoal = goal?.toLowerCase() || 'general';

  if (primaryGoal.includes('strength')) {
    return `
TEMPO PRESCRIPTION (STRENGTH):
- Eccentric: 2-3 seconds (controlled lowering)
- Pause: 0-1 second (optional pause at bottom)
- Concentric: Explosive (X or 1 second - move weight as fast as possible)
- Format: 2-0-X (e.g., 2 sec down, no pause, explosive up)
- Focus on maximal force production during concentric phase`;
  } else if (primaryGoal.includes('muscle') || primaryGoal.includes('hypertrophy')) {
    return `
TEMPO PRESCRIPTION (HYPERTROPHY):
- Eccentric: 3-4 seconds (slow, controlled lowering for time under tension)
- Pause: 1 second (squeeze at peak contraction)
- Concentric: 1-2 seconds (controlled lifting)
- Format: 3-1-2 (e.g., 3 sec down, 1 sec pause, 2 sec up)
- Maximize time under tension for muscle growth`;
  } else if (primaryGoal.includes('endurance') || primaryGoal.includes('stamina')) {
    return `
TEMPO PRESCRIPTION (ENDURANCE):
- Eccentric: 2 seconds (controlled)
- Pause: 0 seconds (continuous movement)
- Concentric: 1 second (steady pace)
- Format: 2-0-1 (continuous, rhythmic movement)
- Maintain consistent tempo throughout set`;
  } else {
    return `
TEMPO PRESCRIPTION (GENERAL FITNESS):
- Eccentric: 2-3 seconds (controlled lowering)
- Pause: 0-1 second (brief pause)
- Concentric: 1-2 seconds (controlled lifting)
- Format: 2-0-2 (balanced, controlled movement)
- Focus on movement quality and control`;
  }
}

/**
 * Generate exercise ordering guidance
 */
function generateOrderingGuidance(): string {
  return `
EXERCISE ORDERING PRINCIPLES:
1. Compound movements FIRST (squats, deadlifts, presses, rows)
   - Require most energy and neural demand
   - Perform when fresh for optimal performance and safety
2. Assistance exercises SECOND (variations of main lifts)
   - Support main movement patterns
   - Moderate complexity and load
3. Isolation exercises THIRD (curls, extensions, raises)
   - Target specific muscles
   - Lower neural demand
4. Core/finisher exercises LAST (planks, carries, conditioning)
   - Fatigue-resistant muscle groups
   - Can be performed when fatigued

EXAMPLE ORDERING:
- Barbell Back Squat (compound)
- Romanian Deadlift (compound/assistance)
- Leg Press (assistance)
- Leg Curl (isolation)
- Calf Raise (isolation)
- Plank (core)`;
}

/**
 * Generate simplified prompt enhancement with quality standards, injury safety, and experience guidance
 */
export function generateProfessionalPromptEnhancement(context: PromptContext): string {
  const injurySafety = generateInjurySafetyGuidance(context.injuries);
  const experienceGuidance = generateExperienceGuidance(context.experience);
  const rpeGuidance = generateRPEGuidance(context.experience);
  const orderingGuidance = generateOrderingGuidance();

  return `
QUALITY STANDARDS:
- Each exercise description must include: setup, execution, key cues, and breathing
- Form tips should address the most common technique errors (minimum 3 tips)
- Safety tips must include injury prevention and modification options (minimum 2 tips)
- Use clear, instructional language without jargon
- Provide specific, actionable cues${injurySafety}

${experienceGuidance}

${rpeGuidance}

${orderingGuidance}
`.trim();
}
=================================================================================
FILE: functions/src/lib/qualityScoring.ts
=================================================================================
/**
 * Rule-based quality scoring for AI-generated workouts
 * Provides objective metrics for workout quality assessment
 */

export interface WorkoutQualityScore {
  overall: number;
  grade: string;
  breakdown: {
    completeness: number;
    safety: number;
    programming: number;
    personalization: number;
  };
}

export interface Exercise {
  name: string;
  description: string;
  sets: number;
  reps: number | string;
  formTips: string[];
  safetyTips: string[];
  restSeconds: number;
  usesWeight: boolean;
  muscleGroups?: string[];
  difficulty?: string;
}

export interface Workout {
  exercises: Exercise[];
  workoutSummary?: {
    totalVolume: string;
    primaryFocus: string;
    expectedRPE: string;
  };
}

export interface UserProfile {
  experience?: string;
  injuries?: string[];
  duration: number;
  goals?: string[];
  equipment?: string[];
  workoutType?: string;
}

/**
 * Calculate comprehensive workout quality score
 * Emphasizes safety and personalization for best user outcomes
 */
export function calculateWorkoutQuality(
  workout: Workout,
  userProfile: UserProfile,
): WorkoutQualityScore {
  const breakdown = {
    completeness: calculateCompletenessScore(workout),
    safety: calculateSafetyScore(workout, userProfile),
    programming: calculateProgrammingScore(workout, userProfile),
    personalization: calculatePersonalizationScore(workout, userProfile),
  };

  // Weighted average: safety 40% (critical), programming 30%, completeness 20%, personalization 10%
  // Increased safety weight to ensure user protection
  const overall =
    breakdown.safety * 0.40 +
    breakdown.programming * 0.30 +
    breakdown.completeness * 0.20 +
    breakdown.personalization * 0.10;

  const grade = getGrade(overall);

  return {
    overall: Math.round(overall),
    grade,
    breakdown,
  };
}

/**
 * Calculate completeness score (data quality)
 */
function calculateCompletenessScore(workout: Workout): number {
  let score = 100;
  const exerciseCount = workout.exercises.length;

  // Check minimum exercise count (at least 3 exercises)
  if (exerciseCount < 3) {
    score -= 20;
  }

  // Check for complete exercise data
  workout.exercises.forEach((ex) => {
    // Description quality
    if (!ex.description || ex.description.length < 50) score -= 5;
    else if (ex.description.length < 100) score -= 2;

    // Form tips quality
    if (!ex.formTips || ex.formTips.length < 3) score -= 5;
    else if (ex.formTips.some((tip) => tip.length < 20)) score -= 2;

    // Safety tips quality
    if (!ex.safetyTips || ex.safetyTips.length < 2) score -= 5;
    else if (ex.safetyTips.some((tip) => tip.length < 20)) score -= 2;

    // Muscle groups
    if (!ex.muscleGroups || ex.muscleGroups.length === 0) score -= 3;
  });

  // Check for workout summary
  if (!workout.workoutSummary) {
    score -= 10;
  } else {
    if (!workout.workoutSummary.totalVolume) score -= 3;
    if (!workout.workoutSummary.primaryFocus) score -= 3;
    if (!workout.workoutSummary.expectedRPE) score -= 3;
  }

  return Math.max(0, Math.min(100, score));
}

/**
 * Calculate safety score (injury prevention and appropriate difficulty)
 * Rigorous safety checks to ensure user protection
 */
function calculateSafetyScore(workout: Workout, userProfile: UserProfile): number {
  let score = 100;

  // Check for safety tips in all exercises (CRITICAL)
  workout.exercises.forEach((ex) => {
    if (!ex.safetyTips || ex.safetyTips.length < 2) {
      score -= 8; // Increased penalty for missing safety tips
    } else if (ex.safetyTips.some((tip) => tip.length < 15)) {
      score -= 3; // Penalty for insufficient safety guidance
    }
  });

  // Check difficulty matches experience level (CRITICAL)
  const expectedDifficulty = userProfile.experience?.toLowerCase() || 'beginner';
  workout.exercises.forEach((ex) => {
    if (ex.difficulty && ex.difficulty.toLowerCase() !== expectedDifficulty) {
      score -= 5; // Increased penalty for difficulty mismatch
    }
  });

  // Check for appropriate rest periods (safety-critical)
  workout.exercises.forEach((ex) => {
    if (ex.restSeconds < 30) {
      score -= 15; // Too short, dangerous
    } else if (ex.restSeconds < 45) {
      score -= 8; // Borderline
    } else if (ex.restSeconds > 300) {
      score -= 3; // Excessive rest
    }
  });

  // Check for form tips quality (CRITICAL for safety)
  workout.exercises.forEach((ex) => {
    if (!ex.formTips || ex.formTips.length < 3) {
      score -= 5;
    } else if (ex.formTips.some((tip) => tip.length < 15)) {
      score -= 3; // Penalty for insufficient form guidance
    }
  });

  // Bonus for injury-aware programming (CRITICAL if user has injuries)
  if (userProfile.injuries && userProfile.injuries.length > 0) {
    // If user has injuries, workout should have more safety emphasis
    const avgSafetyTipLength =
      workout.exercises.reduce((sum, ex) => sum + (ex.safetyTips?.join(' ').length || 0), 0) /
      workout.exercises.length;

    if (avgSafetyTipLength > 120) {
      score += 8; // Bonus for detailed safety guidance
    } else if (avgSafetyTipLength > 80) {
      score += 4; // Partial bonus
    }
  }

  // Bonus for form emphasis (helps prevent injuries)
  const avgFormTipLength =
    workout.exercises.reduce((sum, ex) => sum + (ex.formTips?.join(' ').length || 0), 0) /
    workout.exercises.length;

  if (avgFormTipLength > 150) {
    score += 5; // Bonus for detailed form guidance
  }

  return Math.max(0, Math.min(100, score));
}

/**
 * Calculate programming score (evidence-based programming principles)
 */
function calculateProgrammingScore(workout: Workout, userProfile: UserProfile): number {
  let score = 100;

  // Check for appropriate set ranges
  workout.exercises.forEach((ex) => {
    if (ex.sets < 1 || ex.sets > 10) {
      score -= 10;
    } else if (ex.sets < 2 || ex.sets > 6) {
      score -= 3;
    }
  });

  // Check for rep specification
  workout.exercises.forEach((ex) => {
    if (!ex.reps) {
      score -= 5;
    }
  });

  // Check for progressive ordering (compound first, isolation later)
  const compoundKeywords = ['squat', 'deadlift', 'press', 'row', 'pull-up', 'chin-up', 'lunge'];
  const isolationKeywords = ['curl', 'extension', 'raise', 'fly', 'flye'];

  let lastCompoundIndex = -1;
  let firstIsolationIndex = workout.exercises.length;

  workout.exercises.forEach((ex, index) => {
    const name = ex.name.toLowerCase();
    if (compoundKeywords.some((keyword) => name.includes(keyword))) {
      lastCompoundIndex = index;
    }
    if (isolationKeywords.some((keyword) => name.includes(keyword)) && index < firstIsolationIndex) {
      firstIsolationIndex = index;
    }
  });

  // Isolation exercises should come after compound exercises
  if (firstIsolationIndex < lastCompoundIndex) {
    score -= 5;
  }

  // Check for muscle group balance
  const muscleGroups = new Set<string>();
  workout.exercises.forEach((ex) => {
    ex.muscleGroups?.forEach((mg) => muscleGroups.add(mg.toLowerCase()));
  });

  const workoutType = userProfile.workoutType?.toLowerCase() || 'full body';
  if (workoutType.includes('full body')) {
    // Full body should hit multiple muscle groups
    if (muscleGroups.size < 4) {
      score -= 10;
    }
  }

  return Math.max(0, Math.min(100, score));
}

/**
 * Calculate personalization score (how well it matches user profile)
 */
function calculatePersonalizationScore(workout: Workout, userProfile: UserProfile): number {
  let score = 100;

  // Check exercise count matches duration
  const duration = userProfile.duration || 30;
  const exerciseCount = workout.exercises.length;

  const expectedMinExercises = Math.max(3, Math.floor(duration / 8));
  const expectedMaxExercises = Math.ceil(duration / 4);

  if (exerciseCount < expectedMinExercises) {
    score -= 15; // Too few exercises for duration
  } else if (exerciseCount > expectedMaxExercises) {
    score -= 10; // Too many exercises for duration
  }

  // Check equipment usage matches available equipment
  if (userProfile.equipment) {
    const hasWeightEquipment = userProfile.equipment.some((eq) =>
      ['dumbbells', 'barbells', 'kettlebells', 'resistance bands'].some((w) =>
        eq.toLowerCase().includes(w),
      ),
    );

    if (!hasWeightEquipment) {
      // User only has bodyweight - check if workout respects this
      const weightExercises = workout.exercises.filter((ex) => ex.usesWeight);
      if (weightExercises.length > 0) {
        score -= 20; // Prescribed weight exercises without equipment
      }
    }
  }

  // Check workout type match
  const workoutType = userProfile.workoutType?.toLowerCase() || 'full body';
  const muscleGroups = new Set<string>();
  workout.exercises.forEach((ex) => {
    ex.muscleGroups?.forEach((mg) => muscleGroups.add(mg.toLowerCase()));
  });

  if (workoutType.includes('upper') && Array.from(muscleGroups).some((mg) => mg.includes('quad') || mg.includes('hamstring') || mg.includes('glute'))) {
    score -= 10; // Upper body workout has leg exercises
  }

  if (workoutType.includes('lower') && !Array.from(muscleGroups).some((mg) => mg.includes('quad') || mg.includes('hamstring') || mg.includes('glute'))) {
    score -= 15; // Lower body workout missing leg exercises
  }

  return Math.max(0, Math.min(100, score));
}

/**
 * Convert numeric score to letter grade
 */
function getGrade(score: number): string {
  if (score >= 97) return 'A+';
  if (score >= 93) return 'A';
  if (score >= 90) return 'A-';
  if (score >= 87) return 'B+';
  if (score >= 83) return 'B';
  if (score >= 80) return 'B-';
  if (score >= 77) return 'C+';
  if (score >= 73) return 'C';
  if (score >= 70) return 'C-';
  if (score >= 67) return 'D+';
  if (score >= 63) return 'D';
  if (score >= 60) return 'D-';
  return 'F';
}


=================================================================================
FILE: functions/src/lib/rateLimiter.ts
=================================================================================
/**
 * Rate limiting for Cloud Functions
 * Uses Firestore to track request counts per user/IP
 */

import { getFirestore, Timestamp } from 'firebase-admin/firestore';

const db = getFirestore();

const RATE_LIMIT_COLLECTION = 'rate_limits';

/**
 * Rate limit configuration
 */
export interface RateLimitConfig {
  windowMs: number; // Time window in milliseconds
  maxRequests: number; // Maximum requests per window
  keyPrefix: string; // Prefix for rate limit keys
}

/**
 * Default rate limit configs for different endpoints
 */
export const RATE_LIMITS = {
  generateWorkout: {
    windowMs: 60 * 1000, // 1 minute
    maxRequests: 10, // 10 workouts per minute
    keyPrefix: 'gen',
  },
  submitFeedback: {
    windowMs: 60 * 1000, // 1 minute
    maxRequests: 30, // 30 feedback submissions per minute
    keyPrefix: 'feedback',
  },
  storePerformance: {
    windowMs: 60 * 1000, // 1 minute
    maxRequests: 30, // 30 performance submissions per minute
    keyPrefix: 'perf',
  },
  addExercise: {
    windowMs: 60 * 1000, // 1 minute
    maxRequests: 20, // 20 exercise additions per minute
    keyPrefix: 'add',
  },
  swapExercise: {
    windowMs: 60 * 1000, // 1 minute
    maxRequests: 20, // 20 exercise swaps per minute
    keyPrefix: 'swap',
  },
} as const;

/**
 * Rate limit result
 */
export interface RateLimitResult {
  allowed: boolean;
  remaining: number;
  resetAt: number;
  retryAfter?: number;
}

/**
 * Check rate limit for a user/IP
 */
export async function checkRateLimit(
  identifier: string, // userId or IP address
  config: RateLimitConfig,
): Promise<RateLimitResult> {
  const now = Date.now();
  const windowStart = now - config.windowMs;
  const key = `${config.keyPrefix}_${identifier}`;

  try {
    const docRef = db.collection(RATE_LIMIT_COLLECTION).doc(key);
    const doc = await docRef.get();

    if (!doc.exists) {
      // First request - create new rate limit record
      await docRef.set({
        count: 1,
        windowStart: Timestamp.fromMillis(now),
        lastRequest: Timestamp.fromMillis(now),
      });

      return {
        allowed: true,
        remaining: config.maxRequests - 1,
        resetAt: now + config.windowMs,
      };
    }

    const data = doc.data();
    if (!data) {
      return {
        allowed: true,
        remaining: config.maxRequests - 1,
        resetAt: now + config.windowMs,
      };
    }

    const recordWindowStart = data.windowStart?.toMillis() || 0;

    // Check if window has expired
    if (recordWindowStart < windowStart) {
      // Window expired - reset counter
      await docRef.set({
        count: 1,
        windowStart: Timestamp.fromMillis(now),
        lastRequest: Timestamp.fromMillis(now),
      });

      return {
        allowed: true,
        remaining: config.maxRequests - 1,
        resetAt: now + config.windowMs,
      };
    }

    // Window still active - check count
    const currentCount = data.count || 0;

    if (currentCount >= config.maxRequests) {
      // Rate limit exceeded
      const resetAt = recordWindowStart + config.windowMs;
      const retryAfter = Math.ceil((resetAt - now) / 1000); // seconds

      return {
        allowed: false,
        remaining: 0,
        resetAt,
        retryAfter,
      };
    }

    // Increment counter
    await docRef.update({
      count: currentCount + 1,
      lastRequest: Timestamp.fromMillis(now),
    });

    return {
      allowed: true,
      remaining: config.maxRequests - currentCount - 1,
      resetAt: recordWindowStart + config.windowMs,
    };
  } catch (error) {
    console.error('Rate limit check error:', error);
    // On error, allow the request (fail open)
    return {
      allowed: true,
      remaining: config.maxRequests,
      resetAt: now + config.windowMs,
    };
  }
}

/**
 * Cleanup expired rate limit records
 * Should be called periodically (e.g., via scheduled function)
 */
export async function cleanupExpiredRateLimits(): Promise<number> {
  const now = Date.now();
  const cutoffTime = now - 24 * 60 * 60 * 1000; // 24 hours ago

  try {
    const snapshot = await db
      .collection(RATE_LIMIT_COLLECTION)
      .where('lastRequest', '<', Timestamp.fromMillis(cutoffTime))
      .limit(500)
      .get();

    const batch = db.batch();
    snapshot.docs.forEach((doc) => {
      batch.delete(doc.ref);
    });

    await batch.commit();

    console.log(`Cleaned up ${snapshot.size} expired rate limit records`);
    return snapshot.size;
  } catch (error) {
    console.error('Error cleaning up rate limits:', error);
    return 0;
  }
}

/**
 * Get rate limit identifier from request
 * Prefers userId, falls back to IP address
 */
export function getRateLimitIdentifier(userId?: string, ip?: string): string {
  if (userId) {
    return `user_${userId}`;
  }
  if (ip) {
    return `ip_${ip}`;
  }
  return 'anonymous';
}

/**
 * Extract IP address from request
 */
export function getClientIP(req: { headers: Record<string, string | string[] | undefined> }): string {
  // Check various headers for IP address
  const forwarded = req.headers['x-forwarded-for'];
  if (forwarded) {
    const ip = Array.isArray(forwarded) ? forwarded[0] : forwarded.split(',')[0];
    return ip?.trim() || 'unknown';
  }

  const realIP = req.headers['x-real-ip'];
  if (realIP && typeof realIP === 'string') {
    return realIP;
  }

  return 'unknown';
}


=================================================================================
FILE: functions/src/lib/schemaValidator.ts
=================================================================================
/**
 * Server-side JSON Schema validation using AJV
 * Validates AI-generated workouts against strict schema requirements
 */

import Ajv, { type ValidateFunction, type ErrorObject } from 'ajv';
import addFormats from 'ajv-formats';
import { buildWorkoutPlanSchema, type WorkoutPlan, type Exercise } from './jsonSchema/workoutPlan.schema';

// Initialize AJV with draft-2020-12 support
const ajv = new Ajv({
  allErrors: true, // Collect all errors, not just first
  verbose: true, // Include schema and data in errors
  strict: true, // Strict mode for schema validation
  validateFormats: true, // Validate format keywords
});

// Add format validators (email, uri, date-time, etc.)
addFormats(ajv);

// Cache compiled validators
const validatorCache = new Map<string, ValidateFunction>();

/**
 * Validation result with detailed error information
 */
export interface ValidationResult {
  valid: boolean;
  errors: string[];
  warnings?: string[];
}

/**
 * Validate workout plan JSON against schema
 */
export function validateWorkoutPlanJSON(
  data: unknown,
  minExercises: number,
  maxExercises: number,
): ValidationResult {
  const cacheKey = `workout_${minExercises}_${maxExercises}`;
  
  // Get or compile validator
  let validate = validatorCache.get(cacheKey);
  if (!validate) {
    const schema = buildWorkoutPlanSchema(minExercises, maxExercises);
    validate = ajv.compile(schema);
    validatorCache.set(cacheKey, validate);
  }

  const valid = validate(data);
  const errors: string[] = [];

  if (!valid && validate.errors) {
    errors.push(...formatAjvErrors(validate.errors));
  }

  // Additional validation: unique exercise names (case-insensitive)
  if (valid && data && typeof data === 'object' && 'exercises' in data) {
    const uniquenessErrors = validateUniqueExerciseNames((data as WorkoutPlan).exercises);
    if (uniquenessErrors.length > 0) {
      errors.push(...uniquenessErrors);
      return { valid: false, errors };
    }
  }

  return { valid, errors };
}

/**
 * Validate that all exercise names are unique (case-insensitive)
 */
function validateUniqueExerciseNames(exercises: Exercise[]): string[] {
  const errors: string[] = [];
  const namesSeen = new Map<string, number>(); // lowercase name -> first index

  exercises.forEach((exercise, index) => {
    const nameLower = exercise.name.toLowerCase().trim();
    const firstIndex = namesSeen.get(nameLower);
    
    if (firstIndex !== undefined) {
      errors.push(
        `Duplicate exercise name: "${exercise.name}" at index ${index} (first seen at index ${firstIndex})`,
      );
    } else {
      namesSeen.set(nameLower, index);
    }
  });

  return errors;
}

/**
 * Format AJV errors into human-readable messages
 */
function formatAjvErrors(errors: ErrorObject[]): string[] {
  return errors.map((error) => {
    const path = error.instancePath || 'root';
    const message = error.message || 'validation failed';
    
    // Add context for specific error types
    if (error.keyword === 'minItems' || error.keyword === 'maxItems') {
      const dataLength = Array.isArray(error.data) ? error.data.length : 0;
      return `${path}: ${message} (expected ${error.params.limit}, got ${dataLength})`;
    }
    
    if (error.keyword === 'minLength' || error.keyword === 'maxLength') {
      const actual = typeof error.data === 'string' ? error.data.length : 'unknown';
      return `${path}: ${message} (expected ${error.params.limit}, got ${actual} characters)`;
    }
    
    if (error.keyword === 'pattern') {
      return `${path}: ${message} (value: "${error.data}", expected pattern: ${error.params.pattern})`;
    }
    
    if (error.keyword === 'enum') {
      return `${path}: ${message} (value: "${error.data}", allowed: ${error.params.allowedValues?.join(', ')})`;
    }
    
    if (error.keyword === 'type') {
      return `${path}: ${message} (expected ${error.params.type}, got ${typeof error.data})`;
    }
    
    if (error.keyword === 'required') {
      return `${path}: missing required property "${error.params.missingProperty}"`;
    }
    
    return `${path}: ${message}`;
  });
}

/**
 * Validate single exercise (for addExercise/swapExercise)
 */
export function validateSingleExercise(data: unknown): ValidationResult {
  // eslint-disable-next-line @typescript-eslint/no-require-imports
  const { exerciseSchema } = require('./jsonSchema/workoutPlan.schema');

  const validate = ajv.compile(exerciseSchema);
  const valid = validate(data);
  const errors: string[] = [];

  if (!valid && validate.errors) {
    errors.push(...formatAjvErrors(validate.errors));
  }

  return { valid, errors };
}

/**
 * Validate rep format matches workout type
 * Time-based workouts (Cardio, HIIT, Abs, etc.) should use time format only
 * Strength workouts should use range format only
 */
export function validateRepFormat(
  exercises: Exercise[],
  workoutType: string,
): ValidationResult {
  const errors: string[] = [];
  const warnings: string[] = [];
  
  const isTimeBasedWorkout = [
    'Cardio',
    'HIIT',
    'Abs',
    'Core Focus',
    'Yoga',
    'Pilates',
  ].includes(workoutType);

  const timePattern = /^\d+s$|^\d+-\d+s$/; // "30s" or "30-45s"

  exercises.forEach((exercise, index) => {
    const reps = exercise.reps;
    const isTimeFormat = timePattern.test(reps);

    if (isTimeBasedWorkout && !isTimeFormat) {
      errors.push(
        `Exercise ${index + 1} "${exercise.name}": Time-based workout "${workoutType}" requires time format (e.g., "45s"), got "${reps}"`,
      );
    } else if (!isTimeBasedWorkout && isTimeFormat) {
      warnings.push(
        `Exercise ${index + 1} "${exercise.name}": Strength workout typically uses range format (e.g., "8-12"), got time format "${reps}"`,
      );
    }
  });

  return {
    valid: errors.length === 0,
    errors,
    warnings,
  };
}

/**
 * Validate rest periods are appropriate for exercise type
 */
export function validateRestPeriods(exercises: Exercise[]): ValidationResult {
  const warnings: string[] = [];

  exercises.forEach((exercise, index) => {
    const rest = exercise.restSeconds;
    const name = exercise.name.toLowerCase();

    // Compound movements should have longer rest
    const isCompound = [
      'squat',
      'deadlift',
      'press',
      'row',
      'pull-up',
      'chin-up',
      'lunge',
    ].some((keyword) => name.includes(keyword));

    if (isCompound && rest < 90) {
      warnings.push(
        `Exercise ${index + 1} "${exercise.name}": Compound movement has short rest (${rest}s). Consider 120-180s for optimal recovery.`,
      );
    }

    // Isolation movements typically need less rest
    const isIsolation = [
      'curl',
      'extension',
      'raise',
      'fly',
      'flye',
    ].some((keyword) => name.includes(keyword));

    if (isIsolation && rest > 120) {
      warnings.push(
        `Exercise ${index + 1} "${exercise.name}": Isolation movement has long rest (${rest}s). Consider 60-90s for efficiency.`,
      );
    }
  });

  return {
    valid: true,
    errors: [],
    warnings,
  };
}


=================================================================================
FILE: functions/src/lib/setPerformance.ts
=================================================================================
/**
 * Set-level performance tracking and progressive overload calculations
 */

import { getFirestore, Timestamp } from 'firebase-admin/firestore';

const db = getFirestore();

/**
 * Detailed set performance data
 */
export interface SetPerformance {
  setNumber: number;
  weight?: number | null; // Weight used (lbs or kg)
  reps?: number; // Actual reps completed
  completed: boolean; // Whether the set was completed
  rpe?: number; // Rate of Perceived Exertion (1-10)
  notes?: string; // Optional notes about the set
}

/**
 * Exercise performance data with set-level details
 */
export interface ExercisePerformance {
  exerciseName: string;
  sets: SetPerformance[];
  totalVolume?: number; // Total volume (weight × reps × sets)
  averageRPE?: number; // Average RPE across sets
  completionRate?: number; // Percentage of sets completed
}

/**
 * Workout performance data
 */
export interface WorkoutPerformance {
  workoutId: string;
  userId: string;
  workoutType: string;
  timestamp: number;
  exercises: ExercisePerformance[];
  totalVolume?: number; // Total workout volume
  averageRPE?: number; // Average RPE across all sets
  completionRate?: number; // Percentage of all sets completed
  duration?: number; // Actual workout duration in seconds
}

/**
 * Progressive overload recommendation
 */
export interface ProgressiveOverloadRecommendation {
  exerciseName: string;
  currentWeight?: number;
  recommendedWeight?: number;
  currentReps?: number;
  recommendedReps?: number;
  reasoning: string;
  confidence: 'low' | 'medium' | 'high';
}

/**
 * Calculate total volume for an exercise
 */
export function calculateExerciseVolume(exercise: ExercisePerformance): number {
  let totalVolume = 0;
  
  for (const set of exercise.sets) {
    if (set.completed && set.weight && set.reps) {
      totalVolume += set.weight * set.reps;
    }
  }
  
  return totalVolume;
}

/**
 * Calculate average RPE for an exercise
 */
export function calculateAverageRPE(exercise: ExercisePerformance): number | undefined {
  const rpeSets = exercise.sets.filter(s => s.rpe !== undefined && s.rpe !== null);
  
  if (rpeSets.length === 0) {
    return undefined;
  }
  
  const sum = rpeSets.reduce((acc, set) => acc + (set.rpe || 0), 0);
  return sum / rpeSets.length;
}

/**
 * Calculate completion rate for an exercise
 */
export function calculateCompletionRate(exercise: ExercisePerformance): number {
  if (exercise.sets.length === 0) {
    return 0;
  }
  
  const completedSets = exercise.sets.filter(s => s.completed).length;
  return completedSets / exercise.sets.length;
}

/**
 * Store workout performance data to Firestore
 */
export async function storeWorkoutPerformance(
  performance: WorkoutPerformance,
): Promise<{ success: boolean; message: string }> {
  const { workoutId, userId, exercises } = performance;

  if (!userId || !workoutId) {
    return { success: false, message: 'Missing userId or workoutId' };
  }

  try {
    // Calculate aggregate metrics
    const exercisesWithMetrics = exercises.map(exercise => ({
      ...exercise,
      totalVolume: calculateExerciseVolume(exercise),
      averageRPE: calculateAverageRPE(exercise),
      completionRate: calculateCompletionRate(exercise),
    }));

    const totalVolume = exercisesWithMetrics.reduce((sum, ex) => sum + (ex.totalVolume || 0), 0);
    const allRPEs = exercisesWithMetrics
      .map(ex => ex.averageRPE)
      .filter((rpe): rpe is number => rpe !== undefined);
    const averageRPE = allRPEs.length > 0 
      ? allRPEs.reduce((sum, rpe) => sum + rpe, 0) / allRPEs.length 
      : undefined;
    
    const allSets = exercisesWithMetrics.flatMap(ex => ex.sets);
    const completedSets = allSets.filter(s => s.completed).length;
    const completionRate = allSets.length > 0 ? completedSets / allSets.length : 0;

    // Update workout document with performance data
    const workoutRef = db.collection('users').doc(userId).collection('workouts').doc(workoutId);
    
    await workoutRef.update({
      exercises: exercisesWithMetrics,
      performanceMetrics: {
        totalVolume,
        averageRPE,
        completionRate,
        updatedAt: Timestamp.now(),
      },
      updatedAt: Timestamp.now(),
    });

    console.log('💪 Workout performance stored:', {
      userId: userId.substring(0, 8),
      workoutId: workoutId.substring(0, 8),
      totalVolume,
      completionRate: (completionRate * 100).toFixed(1) + '%',
    });

    return {
      success: true,
      message: 'Performance data stored successfully',
    };
  } catch (error) {
    console.error('Error storing workout performance:', error);
    return {
      success: false,
      message: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

/**
 * Get progressive overload recommendations for a user
 * Analyzes recent performance to suggest weight/rep increases
 */
export async function getProgressiveOverloadRecommendations(
  userId: string,
  exerciseName: string,
  _limit = 5,
): Promise<ProgressiveOverloadRecommendation | null> {
  if (!userId || !exerciseName) {
    return null;
  }

  try {
    // Fetch recent workouts containing this exercise
    const workoutsSnapshot = await db
      .collection('users')
      .doc(userId)
      .collection('workouts')
      .where('status', '==', 'completed')
      .orderBy('completedAt', 'desc')
      .limit(10)
      .get();

    const recentPerformances: Array<{
      date: number;
      sets: SetPerformance[];
      averageRPE?: number;
    }> = [];

    workoutsSnapshot.docs.forEach(doc => {
      const data = doc.data();
      const exercises = data.exercises || [];
      
      const exercise = exercises.find(
        (ex: { exerciseName?: string; name?: string }) =>
          (ex.exerciseName || ex.name) === exerciseName,
      );

      if (exercise && exercise.sets) {
        recentPerformances.push({
          date: data.completedAt?.toMillis() || data.timestamp?.toMillis() || Date.now(),
          sets: exercise.sets,
          averageRPE: exercise.averageRPE,
        });
      }
    });

    if (recentPerformances.length === 0) {
      return null;
    }

    // Analyze most recent performance
    const latest = recentPerformances[0];
    if (!latest) {
      return null;
    }

    const completedSets = latest.sets.filter(s => s.completed);

    if (completedSets.length === 0) {
      return {
        exerciseName,
        reasoning: 'No completed sets in recent workout',
        confidence: 'low',
      };
    }

    // Calculate average weight and reps from completed sets
    const avgWeight = completedSets.reduce((sum, s) => sum + (s.weight || 0), 0) / completedSets.length;
    const avgReps = completedSets.reduce((sum, s) => sum + (s.reps || 0), 0) / completedSets.length;
    const avgRPE = latest.averageRPE || 5;

    // Progressive overload logic
    let recommendedWeight = avgWeight;
    const recommendedReps = Math.round(avgReps);
    let reasoning = '';
    let confidence: 'low' | 'medium' | 'high' = 'medium';

    if (avgRPE < 6) {
      // Too easy - increase weight by 5-10%
      recommendedWeight = Math.round(avgWeight * 1.075);
      reasoning = 'RPE indicates workout was too easy. Increase weight by ~7.5%';
      confidence = 'high';
    } else if (avgRPE >= 6 && avgRPE < 8) {
      // Just right - small progressive increase
      recommendedWeight = Math.round(avgWeight * 1.025);
      reasoning = 'Good RPE range. Small progressive increase of ~2.5%';
      confidence = 'high';
    } else if (avgRPE >= 8 && avgRPE < 9) {
      // Challenging - maintain or slight decrease
      recommendedWeight = avgWeight;
      reasoning = 'High RPE. Maintain current weight to build consistency';
      confidence = 'medium';
    } else {
      // Too hard - decrease weight
      recommendedWeight = Math.round(avgWeight * 0.95);
      reasoning = 'Very high RPE. Reduce weight by ~5% to prevent overtraining';
      confidence = 'high';
    }

    return {
      exerciseName,
      currentWeight: avgWeight,
      recommendedWeight,
      currentReps: Math.round(avgReps),
      recommendedReps,
      reasoning,
      confidence,
    };
  } catch (error) {
    console.error('Error getting progressive overload recommendations:', error);
    return null;
  }
}


=================================================================================
FILE: functions/src/lib/streamingUtils.ts
=================================================================================
/**
 * Streaming utilities for robust OpenAI API integration
 * Handles streaming with timeout, retry logic, and error recovery
 */

import OpenAI from 'openai';
import { API_RETRY_CONFIG, OPENAI_CONFIG } from '../config';

/**
 * Streaming response with timeout protection
 */
export async function streamWithTimeout(
  stream: AsyncIterable<OpenAI.Chat.Completions.ChatCompletionChunk>,
  timeoutMs: number = OPENAI_CONFIG.streamTimeout,
): Promise<string> {
  let content = '';
  let timeoutHandle: NodeJS.Timeout | null = null;
  let timedOut = false;

  try {
    // Create a promise that rejects after timeout
    const timeoutPromise = new Promise<never>((_, reject) => {
      timeoutHandle = setTimeout(() => {
        timedOut = true;
        reject(new Error(`Stream timeout after ${timeoutMs}ms`));
      }, timeoutMs);
    });

    // Race between stream collection and timeout
    await Promise.race([
      (async () => {
        for await (const chunk of stream) {
          if (timedOut) break;
          const delta = chunk.choices[0]?.delta?.content;
          if (delta) {
            content += delta;
          }
        }
      })(),
      timeoutPromise,
    ]);

    return content;
  } finally {
    if (timeoutHandle) {
      clearTimeout(timeoutHandle);
    }
  }
}

/**
 * Retry logic for OpenAI API calls
 */
export async function callOpenAIWithRetry<T>(
  fn: () => Promise<T>,
  context: {
    attempt?: number;
    maxRetries?: number;
    onRetry?: (attempt: number, error: Error) => void;
  } = {},
): Promise<T> {
  const {
    attempt = 0,
    maxRetries = API_RETRY_CONFIG.maxRetries,
    onRetry,
  } = context;

  try {
    return await fn();
  } catch (error) {
    const err = error instanceof Error ? error : new Error(String(error));
    const status = (error as Record<string, unknown>)?.status as number | undefined;
    const code = (error as Record<string, unknown>)?.code as string | undefined;

    // Check if error is retryable
    const isRetryable =
      (status && API_RETRY_CONFIG.retryableStatusCodes.includes(status as 408 | 429 | 500 | 502 | 503 | 504)) ||
      code === 'ETIMEDOUT' ||
      code === 'ECONNRESET' ||
      err.message.includes('timeout') ||
      err.message.includes('temporarily unavailable') ||
      err.message.includes('server had an error') ||
      err.message.includes('server error') ||
      err.message.includes('Service Unavailable');

    // If not retryable or max retries reached, throw
    if (!isRetryable || attempt >= maxRetries) {
      console.error('❌ API call failed (not retryable or max retries reached):', {
        error: err.message,
        status,
        code,
        attempt: attempt + 1,
        maxRetries,
      });
      throw error;
    }

    // Calculate backoff delay
    const delayMs = Math.min(
      API_RETRY_CONFIG.initialDelayMs * Math.pow(API_RETRY_CONFIG.backoffMultiplier, attempt),
      API_RETRY_CONFIG.maxDelayMs,
    );

    console.warn('⚠️ API call failed, retrying...', {
      error: err.message,
      status,
      code,
      attempt: attempt + 1,
      maxRetries,
      delayMs,
    });

    onRetry?.(attempt + 1, err);

    // Wait before retrying
    await new Promise((resolve) => setTimeout(resolve, delayMs));

    // Retry recursively
    return callOpenAIWithRetry(fn, {
      attempt: attempt + 1,
      maxRetries,
      onRetry,
    });
  }
}

/**
 * Validate and repair JSON response
 */
export function validateAndRepairJSON(content: string): { valid: boolean; data?: unknown; error?: string } {
  if (!content || typeof content !== 'string') {
    return { valid: false, error: 'Empty or invalid content' };
  }

  // Try to parse as-is
  try {
    const data = JSON.parse(content);
    return { valid: true, data };
  } catch (e) {
    // Try to find and extract valid JSON
    const jsonMatch = content.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      try {
        const data = JSON.parse(jsonMatch[0]);
        console.warn('⚠️ Extracted valid JSON from partial response');
        return { valid: true, data };
      } catch {
        // Continue to error handling
      }
    }

    const error = e instanceof Error ? e.message : 'Unknown JSON parse error';
    return { valid: false, error };
  }
}

/**
 * Check if error is due to incomplete streaming
 * Detects various patterns that indicate incomplete JSON responses
 */
export function isIncompleteStreamError(error: Error): boolean {
  const msg = error.message.toLowerCase();
  return (
    msg.includes('unexpected end') ||
    msg.includes('unexpected token') ||
    msg.includes('unexpected eof') ||
    msg.includes('json') ||
    msg.includes('timeout') ||
    msg.includes('stream') ||
    msg.includes('incomplete') ||
    msg.includes('truncated') ||
    msg.includes('premature') ||
    msg.includes('econnreset') ||
    msg.includes('etimedout')
  );
}


=================================================================================
FILE: functions/src/lib/workoutHistoryOptimizer.ts
=================================================================================
/**
 * Workout History Optimizer
 * 
 * Optimizes workout history data sent to OpenAI to minimize token usage
 * while maintaining personalization quality.
 * 
 * Strategy:
 * - Send only last 5-7 workouts (most recent data is most relevant)
 * - Compress exercise data (names only, no full details)
 * - Aggregate feedback metrics (completion rate, RPE, difficulty)
 * - Remove redundant information
 */

export interface RecentWorkout {
  workoutType: string;
  timestamp: number;
  completionRate?: number;
  rpe?: number;
  feedback?: 'easy' | 'right' | 'hard';
  exercises: Array<{ name: string }>;
}

export interface OptimizedWorkoutHistory {
  recentWorkouts: RecentWorkout[];
  aggregateMetrics: {
    avgCompletionRate: number;
    avgRPE: number | null;
    totalWorkouts: number;
    workoutFrequency: string; // 'high' | 'medium' | 'low'
    preferredTypes: string[]; // Top 3 most common workout types
  };
}

/**
 * Optimize workout history for token efficiency
 * Keeps only the most recent and relevant data
 */
export function optimizeWorkoutHistory(
  workouts: RecentWorkout[],
  maxWorkouts: number = 5,
): OptimizedWorkoutHistory {
  // Sort by timestamp (most recent first)
  const sortedWorkouts = [...workouts].sort((a, b) => b.timestamp - a.timestamp);
  
  // Take only the most recent workouts
  const recentWorkouts = sortedWorkouts.slice(0, maxWorkouts).map(w => ({
    workoutType: w.workoutType,
    timestamp: w.timestamp,
    completionRate: w.completionRate,
    rpe: w.rpe,
    feedback: w.feedback,
    // Only include exercise names (not full details)
    exercises: w.exercises.map(e => ({ name: e.name })),
  }));

  // Calculate aggregate metrics from ALL workouts (not just recent)
  const totalWorkouts = workouts.length;
  
  const workoutsWithCompletion = workouts.filter(w => w.completionRate !== undefined);
  const avgCompletionRate = workoutsWithCompletion.length > 0
    ? workoutsWithCompletion.reduce((sum, w) => sum + (w.completionRate || 0), 0) / workoutsWithCompletion.length
    : 100;

  const workoutsWithRPE = workouts.filter(w => w.rpe !== undefined && w.rpe !== null);
  const avgRPE = workoutsWithRPE.length > 0
    ? workoutsWithRPE.reduce((sum, w) => sum + (w.rpe || 0), 0) / workoutsWithRPE.length
    : null;

  // Calculate workout frequency (workouts per week)
  const recentDays = 30; // Look at last 30 days
  const cutoffTime = Date.now() - recentDays * 24 * 60 * 60 * 1000;
  const recentWorkoutCount = workouts.filter(w => w.timestamp > cutoffTime).length;
  const workoutsPerWeek = (recentWorkoutCount / recentDays) * 7;
  
  let workoutFrequency: 'high' | 'medium' | 'low';
  if (workoutsPerWeek >= 4) {
    workoutFrequency = 'high';
  } else if (workoutsPerWeek >= 2) {
    workoutFrequency = 'medium';
  } else {
    workoutFrequency = 'low';
  }

  // Find top 3 most common workout types
  const typeCounts = workouts.reduce((acc, w) => {
    acc[w.workoutType] = (acc[w.workoutType] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);
  
  const preferredTypes = Object.entries(typeCounts)
    .sort(([, a], [, b]) => b - a)
    .slice(0, 3)
    .map(([type]) => type);

  return {
    recentWorkouts,
    aggregateMetrics: {
      avgCompletionRate: Math.round(avgCompletionRate),
      avgRPE: avgRPE ? Math.round(avgRPE * 10) / 10 : null,
      totalWorkouts,
      workoutFrequency,
      preferredTypes,
    },
  };
}

/**
 * Build concise workout history summary for prompts
 * Optimized for minimal token usage while maintaining personalization
 */
export function buildWorkoutHistorySummary(
  optimized: OptimizedWorkoutHistory,
): string {
  const { recentWorkouts, aggregateMetrics } = optimized;

  if (recentWorkouts.length === 0) {
    return 'No workout history available - this is a new user.';
  }

  const parts: string[] = [];

  // Overall stats (very concise)
  parts.push(`Total Workouts: ${aggregateMetrics.totalWorkouts} | Frequency: ${aggregateMetrics.workoutFrequency} | Avg Completion: ${aggregateMetrics.avgCompletionRate}%${aggregateMetrics.avgRPE ? ` | Avg RPE: ${aggregateMetrics.avgRPE}/10` : ''}`);

  // Preferred types
  if (aggregateMetrics.preferredTypes.length > 0) {
    parts.push(`Preferred Types: ${aggregateMetrics.preferredTypes.join(', ')}`);
  }

  // Recent workouts (last 3-5, very compressed)
  if (recentWorkouts.length > 0) {
    parts.push('\nRecent Workouts:');
    recentWorkouts.slice(0, 3).forEach((w, i) => {
      const daysAgo = Math.floor((Date.now() - w.timestamp) / (1000 * 60 * 60 * 24));
      const feedback = w.feedback ? ` (${w.feedback})` : '';
      const completion = w.completionRate !== undefined ? ` ${w.completionRate}%` : '';
      parts.push(`${i + 1}. ${w.workoutType} - ${daysAgo}d ago${completion}${feedback}`);
    });
  }

  return parts.join('\n');
}

/**
 * Determine if workout history should be included in the prompt
 * Skip if user is brand new or history is not relevant
 */
export function shouldIncludeWorkoutHistory(
  workouts: RecentWorkout[],
  minWorkouts: number = 2,
): boolean {
  return workouts.length >= minWorkouts;
}

/**
 * Get adaptive intensity recommendation based on history
 * Returns a scalar (0.7-1.3) to adjust workout difficulty
 */
export function getAdaptiveIntensityScalar(
  optimized: OptimizedWorkoutHistory,
  currentScalar: number = 1.0,
): number {
  const { aggregateMetrics, recentWorkouts } = optimized;

  // Not enough data - return current scalar
  if (recentWorkouts.length < 3) {
    return currentScalar;
  }

  let adjustment = 0;

  // Completion rate adjustments
  if (aggregateMetrics.avgCompletionRate >= 95) {
    adjustment += 0.05; // Increase if completing almost everything
  } else if (aggregateMetrics.avgCompletionRate < 70) {
    adjustment -= 0.1; // Decrease if struggling
  }

  // RPE adjustments (target 6-7)
  if (aggregateMetrics.avgRPE !== null) {
    if (aggregateMetrics.avgRPE < 5) {
      adjustment += 0.05; // Too easy
    } else if (aggregateMetrics.avgRPE > 8) {
      adjustment -= 0.05; // Too hard
    }
  }

  // Feedback trend from recent workouts
  const recentFeedback = recentWorkouts
    .filter(w => w.feedback)
    .slice(0, 5);
  
  if (recentFeedback.length >= 3) {
    const easyCount = recentFeedback.filter(w => w.feedback === 'easy').length;
    const hardCount = recentFeedback.filter(w => w.feedback === 'hard').length;
    
    if (easyCount >= 3) {
      adjustment += 0.1; // Multiple easy workouts
    } else if (hardCount >= 3) {
      adjustment -= 0.1; // Multiple hard workouts
    }
  }

  // Apply adjustment with bounds (0.7 - 1.3)
  const newScalar = Math.max(0.7, Math.min(1.3, currentScalar + adjustment));
  
  return Math.round(newScalar * 100) / 100; // Round to 2 decimals
}


=================================================================================
FILE: functions/src/workout/generation.ts
=================================================================================
/**
 * Workout Generation Orchestrator
 * Multi-pass validation, repair, and quality gate system for AI-generated workouts
 */

import OpenAI from 'openai';
import { WorkoutContext, ProgrammingContext } from '../lib/promptBuilder';
import { buildEnhancedSystemMessage, buildEnhancedWorkoutPrompt, buildOpenAIJsonSchema } from '../lib/promptBuilder.enhanced';
import { generateProfessionalPromptEnhancement } from '../lib/promptEnhancements';
import { getProgrammingRecommendations, getExperienceGuidance } from '../lib/exerciseDatabase';
import { validateWorkoutPlanJSON, validateRepFormat, validateRestPeriods } from '../lib/schemaValidator';

import { validateAndAdjustDuration, computeMinMaxExerciseCount } from '../lib/durationAdjustment';
import { calculateWorkoutQuality } from '../lib/qualityScoring';
import { deriveProgression } from '../lib/periodization';
import { getCachedOrRun, hashRequest, type CacheableContext } from '../lib/cache';
import { OPENAI_MODEL, OPENAI_CONFIG, getOpenAIConfigForDuration, getQualityThresholdsForDuration } from '../config';
import { streamWithTimeout, callOpenAIWithRetry, validateAndRepairJSON, isIncompleteStreamError } from '../lib/streamingUtils';
import type { WorkoutPlan } from '../lib/jsonSchema/workoutPlan.schema';

/**
 * Generation metadata attached to successful workouts
 */
export interface GenerationMetadata {
  model: string;
  temperature: number;
  minExercises: number;
  maxExercises: number;
  actualDuration: number;
  targetDuration: number;
  durationDifference: number;
  validationWarnings: string[];
  validationSuggestions: string[];
  qualityScore: {
    overall: number;
    grade: string;
    breakdown: {
      completeness: number;
      safety: number;
      programming: number;
      personalization: number;
    };
  };
  repairAttempts: number;
  targetIntensityScalar: number;
  progressionNote?: string;
  generatedAt: number;
}

/**
 * Extended workout plan with metadata
 */
export interface WorkoutPlanWithMetadata extends WorkoutPlan {
  metadata: GenerationMetadata;
}

/**
 * Validation error details for repair prompts
 */
interface ValidationErrors {
  schemaErrors: string[];
  ruleErrors: string[];
  durationError?: string;
}

/**
 * Main orchestrator: generates workout with multi-pass validation and repair
 */
export async function generateWorkoutOrchestrated(
  ctx: WorkoutContext,
  openaiClient: OpenAI,
  uid?: string,
): Promise<WorkoutPlanWithMetadata> {
  const startTime = Date.now();
  
  // Log generation start
  console.log('⚡ Starting workout generation orchestrator', {
    workoutType: ctx.workoutType,
    duration: ctx.duration,
    experience: ctx.experience,
    uid: uid ? `${uid.substring(0, 8)}...` : 'anonymous',
  });

  // Step 1: Assemble context and compute parameters
  const duration = ctx.duration || 30;
  const workoutType = ctx.workoutType || 'Full Body';
  const experience = ctx.experience || 'Beginner';
  const goals = ctx.goals || ['General Health'];
  const equipment = ctx.equipment || ['Bodyweight'];

  // Get programming recommendations
  const programmingResult = getProgrammingRecommendations(goals, experience);
  const programming: ProgrammingContext = {
    sets: programmingResult.sets || [3, 4],
    reps: programmingResult.reps || [8, 12],
    restSeconds: programmingResult.restSeconds || [60, 120],
    intensity: programmingResult.intensity || '65-85% 1RM',
  };

  // Compute min/max exercise counts
  const { min: minExercises, max: maxExercises } = computeMinMaxExerciseCount(
    duration,
    programming,
    workoutType,
  );

  // Step 2: Derive periodization and progression
  const progression = deriveProgression(
    experience,
    ctx.targetIntensity || 1.0,
    ctx.recentWorkouts || [],
  );

  // Update context with progression
  const enhancedContext: WorkoutContext = {
    ...ctx,
    targetIntensity: progression.targetIntensityScalar,
    progressionNote: progression.progressionNote,
  };

  // Step 3: Build prompts and schema
  const qualityGuidelines = generateProfessionalPromptEnhancement({
    injuries: ctx.injuries?.list,
    experience,
  });
  const experienceGuidance = getExperienceGuidance(experience);
  const enhancedQualityGuidelines = `${qualityGuidelines}\n\n${experienceGuidance}`;

  const { prompt } = buildEnhancedWorkoutPrompt(
    enhancedContext,
    programming,
    enhancedQualityGuidelines,
  );
  const systemMessage = buildEnhancedSystemMessage(duration, workoutType);
  const responseFormat = buildOpenAIJsonSchema(minExercises, maxExercises);

  // Step 4: Check cache
  const cacheableContext: CacheableContext = {
    experience,
    goals,
    equipment,
    injuries: ctx.injuries,
    workoutType,
    duration,
    targetIntensity: progression.targetIntensityScalar,
    progressionNote: progression.progressionNote,
    preferenceNotes: ctx.preferenceNotes,
  };
  const cacheKey = hashRequest(cacheableContext);

  try {
    const result = await getCachedOrRun(cacheKey, async () => {
      // Step 5: Generate candidate with multi-pass repair
      let candidate: WorkoutPlan | null = null;
      let repairAttempts = 0;
      let validationErrors: ValidationErrors | null = null;

      // Get duration-optimized quality thresholds
      const durationThresholds = getQualityThresholdsForDuration(duration);
      const maxAttempts = durationThresholds.maxRepairAttempts + 1;

      console.log(`📋 Starting generation with max ${maxAttempts} attempts (duration: ${duration}min)`);

      for (let attempt = 0; attempt <= durationThresholds.maxRepairAttempts; attempt++) {
        console.log(`🔄 Generation attempt ${attempt + 1}/${maxAttempts}`);

        const isRepair = attempt > 0;
        const messages = isRepair && validationErrors
          ? buildRepairMessages(systemMessage, prompt, validationErrors, candidate)
          : [
            { role: 'system' as const, content: systemMessage },
            { role: 'user' as const, content: prompt },
          ];

        // Call OpenAI with appropriate mode based on duration
        const dynamicConfig = getOpenAIConfigForDuration(duration);

        // Always use streaming to avoid timeouts on longer workouts
        console.log('🤖 Calling OpenAI API (streaming mode)...');

        let content = '';
        let parsed: unknown;

        // Call OpenAI with retry logic
        try {
          await callOpenAIWithRetry(
            async () => {
              console.log('📤 Sending request to OpenAI with model:', OPENAI_MODEL);
              console.log('📋 Response format type:', (responseFormat as Record<string, unknown>)?.type);

              const stream = await openaiClient.chat.completions.create({
                model: OPENAI_MODEL,
                temperature: dynamicConfig.temperature,
                top_p: dynamicConfig.topP,
                max_tokens: dynamicConfig.maxTokens,
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                response_format: responseFormat as any,
                messages,
                stream: true,
              });
              console.log('✅ OpenAI API call initiated successfully');

              // Collect streamed response with timeout protection
              content = await streamWithTimeout(stream, OPENAI_CONFIG.streamTimeout);

              if (!content) {
                throw new Error('OpenAI returned empty response');
              }

              console.log(`✅ Received ${content.length} characters from OpenAI`);

              // Parse JSON with repair capability
              const parseResult = validateAndRepairJSON(content);
              if (!parseResult.valid) {
                throw new Error(`JSON parse error: ${parseResult.error}`);
              }

              parsed = parseResult.data;
              return parsed;
            },
            {
              maxRetries: 2,
              onRetry: (attemptNum, error) => {
                console.warn(`⚠️ Retrying OpenAI API call (attempt ${attemptNum})`, {
                  error: error.message,
                  contentLength: content.length,
                });
              },
            },
          );
        } catch (error) {
          const errorMsg = error instanceof Error ? error.message : String(error);
          console.error('❌ OpenAI API call failed after retries:', {
            error: errorMsg,
            contentLength: content.length,
            attempt: attempt + 1,
          });

          // If we have partial content, try to repair it
          if (content && isIncompleteStreamError(error instanceof Error ? error : new Error(errorMsg))) {
            console.warn('⚠️ Attempting to repair incomplete JSON response');
            const repairResult = validateAndRepairJSON(content);
            if (repairResult.valid) {
              parsed = repairResult.data;
              console.log('✅ Successfully repaired JSON from partial response');
            } else {
              validationErrors = {
                schemaErrors: ['Failed to parse AI response - incomplete or malformed JSON'],
                ruleErrors: [],
              };
              repairAttempts++;
              continue;
            }
          } else {
            throw error;
          }
        }

        if (!parsed) {
          throw new Error('Failed to generate valid workout');
        }

        // Step 6: Validate with AJV
        const schemaValidation = validateWorkoutPlanJSON(parsed, minExercises, maxExercises);
        if (!schemaValidation.valid) {
          console.warn('Schema validation failed:', schemaValidation.errors);
          validationErrors = {
            schemaErrors: schemaValidation.errors,
            ruleErrors: [],
          };
          repairAttempts++;

          if (attempt < durationThresholds.maxRepairAttempts) {
            continue;
          } else {
            throw new Error(`Schema validation failed: ${schemaValidation.errors.join(', ')}`);
          }
        }

        candidate = parsed as WorkoutPlan;

        // Step 7: Lightweight validation - only check for critical issues
        // Trust the AI response more, only validate truly broken workouts
        const durationValidation = validateAndAdjustDuration(candidate, duration, minExercises);

        // Only fail on critical issues: empty exercises or completely invalid duration
        const hasCriticalIssues =
          !candidate.exercises ||
          candidate.exercises.length === 0 ||
          (durationValidation.actualDuration < 5); // Less than 5 minutes is clearly wrong

        if (hasCriticalIssues) {
          validationErrors = {
            schemaErrors: [],
            ruleErrors: ['Workout has critical structural issues'],
            durationError: durationValidation.error,
          };
          repairAttempts++;

          if (attempt < durationThresholds.maxRepairAttempts) {
            console.warn('Critical validation issue, attempting repair:', validationErrors);
            continue;
          } else {
            throw new Error(`Critical validation failed: ${JSON.stringify(validationErrors)}`);
          }
        }

        // Log warnings but don't fail on them
        const repFormatValidation = validateRepFormat(candidate.exercises, workoutType);
        if (repFormatValidation.errors.length > 0) {
          console.warn('⚠️ Rep format warnings (non-critical):', repFormatValidation.errors);
        }

        // Validation passed!
        console.log('✅ Validation passed');
        break;
      }

      if (!candidate) {
        throw new Error('Failed to generate valid workout');
      }

      // Step 9: Quality scoring (informational only - trust AI-generated workouts)
      // Calculate quality score for metadata and logging, but don't fail on it
      const qualityScore = calculateWorkoutQuality(candidate, {
        experience,
        injuries: ctx.injuries?.list || [],
        duration,
        goals,
        equipment,
        workoutType,
      });

      console.log('📊 Quality score:', qualityScore);

      // Step 10: Collect metadata
      const durationValidation = validateAndAdjustDuration(candidate, duration, minExercises);
      const restValidation = validateRestPeriods(candidate.exercises);

      const metadata: GenerationMetadata = {
        model: OPENAI_MODEL,
        temperature: OPENAI_CONFIG.temperature,
        minExercises,
        maxExercises,
        actualDuration: durationValidation.actualDuration,
        targetDuration: duration,
        durationDifference: durationValidation.difference,
        validationWarnings: restValidation.warnings || [],
        validationSuggestions: [],
        qualityScore,
        repairAttempts,
        targetIntensityScalar: progression.targetIntensityScalar,
        progressionNote: progression.progressionNote,
        generatedAt: Date.now(),
      };

      const result: WorkoutPlanWithMetadata = {
        ...candidate,
        metadata,
      };

      const elapsed = Date.now() - startTime;
      console.log(`✨ Generation complete in ${elapsed}ms`, {
        repairAttempts,
        qualityScore: qualityScore.overall,
        duration: durationValidation.actualDuration.toFixed(1),
      });

      return result;
    });

    return result;
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : String(error);
    console.error('❌ Generation orchestration failed:', {
      error: errorMsg,
      workoutType: ctx.workoutType,
      duration: ctx.duration,
      experience: ctx.experience,
    });
    throw error;
  }
}

/**
 * Build repair messages with validation feedback
 */
function buildRepairMessages(
  systemMessage: string,
  originalPrompt: string,
  errors: ValidationErrors,
  previousCandidate: WorkoutPlan | null,
): Array<{ role: 'system' | 'user' | 'assistant'; content: string }> {
  const errorSummary = [
    '❌ VALIDATION ERRORS:',
    ...errors.schemaErrors.map((e) => `- ${e}`),
    ...errors.ruleErrors.map((e) => `- ${e}`),
  ];

  if (errors.durationError) {
    errorSummary.push(`- Duration: ${errors.durationError}`);
  }

  const repairPrompt = `${originalPrompt}

${errorSummary.join('\n')}

Generate a corrected workout fixing all errors above.`;

  const messages: Array<{ role: 'system' | 'user' | 'assistant'; content: string }> = [
    { role: 'system', content: systemMessage },
    { role: 'user', content: originalPrompt },
  ];

  if (previousCandidate) {
    messages.push({
      role: 'assistant',
      content: JSON.stringify(previousCandidate),
    });
  }

  messages.push({
    role: 'user',
    content: repairPrompt,
  });

  return messages;
}


================================================================================
CONFIGURATION FILES
================================================================================


=================================================================================
FILE: package.json
=================================================================================
{
  "name": "neurafit",
  "private": true,
  "version": "1.0.17",
  "type": "module",
  "description": "AI-powered fitness application with personalized workout generation",
  "engines": {
    "node": ">=20.0.0",
    "npm": ">=10.0.0"
  },
  "packageManager": "npm@10.9.2",
  "scripts": {
    "// Development": "========================================",
    "predev": "node scripts/clear-all-caches.js",
    "dev": "vite",
    "dev:host": "vite --host",
    "dev:https": "vite --https",
    "// Building": "========================================",
    "prebuild": "node scripts/clear-all-caches.js && npm run update:manifest",
    "build": "node scripts/clear-all-caches.js && tsc -b && vite build && npm run build:sw && npm run build:check",
    "build:deploy": "node scripts/clear-all-caches.js && vite build && npm run build:sw",
    "build:sw": "node scripts/build-sw.js",
    "update:manifest": "node scripts/update-manifest-version.js",
    "build:analyze": "ANALYZE=true npm run build",
    "build:check": "node scripts/check-bundle-size.js",
    "clean:cache": "node scripts/clear-all-caches.js",
    "// Deployment": "========================================",
    "deploy": "npm run build && firebase deploy --only hosting",
    "deploy:all": "node scripts/deploy.js hosting,functions",
    "deploy:functions": "npm run build && firebase deploy --only functions",
    "deploy:rules": "firebase deploy --only firestore:rules",
    "// Code Quality": "========================================",
    "typecheck": "tsc -b --force",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "format": "prettier --write \"src/**/*.{ts,tsx,js,jsx,json,css,md}\"",
    "format:check": "prettier --check \"src/**/*.{ts,tsx,js,jsx,json,css,md}\"",
    "// Testing": "========================================",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest run --coverage",
    "// Preview": "========================================",
    "preview": "vite preview",
    "preview:sw": "vite preview --port 4173",
    "// Analysis": "========================================",
    "analyze": "vite-bundle-visualizer",
    "analyze:build": "npm run build:analyze && open dist/stats.html",
    "// Maintenance": "========================================",
    "clean": "rm -rf dist node_modules/.vite node_modules/.tmp",
    "clean:all": "rm -rf dist node_modules",
    "reinstall": "npm run clean:all && npm install",
    "// CI/CD": "========================================",
    "ci": "npm run lint && npm run typecheck && npm run test && npm run build",
    "prepack": "npm run lint && npm run typecheck"
  },
  "dependencies": {
    "@sentry/react": "^8.47.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "firebase": "^12.4.0",
    "idb-keyval": "^6.2.1",
    "immer": "^10.1.3",
    "lucide-react": "^0.544.0",
    "react": "^19.1.1",
    "react-dom": "^19.1.1",
    "react-router-dom": "^7.9.1",
    "tailwind-merge": "^3.3.1",
    "zod": "^3.24.1",
    "zustand": "^5.0.8"
  },
  "devDependencies": {
    "@eslint/js": "^9.36.0",
    "@firebase/rules-unit-testing": "^5.0.0",
    "@tailwindcss/vite": "^4.1.13",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.1.0",
    "@testing-library/user-event": "^14.5.2",
    "@types/node": "^24.5.2",
    "@types/react": "^19.1.13",
    "@types/react-dom": "^19.1.9",
    "@typescript-eslint/eslint-plugin": "^8.44.1",
    "@typescript-eslint/parser": "^8.44.1",
    "@vitejs/plugin-react": "^5.0.3",
    "@vitest/ui": "^3.0.5",
    "eslint": "^9.36.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.20",
    "globals": "^16.4.0",
    "jsdom": "^26.0.0",
    "prettier": "^3.4.2",
    "rollup-plugin-visualizer": "^5.12.0",
    "tailwindcss": "^4.1.13",
    "terser": "^5.44.0",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.44.0",
    "vite": "^7.1.7",
    "vite-bundle-visualizer": "^1.2.1",
    "vitest": "^3.0.5",
    "workbox-build": "^7.3.0",
    "workbox-expiration": "^7.3.0",
    "workbox-precaching": "^7.3.0",
    "workbox-routing": "^7.3.0",
    "workbox-strategies": "^7.3.0"
  }
}

=================================================================================
FILE: tsconfig.json
=================================================================================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

=================================================================================
FILE: vite.config.ts
=================================================================================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import tailwind from '@tailwindcss/vite'
import { resolve } from 'path'
import { visualizer } from 'rollup-plugin-visualizer'
import { readFileSync, copyFileSync, rmSync } from 'fs'

/**
 * Production-Ready Vite Configuration for NeuraFit
 * React/TypeScript application with Firebase and Tailwind CSS
 *
 * Optimizations:
 * - Firebase SDK properly chunked by service (auth, firestore, functions, analytics)
 * - React/React-DOM in separate vendor chunk
 * - Lazy-loaded routes automatically code-split
 * - Terser minification with console removal in production
 * - Aggressive code splitting for optimal caching
 */
export default defineConfig(({ mode }) => {
  const isProduction = mode === 'production'

  // Read package.json for version
  const packageJson = JSON.parse(readFileSync(resolve(__dirname, 'package.json'), 'utf-8')) as { version: string }
  const appVersion: string = packageJson.version
  const buildTime: string = new Date().toISOString()
  const buildDate: string = new Date().toISOString().split('T')[0] || ''

  return {
    // Base public path - use absolute paths for production
    base: '/',

    // Path resolution - matches tsconfig paths
    resolve: {
      alias: {
        '@': resolve(__dirname, 'src'),
      },
      // Resolve extensions in order
      extensions: ['.mjs', '.js', '.mts', '.ts', '.jsx', '.tsx', '.json'],
      // Prefer ESM over CJS
      mainFields: ['module', 'jsnext:main', 'jsnext', 'main'],
      // Dedupe React to prevent multiple instances
      dedupe: ['react', 'react-dom', 'react-is', 'scheduler'],
    },

    // Plugins
    plugins: [
      react(),
      tailwind(),
      // Clear Vite cache before build to prevent stale dependency issues
      {
        name: 'clear-vite-cache',
        apply: 'build' as const,
        enforce: 'pre' as const,
        async configResolved() {
          try {
            const viteCachePath = resolve(__dirname, 'node_modules/.vite')
            rmSync(viteCachePath, { recursive: true, force: true })
            console.log('✅ Cleared Vite cache before build')
          } catch (error) {
            console.warn('⚠️ Failed to clear Vite cache:', error)
          }
        },
      },
      // Bundle analyzer (only when ANALYZE=true)
      process.env.ANALYZE === 'true' &&
        visualizer({
          open: true,
          filename: 'dist/stats.html',
          gzipSize: true,
          brotliSize: true,
          template: 'treemap', // 'sunburst', 'treemap', 'network'
        }),
      // HTML transform plugin to inject version and build time
      {
        name: 'html-transform',
        transformIndexHtml(html: string): string {
          return html
            .replaceAll('__APP_VERSION__', appVersion)
            .replaceAll('__BUILD_TIME__', buildTime)
            .replaceAll('__BUILD_DATE__', buildDate)
        },
      },
      // Service worker copy plugin
      {
        name: 'copy-service-worker',
        writeBundle() {
          try {
            copyFileSync(
              resolve(__dirname, 'public/sw.js'),
              resolve(__dirname, 'dist/sw.js')
            );
            console.log('✅ Service worker copied to dist/sw.js');
          } catch (error) {
            console.warn('⚠️ Failed to copy service worker:', error);
          }
        },
      },
    ].filter(Boolean),

    // Development server
    server: {
      port: 5173,
      host: 'localhost',
      // Enable CORS for development
      cors: true,
      // Disable COOP in development to allow Firebase Auth popups
      headers: {
        'Cross-Origin-Opener-Policy': 'unsafe-none',
        'Cross-Origin-Embedder-Policy': 'unsafe-none',
      },
      // Custom middleware to serve sw.js with correct MIME type
      middlewares: [
        (req: any, res: any, next: any) => {
          if (req.url === '/sw.js') {
            res.setHeader('Content-Type', 'application/javascript');
          }
          next();
        },
      ],
    },

    // Build configuration
    build: {
      target: 'es2022',
      outDir: 'dist',
      // Enable sourcemaps for production debugging (hidden from browser by default)
      sourcemap: isProduction ? 'hidden' : true,

      // Minification with Terser
      minify: 'terser',
      terserOptions: {
        compress: {
          // Remove console statements in production
          drop_console: isProduction,
          drop_debugger: isProduction,
          // Remove unused code
          pure_funcs: isProduction ? ['console.log', 'console.info', 'console.debug', 'console.trace'] : [],
          // Additional optimizations
          passes: 2,
          unsafe_arrows: true,
          unsafe_methods: true,
        },
        mangle: {
          // Mangle property names for smaller bundle
          safari10: true,
        },
        format: {
          // Remove comments
          comments: false,
        },
      },

      // Chunk size warnings
      chunkSizeWarningLimit: 500, // 500KB warning threshold for optimal performance

      // Rollup options for advanced chunking
      rollupOptions: {
        output: {
          // Optimized manual chunks for better caching
          manualChunks: (id: string) => {
            // Core React libraries - must be loaded first
            // Include all React-related packages to prevent duplication
            if (
              id.includes('node_modules/react/') ||
              id.includes('node_modules/react-dom/') ||
              id.includes('node_modules/scheduler/') ||
              id.includes('node_modules/react-is/')
            ) {
              return 'vendor-react'
            }

            // React Router - changes with route updates
            if (id.includes('node_modules/react-router-dom/') || id.includes('node_modules/react-router/')) {
              return 'vendor-router'
            }

            // Firebase - split by service for better caching and smaller initial bundles
            if (id.includes('node_modules/firebase/auth') || id.includes('node_modules/@firebase/auth')) {
              return 'firebase-auth'
            }
            if (id.includes('node_modules/firebase/firestore') || id.includes('node_modules/@firebase/firestore')) {
              return 'firebase-firestore'
            }
            if (id.includes('node_modules/firebase/functions') || id.includes('node_modules/@firebase/functions')) {
              return 'firebase-functions'
            }
            if (id.includes('node_modules/firebase/analytics') || id.includes('node_modules/@firebase/analytics')) {
              return 'firebase-analytics'
            }
            // Remaining Firebase core
            if (id.includes('node_modules/firebase') || id.includes('node_modules/@firebase')) {
              return 'firebase-core'
            }

            // UI libraries - icons and styling utilities
            if (id.includes('node_modules/lucide-react/')) {
              return 'vendor-icons'
            }
            if (
              id.includes('node_modules/class-variance-authority/') ||
              id.includes('node_modules/clsx/') ||
              id.includes('node_modules/tailwind-merge/')
            ) {
              return 'vendor-ui-utils'
            }

            // State management - Zustand and Immer
            if (id.includes('node_modules/zustand/') || id.includes('node_modules/immer/')) {
              return 'vendor-state'
            }

            // React Query - data fetching
            if (id.includes('node_modules/@tanstack/react-query/')) {
              return 'vendor-query'
            }

            // Sentry - error monitoring
            if (id.includes('node_modules/@sentry/')) {
              return 'vendor-monitoring'
            }

            // Zod - validation
            if (id.includes('node_modules/zod/')) {
              return 'vendor-validation'
            }

            // IndexedDB - offline storage
            if (id.includes('node_modules/idb-keyval/')) {
              return 'vendor-storage'
            }

            // Other node_modules - group remaining dependencies
            if (id.includes('node_modules/')) {
              return 'vendor-misc'
            }

            // Application code - let Vite handle automatic splitting
            // This allows for route-based code splitting via lazy loading
            return undefined
          },

          // Naming patterns for chunks
          chunkFileNames: (chunkInfo) => {
            // Use content hash for long-term caching
            const name = chunkInfo.name || 'chunk'
            return `assets/${name}-[hash].js`
          },
          entryFileNames: 'assets/[name]-[hash].js',
          assetFileNames: (assetInfo) => {
            // Organize assets by type
            const name = assetInfo.name || ''
            if (name.endsWith('.css')) {
              return 'assets/css/[name]-[hash][extname]'
            }
            if (/\.(png|jpe?g|svg|gif|webp|avif)$/.test(name)) {
              return 'assets/images/[name]-[hash][extname]'
            }
            if (/\.(woff2?|eot|ttf|otf)$/.test(name)) {
              return 'assets/fonts/[name]-[hash][extname]'
            }
            return 'assets/[name]-[hash][extname]'
          },
        },

        // Tree-shaking optimizations
        treeshake: {
          moduleSideEffects: 'no-external',
          propertyReadSideEffects: false,
          tryCatchDeoptimization: false,
        },
      },

      // CSS code splitting
      cssCodeSplit: true,

      // Report compressed size (disable in CI for faster builds)
      reportCompressedSize: !process.env.CI,

      // Increase chunk size limit for better optimization
      assetsInlineLimit: 4096, // 4KB - inline small assets as base64
    },

    // Optimize dependencies
    optimizeDeps: {
      include: [
        'react',
        'react-dom',
        'react-dom/client',
        'react/jsx-runtime',
        'react/jsx-dev-runtime',
        'react-router-dom',
        'zustand',
        'immer',
        // Include Sentry to fix module resolution issues
        '@sentry/react',
        'hoist-non-react-statics',
      ],
      exclude: [],
      // Force CommonJS dependencies to be pre-bundled as ESM
      esbuildOptions: {
        // Resolve .cjs files as CommonJS
        mainFields: ['module', 'main'],
      },
      // CRITICAL: Always disable caching to prevent stale React instances
      // This prevents the "Cannot read properties of null (reading 'useEffect')" error
      noDiscovery: true,
      // CRITICAL: Always force re-optimization to ensure React is fresh
      force: true,
    },

    // Global constants
    define: {
      __APP_VERSION__: JSON.stringify(appVersion),
      __BUILD_TIME__: JSON.stringify(buildTime),
      global: 'globalThis',
    },

    // Enable esbuild for faster builds
    esbuild: {
      // Drop console in production via esbuild (backup to terser)
      drop: isProduction ? ['console', 'debugger'] : [],
      // Legal comments handling
      legalComments: 'none',
    },
  }
})
=================================================================================
FILE: firebase.json
=================================================================================
{
  "functions": [
    {
      "source": "functions",
      "codebase": "default",
      "ignore": [
        "node_modules",
        ".git",
        "firebase-debug.log",
        "firebase-debug.*.log",
        "*.local"
      ],
      "predeploy": [
        "node \"$RESOURCE_DIR\"/node_modules/typescript/lib/tsc.js -p \"$RESOURCE_DIR\"/tsconfig.json"
      ]
    }
  ],
  "hosting": {
    "public": "dist",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "cleanUrls": true,
    "trailingSlash": false,
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ],
    "headers": [
      {
        "source": "/**",
        "headers": [
          {
            "key": "Strict-Transport-Security",
            "value": "max-age=31536000; includeSubDomains; preload"
          },
          {
            "key": "Content-Security-Policy",
            "value": "default-src 'self'; script-src 'self' https://www.googletagmanager.com https://www.google-analytics.com https://apis.google.com https://www.gstatic.com https://www.google.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; img-src 'self' data: https: blob:; font-src 'self' https://fonts.gstatic.com data:; connect-src 'self' https://neurastack.ai https://neurafit-ai-2025.web.app https://neurafit-ai-2025.firebaseapp.com https://firestore.googleapis.com https://www.googleapis.com https://apis.google.com https://identitytoolkit.googleapis.com https://securetoken.googleapis.com https://firebase.googleapis.com https://firebaseinstallations.googleapis.com https://fonts.googleapis.com https://fonts.gstatic.com https://www.google-analytics.com https://analytics.google.com https://stats.g.doubleclick.net https://accounts.google.com https://generateworkout-5zdm7qwt5a-uc.a.run.app https://*.cloudfunctions.net https://www.google.com/recaptcha/ https://recaptcha.google.com https://www.recaptcha.net; frame-src https://accounts.google.com https://content-firebaseappcheck.googleapis.com https://*.firebaseapp.com https://www.google.com https://recaptcha.google.com https://www.recaptcha.net; frame-ancestors 'none'; base-uri 'self'; form-action 'self'"
          },
          {
            "key": "Cross-Origin-Embedder-Policy",
            "value": "unsafe-none"
          },
          {
            "key": "Referrer-Policy",
            "value": "strict-origin-when-cross-origin"
          },
          {
            "key": "Permissions-Policy",
            "value": "geolocation=(), microphone=(), camera=(), interest-cohort=()"
          },
          {
            "key": "X-Content-Type-Options",
            "value": "nosniff"
          },
          {
            "key": "X-Frame-Options",
            "value": "DENY"
          },
          {
            "key": "X-XSS-Protection",
            "value": "1; mode=block"
          }
        ]
      },
      {
        "source": "/assets/**",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "public, max-age=31536000, immutable"
          }
        ]
      },
      {
        "source": "**/*.js",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "public, max-age=31536000, immutable"
          },
          {
            "key": "Content-Type",
            "value": "application/javascript; charset=utf-8"
          }
        ]
      },
      {
        "source": "**/*.css",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "public, max-age=31536000, immutable"
          },
          {
            "key": "Content-Type",
            "value": "text/css; charset=utf-8"
          }
        ]
      },
      {
        "source": "**/*.@(jpg|jpeg|gif|png|svg|webp|ico|avif)",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "public, max-age=31536000, immutable"
          }
        ]
      },
      {
        "source": "**/*.@(woff|woff2|ttf|eot|otf)",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "public, max-age=31536000, immutable"
          }
        ]
      },
      {
        "source": "/index.html",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "no-cache, no-store, must-revalidate"
          }
        ]
      },
      {
        "source": "/sw.js",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "no-cache, no-store, must-revalidate"
          },
          {
            "key": "Content-Type",
            "value": "application/javascript; charset=utf-8"
          },
          {
            "key": "Service-Worker-Allowed",
            "value": "/"
          }
        ]
      },
      {
        "source": "/manifest.json",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "public, max-age=86400"
          }
        ]
      }
    ]
  },
  "firestore": {
    "database": "(default)",
    "location": "nam5",
    "rules": "firestore.rules",
    "indexes": "firestore.indexes.json"
  },
  "emulators": {
    "firestore": {
      "port": 8080
    },
    "ui": {
      "enabled": true,
      "port": 4000
    }
  }
}

=================================================================================
FILE: functions/package.json
=================================================================================
{
  "name": "functions",
  "version": "1.0.1",
  "description": "Firebase Cloud Functions for NeuraFit",
  "scripts": {
    "// Build": "========================================",
    "build": "tsc",
    "build:watch": "tsc --watch",
    "build:clean": "rm -rf lib && npm run build",
    "// Development": "========================================",
    "serve": "npm run build && firebase emulators:start --only functions",
    "shell": "npm run build && firebase functions:shell",
    "start": "npm run shell",
    "// Code Quality": "========================================",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "typecheck": "tsc --noEmit",
    "// Testing": "========================================",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage",
    "// Deployment": "========================================",
    "deploy": "firebase deploy --only functions",
    "logs": "firebase functions:log"
  },
  "engines": {
    "node": "22"
  },
  "main": "lib/index.js",
  "dependencies": {
    "@types/lodash.isequal": "^4.5.8",
    "ajv": "^8.17.1",
    "ajv-formats": "^3.0.1",
    "firebase-admin": "^13.5.0",
    "firebase-functions": "^6.0.1",
    "lodash.isequal": "^4.5.0",
    "openai": "^6.2.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.36.0",
    "@typescript-eslint/eslint-plugin": "^8.45.0",
    "@typescript-eslint/parser": "^8.45.0",
    "@vitest/coverage-v8": "^3.2.4",
    "eslint": "^9.36.0",
    "firebase-functions-test": "^3.1.0",
    "typescript": "^5.7.3",
    "typescript-eslint": "^8.45.0",
    "vitest": "^3.2.4"
  },
  "private": true
}

=================================================================================
FILE: functions/tsconfig.json
=================================================================================
{
  "compilerOptions": {
    /* Language and Environment */
    "target": "es2017",
    "lib": ["es2017"],

    /* Modules */
    "module": "commonjs",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "resolveJsonModule": true,

    /* Emit */
    "outDir": "lib",
    "sourceMap": true,
    "declaration": true,
    "declarationMap": true,
    "removeComments": true,

    /* Type Checking */
    "strict": true,
    "noImplicitReturns": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    "allowUnusedLabels": false,
    "allowUnreachableCode": false,

    /* Interop Constraints */
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true
  },
  "compileOnSave": true,
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
    "lib",
    "**/*.test.ts",
    "**/*.spec.ts"
  ]
}

================================================================================
END OF CODEBASE CONSOLIDATION
================================================================================
Total lines: $(wc -l < "$OUTPUT_FILE")
Generated: $(date)
================================================================================

